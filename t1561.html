<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f617203858e86c9a6be5106ff80b0412620ad4a3af1fef7024ecf11c2304cc0ef75e1899f2e438b0f42073fb6c9c9ff43be48abefb27f40f109442780cff5f96bf285affec36bb69b0ef1a67050d8e3ab82452f5d9e2a74760c5e4c37ddf31b4d81b42dbc0ce0b0235e6c788ed287260769d21bbe457df0c62f8e3890c7ca747e2844ea37b3e7e2248d3aafb0eebb4083d00a539550bb169e9d252795d12703fb3eff23b28a36686985f09ec73f64699d283589b7d7108774192aa73c10bc41be337c4154e2930bd69dcbde26fed05ff66774fe6308ab628632e1ef5cfb29eefb78f8f717f35fd5d897670854a3a0a5ab39205ec50265fc57a9124707c38067762bae1f3063054302f282f8d30624368c3a3edccf21f7f690007ada3d4fc8d959384622db24e46cc95f51da2204ffa2cec3d3cc01bffc198b55a2273e5c2e101ec23b9514de23ea37d30d5c27da32109d7587cab88e386fae8079994c8983056c5b21f4e62350a2c1ef398d7e2d282396b9a173677ceafa5418362be25c34a9a6b540ac3740762538d1bdfd31638ae287d64be1b8d9e8c9238b8ffd3f222705dadb3d059c48cf0c36427f5908f1f2fc99caa1eb5fb2ae8bf656dc316fbfdb11285ff9eba90e7192d8e7bb1ab8d783b51c11aba70f0d84c2b6a990ce65788fe838166a14df1c0b4b5b4012f7b315b027260e5b2ddc8eec971d85fc95f1b9a21e76a8bc3578fe5f75a52b2d3e8caba25d7668874735d80e5e2ba354853e1cbbf5809bea0e6280fc50919a682fca2a84bb301e1c6af603bc9d658e2867d4ae1ce608f753ca3ce43f84f66abd6d45feadb319c20a1c7f5aec5414f2bbd03d7ff88e2676d20331cfb7dac9c0732f5077f0198dd3e47b9a6abaec325a751f9e07eb9ee7de60d65f805ad5c467ce56d7e279a1ef57169c33de495184338189e6edd17717309f8c3cd9a762565d4fcb6821cb2252c2738af93efe3afcec4911c2d8068158bc90217187194f4459e4b7e52285e67f85ba277f3f315dec8c758eea203b0b4ec891f843c38d414cd67c70a3626b11090d706269bcb7b21b1dc9b61e83b1fd8fa7f50724f447ad852e10f1cf2be1c6be3c52322325ba03fd2a4ea0806034743fd67bcbe6886e678aace04351d2c8fea5c9f29f80c660d97b242f6841716424c60779477d339828285bcd07bb665ff6464f2c5d0fc2582c57fcca9ff38da57f310a5219ec2f439e7e86057fea7dff17cba162e5babbedb5083fbbf9d76494fc0e0d86bf88883de18dba1e32018fcb4f62db018bf2c999564c2d24d04ec893389e472c625fdaebaa68b4249df5ef34e54fc8792ec356d94bd32ebddcea2a569030f7b878ed10db464c55588411ee046ced7a77c069a96f2012522c8534507667f99e9a9919bbd0e8a73f6672f2e23a9a126cb96ae83ce4fb196ea07e7dcf73c599e74e3d1a61196a81cbec15405ac97843e98c152e57188e9b62ddcd9c28ce1f3721d2d3018f19c86a92b69d759c95983d6022365cf4953a3d39570b8d6434351e4f4d736f7e9b2f6f2817ff3211395c06886763bf097b0da9d086eb3d435e89961bb2bc95c2c280ba944cf050af98e573a6a7d7783bb2a8055ae7f628e86e1ecc3da6756dfc6943ace7979d20f2764674816aada1d419b83d6f46a1357be19c544e27b0321b19b9313f9a2d1ae38d784835b781b5ed08d2c8d665a9d327ceae23dad6514e394c371565efef2f2170dfcb30f6430e4f88c5de84cbbd52c16c834005da09587ceb8b96f94dcafb71472e1d352c7cd261d983d41b51dcfc6480dcb1d368129fce48ab50f1f1c1bfaa76e445b3d09717cf79ae38124c4bb853da90d30078bfc69ee4f8b37f94ad1638e2090d672956adfb6b54d21dbfe02f00ee799f0d4f0c01f76599c44eed4664ba79483ade07ffcd6ccd70097ef8dd000fe6c35df8527e08514b9b8b89610e371e01d67ed0944146c7bd375d5676969ae18a611cf8c16de0b62a934efc02bb0a113f22ef4354799c2d471356e252af822cec7bd23dc0c66762d7fa42d43ff32c4e87607545096e064dcc40fa25076cbd46b3e818e6e399ad9fc2328e3adfa6d3c1d218d7594690ce4586aab8d98d5089a6a26c919e9a0220a9e77e1792b9cbe925e36345ca80863d223e2b1ca2963b26dabc3fdf2e92ed4a6fc7dd99da169b2a41bf24789ee40a7046fb1dc582607a97f20aa831d06684e0ba271d3c5bf9f0cd8eff361ff38525707ecd98f3a810b823193b1563cf16960c490178032adc9aacf5c1a07e81637111cd42ec50e178ab241bb7492ca6d9b74fe112e633cab75b7fd242d706ac877fd033905bd84b79b9a20abede9bbe4600e100b6d9dbdb9487f45480dd12ce171783ab38e526d39b42ad5b1ff61287f9c1c66464136f6ffff82e8a94f805273d27fa832e48dd449ab3f7bfc6c57b128f607a2adc9bc4f5b9e964ac71dfbbe9a5f1d29ded28db509f2deb61cdfbb76b24a2fdc0f737b914179e39e155af2c6b495e0158630f2fb1b09b71a5c2dd28a29ca66d1e2fb0d72c17244ea92079ce40390e8b49aa821addf848a69e384808f2f2548e7abb6f25b551598d48a902dd6c95bb8187d0ae78570c4112c0b96e77d6f6892b5518b8cc0d9ce892313a3c60bec535091e1e7227ea07062ffe9b94ce6ea041f4df53d9dba353094282eb2155499ff02f5a79821f812b5b76127055720a084153498aa4037aef8c959652f044b019f7218c6b16e68f5453f31e4a3a95406a3a28f568c06f41ffa840ad9ba2b4beb3227bd32e894c97a72367b442a7b517b49098794121020ead312fedbb3b74cda893a72725b5d53cc3c281320330a2716d63063837b771aaf841f4bc6cf29beecb626b5d21da322811b9cff3ae9267af3a6b2e86aed6ab2e953e501e7700eab8256bfb6cd8d61743e0eab427361ee5ad3a48b9b8c35bca844858f227bbaa3da26ed6ca93f53ecb42727969cd290376233919c1f1cd2e5fa56a0c806ea1ea068052e5e56e6f6c265897ee9b7fc5dfb8fb7f50db9bb895b16f85ef4cbe2e6a7225c1e7e2c0e957446e43d82dcb01eaa91ab78228891d8900e278d924c7d550d950e72db49e54b0d6d38b0207a1ebcd9f9233bdfb4b98ba6c86205878a6077ca67f6aec02ae7f44b07accb8888f8e939f2b0417f236534744c6ddee5fe0acc0f444bf0e1078b4d5aaf39b7051350d2442d1ecb4989bb9789e85cf4375d88366755086fae2ce420774174a645b074b55daaa29ac1caacfade0d1b5b070710c4376e4197b54abba735485fb146ee8d51e9bc654e8a2b7cf3538ff598c2f91d253f86cad43d030468afe125608407baec5f3a8111d77b1b69cbd60e93018778f9cc9712a9c15530da05c3f99f6c3f62a2fa5890ef7ab81c98f840316644455d7dc7213da6dc4807826bd2443ddf2dc757f2a587ec41c5284b88a6ebe9cac36c2e9f1745eaaa5b6942107f8124986591c1e5e9ebfb1c9bc5e55e7142bbe460d678eed06126185cb6cf9e325ec69243cc0d23d0421905ed6d135d870f1978343c35ba974d1da9a1a5ae68ccaed9c23a04ae4823f58a5202c32315553280bb1450cd45fa0ce51fe0f5b5a2a3f46090b351479d7a7f0b50ffb398b9c16c4bcfa46c0f84d41b746fd25b6ae2b96f0b47d029309c2e22f27b8a38bb1560d06a9e8976cd7fdf7754ca1248d3ab2cf0aba0f7dafae35d18179921f50b9db65db275d7a2dc0e1235cb0e4576e6fb3cd228f165dcd09c90f777d6987968a727e9f99110e5f8375052160e2199904788e429cbcc45f6996f6863d810a8e605356cafdd82f6ea6a86c263778b08de32a07c4e20cc603368b1f859c8489c184bdd349263756e810eb28e9bb8bbe531d8c59bbfd6ab638a90011ce03645f75cc3eea027cbe790544141e4fcbd3921711f5d7173199dc70cd5dda21a78d5bc328d23614cf0e785ce63b6de5490c1b59248192b35b10e6982abe3fb3f2c94294a4f42bed93dd362f3ba2930f5b7c760fed08cef77fa05a46020a03b2c8ef70a66ee21655c2f7cec7b81bcd5d238783dfa8feb2b7f791e0ab95318bcac10a5a18eee5a69053e959d6178b81575e471840fabb8de46739a644deacaf69caf53d83a7e1a032bf5f035dd1ff7c5b39eb3552846c63ecf8183fc884afb2011c0a402c2b3039a5fc561574cdd28db57a6fb35f337c5623315534039f89857c52ef2cf823c86ad045a04a57ce73343c775d0727d564771006f945ab8e652013f469c1f0bf6455fc72ebf6dee753308f012c71c1f28ba1fc38cdef295a3883770dd5a5322c6cb207c26175db2d204dd1d4d1f3f494426693f1b80ed9c41f49dd8a8da574cb856f6107642ee7ccf1af5fa11591e79086f0d174c0117cbe8032719b76aa9e837c9fb6c4586ee151c99a94f43ad1c99dd7ed0a423d3ddafc0761015a58680dfa88ede9bcaee7b22d9839f231712e0f80e482a84e28e95c4fe74c563a102566edf84216a3e49b1596cc92f717b454e74ff7c38534e6ec2c622a5836a4c1dbc226eb2fb5cc2dfb9b75c8d78b0c3c3f6a28a5147ea8b8740bdc15bb0e4f05af1718ade4f5d5edcf61469ac401aa1b26cc48e89e5730d190a08c44b3f00da418e720edc6349c62dc24286def797fd9294adcb6e8f950661db002d8141a4ed1e9c891bfa7cda658aafe5647d0eb1046f5546ce60dd514eea41df48ba3d0bf4ca8bff2fcba7bafde14b78c50b2ac9ae178949d345d4e0aa03774c116670611380e94e74fe9c5f5c8773714c58ddee958a9300a01e36dae33822d088d53fb7fd7986cecf45130e1e46111ce2064f75e21f2c543e0362d876dca397a4ff7b6621ea995eb2941a7a9c01cd4bbeaac5d1b6782e2c97e09121e3ae613186ab4a689d082b5a61d86822d14ed8706a00dac846b932662af93606658d100222c5245a6cad16042970b750e172d750d77380d6388e413bd945a92c40d995209abc3d7d14e87c01e7edd427e91049b46089317da23a9e3eef495dced2cc68070950c198824906b4fc8738ed380933220d6bcc0b4743b0a6b349885447cae1fa2bec92a7b83dab0b2370caf5516a32d53a256f47fc0d607e1e3c7c63703c6e9054a9959812b3b629f947685a94901d68bca2d2d5844fb31e09b5d22fbd0e4ace6724653ee444980e8e99635ac0267ac1b56e7c35c8c07d31eedd01cf038d71a7e95ae775d31706559b4389e98f0f7d5c43223893b71a6d56f6cd8c822016a50a25fbbc7137f0fcd927d8d0d69c9c4f54195fc0d7cd14da40055bac61670fcc4ed927bc2232cdda7ab7e453ff619d3694a9b6faa9d5c6fc47ebbc30daf2c255cfbeb72268d8368f832e40d32b1ff275c24d3180e9e474a4e6f9b3d79a396f62564c1a0137257ef2cd6dc994b71aa58feded78c8ec34ec36730bd11a612463fd3cb2e3c9f7fb7dcf4c3acb262946778c58436fa59e04ba112023c53c18c6bde0b386d1c6cce992571fc24830977dd404a9e9880a15ee4d06d09bd07325cbbf8fc4c6501708b86d14db435918d5971d27c7567188da4ee48b42668622ebbb16aee56783d90ef664fef09051462dede0b98880993ed913894b69af22c572e696f23da2c061fa0f215fb381a143dbb5316a9698f6af07b2d6b7f08b18a0ce9202ff597aeef8546ab53d4499781c77911a4a21bf3a084d47abef1c2876acc9906de10642a146dc9758834f98f5001fcd8942400d04d4b8904b04befb036a39f6a09719d3dbcd4d1f9500bc5d974c692df948d1241856401399ae38d9d91333111fdd89c192effd19d8ff6b5ec0dbbebd834bae985e3caa7d0a47ba1b3168f54f75139ce6870e17056cd0c670a0c75beb8158b210147d55029c1d3615c0a7e546aa8bd4c37c1f03967b217e2935d5b40fc6f03e57d2140de14f1a4a1164d546d179d52737d8bf88817ed4f4558598c86f6abcb4434b7719f4abce9dfa900286e6f5dbd8163abc419a4772bbc70dd95ca3f11a41e9f576ee299aab0c6ce8cec0feff5f133e1112c45e40193d65efe945362f6a766be3b64f1c11192d1172c48087d6174795d47b52cbe0c76bc83d827c73bc605ccf731f4abf33d251ec01aba0a35fec25a6a0d107961efe04a0d960dfb7776cd9546ccb7998673254f773d94910778f430f8757f22d6714c4ec0ba8778d935372ee0501002ded14a175821a5afb211e8c8d8ecdea09122477dc1fc21b54e3741f63cec515d527ea200051726e55c21d30745c3cb4da386b35865c1748ec449f4e0955ff4a394f07e4c92683f78ccaa8ead60e75a6b8527e0c91eb865c21c1140a32b3b78d495f634504b71aa9d74ee0878255ddcb3225b1afcad94db887768d984aacbbfe3d05194ca071f5ac3eb9afc8ce8b741cf76eca32a4c70e0f972978f970d0071fe93249f8616846f1ae0bc559ba89de5f407559dcc62dce1f8d96968f889a67a5e0250861a78b75db03aa2d81ead14e6b4fe44ad7456aac8f598db4ea9a3b08ac0b30a3c7e48aaab4ca2506965be753d8cfb8ae6f0b412fa28df51807579cd784f719b6171feb0e8ca48473a3c075f6bd9b0a07b2b7081abce2223064aa4225814944b8ee8c623561b60eccf9eadcbb4c504d262cacb1a3bb8118690763b17c956da140947f00f9719e6e85d798ea96b28fee5f6cce3f94dbb2fcb7c749dd9e574a12b2d13511755a262e9311db6f433a426d72726a836dae940da1b77413500610a799f6c3bafd10d1d11b76ac76f91f61d5bd5d0be01ceacbf17fc8c88dcdee59c07ad2ed5da5c07236e53663c16261f6c809767956859a62c0f29a79b0608008edb533d31540c0a4a0ab78aa6d8fcd8700833e7b0c51544d49fd16b92ffb8982456ac7973d5ba85f21721f0ecf195cf7c1aa6328b6f2f2090a1f545f531dbb2716e5d151289709eec675809c18335702af8a1e73ed77169a1401bf203b254c03d1d78e1f5e394ffa202db08b805cf34a3a72cb3fbbb9e0b98fcd8f5569ad36a851f5b1197cd2e194fdf6937cf76b75ed01d92b1900c9f6171d56ef95b23e713f8d48b97f27379448adfc73c148f8bf37654979110d5c007634f63ab45e707db9ce80ffe6ab8531f29cc6c4729d2cbc0b708976edbf1282173d38b73411d047aa96710e59a6ab706774d8110295bb9b0304fe5982482d5c855d3b079d0ceaef4120a35ca66efd0c145f6ba24e971ff4931f1251c81a2c982c088a6d47f5c62a732cd514d2f692bb1f04586cb26ea728967fb1bd82ed61bcaba9f832fbd282a8dea2f0743bcc777d04402058c1f48aa9d44b9af73b181553778067f453569add5a1b27b8e1d6b648a4a9cd72d5889280eaee33bc4d8e95284a8a7e08d4ca3067b24c4b4a3a216cdd62c92fc16028a46f2457a9dd9483d5045c1b4a494cbf2bf32fb37a7c82c6ca3e0587f8f85d2f45021feab7c6127ef11cfd156e2f18132743fe93bc8c2ad5c7e6de01726ae280d591b0168b984a510f5122d97f07ed606ade64b59cdec9c2b237d76a4af822d23a20ae0d42e6c212e26387c459b303676917c55a77c06bdb0905d07933053aadfa4d69999dac3b76f09120dbd2d87df6d1542905c5fb14958a5f6e787d83d5679076fc1fa9e0b1f24abc7660d40dca16c40040723ff371218482041f351bf34050dd8ba0eb99b5b80d2c6dad1dbd6acb90da53f6bef8764a8b198f453240534cce69b960673b54b83d3a2ebc0734eae0dae5e74889ca780586b4384469a42141b8bb1f3d1ca37c4830aa3c1e547a0e9c24c4ce839fb2bcd537256c6c7c9075611771a1d1fc10984fe076792a691afc92c64b1490056dee43535f231d892084f47efb3cdf57da76003facb916d2e8c86cf65bdcf368903424a26ccd553f5c33ee2ba453161e2048d372f1166147f43583ab3f164238b3b6a45e77167a39c2e34b74d8333731f6ca017c74463eb4b31bfc821ec717f31db597eab463ead580695e9007978abdfef7f0a2de33c037089b1c5c2544f5ec754eee138b0dee797ad4b93a5e86a103ca0deffb81d6253a80dc6ee7c5aa2a2d5797dbca35858aa1d601fa19cabdc1f5b283c174c1205e98eec3cb144002b954c9738bf36185df157b7fa7ba224198936f2082ee7ccdb7d7ec0100216857df11f9787cca69f5fc8a3ecdf30d2718c3305deeba53d2f2f706e4b395bc685574c46f2a1e7d205aec733e95195802b7a50e6faf6a93d75fbd19e304e85155ae18f7270fa86a773ad4d73da8a0fe5c84a45436385e0f1b80b26a54a81deb48e68f488a1aecffde27c9edb15bdbc9204eec6629903bd619c3d50cf526c3e772c596defa04068707867593f1cf1e7c465e58e4b7f61303005a9f6f2207b16502e3a0792a35008db8936eac659e72bcadbd95e70791e890072d4aeeb5f41028a6c4ac56b501c09d22ccebf0b63ca0d5e7590e2d5a5e43b0d8c020280d16b6f288c9a3941bcc8f2854622411c1d4ceae14bb201daecd948c992ba47b1e200c900e1368fb851b0f2650cc1c7cf9939247b24aa34ef83bdeeef0fc3ccd69db402cc21224366ad25555b243f4e879a530afc3b9f5e37e558fc3ee1bd227e664ee4f255eb1c9d717040b074a6b8daceb5fb57b7f0a99be50419f6aedf9f1edf563edf3b63d1081b4b4043354b5cf9c64a28e314c5191f8bac5a695a6cda1b9a7738bb88054db538331b3eee6dacd12a2edf9d9a2533eaf76ac8aa34db4aa4ebc39829d04f115f4a67026e26cda060a2e6253b888a31617e24c669df4ce38160ee1cc4b79a80f34f3298a9d0dab62e0a1788d060827e29c94b442e3fc53cac0fcee23c10323af0b2bfb493c9a7729da9c06bf57b3cf5484ed83994514411ada1cda5283184d0d57355784e158883e86c9c17f83ad4f8057e5fc94625cc0aee19b3a9eb69a739725dd0f095cb6f38b58f5e0ca8a2044f13dca920ae68e0b7ce55c0d02c748be7e8d11ac3eef55ec32d1c8bbbe132c47e78c3b3f89eb1322bd76591096e206ba7cae491bd29170b2294a9abfcb4627c4a48168ede77352f5997a982fb85e21c511ec7112307a6ddda9438acd223aef51b0b57951cf52202b7f54654d9f2c9129c869745190b12e41f8594a43f5904106459e2b6f70ff38f0936dd35ab77b8167f4e338f769d33ba82931c783b9dca0bb1b8884516f5cc4696df05c7c7f3a3ffc590e70ce76ccf1e81a2caa365233d65f341d7982e11ea0e4b89abdbb09cfbe1690fad811658e58afa0939aa37a481543366ba59fa70edcee737d388302fb699993517dfca4f94a8e0ced8d54c49bd94dcd7be8a589d7139bf10d8900ad9e9d3e31ac5cd2882bbe1cc45916d3f2df25882190822a34d3faff1af4e00c48109702f18329ca4798e4db1eec030a12933d19d3ebffdaae8ba9173a3b4ea11a72abd193e85ad91f44d4aae8bd57b6e32b043825d567dcbe3ccbd197741dd69ad8a019cd95e0f0b9da97fdb988a05f520618fad1abec90d2e3732a13ae281034e606ccbde546f54c8e9fef0903e7173774d493fda868acc547100925e9c1d5a304c3886e6a2556bbff53112548ec4f7ba8f2b4de2eef654390c95db3919b851725dd6d09915f54505cffbd92e5a880b317a46661251c61666fafd1f1bfc892755b50014c547dda702cd1dd02b9d323dd19b8dc2ee85bffa70e36420139f59f4388c804817bf684465e813ddc69735e442c2ff519e8662cd7e892e990957be642fc81d7d96e49ab9970fd72020b92a9955147b3ba03afa63a08392966d7818770cd46d0f8fb33044839f2420a383ad729acbb1303104798714386606bcfc24fdfb2ecc1e4b76ce834e0cbe034e007dbf6a0d92115a04e60fb944c0116e835c94636cc13e18388c79bdc68c387ffd3eafffcefc3bb243a2bbc88e07b8afc5add82182fdc9294e1deaecef024bfd6c11ad65f59ae433aebe9527c450b8dbb8320b2fd5ba7864fcda82a0a86ef723c4947ee708d22bda8ea286d6812fa7339ac7669923ac065343ade762defc22b954c53ce281d49575905282d5c3b8d0e24426ca6a7b852020ef14be895a0ae8e386cda47773f02f84b3014c61cfe4235f084e24341604dd6f74426dfe15f5c86f95f066f7e80d0939b50eb506f2243cf7d9b1486b84dd97bd34552c8c0bd7c6d5194d71f7deb826321ca4a5a60a7b15aae4b7e6e462785eec327ee974bb6c63ee10abac6427f5015d74750206278dd082e76f4f82730ef647c22b3b287c88b9b820a2302e7774fa43909d82de51d9ad99c216b2c969c1d4c7612d4e0333cf36663b661aa2e8f307ad660caffd702a40b98b1eced110c56e063534ce6d6d9020e860ec5cd4ae3716ef9b074408a00cb24d37e957d020f29abe9b06520f2926639e29742334fd8b8d438822f9ff5579259d3430f5caac51268f6c98d0298acde86e92089fd84eca5df0d08ed4ca11c4898eabac1c7a28b9b3e1c805c6d41614f39d56bcd40ea95c5f4778f7ce820df9026f31bb695634f77c85e9b73617218450a140d2592072301f6d4de0d0a8aa96f113f0bdef6c83d3c0cbc48a7d2c874c2708224b4ce630828e44714b17d186f545526918c7bafca00d5c02fab14663ee2de8045cc4f87dd3d6c43663a66f8583cf687c3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
