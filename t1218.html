<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31ac8fb0b30778b02e9d56117fc9e357ce83134518e735b938562cc85dfa7874a4d10d3b3528a6d91167dc4c12df7088c78f822fee72220c7f4a4fd6118615c48ab0e277d13204dcb5065c82423e889143a88d8f33ca4a53a318fd9978704c2f9bddcaa738c8e5d0ad6a196d855b6fedbbb05b45750e1e83e16c02652bff73493fb6db9904989d6b0b9bbc20aee7c85000ce748cadf8fcb2ce4f235b255064a71affc7a64319cedc086b0d3004f257c54c8ee122badddfc054c5d3c88ff1931c028c2f0eb44db640010944fc78cae9bb8084c4c81327400ce3bbe3eb32be99fdde0f3a9aec052ac470b2b864fc33e73b2e7028e971736d51961bfb122f69ea533e564d4f21fd54a5fd250cf4dcc34908d409a34aa25d7e072f7eb0dfea090b85bc7cc1ddd5920cd72415ffde4f085df08e299cb42a49e9daa84ce05ad9ef6f2d8ce7af07b3272edce2b431a47b9a372290ffe8e85569f5898cda725ddc5176296bb4a866637ff696beba77e3a47e0c0cc678d92e78dd9792f11fd1e4def80b2c5a803d4cd84d9b8b629a4868903e55582b3f7c95f1edd63ecc2c828667e83935949b7dd8c6ec4320f9f5b57e749bf08a22f3b43400a501b0fc89978db6284781e2352c6c85f15254047aa3ba5778fa0c893194d5c885d65fefaa26c14351a583b6411f2e97543ab2a48a7157fe19758945966ce2e21249ae701bfa8cbab1975626c0c241f1333e8748f485b2f605a8084ecb9ab973d31eebab745ade3a5172438ddee19455a82ff0944d4f55195cb92d0bb6aa93464c2fb2d0b8a9ded12dacdb1192558b39285558fe9c8e0dab0f6b9d8714bd0b0855ba2dbbe63c2b5b675752f037193da201ea6f88353202ff05d7600152005d3a1845714c155f0666d60e7c586ed6615ab1c466454d91ea0ab441e0e696163267824c40226af7d89841d6397098ed3908accbc43ab85718a33027108f604b758c8e080ea9417d9e3c80bb731d5744b6ac258e720401c4bdfe0a2276333a0e2a1d10ae8d5bf9fef1201e56ab6d10a46016328bcab396fbe7264d66ad744ebe69db450017e6dbf2058d8468aff458b7baa931349328165cee57eef8e37239e64af57adc7fa8585b58e4386aa224d25af6cf0f96db65957b394a8ee8d8e9eecd5aa61857d6167a7d4b33eb32942c1be4fafead3684f9595cdece5811a5d9d7477d8a1bf3ed419b8f248869b11544477e786b55820070827dda21a1a0ce87a86f300e9de62835b329cf593a6a8ec6b2f508fd0e0d5bf7f75fd6dde083b9a8ba48c23183e6f68376c5e14e4057ff41f8b3f75fe46db465564a62a5e232fc78f01d28323cbb71352f9458d7dc77a4953b0612605fc671c1ce0e4bb31dceed33bd559828fb1de1f6d8ec4d2a888013e82069f484007989dd687c730a0c55a2bfd555956a515d852bf3166f35a1b7a335d986e7dc74a7531f5452ded9b64027db8c5aad2b919cde4ab463881ada65aa9660e0702e01e31071d991e8c327079133024540ce9de2a0a37b57e7db662d95349bb42856649f35595c4177f735534483f99a40b848c49a96e6c671d5c6372d2710b3caafd12e200aae41905db5c5eaa1cd1bb5dc38407cef70434f59e2366a39e81786ae5a81fd3a91c1474959679653e87c78f62d787695a09abbb61ea89d772c9a5c58cbe00806f42d26c1bc4a47f62aec0acd5c2171d2d44a82020bd303acc9c8509035ac4808da3789c097530c3f9acc5eea241802bd664b8064e1c83aa370075a2c2589592df249ab8ddaad61a8012a36f5052e50334d9042c12bbf29f812960fba36d7b0526c93fe8a53f78037cc53b6371cc2844783bbc81c687ecb2c6cb3f3444886c66813a442228485e2a310f410fdb48a21e735bf06a97d36720ed44e2751fc883d44c7ec94255ee4c685a90f5ef6699e9a5a284235c3b4fdc5e41e85d5f51923c2b99b46b809708a841c8d39e153155d88868e279c2c7bc36e7a3a9602791b8d1d24d0c8710c32eeed84098131fc5d03dc42e2c84811d6d65e49cda7d2eea47c08edf2068cbfbf523fdc421ba61178a06c88974dc85c22f05e6d0bf18be92515bedc3fb635bc949b4c5e93818da6ac1df74723c9a65eada1e709c9117f9e60e963fa0213026f41cae076ef1f021069125856d91cb58c868e7fae123be37d433420c12ce76930a7d43d84010994a7d51f62a1a76144eb105a3eba996a86b2d1ecf3c547a089909b7439376709b7c6f19bfd269acfe27ae9cc3382d7fdcc58a15cb182ce042f79c6138e0050f5621a630810512add45225ae1ded09bea445d53c3943d394340bf1e29f49e2a1c728f109ad8df7b8fcdf3dffcde0ebf88e8c5e56b95035e4815d22aabf1aa91a6dbb7881daaa644838cf0dd180dea91ce95c78f38fdaa6634187438fb51be3a302cd2cf2b1eecd2cab658944ec46befbe1a573fad19482aa2eb6805f9dfeeb4e1db86639be0a946b483a95f8f74c75dd64aabd806773628944390c12f201de13b5f05e0082c494bda7f89e2dcf5582f922f84b6cd84c8becf6af1e23dd87fb37e695ca0e43ede92c5b46c018e35cdb141b08b51626428adbb0ee3c51be36c12d4be361fbf6097965bd1f8c56faecfa8946c49908a9c40b67d872b62d49d1a49a90120b6f9ef8ebecb9ee0b15ad1df082d53df23b877716921a11976c3592609e6dcd8937828881c3c22c2625a78843e185f618893618c66a0bbd87920515409effee2e1a2b26c3937498aebd45f6c7820800e4f545f7aa33ef091a6f9a385c7b96b15a37b158c07423d20d8f717e535daaa12063d7b09f1ec2b16c0e9f0235906051d3eaea7e469b0b1624c9454f04f92d66c329c393ecc94c16f28b3ccf40aed1a69e1ef797af7b2680b53615a0f5fc4ca8eac24f64e0563a1df0d8dcdd470e07d2949f21857a3af8abc6593894d3e050e8111f5dd8465f721ffcb1caf9f3e813acd7272b3f86d900bfbe2ade58dc923080bdbfad5088243438c0ddf36d255cceadbfcaffcff994ae0c56aaebfeab3714f26a440e9f9436b388654c35c52f455bc701f9fcef83eadf88308a83518fad3536b1ca9dc669baa56c327e2e4bbed3e2cf6281fa5b8511d188d65973ef76da9e97f57258863a7b51f238208590427a03a56a71167525e0ab8b398a69273b4a5c2bfd8dae72f7bd5b07dd30f5a4ac4d85c4c06f76036a86e212631512217ec017c429077c52156fb894befe03fa0cf4ea7199a7e29e66ca075eedd015a3b9f628cf36f4b7c66c5e2887d94fc7fdec550473e7036479638720eed63531d45cdab304867642073933afab759828ab86ea8809fc29c06bf39d383d025cde862ad056aa6b98c7eb3218410ede9b070abe796c9f7225ac75894d80706f88230229c199c647978511a1f1366ae0873e6add8f4eba76ec098dde52221ccab6f2b222f862dcd90303b21bb006b06319284bf093bfe8d3624ea98047973143f5fd5c749ac1937a7617e9c7bdc6a9517dd9a71b932297f683349f811f3a543d6e10db0b9028c388acc4ab1411ef7fe355b0d23cc5ba26252148cd2ae0e5222f27f5b096d7b57a7fbce2669ea46916071b3fbb6ad405b5d26b602b3bf1331077147d984d2f4e12e93666c3eb208d9e52956ab8552113d2380568e457d569eca1474021dd286819a84624c31b271f24ffd1e99ff32903851a81ea1bbaf2e9537a8b55ef05a9152c9c553e466a6177a5bc5ccccade8595186e7284966f229393ba9516fdb4e65280bf89b6e5b7232e74349e409de82a7e0e17b5d0a3bc77b4ae394e43c28f08e72111a2973c153a1620e3cb5bda1ebf61a4ee4cda23c54c2601de237163a12f4cbe19002c957ad89b17f3023777844927507d1de9927d2864fbc10dfb075a68f2d0294e5ed463aac929dc132c28e8a13367b8eeb7472df61d93f71bdb9e294261def4d123bd0cfe783d9254c4bc2a9585f46cec0bba085ff23a211bfacae91bba53fe53ec9588c3deb07e0c91bca50582c5c14703321f46425361de1a47bee124462d6b5cc54a09b31b96a6057203a180f6b18a4086943210fcc128575370f6d2017abc1b50d9dcc01567758a77ae62e72b6878053c0609756e696afb9a1c2192cb5391c1bd44c30e757d435cfe049d3c7b9ae66c618c5d7ec80963c92d225c9730deb5d8ca1a3cf5299b8e57d0e0d63d5d41de6b9fd8609952352ab45b030ce49d665187ba813fddb0d5b7943cad96d7bdadb8df9a0defc19e4db53d57939758f9d524b3d6ecbcd53a979ec1be8b02b2025bfafd3f081762d1a2996ae78bda4bde67d88f36386fb2be335222843eed0e2834351ce2046ec551748919a4924fd32608c40c05def125f60de12a4f5fe9f6d368ce20eb75a4b6a4bd8a1f4c8aef7cec105cc2e62d1b225d5081704de23f96bb821c35503ba4485649e3bbdb6b0a972c21b2f49ec7999c37c90737ecd2ad065419a4cb626b67e1db6a027776fccf9c575b03e2d022baf7fdc3ecd942ab513e5d19efeee5351fdaf7755bc3d4c750ff15e9ff61ecc80e9f45e37fa6bed8fe8b05517fdf673c50abcc0c8d0fa7a84cd4c4f1975095c5a57bd4fb7e94258207f6a400e86e036e93a8d4b5f02e8cd81e87283babc87aa78623bf3f022097aab7a3fa68c2bc8ce8a441160b75f57c60cd4a0dba7929a07118bd0bc02a695fb750d29f3f00234c788064e474bc98b6d4237de2bfd6821eba4156c810a6a88cc8a9059731159dd156809a82f8ab2d7a02adee698cecc5def119ecd5003a8776cd6a1d3e8e29cccec7b45d9d0cfe48c8ff9f5f1f90ca693b9a706df47c5fd293b1f00b321aa17f16866987057c78d921ab655e2d1e1793ac3cfb20e4982cfc5f691c84b2b31788341b728e507f7ad87e6b53cebc135912ab4d5991c950b51c60e2328a8ce0433059829b2ab268da7588911512bbf65481d98e8579633c5cf715beb3e7bb19014c052b9ff67a44902de1fa30975f45abbf2cf216c1008492ea4a24b59024a642222edd85f5598c83acc546cbb995bbc21c51a563ace8beb20f79673b6376ab66b3005e3e8dbd202e68633998f7b3d9cbf9677769f3e3446f9e3fab198c75b0b74b1c144ed8e879a24e7ea451ce456ab5adcf4f70da1f30540b246aecf6805a1a37bc6c836c1b55aeca11fe63302a3705cbc01d91d8e8d554b94fde03706dd89199adf790a8dac8f796265c123c3f1ff6b1f274456029fd088a7d1a18f726f8726fb0e4b0bac2c0061e08fee3a80a6fe622466b33ca8b7aad7c15353d53c6a1767f6ab7b6436319e32dcdb8204aa21850fe0714ffd3abdb7edfae4df38e7e08656fd25f9b2083b88f152e03ea5b69358185a7c64030cce9404aef69630b8cefda9db39bfdb63473d16edb189666b89fd2d8105fee4e73b90dfa6962435e13f263ef39eb88c08ace8c861e3558673e2bfe6483e56283fa8fd844a79a4df5317afc57e446abdadf099f0640d4f1e1ee5343293a347a8bb25a821c81ccf0110d2149d86481f4aee14fe4cadb5d8338b732d0fa0e54dd1504508baf3d774efc0eee1ce47628940e5ca5687b7029cedafcdccd5cf70f19414371fa0a87aca1bf8d7d7b356534ec6388447f31af66da5a8a91b9e15e77c958d82307c794c40f09c15f89b5baa0196179f3bfe23e714161ba42d1ca3383148c329050083bae4a11d6238ac4f135b08d110060417d97d4e437bd655725297f9e2a32f2f1070417cf610cfb4460c34bbcef51f8550d2de958ab12c603934d87178e850eb78908bb56040f06cdc23bd2249359417dbac4dbb20abf7249e9f135bc7898871db96a9799a08ae463137be37a8f7a91b78975b96de36f0eb6ce6a81705bc16d44c67c9c134380fa4eed338b96e508f6bb837d7b9fa5c6dc6b72bed128a32faa84a533f0b526cac401bf18d5546e6046fc5325c66b9cf761610e43f2e81987fe3269d7c46a116d8b6d882074a22e02b1f4cc131ab748b5f85747704e2059635af4ac21ec3efff795382b9025da83547ed107a25bee91971988a6fe74050a4914e04f720ad91a3ee4d6ec660abca807d9369a9991ba5a4b85dbbcd0651c2c8b35b25fa3eecefaafa6e6bc27ea90f5162ab41b57fc3ab1e57ed33b18061c6278264d10afd465cbc061d49cdca4351927690b5fc6e1ceb03e090a2bedacc86f434ef1c344008c938d7203ced70c36b462bcc4e24fff43ce70c3a57e2ffa3934accdc6873edb1270cf1c1ade66ffd42ba09562d99090325ff8820662fe33a665d6ed5d1936fd186d8fff96492e7b2e03cb8bc4cf2c6d8258e1157c917572645474ec2149aab2574d6e2abb81d2a93ecd1d28293d4b05f5a7a07166071265881b631b95a4d4661c7ea48d7be76dda32f7e328f6a4733a8c22990ac8a7819de2f220fd7d257c56f86bbbc56bda0600be4548ee3d89feb34d8cac644ff018e463f6a1ec46fc3e18799efb797123016425f80384129d48adc48020b36f4534dd3be388a12a2f382ba6ede6861445e9377992ed491b834d242c8bcbc1829895b60dfbc0ef989ae38b93f4de585eb80321b752b0db0bac680bade27bdb99425d038b2f7eac59cb79f8ea11bbacc094d40ba4e8969cad8c4b902d8711ee47d62c4f0af5fdc158d75ac2cf002e057f80eda8a9253dcb1e3aa09af80e104efa0189c973a4769144b9b40d7eae9cde00bd7e9b2f54fbc685c1434751c484cd57fdf3cf600baf5f801283a7839dc2cad161fd148c62feba1058e7185b648b995621261ebb3f38f58594c081ba310df83b1ea74708e8ae09952a6bc0163a0aa1b1c0d5cf30f4173f269084e39900bde6b76cf791bbbb161e0ac7786ef30a355cee5ba5e0851063d82505b94c1c2361172a52bb169b2b1dbc1625227fe40582c7a1c45bebf1dfe419a7c8f169185e447f3ef99fe5b1f69928e534e424a4f1372a06556b0eb7fd0bce21d177b95b8536c40ce3a72c5478cbc72552253f03ef8ae6a6bfb790be6348e6483ef13f5156371885d710cd67d420983228e4eb2b4db6a9ce8855e229ad46648c082cc4d06b3dff1f97bb0c822bae981377d8170ce8f47108f67e1915473ef25dbf8d5faf8fb686ac0803c1919b7e0874ecd46544f39c1364f99d00701a1ecad4201714214304b3456da74c9652c4b3669a35b76c05b793ae4188ff17e39246480521dcd54e5f99ce5f1c7a63dbf4210cab6b848a90710175dd07ed3e9d8d640b369b4e6e9d8487f82475eb8b748ffb342d8b799da5226148b3be0f28da6816f3d3cf21b424ef341377b5e44f22051de6217ba037b64dc5ef37adbb36990710502be2af6c496fd46d54aedfef3b113a354d61b2142507ce70c7a6a3102487cf203d3c28f078d9d734cdb08fce6ecba1ba0af8d62d562acde97bd080db7ebbf21492db3a61fe25635bd5bfcf05691a5d742e78504d36185a9cce581a35a7e5061714bdf7d5fc5b17a9e5db783f2121f05bfaaf18903d4c3d11c45a46f881ea08f51486b71de2828c958e33852dca2a9e689a7e595db7a57ca850bd04012c38c9e5d48779488baf1209714d2dbb8ff2661d1932cec4ff6e7649315ff7f4af638a12086573a79ad4b0d81237492f4c43e506966380dee8ff5356f8051ca809dae63790e623872dcd1668a7716027ad2b462a680651ef6ca249983ed3ad3d61875a46ccaa558774766e6f668abb3ceadabd9c6ee462993db833350e986ef069a69f5ac16b606ab30bd1def9ac1e8b127e1cb0379827da57b8d5353f492d44c3d3a6d9b860484afbd28e3d767161f6ea3a94f27112af1006cc54756b2063e2a4babf3f554ab292a0f60f0848ae4e52c0e12803a40340753223499e17e3b8e6dc8c8a1d4ee80211d26400722b327bc1f220e49e981b9a2cfebfe3016ac5551d470925f803328502980101a6e913d3515f011128ad52c9506b53c86828b65038a2286b5deef074d41ea9f843a37775cb51934b5cea64b145e5a85a015192d2ee162dd8fe92894e50ae4cb9c122e612784449203e78e15b1f7603da5a1c3e772e19ea48dbb1cf17ec336326223516d3c2795c626e5f00a229fd83ca829de69f08828504bcf850656f36ec27adb3cecf97a0f79ae523a05da39151a36a413cb71455353d9499841c2c46a669692fc37becd5b9a575f424be0852d4b425c1bfdc2b2ed670cce8f10d1f59680b6ea3521648cd78735a2b89f0a7bbf2a648b2213bb639ef206799651e24fc6047fb88453287b4a2e77126e36f446afb51aaf698691106cc6efce948448f07c73dadf6115f8a790d553ff4ad63a7c92fca3dcfc90f1a44fdd540405e239a54e617094335ed54d9b5a5793fdebb34660143d5be15cb94f8da04f9a6fb41dab8cc1ae289a7591d70878fc90e2a1108005e9abeb67422df21329aa54f9d5ca764596caa6711fcdd396eb5f11379973632f9b30390b5d79e0d1c196bee5a2146fc53c5421dbf0d7fdbdbb19efe2024655c9f4219d48cac13bb6b6103204b26edfefa4eec26ff84e2392cfa7c493e2c71128124a0bbd9e7b0539f7e61bd9fcbb8fea78ed852a616ed2274bcf4ba1329f3793c41b115e3a1c7d3668dbf8fb6d5a14e9eeb90566e73fb54765ef19fa16dd9bd30d36db9be7e0aaebb5d7f23e1327ee0da6a1138e3844fd29a71b1127912bbb907179393303de8a5d1ef0ccc438878a3029a86066b8b6252eddb0a37fa9762e3d8e3ba227355710e52caed531f417138e9976059efe63eeaa5da43003ac737498d04ea32614f0c0adffc0c1638514c4018ced3f4e5a851ef10174c0981d18246a50574f1ede11dcd45527dfcdd634869e48b9b80fc1607db6afad4f42270b98151c4b82bed9bfaa431f7ac56c0fb16dd1d6cb1d1298e365b13717b0dd15c91149e3911480a8d9a5a389bc50c815bb6676c5ae8da21a991059f827dd88217ef06bb9be988189811bb4accff406052fc855ec1bd488dd1b1572fc12c960fc78c1a2f637becdad34f162590ef5975a22a84e0e07c3829941bbef7f0caf6b0cbf194fe5b4e39e31069fe4befc3a4782f2de913dc4865376c9f51042dd1127757c383e4d4420e3a33c3cddbba725683863293c9f1899a27a1937ed95e5e1ab50140522706723f406dae35816c7c38180ec4d22ceefa6148687c3247c6236ecfd70b3dfb3c1f969a3888a23c2da287aa1103a129b480d61c055510d0c577d06bde9d988f6fe54996017c05ee581e211b6d9e573645a9697cc9c325e2cc6e029a5160611d7f1f3c7a330c8961a40cec43a9ee6979676a3f9c3cbb115e19da0a563d0232dc12e4affbc33f7ab46fe224a01c185c3f4f88edb19edce0893ee5829a84d807b2d15e22a59c8859821d11058bceaa6d58d0ff6d770781a3a689f444ba7d4e38fdb5f5dff4ffa5a365018f24c4b7e2c8a2b46f3876b4b8089c30203af83dac4eda7b06f530b52bb2bf3a1e65ddc74633bceb1057be4a18d93ad84ee8573b8cb23559d18dd3fe59c00f2e8b56805f3b7ef2706431d154932e0a7fd2caacb2cb786a9c8fb5681accd373728914a9c513c6fa407b8ad2703675da29a15217aa785f8394d180fee8946107f770569315d42d96c186358a65b29770bd4ec0322535e70c57b4a0914d4369fe2a91cae7cb424126fb0359bf8526f72f000b051f6ed4da4c96a63ea3492349a5f56c2acbed0cfbb519b9ef83710496e18182505081f1f2d832c95416a82188d26aff95d6af4e5af9adcd917d31b432e2a0bf24760dd40a7f08e8bc9ab9df0d3077a83ea7a4cf1d491e30df061fc9d92973304fbdf43154580ce5c6afbdbadacee6b0027da97e4433c25049a2d9feb24edad6291e9c79be747e2ba2eb137083e5433c5c974f9e244ae036dce96dcec26ca0e94c601dcd829d5a740102c1a6c5e6961eff1d5c0c5c26d6a75db6d8c48cc3d0f492c98f53634c3223393c87d66c8d39d22f5652a7f394956a99966621c8811e75673f80705865b09bc1e99890c1af54c4ce21836264fe8a60d1595fc7a4e74c4564585466b9fd4af4c9a92ba1b7b7eee9f0e91d58bf130ec6bad24a94eeb9149add9d9e2cdbc6f6292f87d0b6e169b549c4636e2873028246e6704bcc3a16f33a0a21d3cdb995e2554a5a4f8cdbf1324aaacd4f6526cc4142261e072d78db61eb2c7722f76db8c1b52d51395abab16a2cfc4a2fc5bdd7e48f229e9ab81d280a4da97b75962ea0b9efa00f2f4d8aa3fe3e1de482e1a3a9589ed148f83275d25d4fdab206d064c425aabb05d5c8410195fd6a7b4f4debe26bb747facd575b39eee423530f33fac7145265b67977001ffeb9c1cfdebcaa5ef7823694047621bb8ce97810300d652d2ddf7c9267d3d15edac42814a4be4c32264cce37838a8f7c0638e176fd92b134784cb9195140610fd2b3d313e32cd0c52a8c4c60e36e864eca71f91edf531bdbe04ae13bb312791a829c30aabb76618404682e54d60edd19137653ba4bd37e0c3c0dab22b2cddd3cb7e61dad7a2a88d69eb5f9fb391eac83d5cc4601ae48a317eb0df004e6bc0f32494ac945db12f1be66082af61d1410c7170df358612e3ba1289391258a724f6bb42d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
