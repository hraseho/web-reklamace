<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"58997360e16b935fb00b4c6c2609685cc9accd412ff78820e5a01e650b9b7b3c698e48af7fc45f2e671f0ffb3e71358b66c88fdb2194f0f670a045cc60c9adb4678a93befd02f607cc4676a78fa2db518251b4f5b902dbf8d402b15c51e891578356ce0783ff063fc14ce3891ea098de1226e0a75b7c725551af0d30c3588de69b89d28de4c5d6ca26c67c6987a02e30723428e573c679440f9c963b594d598a644a09418157c77f8f48004023d5744c2278832c0366c0b2cef927dccc834a2937c38f1cd282340634a0b4076d890f8214274958231e0d62193440c1b154e3569fd0cc7451f7a1bdc5cf4a28c79c5220ae5eab95137c7b621b79709979356cf8750a8863c690bb717f71a6a77f10de8a0d8f49504a37e32b895503453dc21f90f805cc2abdf47f66dfb353f29be9e91247657a59f3978700bc1c00f488092504414063c9e6329f2270ff5b271207b89c38034eb02525ae92c6f497cc0a4f1a341f3b6470e8a6e90f0b0da7e0aaa78dff4652b90ebef3463da48a8cef7ab7b0880c470e3cbcf4851a4d2b90c32b7eb00a36f8751ce771c8506a5d764a676348a658bec04504b13ad79131e0acba33026ce10248fd3b76325da13ef0bee2b9032d6e0a136acbd6bf66d58ff2fdf37dace811cab6d8d468ad5fab4eaf117dfd07056cbcc6da9a893ce2668c67c0e5cf441ea0733e6e062b7e101cbe56b10e2d3785cf2e810752e4a7e78f4f84df3e01d05e28d28c51187ac37dbc4a170b4fac95afde3a7a054622bcd203419ebd2b8cdd6040b162f2438a5969b5c73abb27b20c46f2eee1b2573c829211321f94fd75152417db1642a1d94d4a7ea54575725eb70b8b47e63ec807c2adccb14aec0ba982b16d67f6b1980deef5cdf25f4a3024e4b3226153d79b87520a72263af88a93d2ebfb1928cc6adb0f1f86a263cb80b3b90bc5680c8fa24a3aab4ae853909211a96161130d5c9aa82e44a7f7b02d3c92b8f6523c0c8bbf16be3af3b0a8d91ef610a03e2447e4badedff4d35bfb2a36763907c6267925dc4bbd40bdcae3163b06c4afbf49078aba996d2bc91b4bcb78e4165ff98d8fd689be38cfa032a7b8e37cf1a56e2646f245aecca3b10d0ac2a8518b74e3eb427f3650e94983ecdb407e628040b37344760f3a2ecb39ed5d4ac10e37ff2234d2edb790bb74be4f6441e723c2d7414f9a5f5e8b04198df3e01ab8de78b0eb1147693e5a244ebc0e042c3df1196f97f55adea09f578c7102f5be636a621b63e78abd83068264c9b1bf2c575f1d52b0d0d16a13428beef6d9c7cfaf828af96c1d71b53d014f800f72bbb94a884d655950452a2b757a3a67630c1a72f07335dac3c722d9a256f981e490c7a4dcafe50c0616f19fce9aaccd8eff57a57aed9d256a8879377558c3eab3765e0acd1704019547d3f90bfe6724eb26bb8f8525e6407ba7a12ebfb6ab7789314cdd3943b3d7d8aeff96b35be0d19ab09adb0129994c1c2eb6a5d469195a527cab54c6d639674c067f4b7d95d66ae37ffd785ae6110a28cf602657e4a8c96f93867175068259fd0e3c81fa5906a70993eb25b44f8fa0eee29396e46a11be31b8752cc7e70db738cbea6aa834ef8894d8fe01093b23ca44ffbd718389c60de3bd0b061723ab895fe880239ea22c0872887b5c0da24ea21ce8765dc6c7b7e2eb011015aad51d2e0f805afcd7e528457fecc27efcf4e3f54999f8921e6aa966dce7ed0e501299a4fc1449ec888cef6d822d062793e2a467c7729293ce1cb37a53025ddd1ee669b3f41f9db10d79bca10ae505ec387952ffabfe0f304dd507e180885158de06fd76370a464f35ecd8f3f3110558b35b4e72b61b3af176ec35755383cb13532d09ffe0de75f8609c2189af2e05a18a50dccaf97006c9dd72294c7848f62646df6ca44146085b0e579e3ef507c0ce5816caff2caee5ceba83f985ace17ab4116225dfa121d2378f7c8dd0a4724020971a767ffcc9e94d31b17b2f4246998fee577a3da6e09a2081520325a8386d5f55ecc0605f91309b2f2f7fe51c5a48a6fda6b1a6b9729c8deef10d853f9115bb8e5de3103ed2b1d142ec0862c1dafa4f44477b3ba3ddaf996247bd7c470c3ed0383887a3467a9ffce9f23ea08b2d1b1ca749d8d43907ec160e7864cb4375e97ff719238010e2b6f3caf386542c2bb8c078e02ffe533f40478289d38510cdda636b0036d6cb739c305346a8001b290c879b8ea6bf7a3aba13fbb700430761c66dcb90e90e2b76b897475f832d50eff84ec6902f27e74f2df98ca5b55848262e4fb95061a9c5791abfcf490dce830adf2841e3124264a9347156ae05fd334306b4a37dc773824db3375cbaa4b934a6607f6b1342f39c809b2ee595d6e00041ce951f7e07d555c1ebdda9d6b77c66eea557fe388cfdf6de2966eb24f5cc154c8143541c64e6924ce77000827d744b4eeb93a78998dddbf80b3dbd843c77fccb030a444671d29f95040e1ab75daf3d9f0eed6341e3a1cf75138afd0e1141a16c4c1da6c87472f7436ce6902767b7f382cc346c4b3ef27c81bca42006b668a1a8797f67b36b80d20db447ab38c8766261505696dfd95e821e179743b16c50d31688f93bc0d254da99e38d64c611efc010da47025f85d337a4bb45d30f19bbfd015bb7463c2d90030b3950f432d55fb1c698795047d234c4e6d49e3840c76835a3c2d880a03de2a1b5be9bd6ea07f6eb0cec23fa0b5085e49bd9b3862e60be4f8a75f22c92010aaff5031d3fbb227444ab6818b8fb98a94629b5575b68fdf1b7c282a39122ea0eb0f9daa88c8f4e292384192d88e3ef62882fdb758925f0367ceb3cdf19b88c647087cad9b77c603a04b20ad1109910c0c4dd118ba797049637730e2294a0ad921748b7743951173cad89206d6efcbfadb2d5b0312220bb83cabb919385c81dec4e1859238efded8fc9a33b64c09757bfa950a25782f21eda6780f2e4b3c42925aba730417f8673a8cbe525894a3df75aad2c215024ef6af489725cc8760bd2155fef41f2d660396049ce1a2b6e62e09b4b72a973d5e2d7b69f760749a526f2b9ba576123ccb158514abaf9a7c1d046b51b543749074c6986bbdf3598b7eaae8521388811cc90661b49e66d06acce778bc9c22648725fcaee698c67a85caf63271d399568ab14c3fb5f26ddbd64919ebc342f4587588817c399f99b6d5855eec36e18d96ff3458113a2a0cc75e282a76851d177967e97471461a1981e562d00cc4e1947f0b006eb977e0ee72efb27022b7cbf8e8742c138cad98b6812862bd636db6bb9d60a60d9ad9c0a83737f73e4da70ea8f135896fe5e1c9ad4ccfc9ce8e7b40810d1d9b59208f612094e36c464ca2f01a9afd15c6913fa0398e508d713fbdf15bb081a0f3af00d1f92e040072560bc3df50d9fd5b2fce69f550cd989a78015b3d655165d5844a1ab4588bb7363ff064bf70cba92eb0ff9f1d931463949640df2fe15036579fc0aea79fcd57fa03a07c85a9f3e42528b1fed9daffd1145e2d243e40673cdc2f6ae91c0ccf832b5f2b42352c0eaab46a40b2682df4a7ba7719f5d41f3abb23b4491d334e2b82e4bd7f57c2002a5301a2b39cc64e3da7e7cb07ba643e71a394217e943becc4081e78ac04373f1c6ad7b2a44667ec4654389a7f68bf0e6df8eb121e3b6744f4d11c0021b65ef2903cac02b8a9dde6a1ce28ffbe1bbc3c044a442ef8fad7a59cea0e08ef1e0a7a6169adf470c0bde128ba526ff8a4e6c85be4b098dae2d76ea0440f6e9db1f21e9a56d8033565c0b5db4b3e261cfa0302cd4c3181d02984b75f3a31ef4174c6799ae130052a14dc1ddde163aac3a315962b25469b1b5fe0ac410b58a040975dc778f2ae999b7b3b4bbc76ea6c7802d5eea615026b7c22bbde548bbed6495865c41fbbeff215dfa7afcce31202f0327b2669e1eac17e73614322b3a9ab0da81fc19e41b3afb0a713fe8b9b8b61a5183a22121b37ebfca5f338b48f7645de643166f21470077209fde85b719a6d03c848fc1beb6bd979ff486325d66dfb0990e8527b7fbc328f2741217105456ab1e82f8456be5bad35598535481d98cc450d752c336258f5e1fb3b3782d5edd83b92454435bb37ef6775a12aba6da33195edb8a21e9654bba637a629b20797ea64d40f5b370c84dfc37f1c1fb06faaf5e063aa16d5b19f1d9c2b276c52442c5b06e75c5097cb7e2262c2274c9ab6bbb030674d2217c19edaf6c9ae8dc9e64d6a41440ad7f8787ea867d4f7ae445a7a84f832d1758a983449f63d21703bd7ed25331111cc0741d0643678771cf4af5ad38a82ecca488fd73ffdef9ab6e1ff2f69d7871fd36ce87c0f56368dac0ca3efff0dec01b4ee3bcfc2346196f1a1a69b7250d98aa3024629527ab0a08e00559622ad4b2150b12867992de10f338f33f4c2246c32723bc3923d1929561d9eccb65f44a5b9a1af4e4a6ed81febc17ed6fbfa604b6db7b3bec41b84ad41f52eddbe070f37d004313aa746b0ee49fa911c8c9264dda520c1cf1162630a0952c94a7c3075400c19a815e9b8831f17c3756e9f882b69502c5c588765d441cf141665417d0f936247d4b1eef18360e0eccacfcf937dcb63ea363bf8d0ff2a2841ba70a5cecf9aff8bfc3f367698f1dccd1cf4c248b8ca0e6058478c91030fb1cd671a3b35d0ccab8b5a5e5b78f3aa816330200437a132f45082796d82cdf4d2ce93be2fa4cedc10245e224c1aca7ed78d5962178b6577d36fcee09a254141307d75362698f6ea774eb745318bdff5d41ca2a8f32cf36e7b26c3363a39368d82ad8b971dc4c3553cd061c0219f0668389efdc1228e3a48f458c0b63c972418b6ea5656ef035c8f0e4a84518c72a1f4b87e696ab3ca522a34e7121fc3b18d3c2930e74259da769711cb657e977e59232fc51991f32c63ee0ba692d24302e53c7557295428ca760b6a2137f3cf1ccac8662862dbf8e1ee274ed91e2a385932596c85608935683e7db3deb80b559ffb91c5277f747a88fd34c2a27af079047bee104ef0045952a126ee3dc59c041d5fdc83c88b1bd6c7d82e71836b4b886381641859d33eec97b7982143d71d3fcce1058e7ed9fd8263156b2c5e2bdca2b900f6dae86f0b2c8d62b3878542dbc7360dd918c93c8e7c25299cdc52f8579bc4f224d5dcfd4e36adb3016a5041746931beecf9a42fe72a3aa5478d89b64330bb0f061b5753ef274c54ba9aa58fafc494a36f9ee92263d6ddbd57b94e35d68b5fa5b2f3adee1c963d54d64e497ff3ba473a96e2fc8fcd238fd9889ce4aa8a891c8815d88fc7c0ab59a33648c6ca45f1b82511033ac735abc1324cd8a8b654436657922387dcb4f540dc79cbc4b82ddc25122862ad14939a764d28779a9e45ae0b54c5e0e7e32b50ade69adec5df563f94c58a55c20bcf25f80fd153404b5fcacc1e81fb5b6abdc209bfb0a6c247d3fb817e4e04a74f1190c0d2195a4724296f6ad9e73b556c6b73ebddadf4d14dcfc83bf74f63ab4c748c9df915bf001bc8c635b026a406463b148b99b59ebb120a0d02fc272a74ea05d9dd168bbb51d06382068ebce6beff240af8ea303250bf63cf2f0654a09f4ee532380cc388ff0b15fd3a267b8cbab3a624bb35f7030b7c36ac8e09ee948de9a0b65273855b0e52ee399a3d675ab0aa0098b40ae9c7f1fce5e2f8e43c0e27817391ce6c091d21ba5ff5afe8263f7c53b9b31db851f0fe1612d6b17c86ae789cc48420c6b5727d67a61c11e63aa9d20372ef7f05848b480bf471eedb017aa77ab1711f9c4708b1d63a8ed1be55e538e25aad8ba691a5a9af004620ae87b30aadcbd38597b3b63196bcbe452dc5a91e7430ab7a3de93f07a22a91eef3a367238d3b2ebe7481852a1a4c1e336041daf8113c00e848667f21eb3d2f54a70239aeba0c7803ea98a3cd39f8a4a4c1e57f5fa0a9cb6352c59cec86295ed22707298aaba6716fd8913d7bac8487eb1ad93b81feb68b051a3b125fa69d2f498872da7bc6988a0391f26ba9031ef2c3abb9a6e8f6142901e250e99eba0e765073fa6e02cc69e176bbc211afa475b1528e4fcf4a40bb10aa708e122b3a95ded2badfadc8264e63b049af692c8f398a9ba83008533430c519e85675b9a0d0f1c76e787ebe5f099e2344e48ee6a5bc64a3510ad59480d2a0d643a17352477f2620a8a62969c67e478fe5c5e2f5cd25101a0d4e715df27ae46d697d14d079afee73b6160e959022d1477e99c4e765e7ee4500bb5e9c21927cb82b428e7bee02c772ba463dae9894da488359e17d5824046eafef12ce5c2e516e2acb63bba5cd3d8c098ff9c7e36c8b5efd7b69542ca3de9425ab3a7b7753cfb95b1070cf8466f35a6dffcc0bb28fef27d7d379d1c39ea5b7d49d1f4cacba3c782123135321fcc7330db1f07a985394b28ab2f7dd463f707c50f0de3b35e229acdae17b613e196bd4a2bad0913c5cf82eb727c567c4d9b652bcb327e4f6153cf1d7c8a1a662d8d6a9d7798e9811a659781b5fef68d5a3029e166a79f047930175ae5433a03441e237dc2b81a3161905c98bd82717d1f99ff58222675de9c7cb0953d4730fb4cf80283fc9b3afe68ab93acec5351bf68e4145059e0a9a43baa4f6ce4b12f0837f95f76469d61947ecff00c7d46409c80110445582d2215a3c35de306c3267edadbe4f9238cca16a0cf74eafe2f157df38a2c4d4d33ac8bf3b9fa73aadb4f477cedfffb1b06c9923086476e756ff6e036d84a5121f16a120e66191f5038ca93fe274cd6619b138b914ca88a91410c24c084a206319f0e7f67d3694d0b9a4fbc3c883d2cfc4e9b0aff1559070377819f8c8037a04fe71b1741f4065d38c4b8421b1b5ca51599d33bbbd6db7c77dd712b6d66ffeef35a43de3f6675d157f6d9951ecfd84a8e60e40f10461b1d2753831737ef299786b099aa165521d8a97201fc633c6af891a1b706b69de4e49eacc91a9a9771746e5d66c031c79c83e5a72ebe5d85b6309029a32c6faf551ab2cfd9b65100b91a874dfd3ce4f6ac5ccad38b2f2e4582018092ce93674854d2d4a7d9b96ffecb4b903e9bac5d2156469c3e2f532c921e84efa4c149f4e4c0f8dbc8f1425d5540a43f4126f96266dbd94d5c790cace8e22f72d23fb04efd1d7cb12af66a3100d1462937647ac8d1890804ab6c45a2b525ba8fd50f535510e6a75e83ca5ebd3981a119e3bf51bfad5f19fc5cd49470a3841d5301852351a31070bd27ca80fef160225883ff1415db85deebedc74ab8bba253ea0f92747944ec3378dbae91cdf303fe86b29bfeab4a19863d90af459bb98bcbd72e0b4df6fd30e071892f53b00440270f71cb662a37da94bb83e4abbc3e16e628b80dbed915692a023ee73b0d7170ebf70a85f3f4d7512215cb133c843d046cde7f7d02f297899c7b21360b44ae98d2bdf96764b4dd530af667c228f8cd6b8917b0046de5a300e2ced4e8c62b7146807d3701ba7dcf902d836711efc4a24885971a82ad9dfafb809dd1245529b2bc573b10a5719ef78cdd1d073312810f5a2257155dcf71d8fcf5ff0406ad9bece1973725366ba258dc8c1735a7d57b16cdbe6badd6d04fc4d5a0ba7c2c16ddc5c08262a42d54c6458283c6f5ae99cb073bd04c714f38fa7281cd15ee16a3d52260e10c7331d7405d18c36dc9da68dbb90e987bf25a9ea86ea2e732f47d7be02a54485eb95c583dd0642989a4b025ae970f3e4d8283538510b57f8c860699a8f906b38f9531cc290214409f53fdecfbbe9b1ad8e01a003e3a01d91ab9ec69d775e059ba325bfd8b48998418056f795488f550a4c39ab12d3b8721e154a4dac10eae767958f8a03c14bc7762b2ae99963cf9f26f0cc7e94e06a4abbf19e28e16399876c38ccac0795cf59f4cd2ed05fa5c1b013c55280be64c40048d453d7068928913a87cb3cc639a96b94269c6ba1e3a5ee3c48a95f518e08db29aa9c11ac1701ac6d3e9ca80dbf762edbb22fcc2f77e18eaeaecbed20b12b568793c9e75bf95f066268dd72a54129882ccb7ec8b5fdd9af965a074b89976619846bce03ab33a70a361040f0fd8acebff39da148c28754258ea417cf4f7c1fded0c88a02b760a8d94c7c7c79b4ddce1b7df75113ab96248831fe132612e80cee19bccbf03a48c77f2a764c0a1f1cec3f80afffb008f1080140ea0080885d836395db20cdfa5db04747a668b63901a807de549e75c7d991f8fe39001559457fdf291ab3ca21ca8d936e7d8958f5ef60caae4e29e4b5b7ea14f5b0b4d98caa587a56415294ce367219666207696e3d3095b537b1ee31dbd833a32eed0aa6913ccb8f99fa0350d5d1b5e0c69b07d6440790021e63b1d0de662274d46e29fe5d1947f97befe8113662f8adc05d790f0ffaeda232dcb348485bf34b1f2c9eab116198aee97d7fa0b832add6b17f6d71132da761cf6aa10a462849ebb2e9de6da3af5b6907d30a9ad396ae279b770536f3bfc6fb084bd1b9bd21e8bbb0282d3d13b2593c7f65fa503f9c07266690690dc932bc754771bb79fe99c941982b5bbddd451eee143520ed63de0fb1b7d8e874dd768a663bc815f326d4fa65a37063bc8a9e19633b66e1386745b2c610fa073bcdc216870aea097e28d2234af12054a8a04ffd59e4fbae31e85a76c485e11380e81c63ed791cb531bf2a22fe1b27cae2593c2d275d129ea2c2e1194b470adfe6a7194d2ecb57e3c22cef9b0ac02009ef4b05d96ef8eab7cfbb856fb22c1da7af1ea998cc2ace9d3e66fc5ae7fa37c2f6e533758d931e9cb817cab60629c6f5380c87dfceaf6032c6f16d8253968d06f68b83b1843ab32aa92703816f8011218eed977bd6e5930286a0e7f22cc7a51b1e564a1662fef612eb50b60690533aa88c59cdaf3b8c8950dbd67f53de453386ddd374568cbc387bcfe570bddba63c77cbb626b0fa40b7431d8d63dd8adf098ea98f3793c12385d2fffe6614248452629dbed0adf3d0c6783872a90e1a19548a9fd44a0a7cd307b65fb4d323c6ba3cbc70db46a65b6092a9eabca20e53e52250338ce035d7ae319655dedcc795727a9bce8ea3fed555a407593b9d07928f63334cca7a698e37e1c0512b52c55ada8c4e3daa3c1b242c9359b1ade4aadb5c88ffed5ecfe44f07b42d945f67bfd1253c3e0317c1285c6b17d8f31a088f47512c1e5cf60483d7596da2875759a28feb85cceddfc25c87dc1f176bf2740796c991c9bb4effe1884ce92d3e142c026ef6be7bc20af3ddea5a4cb8f17343194bbb2bc0dd6f6c05275f20f09d510294db94ad11d499439212809be86f87d925d06f6a0bc1a5edbbe6e9253cd2fe9c223f4b581a06cde0f4b1a998959985d8db59ad94c91be5c1bb31b7e71932d1fa107bcb3e75696ee97c51211d48ee5e19030115cbb47637fb13a3eb2acc30f55a0e2cbdbe12875bbbeced934238d6a5c692027e5dbe556e0b33955a2e70cb25c1fbe98e5a6c9180bfabe76c3e11a0dce08d409889458f2a529b5a8500d86a8c435523bda93d9de6d9c4f623a780313c01678c4f02d2f8861452915e261871ae572f7475b8116fcecce38f0b2a3eb5f07f3319a656c40d7a591a4640450a353835dd8ce02f6759dcfb96db827d5420f95df28b5fb259ebc3dbbfd29ee45142c2f5d33ef6f7874b21896a373ecc37fa323da63f8e6a4c93315004eb69d22212ad727203eb7660143dc46da7a082917edef930a17b3adfb15ca3631a8d6aec7661f96698f0591ebcb5952a313ca1f7aa8e7ea3d74e2cee02f5747b7c62048fda8822cbb4b208a841a14d03392e83097d7a75d9eec169e2c51cccc2a039e253ca85c71e7f5ac7ac6fd120bc191ab1c2c8a6d3054a71b975290824d4f9ce0972b4ccff924ae88c3f775f7864ad3ae69614caace679bb9693cd2aae912e3ae0c34ffee484303c55378defacb0d7fb0603f4cfaa879ca8d0a993aacb66ebda5a67fa5227fe1644b0c67191119dfe8eef161014ceae6d5f79c1b63204c0bcd44c12217ba4986a780dd4f9b3d392fadaa992b18d7946082d12332584530125076d168df0f4070b849a7e3e9c5c13bb5ab89f19164e9a5e59801b19374645be250414fde8a6675d39196f11c5621d322d72f1fcaff6e2f785b77b21f29e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
