<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d860f3b4421dc882d2f09be50b6269352b5a6aa7d1cba480b763e10762ca15cd3892024c7be6c27cdee44c9903b43841453e625cdb44f7d876ba2f1038b7093d60d76509cf71f198e0812b2397aacecd8f5c9d3eb2faa6781ceac833a99e12d91b6e977f11da449bc3b590f87794cb8ff59feb4a49bcccb3321f35384209f77f2496dab19cf3ac3389aa494d078dd02e228984f912f26c4c4f164f9568f4c61b52c15d1272669305c7b06ae7243e2685017649f4dd5530df3e9eae6d3c98eda4d7f6e382154717978ff9ab5e36fd965457b95fd6acf211e4ed0bff2da13c98992b256b26c4f02477d7ba2eac415c248df792abbfdcda8d88d4768407415040058ee72cc14c1c416b3428ad43f1e71aee812e1437a5c52cf98d4abf0814b7c2a735f474fc642ef2f40ba9eefdcc4ccc6ce3a2ea878c2f6135607e714986916013524383a9cbff384d6e2a89081d2ad56a533b572b12d6b3c907fad5489843c59e0a7041bfbe966b3fe7f2b354a73232e1de562b9f83e7a05ba3c70e0a5251645e4c8e7248ccc5c826ad93dc38a49b773d0e49c80cc01fd2fefdb2dcff0675ce860f3707c93a0327f9dd7598dec1798715163232424a9354e891694612187a9320af874e7325dc037834ef85afd32cf70ef1bfc3084cfb744d023fb089dbb89c6a6491bcfeab45df8463de4578faeffd92987bc7a53a6650a081036f1850e2f8bdf14f9d07b5a4075e3b64ad4c638f3b73d6bc9ad87a564558c98c385eb0ff9946317abb40c87c8472568825701cd3627512cc3ffe02b13382caefe2806d5c0a355655f4b4f3849c79dacf2f8b93f5548c38ef2ddcfaf8e7c7be5d18b9baf89eb892261ea6c19087e82ddeea0b64b62a4d60e630746a212fe1e7b9ffa081ab1825f3e5b8c05c264b244dde2374624e139fe55fc2234d249b079308160e2b8f3ad82fc5a6aa07bd0450122289d7fb1b2094a0c2796052c140975b1927c6b6efdd0659503d5c049dc08069e457516f19850b917dfac8bc46142606fa7fb18c87186d6d6431c985cd45f083f9cf26b6bac42d34931b6d46888923f413c43bc211c4150ab29382732d2330fe47f801e685ff1ec83223d352702b512f812d303fc662e3225911bec853cfdbba2294b81ea642f68fb2de05ad9af02e2ced28e812547620c65ae9b5eb82fe0db816852182810a0ccf8e08984851c266c021dba82fcf6e95abadf0be171a630ca4aa2c752d533089e8ae4110dc826611b2699345c56050625e10cb2afe921fb34cbc78918c52f5885172d239b9bcb9bdce95b87ccdb389bb826eefceb21e2dbfa15755ea6b1425dbc1068110ed82fbf9f1a40d27d14cf94d5dd1929807e1b08d24c34491b285d92c3905def0cc45e4bc966651a7f9c9daf1528148c1acce22af745d4003ed87be6db85755fca560c57495be2fb240ee0d39f78ec90ef8f7ff26db42922453143f921899700323c3e5f90ec10829e10c9edd5a5add7a525b872592bb7b683f5ebb04c79c259cbaac63f3ae6d4c115838ee4c3174a95c1da9a77c28a1a09bcb68beea883ada61755495bb1bb41347ce0626cbf6c10be3c61a2303dcaaefc5b960c2fe6a4c41edfc104195e93d07f27cf057e27b487eda2042d3eef31b56293dff0243b23db5e567a25303d5951812a5a7338d0b35683b8f4b15ca94115230caf66ceab38d94bd00069b6806f0f297142a0cb55eaf992390ff36b52143e781f2526361e684aa575e65986c903e473cf483f7e1421ba7f5ac3838d40e668ec82b8a02780f46a4271cfba84b212178472c3442910c2510c0013f8d7e1f2abdf272381b16211bdc36a4eadbb3d8e3429e440b9b1acd0b70a699e8e90171568050f58a1f0d74b4e7954f95ca82124961c841155ad347da59287903140579ce966d6f6bd4fbdb3e3a79876d65d12b4e205922d8a6f6f1986e04e162d26371a4cbc3ee94aa092a85439ab7f21724ec4838afaaf33be6034849132b011f8c03b8fdf701da9abf4b68ec50bcfcd1bd9ded70dc3f59e1c7d11e6d564e7fa7661da613d378d35f8445dfc1d812e768eb5b9035d6b08ace0bba4c493ce384a6181a6210db711edfed4c784a124fabb248d22d94766af07176b401466776c872cbeb1d6f0014bf936d3346657e867bc982a7f7093886f63c4cabb0a267e78354c7e38b8d15406b4affe914d4c64e7c2a462ac56cdfce65fb4951d72c5b21302008d3eb41edef17ce2ec11ba8145230f3158078d822c14aad213d6c2b6c8b3daef62453116cc804c304c91e9387b555954a75750893b4a6c5c7f0efa61436e40c8b4f5f5de4a6abf050d6c6bffbdd153b7946c3c679f694cefe8f51d93d234163049bb1b3c66b347fb3f13a5268ec5dbb9a46bca32d6b79076b7510e98ab1fb6f22d433f477236ad1350ca6df388d5e16e135684e3fa11b66fdf90ac467b75c526bef7540e752ee18f28559ccc5e040a15de7c15c94130ff64153ecf4bc91b4ec95fef5a5cbb3898f7d17ed2e609f3b3431b24bcc34f57e3519a0c055aabdee3e52397e8b3a8539fd0a404649f54c3dcb3865c28ce0728beec3089e4eadb6d6b12f6da20067075a5aff799e016060446331bd3a0ffde61cd695b0f7df1d50dfc05f75c2b3ad2098f05d54f79dbf9b3e7ac890bbd2caa528846181ec78f897fa0744ab5204bc7816060e1d47d0de79ff08d48a013cee6406060da8bd5a4c7bcadc1644f4f883657142f8e482ffd67f792a4c34c75ded399354290273b7ff386add34ddf62c57d8df244d695c6b0baf78dbd817c8a83bddbd8661b7c72171fd0371e92a10dc8fb83ad0e8ec6b9b7a19f704434d5e8f58d00917a564600fdbda52a95c6809e41fe3bdb6aee746e5f4c73d0d9c2047eef0a69cab347045cf37a7722e2f2fa71bfc4bdc7999f379fbaceba8eba317cc5ffdcd750ff6b35a8842332ef732238da80ac8fd83ba760245a4bec40415da21e231f904323529ae5d8328e35799affe0030cebbaab5bd321f1faa1b5a0a979b3e7310ce62b57736f6471b51074992dc563d538592c0e5eff2e336af4848edfa1588a7710228bc12eda8869a65c64389ea798eb6e6f1173cb1179c791e37267c0d4d7843ae865f640de6ccfd73c156c0cd0fcb48343f9b20d324f348901178e18dba917009fc1a862c8f79485563335ab400e066d15a3d1cc4441751f3f5e72feaaa7bb7fbb726f909a2ad2e9e5e62738c4ae0bf32ea763737196429c2596ebbcf17a1db543d6c23160c5632ce478ebedc6e6a328cb98bd60949ccf0ccccc45045b268273c0d6061aef2d8ef5077f4723772278bb1d0c74b9c4d7cbf973ee4dc7f29b5e21c756c1f1f43a46ac9f8abd0a6335bce98df83bb78d52add5e77fc92bfb6e36e8f46025d4e3f751250bf44fc299ebd81eab3f50a073b7de3b062c891931fdaef21f891211f42baaf6288de24cf860afd343116f3215b502cbb344db69331d84a259417c84eb748df6195f16d26efe5cc44026b6ab023e4159d16698166135d50a46d9fa0738f73e6f965df91ee52118ab75ff9b15d256e5f9a5f1136d8303ec46f6d9d72b9cd21d11d5caaa68fe9f588876a20e2dd2b1d6ee92d2b3286b5b9d89b738d7371ab2361bd690f431dae811d11809a9d0a4715df70dadf049262453ebcfe94102855449a02bdff30349d6957dc8af76d4d544dca9908bf9ec87134a16d4d4d3da10b39e919ececc7e0ec8e0cfec50a903a3ec2909200d9521dca049d6a40481e39619a515b10f675ffd7d6538c7c60420143cee7a2c20b2c852ce102c92a4d9012678bb96dcee76590da02c0318c1c9560386f423b3a0a513b5fc21bafccacbcb73fe0112c05287627d095e7cad18f1bfdb663400ce5bbc3b067350f4c9fda3be3739e42dbc507ea62edc979ab990a87d07f539509bba3a9708ae096cfe43f0e300870f84c0c5bf186338dc60400ce0073af2514dda92f40f5b80da078c96171c78a593c92cb2334f10e94568ebfb231315e02abfd3fbe7aea93a8de610cc291e9fc55983797261b00499c84ac562cda1a1929e9cfbcda70b8ed0f8219041bb2752efc2be5b77536d79e67c08249cb14bada711ae231e2c21788cb646db8f052dccfc6c62bc3322edf4b246b6bf4b461e047522ff00b95dfcc1324d76833c082f7fb90db53b9987caeac1c65da97f5fee8884178cc08e39dd095eca4dda2288bf38e98755b6312c92b67e0983ca71b4f3ce66612ab3f3817cda8cda31f8c0e69be9401c429b41cd0dd0ab85190caab52f9051f4a03467d1e0cb8df7ba1721056bf3bbc3eeebe0d57234e20c4ec7245dc83259eb0231c0a7821e5a775eb94970d8bc6dcedcf0dc0bc4f1c449841b054f681e9758349c79bf20d3e771edd06b5fb7cb74cfdde73473bfeba9be90dd54f01ed1452264a06a562e43b6423666e3fd058c531eae106f012800ec0c2ec11413e304e33ca21a5436f2914cf0a9ecf41baede2a4e81793fc30c386c4b0ee7b30b67cee3d3df07bab399c767bf3ba2097d7b61ef9323bdb58791a236fffc46b1ec857d1b8664eb3eba446e7219c46c4d80e5c3c11b0cc4628b35859c5ca214b83a70559e04ec18ea4c0d0b06288257736b41d17f8b94cb6391f6d81525dfee28e83cc6b3be99ffe91a6a20ef00c5ae2cc5308059ccacf3659d0f6d1beee232ec3a27dbd29658aeaaf9bab1c59dcc2f600fb63f929104c176154e8e63b5aac6a9ad96d9bf162bd44cb84c5a80a53a75b13252bd4f7f79b5f81cea95b501fb65a66681a71167013eae1a831e1d52b42ca60924048b0ebb96c3c540ef888b1147e16f9d05c8104dbab16bba6e987493603386cc2130ad50424c202a64822184c8f412975cd97c565fa3d57079828afed392e375639a55d551077652f5e69252faf64c022a48ab7ee79fb64583ca2384516c709c4f22bb1ae5075dee8542018ef6ffd780304adc0d854a74006330a0df99583145c7a9983ec916d0e02207e69f27be3698330ca5b105a3fc28948c328f2c012665c0d2164d8809b2c29669566ed3dd9ccb4ce95f7a3689ead030b037142a516856ac1df6c8f4fc88e91b86a7952c185bfc8a947e4e02a3a96609f5ea9310af08eba982ac894da7286e63760d19188900b11e5bde99be4faf9ecff9e359d662cd282f7d5907ab80490aacb5ccd49c34ffd75ce0c4af27c611d2559b0b2cdc14378a7e3e95845044b7f98350136a4e6bc5ffe1b11b2e9a585f7f23e18b14af7c24b029187d27911ce6543a0fcf474acb66b7d4522dfb6d993f511ee8c86f5720d51422c60f75ec780485d7245c5d895831cb6c913ed19b881f5816c6b290fc94a6c5c9028fd6588e674d09672ebe2f0335155e0abaac2f2722269f51f3fa602e366d89f21f012a5efbcbcd9d71494ee03e43546923f5ec9a2e3816ccdf4f6040f4f14e01df0be317ed16a1b2de4b0bcb1eac3b42c7b355507d53ba3cc39844b3118f9e608bac15239a82179a22dcbc0a4600ddd089c92be2883ccf80f40f8e290fb56ad6102bb50086fa5d8ff62b1f323b54e0d8b6495cf2cb80f71a4eb257f1c034984bf2ae585622ef7b404bb90c5151ba9ec65d01275100155d008cad8de006a1c77630f26a6165c97675928139ac8ee768b84e91c9f3d9874de347ffea2b86bbfdf0c5fee45f06316f3c137eb6e12cb0a31f8166125a4b47b5144c0f43b2e8c5f12c3c0e690eea036b2950705b77cb8df594b60e0e2c1348c4dfc266252d0ebb7c1e12be3a437fcfb2ae8e0d1c518905a4f4959b296ffedb2d77b6af7f6b709c4ef753088db7820bc9275ccbec8e22baa697505683cae8a52d75c3318d0057b17ab54896ba24f052ceba6509d84b02c1fbbe04d51f64efc502c15ba06374858d80b88e816ebd5a5c53f5dd273da004e9af32652acc60118dd2a89cda51c416722768dafee494f0282465feae9b325d6b494025b32d47cecc3cd1f9ad323036d58d5b19989614b90c68f58c9589b11bba2fcaa3ca0a58ec8c52fb7e9b1f9f7e0a331795c0d6066edc162f36f55e1719d6b47a2b694db9904a3a44b4db68eb618832df0574ac720f797d267fab0dbbbd825a319a839583b1c63ee68000c9d14ec2532661d4dd9bbd01dcd1c92550d32bfeda81f0100b020d318d2ea01ef664293a746b38dc64615267ed14a1f5ed19d75a214397f6614c16b96998796f6cecb3ae1f92f62432d5f143747806d1ff8a2e82bc22681d03345f115c58a1dca5aba4af8b7c219029e0c700692d0a96fcfdc512a53532cad89f277f12af52144ffb40a87076ca65a8b3a1fbab344588bbf87cff19231899b676a2717990b6e8dc9242ae89094ed00871e01ec939000c45419b908ebc58b424c81b9c225f6d13f4269dbc71e0d7eadb67735eb5016f5cfb24439a7c6a0031adf8e94a029de5ba56931c182783acc66310a22656f2bcb80d9dd288715893ff278d9aad513fbbf635d7192807f84c92cd1487b5d8ecdac12a658b9d5eff252b56f85d4661719af31c8dca75e66296d87045bdbd15de679f63be826583733afaa2ac158b39cbd056c5902324bda537e02a9829b8a24d3595770a2222a30dc0900e37b2b48bbcaff9d3da0e4fe0a9f23c83771693754a38de3b58d9b1f9d5d1223f31bcf4c65c3ace4f1f5d8a52fe34b8f33cbfac449bad88e25b003235b4d8ca85df3ac50ff24b90134d4fb1866998feb38c0139ce0c8fcb6f61c7e1046fc7b4ce5ea640ede80d52f8c07b9c2e8f1edd49cdd7199baafcc31cd248449852626d70c04bb1ef5d4108ed3f91625e93c2ed5a420a2f78dea99fbad374fb44f79c2cf1a31b8d217b7d451e563e7006b26e376af995d042ad5df8b47feede4fd3c897a06cc253d5d3b61e5b8929bc11f37b11de2dbaf81a8d9cf4eb5382d9631415aee20b677298ab14b28bae742569916847fda0cf221d74474377753697421edad6fa4a389180f3b5d13e0f862273a5463105c3ef687e6e0fc2fea3f272a3d4d352f30c78f8909c959f5a6e8ce79df7bacf90f6d190b2f90965aa5a2c2aff09ad4994881fe4957b90a3ec6a9b9b0a3248ae29d685a9cbcb7199c0265c0aa57a3fe7eda93ea06c67e7138f94f73a27ab20e054dfb7dcffd140debcfd0b5a5e41949080db9c80c4de5bf6be68e7613bf6bdf7b3de43539ce9579a90d3c776d79dc2a1b18716121e710fbe4221d6fa7fc45fb83b8d48b28d8e8008ba09b757c3c562929d44adaeefbbe6b3867892cef4232f0e48fabf16c7f7b82822b3c5c1a440ad0512e25aae32618ab49c481687d36373d0d0770f9134ce2ad6588b529cc393efaef6fdde317586c52b426fa3b50562dba58a0567ec23843cd717b4856ecd66e7e53caee0591bde6075747998e10f65c96da87d66cdeeaaa711ae4e81631411b51fbb9bff20bc451cd1cf332cc8c3fffac6b189da2d2567b4eca17e1187c154ca62514e4ecba505cfe49d361cb7d52c78a143238a45de98f6be7b7ed1d32445a1b95a029c66abcc65d9cbe8a9dd70f2021041afb4dc6c8b7c0c85258dff1f208804ac52146eb9fc59cdd66cb2ef6f0652aa60cf4a2202608e8f577a4ce772bd6011f466dc3ac74ddf5666d2d92b2c72b2496809b23cd68266ea2db7a1a15f5134e92f2724ebe4cd1296822af5ba902a0dd0b6ec2d25618ac61400d5526fc238ce10cfce913ca9c633e86e9f313d119cb3d6726f284c70910a073408987d92cafffe2ad087dcea9954b412e79840de038ca5377ca780ab859ee766ac3002f448be1c881ea9d97b21ef2a61da7a298fc7e7a651ff4a4ecfc57275828ef7dab1debc45c4ba2e419c0bd2e1335a795d4b953a8929a18355e6f3a1b19f4a061d2862364c9698c980dc214f9a186a24498531f54fadb88b32fd27839203560f68025299468a9f9e02f5de281609d15756fba223d62bb90e77c35b02bef6f992dd469eb932fdf6128d9f0e6eb8aae8e65d7966035c861bc857a13a33938d479d86782ad001add8c98206eac3432a0782e7ad3db4d48f01a92f5840951d570455ed1a343471ac41dc069d9fab72fd9b0a8f455c6dd640bb8983303135161b899ac91134738c672a75547b4dc65d049c577d51f7ed1bb2541947c19343538d84557f3e9164cfc8d255e54b12d31fb4f845337111fcf302e82fc704a61903bdebe87143eed98023f7584eb59e2069a8c4807e0d3cac9271e7ddcd5a34734823af876289a96ede79647b3375de1b28b9969acdbc4466811d4cf9a91efcd1a4e53f87fe22d59f6ed7ea57a79742c3fbbf1f4427b443a3e6ee09177dfaa58c5254d400852deb30619959d553d8ac450a9d72139ab4011403bd219dc1a84751836147d8989377c65adb1193a175e0916a5157e7c13ea035ffd8682aab33323c3be7410684c12d8f1eaf11ae4257f773357c2b5c0643b4c1c1f4e07734871e6899f1c157d22237992a65b8398392ae6cade5c94832573355f5453371ddfd57a1eefe68245a04a1012c3172f3a86e8a2dc06ffbf307faa4e50708202ab0ed11a271b114ea14aee35c324cccef3415c282304623b82d2811e3f164724ecdc46ed3375cae296eda756a42b1eeec58d9999a953c8c636c1c76b54c8e53549ccc4fa4f1b484511e0f5ea58877f62cc3c3d58c5a9500fbc9796ca5a6ff80b473352786779ed77bf8df451ee043d87e7b75f3be395f4242fbbbee4a0c899f99ce225aac70370ca83d52c11a958f1b3d8f0def9fd3507cc648aea61e2079d8e69a5ac8ad415687efd8b2a13c6e936f0975eeeb7af17c3ef0cda85ec5ef362bdb7e9ddcb87ba26f64c89b5d20c7136715b97dfd67085d6d2a85456f4f8e0ccf7d0b9fcff112d75f4f3dad5769cbc4b31a97cacafafbb0286dcd9ec4797417cb252d22c703c0080bf6d3ccaf7bd87275bb800b59925dab7a9c6c5f78cacd924d28efbceb21e9878fa4012eb168f6915b6f45754360c5f1876e3b69032153e0a87e1eb785177bee14b56cf3dd3d0cc16c744aecdf1c65693c2c57904bc86f44071a41742ac9b79990d1cc9e88a19e97203963dc0341bc2c7a1169eae0477586301f654ba91f1755db990ad1dc907965f704176af6e6316648114254ee62ddddb375843867f68567213ca2b06d50a9e6b7aeeaf2aabddadc6e7bc8f2bda96d8e53328f3adefad2283aedd19b6f404f3e6c1dc796e435f1e8d37ca7f91ecba3434784a5bd6f002b8cd740386cd997f5f7893eea84eb6c56f5606111aa9ff358c8fa7b9b4f3371669fe24c8b7fa51a025c619675245ab61e450e1fe3e0b96d8e3fdba922819d587fb2d7bbfd4e4289afb63ed3e3760ad1f5cf8632e69cdbea17392fe83eebf6124aabac2ff8f7f83c57030221d4375eecb3d89ed9c93cafa6c308c334e6cebceacec93b3abe728a28bdc7f35fad32e498d85ecd23540ece46f0f8ac0c3d7f9d1f26de8be2841e832be96da6bc72a9ba50d8398bcdc49d4919305f8245fee8de0700d6c2fd9406751cd275648b9bde6ce6182713d71b44da3e61b0d3021c0a9debe385c60a51e8894eab97df86a477de7144105570816e63aaea287edd54f66072ce08de6a2f2297756b43ec7e0e31e6ffbb0ab8216915c520d4f4d18ade538338cfa5a61e5bc38ce1f3abf6ab2af09f409a766cc80a22f8344e170f392f36801949aa500b291bdefc72d96564528c8d4e6fff87f3a026c7cd4eda457aee0019b3efba2cc8d4ad7cc59d6348eeda2253ba42cd9c716e6ba1d0bb740697c515fa5b27b0d4d92edf16ee2e655fc91c62a7bffc299921f34408317e89d469b3edee157705f44a2270d26829381fe36144fa213fdfadeae4bc92d74477891476c4074f0e4bb74f7208e418b813ef4d8c66dfd08d0de0dad1225cb5383105d3908364457c0456844b253cb94297d6d874f984a45ccb71037cf33f175f5f1e10994cd39eb28c18d587043164a594489d61af24f3c9b2e6c34d356aa6dfe2e1150e87efced32acd5a9537f0f6e36ea3141adba0ac244101ea402a347c88171b26331031e733e5a7540bbe3afb6e5b8a266c259b5a30405538b235bb44dd83d5567e0beffaab88827836c66ce64e8a8e36bc920923800f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
