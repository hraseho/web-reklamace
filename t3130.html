<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16afdd2ce2cd617f0944a74df4b89ea755e3adf1fe80263c6e60e27309cdf0cdbd0dd53e2f8a8e1e5deed9a6d92dd909936866d71d3f22abe7a6638060afceb94f91ecacd631bd0e309cc26b3454800adbac4280ab975a95508a33a0e429c46d84c3331379129dc9a853a35abf3c4a69b99405d5ac91373aaee9e418bd73efe0a37e3b9ea7c8c229445809ce389ba744c96c3507fa2f10e46d92c119bf42dc974d082b24d1780a5d6a84f1bffcefa8776d69f7a2d278fca7b977654f5b12ac4b28a45166278570ec9543749e7ffb0bc447652343158460a3ac50734be9a882329ffed49821e6d96abf55bec1b672381349f2530de01bcba7540107bb8d706f95e4fa54125f3333d80ce9e772192c79f06fa335c40d3a7e3f59ec4e88f7e279bb7b0597bddbeeca89606c9d0b77be74d0fa61eacd4dc301758047781c5e987ab360e801f0eda40680add657031f92489cd8024d50ff6ca0b99000efd00e0685da786457729cc685a2e031eb200e5813b66154e929eada08a709b2d605854d3b1dccb64b47400576e0bf46d27d8e4f817902fd078d2fa18bfcb25fd34557b2c6dfa57839a4aa2ebf07374bd354ac7fa63671f21eab70bbb1916ed9be7bb2b457fd4b274b4596b3fbfdb96a8c83cac1ede3d221c84b221e0f1e68d3a6f0a0cacfb7a4208945a190e663a46496ca5da1d904eb627885ae90555dcfa4dc2bbcd0e29b8973a256a4b74577559880230bf2dc98d85f841a459e67d30a997896d53029b50cbbb44c904cd292a7e20c3d51270cd26df829a54c2ee085fe37d79b91786ad5e0a3488b06b3760ea41e40f6df59a7b657d296cee78bb987a3e3fdcdd78656539686414b3a57d3913a2a3e249c6ae4ea6ba23283b2287d3f37010d49cc34da049838f559e862b1a5668f2814d803da7307d3c2ad9b2eeaff74ea56670774a5f1906692a942167390e4c238b09e81a2345759e6636050e810eda08d5969027cc0bac9c48e3dbeb551ceaf7797f8561bd0547e6d924432871b1cee6239d7664fdef8d864bb8564277b0e3ea1aaf1136c0e6ac8474687b9dc82b812d86a63798c24623fd9752ec0a3555cb4092e2134d3cf0fc12c9413830e97b4c9b205d7e9a03c9d4cc3b4a32973559e68623d7570657921bafdb0773164913af86295150dc952de9fc340e8990455de9d54a8e61344520b5c3017e117b9afe510dec13d642a5094bfd518ef88375a3a8a9c15f42d15aac297a4cfa090451fd67c9cce5420f18193b4a9104fdfcbce850673e8f0fe89e8337b3e161b1776ddf07947a0d4f1b23b258afbba09d4cad754688a8aff4525428c60b5f3895fcc1fb1d019c9f2f2a56b5f5440ed3c481318a0e05733d19a2371d23fcb9a6596ef4f6c015a0e2ff01ef81014c450552884915c8917e7f9e6c0229da472bbaea9b169cbcb90d5f427ef34c047b8ac8ed2843abeeeb4d4be977f1d05dd085b93a74eef22a87eb42e944a293f49b6feb2232f17060555af379bfb9bd8df702325e4345ab426ad254a0bb02551258bb9e547c818821d4b99ad3e9d94bfb8109ea38d3532a110a0e55c36a198a8583ab111f37f57bdb8fb5e71fa89378211e4b7470e832a5f1ced88d82ce14780142a6d7fdb8599dcd0f73e8bc7d533bac75fb50e875a7d2245e5ad285a2466b152d6315eb66bae1bab074861cd69724d482d0cff21018f7baa86e4acfaf21c15c63b9d46e94b4b948da0fa37a704130584462f5c783af487d6495a9ba2a599a599269ef9d93bf91496f914ab63f27f1b963b0d14af4f6bd1e568c13f4c9b0cdc620eca14948e213480ca363d980db91b6efe263c92729a54ad0ec5d0ec638312681cd6694754403b79197bbbd86705acd7cc7e870a3463ef1d850e57c14d3d01cb60093ba578ba86e74a646541e4e9893507435b5f7282496b50c0b6774b2c366da7654ec5b1aefef8d7790e05170d7a11c30da9519864bdc6a635e6a2d0fcb02e2bed79f222ae0daf00b5896b0a563ac77fe970c1edfc0583b796ec498b5d4a394fae54c7a4e6e2f2c3ba0f0447d469a21c98722a8edcdf55b3f603e40ef213286e5ce307e7a537f73d195984560997eb196123d593628d5ad9dc371dea9822897e56fc6a4caf0d527963fb285651becb4e4668d5bc7df482708e55e213d1c8141b71bafec3067e52d2fa09edebf7e0565bf440559fe8c40f27e88a06ef4ff45381841946ca5e95ca04a746c51c180904f3fa941a8cbff6feb52f1ecf86b4f93331265ca60e4391a4ccdb0d00e7bd915aeecf5dee3a243c8ab55a18cae1a3bd541a4fbf017d2cea8cebde999a5159c895818ada297ec235a31f841e6b54391de8e2643df6a882632c56351ad9f9106afe498e3459991136cd9e83be052f0dea7deb979da6d47bba4936e9023723ea134509c16f292cc371c75768db3a3946b5692d0cc1602dded94e50a82dd9a2fa27ec75cd0705c0d21d9e1b285b5f33c65653ce91b22bc5c414ed2fcf8ea8b44538b140b208c150e3d63d599dd81eef71a421e14c48b93b9f66a1256938fdd5a5ebd2fa8206afd4aab837b463673c2115b0d9542628239c304e43d46114bc0f278c8fe9f00b0765b853244b1d3cc2b6f39897f6b9aabfa3fc28ac8f0dcb2bda071625b8bb5bd3d2ff9afbe1aba542190c5eb2b81f41d9b37252d877937f9d2823f700442ccca2f47d9e6c125eedc70b57f6258e646c05fe672c91953bb502bee3c0521d115684a1a82daf25ff1332f59f8564dc7ff008a5fc4855bb56cd52cc7c1f8f1bf55e2a70e3e060d5760a58cdd3f5aa1fc4373e8cea7d9a65f356e96328938ca61958d6b6a8612a01d6c8bda6c102a07da174980df56ccd6737245d201cd0e48bdb9ab345ca22878554c6b486863154786fe1d0dbf51f39542ce7b19fe2d09c13c2d80b2b4e00ad1fffcaef446923eba9446944323647205c1d613c7df2447b454bc2d192c31964db79deb7fc3b6f1c7b467237a298674f69fa8ef7b7cbef7324e2be5ce0641b003ca11b9860936ee9f96a181381d1c62e00be1542d9a4127472d92ca849885f522c441263ed2d484e496872ceaa914882725e3526a517d5b6b347d0f2f1d675c07cec733a48c1dc323d5656f82eadb7ff2ea10470067a299a85f43bb090fccc67833ec80584fe90fda698d20a95e0cb95f2e9a4d58810232009dfd5fdb22452b449fab3393b081a41e8b6bf337cdfff0847e4abbbf6065688b462586e125c42f2ea669b85b4bf58642023fd54c443892d4aa3908dabbd0a12f79f85c9f64b0e1474c5db3f69ecb5d827bb974aa8b192be462acd4760853882de25548b3ba447cd86dd57fe45a55e462c4e6c49bfc6e09abfa0b73841ef732f582cf5a2d97e63110b60801b3a4837f15264923b2d56b81f63f8becfda7c7906debc216a818a0572c2c3e250791ad8bffa9f6dfe5337447d20995778aa6016cfe91e365aa8928012271b63d0a330b75c339c5129a394557dc035763f972075b7a3c7d02c187aef38ceebec9e4cddcd9017133d805149442c8e7e09bfb79ed5d2dfb8585e3555fb5e7d2e063dd72c59e0ca525b876814d6812b688c7891690b8a45e0258531b36f39d2abb5ae174abc5ad7db06f4b41a626b4f96eed1153186adb412d8cf78505db2324cc570d615b907747b6a9af974af686d80afe1fbdc8d6a7ca1a0fd6cd82de69bd6c13ad9fbcae0a8df5c41fca101385f7201e8ea767dc8bb1ccdb41dfba85523df1682bf6dbee967445526760f19b1dee394fea3a04e8c4b65cf13548781c88a6f1e099dde41767496118a5f83aac96b78d8de1215bcab5641a06f40306e6ef5f12894ed8b0cbb2be5d59c7968da2d4c4a90d82c0ca39f279b7c97877cf533188a95df88416af5081d879447544509f92ce9396607b6655d1fef3f5d144e23d7c62c83a7b4310881bc5634fb8de4ce961e48b5d221544673d9078e0d1a626ca8fc3c5863c7a6e6f80bfeb3308d5ba0ce704b7072286d43b7d30fc63cb9fe47e488ce6d60c595a6b1536c51bfefbf589f444c43030da3456bc968068aa4bb25ef02ab041d14f071dbac07dea3a24c43f1b9f7769843911eb6cc1e49c46eb0cc984c372014b3b5ba6cb45e42cb6b78d35667d65ca08bc9ac17a418f42989827f607e0abbfe19454626ad777e53196a75c2f2d23bf8e5a0f0c535a769cafb05e24580f7f5303cb3754ad129f06e122e86c478c91f33d66348005f8e7a7fa5261c66271edbfbdc2669fa2907aeaae97fa2e277962cf21ced340602298f76573ddb2df813964fc75570142143f40e23b0bffd3b5d1fdeccd6c34aa5dc3628c0a96c091ef04c180986cf303909ecaeafded20c7a4e9b7f54961d30023126f508c9d3f225ea45a147d2f518770cc24bbd804b6a9696b7c0a38424764dc407aab7e4bbcdaef7082044f785659ef4529228c5ebf7472b39303a7106f794553f71274dbae262278f8f6441e87718b5b3b480d46b50174d99a797a99f2c5e4ef7c93ff74d91f579834bb60dac63f0a19dba1b36cf1c3b2519a1e9115fb3e5a31c99d778c529af171653ca74f8d926c54a5a6fcc0cbce0891220e4faf5ae7dd39082eb745d6cd8adb0bdf334f888d128f71663588c914db2375394efc73b81af935bde20fd980b7836d7199a10cab6390d39befdb29556deb49373841ef9324835b057b5b82c547895412ff974d65cc830a968de3f169c9b0287467177e5c027ac7a52b089544dc88f66f0a377542ae823fa3ea079e738497e51158368abe4b06d05bebcb1570ab882763dc54018fb8343a8cc5efa73005d3a0d208d74c7cdcecef9b1e846d6552ea20d39f3b13d764244e8aea2d23a36a168ca6299274465468ae3040052ef3d411710bed4d47b479479e2b64532ca7f47f88550ef267f7525c274eda7465cab83d820bac8208e59a85d8aa7d240f2a9c8f783d88f8f9a6c22fae977bfdf8563276a08f44ab37acf3410369a63a5f6be3cad9f981ce1359da77eb2b1c2a6034e0aad55c42d8d9486656977665cf516e4136dac57f4e4876e8059977dfb4c00c0d7c940065598955671da8d68349736b94a6406009ae83538a056327a4c92cc3012aaf6a433997bde3354e424a47647a1b158ea797f70cdcccf2a66e482074abe0b3291c67743803477ff1f589f91a0648065f1aa6c2a7fcd752fbeec6fdb9591525caa29ab85b82e0356c0792af2fda5894f6b882872d8a3397e86c05d092caf131bfd6a616dc563bf03482d7a554a1f19a647d370788fa5f66c0da8a3da3a4b228f419c5a4c9fb65e04c8753e53f9f28234684a1e325ec237017d33f789b1707614211550bcafe5d891dfcdc62cc8d2c23ecf325301aae3e8dcd9356c4c733ce4f250d7857f7001d77cf0b6a2d70311f9debcda833e8478bfce40fc0f4b16a9594fb3f1c41c680ae9521c473d70b01d0a2d59670ad837fe78afae06535aa92638d370670caf9f68dec6168c712fbea2e5fe7019c4af892a89187c05eb5fe1091f50767d96e1a0694e2e6b5611677fb28bcd5a0e640e9dc7363daf99c2ab372b89d1fdb79a4da2443ef7c1322ad021e47b35e3c6eaf567219fb7a92f1fce0e900cf7cff42f59e21c0adac22632d15b27e07e3dd6396b936365542a60c8991aafb1af15d238b10f1e6b7d2cdb62a1f7f0869f6f54c27fdeb09e37ea07de5304cdfea2160299469d497e1fb1c50c5b3938f5d23a49aa075050620688f80f5644c1c875680932bd7f269e7385550488d70931ed454f042acc6216513264d9f42ae33e4eb378b60e57e294ccb72d8d4f8063c8436d27824127d0c0701e658d3d6c818246cb1a41b4d43466264477cfdc0be5622d022ad5ee779a5e98fed9cad609402774a5032905505cea8886fd8a8dc49c0676441e50957f527d0fab52eebc55c282f67e48d4c93f570230e2ddedee79668051a78320e829860ab4f3e8590a32b2af092ff7928bb55224854f374218126d45d369145e864b18711b4eea84486a12c3af47717e3326f046e60a26fb7a0435f8fd0543b7aab6b5fe18dfaffab7353ff1a25e01b49c7e384ceabc10c92d6ae6a4d108ce6eb677274ffee5251368297ccf01eddfddd14d28504cfdd098420115376972028aac5cada4b79e407c169859aa13ee78fbeff5d0a531bdc6334fcac3e9a805e074abd25d6708b630286b499a5e5afdb11dd115916882f362e64b847e6c683f099317624d79be9a39a1021a4e15b1cbd26ad85ec51842666a64edd68cb6111767ba2d20d13971efaed372bec7c0fdf993e4f491e2a91ed217cdd1b163aa2e32dff5de96c2f80c911b8123a5f57edad0c310888fc0532374595a28905b6609254cda147b0706edbafd2b264cdbb6a6072e35d0dba2250037c6f7a4ff30a0d7c09221e60782f65b5169afd97c1f3fe9814d641f56a057fc5301a709489eed9b76e3b176c8f32347940342d51f500fa1081f4f5a9843ce5777f05630e1009c143c7f7cd02cc375f2a7b34f885e9dcf3cd8adeddbf92a8d477ea45479a6188abf42cd663f37f3a66d5ce05920128935aa482fae7cb17df2206b04edd709a8188eba9d08e364353f617b26f4a6a386c7846529c36f2ae43f3d901e07c39936ddd802e2bbf7159d50acca10b8fd7ae2e32f07045108920ebe68bf337cbcba4c37796ab7f4d064e634eca3a900b2b6f95e688760caf193e52e441f5bf07ab31193b5c9aa1e72ba23e76b5fc3747f2be26d459099fa6bc55d65eba3b2646c04fd176c977ca705037e2a540f9c2616bc39078e6526786dae464aef01d62f5226cc0bd3f4830dcb76f3c69a6fadaf0a0f381443472ae99967dd4a56aa87bc60c47bf6e3523a94e5ca8f36362147a8c9d1f557a1a960c51c04a88b3fb1cb036c281b997417260823dc3d0a33815eb75bfb9234240017cf79ee0b6cdcc0ead4acbcabfaa742a6cf8480d48709826cf9465595a2f459cc675ed25182e4233341bfb40517448a02560cc9425f3dddf7256577b41f5fe13e3a4e3ceb054663190b379610278687c7525a755cb0279c565554d578b040cfb2407672b8e05453a7edc7d36281ef3db3994d4977a61005f2eab74d281ce93c9134cca9d52be05156ee02dd53bf4d24ba5f2b59feba5062d205d600275eb9b877b38a91dbd10193e76f84a1170bda1db04093e4cb2d34687d9d3a2d499e1b39560db7bd1a962a0e494c0b6b1ec8ea6ebb041260b1aa038c8168180cd6ac559344661a9ad0eded42ccd1f26948aba479d17a0a7e4cca5ae3f50866d282da8562109b0d741735dd0657ecc6c0a9d85cd20c285032f618247584d4a2e1d8b8b90e7eff0e9356456f6ff22ed0c652ba5766087d63cf12ed16c9881e77a76d21bef1950e60a24c2baaa9fafc053ec312ddae4d3349eba3640671a518ae32ebc4568dfb1e85459b8483c381f6ab1ba1b7e0da35782508cf6ecabadb90d600f419dbc9e6cd6247806ec5f935c74527218ce6c29ca025a9e5ca1b0970de5f5700a270a0ce20c9c20d7ba37bb1122df3ce2c694d2a3eec8ac1da061f90d0582913966cf163579abd54cbf944ec2922d7f3f93aadd883ba1374e8b65319ece839ac55c02fda91a5de794b66ebf309a635b18be504a1f4ed9d314cacffcb2f14e24be239ab170e6665877dba9539743381c1bfb07c92ef388f1db502ed4fc245a5fe6dd500a2e0b668119477155887fca63bf4fd6efcb1dd81fa1f5b244fb2bdd47497701bef0d4d6aa2e3e352650e3d7a3dcc951da30921453566cfe142da32e4758a17410b0330fcd95951b3e04839ac4616155bc3eaef1ccb69b7f6feff251ee041105900126fb6ccfc505fae9743889fda62ed85f06c21e27e8d7129fe7b4bf59f3e03a87b0e8aec6d93d38e86dd43f714ecfce96805d949f4a4a33100e0f03acb34b3818aa31eb0b2e2117fd1eff1457822f3f683bc4a8c48ecc4e9b23f716d2b414296503a150200699d66822e815870041a77c5df8161506d16747a8b74c53cef5e195e81ad9bbb96e3e589a44c94917f2b88900f141bbde6175d9c985dac0d0d32915c5dcb2ebbf0823f822ce8a08dba7059c5989ea0970ca4fca08fee3e9658b6eda86e719a544fdfab5d312bfb09e3789c852e503a75b476cc7ce7edf215fbc575a5bac836d8b11831c2f1d16e2df71b47d39f27d93bfa82db34d771ffa79c4a17835c0f88e9d17eb8f948bb8adae9792e0c1d875361220e011d43a57ccdbd059f174a02b9ad5b42c8f4e4b97d7c8ca2d5121d486ea4d3ccedb37b0c02c01a6721b02e57eeedcf1e521ff9831792e594b42e8663738c7c82ee8e231c3d5fd1845f102db15c5a8c76ccfbe5167aa4aa06baa9142c9d221eb5e6fa2248b797ccd49f11064609d671d6e135122419448b36685e19fb624315ca7e0d3f7f8b12ee54ca2b74a59a9a7c284818dd3a810ba82af4800e6c91c753e7051b2723a4137c4e93f2c6575eb66f0016051fb4f55202566865e0fdc28bf12a7b03934b0bb2f3d2085460b64706defa75a22638c0d6c1064bb8126845a25039d24508950540ccaad31a95448ba5374e1381cef06cf86681de2e00931567358e462ce3b5b9b48d9ee388f926b2e58bc7a661fb6c50b5be7128b754b6ca88919820df8b1e6c7f68f33c43fe0a1ca7adaf902249fca7688dd617d3c5ee22147d2a43b6a32d2be18ea3dbd96825d0dd3396f7bc251935a9cb86b3e7a8c4f164b0ad404639341f6914371b13fc1809231f6963b823b19e835c2c068ec1d30fffb00e2a4312c3f65b468968448784d7394052a26f7881ebcca465473906661b3ce0346b21cf7b1a14ccb2866f6e35cd7b183ff37cbc6611df9ae5504651d6de1c74294d58023c92710e529cec7b0f955b60995ecdb88427c74d5499fbaa565841af1ab60698fe2ec4233379555e4eb85069b7795f3759dff010cc0f87e8776d4485b3184c86f680da568ff8e67a35fbc51e360567dbc07fcc2438fce8277e601d7c9706c05d069db9f17cd3da7bed43f8c7059476717665fb97f737e35fb8ae97d409cc02ae5be5a8dcead8e088b4acdff23086e6e3097281ce1969fa7116ca5eeaac829e4b4e7b372793ca90594bcb302ea14045b6318ce294ed0e555328306f63a848cd45d7ca2fcf7657a84eb329a5fcd6579cf7a31709c1fc8965b6c17031fc981c50e94ec4d0ee61dbaff109730cd758d492ce477729b5c9062dc34a2581323c9e7c76192216991bd3837b7d837b512b08395cb5193df77a560c9c63bc3e992cd112bde79cd2669de39ebcc4bf48acfeb92c8625433f72dfe291834406569f40cc3b4df24b55157b7374fd30259e1b9e713e3e7dbdd5617403b9b9f2377e9a19147cc387c6db7387c176897e58d9c36eafa44a4e43731905bfdef4c38e5fb2d620ac9f9d7f24f60f71631083e5c39c3f91dc353785981ef457dd8b069bba556d3a21e69bc50e14559c352cad8bec46d8e1ba5a6a75a3a835aa0c19900d71c43388cfdd8a5ad33768a4ddf7aa3238025c03c6d9b1d09cb929c8cb12b5e536d12eeb53c81880b710df31e35a34254e7f2562f77975ed6573a7a629db4bcbd5ecfee59e4e2c5943d872a6d19f44afd763d6a595970fdf48e2042bef50f1f0ff189f6b18214a2b0e6debf537c7eca00b8ef15bf4b6ffaf3faf014e28158594e60bd6be49faf8cca2f126d35031f73d7b47b358d63531d15958bbcae79a1834dada4323a0c5532a0e5ca135331ecbf91af2a444401d9a3bab1a8dff91d111a796e288ee2ce62ad6bb535fc7b3924a80745319c10ea4d4e101b4dc8ebadb7edd1693bd48b03a06bdd6452e100a54338dcf7bccc564a5894be57d13d71e107a6bd9488bb7e0eb968896b48bd1fcefcf4b4de907139753d11e9ebc4e64a4c17b8bb9e440aff5fff3f95a5daa3360519cc4e50f07823e843f721d32a5ceb51cb947ccafa555edd687c77054b000dae0abd862b24af0b13f4f02ff93602ba18363889d7a443fe094895bf06823abc23d6bd33366d5959633cd0e9bbc14947b550aa2f9dec5baa7fa5a319474dd59f9eaefcd2cacc1cfd7d2e659697dd82c540c0f8f45ca92ef52f31f533a67a28c81e172f954ba04023ace2173f9c485ce10bf83fb56f04d411d456f316aa9fe391f525e87423bb2b2e4730f6a0f2815ad4ef468847be5a33ae03d9b8eaaf6f1bdbd3e9b9c0de23e68075bb0bbbc69173efd70bde11e151dfc4773ec8818af7fc83be28cdbde4bf55026d16459aa3a36a69314c6167e1efff6575a87fe27753b58365ffc7145ab64abf490d79cdd0896ef3de57f29380254409960e45c58933f09ffbb2be001caf2fdbf3123cc9ac8451bc74854f0e606a135d313d27defdf0bf1f8a4e03f987c8a526efdb45c5ee24c1badd458c18eb1ad2dad63900d76edc5bcd0f4b022f5c33719b07c2da3543cfb264591c6fc3b4b6cefd8af29d930b026f9974e094107a8e9c1a3f14def8ed18d12b8b69ad4127b38ef930ab2d24f0ed5d09dfc52f0c35e5eb652f0b4d3182f622e965ad2c24f1bef4f438e8f3841c170e819c8a802d103186111d9cd4d7d1ad2386628af8d25a43949a0e2c15c86e8b7caa49d0634c0a98d7914a754036d8d23f9de960a201019b17a73392b4e65352ddc04c2bd3c60b77fb85d1b2b9793325fb32419cbb1e88d2173cd9637792463ef1b85204301a1409eaab8b092a797985e6b17f750e660975155661f3238b8e1b8556e1f141150f674ba08d7c28e5f036eaabdf056ac6bc2041e2e16e91fb1383f4a4ae2b4823060e32bd6f99c2b55431a00301ccbd01cd580044ccd1fcea23a4072b902d48e98ff8dbffe7217b0dc671acca35886fb0f0544017ebf14808f04445347a87ecfba99d5bd50a4e9ad329cb7fe2e8c92fa10dcdd7d78b87dc06b20459c3e7b8f86ecbc988979d16637203680a95b15c99a9ca29e2c59b970dd8cb27cbd7230c72e221a75877b1ab2398df0a1dfd75abf151fc72782b8b557e4bea61cd7a3da1aca686edbbc8b4e20a2ce183956442c298295b89fb18d7168e1ec2a37b4dc2eb7fce2078ccd5ac5544d8c0992f6b844c2cf692efe48181efeb641e1672bc21a4cf9a5ffed1e2595a46ceb4938f93558f61c9b58665c0e447f5c75706b53e5a7beec31af381405d85dd757d9442bbe90e70d13d0820bce49e1419786dd5d8893fc7429e010e7010d8eb6d58c9e66de591c79100a481460324be78aab4e628ac6ddb538a47f56ae32f41cdccd990cb236fd37a1e70c0c999bd39dae91bab98f42664eef6c9251d0bdd58356786b34a0ef3f669a67992dc081c01706e66943885559d3b908b7b23bfcf97805004debcbc58c454fc9320dafbc2ee3d5a88313d6c01a64533472e0895d28db697150a48262617f25bbb0bff94b4e8030baac3a8c2357b4eb8f97d78946f414e08d72ff08c2d94663e40f923a1cabec9d3128dceaf2e15feff1a9f51d8d3b4654dc01d7f174e9e0e33320e81eb6f624147b6ad8fcb5e480a7479c259284c6ab71f7e1145e6873e3d20445dd536974279f0e09b430f825783659521f1fbb99fb8e234831fa93e742dc433e68899042b8b4cdc275a8750d78afcb99b2520d9eaf2359ee555258c56a44b37f84108dabd5e4f8ff514a202f9e0a63e7c5eab4f2ccc5687f7d549896b71af6796fe5e96e99489dcbfdcc627d68e2a7b782870493022cd8a65e36ba017c8b665e1279235bf766e9e36f9bef8f04a968a65e8d581dd479ea2a2e1f8e72ee24269a5ff7dff0210188a6d954e7153c776db8bbda7a89c2055d73c9fd936464c226a488dd92a9741ec6071e2886010188c51a32d2b2032d314eb4818c22276e5c4c42ee954c7fba96ab42ce3a6849ae5df8f97098e94262510cedffcb9b6af5aee0e0a799da7468bb2f034e2d424c5852d155bf54b2fb8d1681f4a1b2cadf9539ce6c07109d6149b8c906fe657ffa88bd225d78df0cf21908c46592bcefbbf4970f97fa866b9980df5f4ff100164207af787d4d34c874443c9b0a26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
