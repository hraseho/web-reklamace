<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1f78ee6d032a8dee0fb9f0b4039dbdaef207e2cc871915aca7d0164ac5cbbe66c6034a7375a8d1b35cbd87df0d431701492e7842e4764297969ea41d4a8f8117a0f8b127625a6f9868c319b47c293afbe377eea5fe2bada81176064d6ee61416c928daaf94db1c6acb34cf3a052458d18c9d3bad1fb213295e51e48b7e5e64d8356c1d0e57e16faed02c3b2d4a3ca5e6d56cc5b23c9d68a0082e1b90e1f811412c53553086bd8eb86bf4a20c49d2b0341beabb3cf8f554775c56ca019a5c06cec231ea8f8abb1aa6d7b4e189c9eb6651f8fec128b6cda635d2cbfdc2a4ad5b69dd1a2442437210d0313868b5feb955d7e8664336d5056cc39b1b631ea5a30328adefcc02db33b4ab927b9c3ef1039cdb41d154d693c2b037496a8d2fdf3cc6c73ec335eb45866cd187f6f61f449876b1fd394ce7a92df3463c40608ed1b64c772fc598a56277e64fd0dc573a915309e8438f63df4980386e5d29327d94a4a3d5ef8d1310a0b69c9fa6af99b314a4e82346a7c5d633a7caec724203015f43671a47450e4ebf1c44fe85de2cd07bda46a9e22959ab51efe7c072fac0f40d0c31c5cac716cae7d6c7a0d81e2c5febb9b70c3e89575336fdc20ced52b4f5b83648ddabc55cdeeff8221a24a48fc260a4bad3b49e4d90d61e60996bd28a105d14d0b626ff59165ddc61c433422cd0ff3a5c9b8d0b8e954c45585cf7b171e5cf10c744ea368a143d57697a1ea85494ef9f99eb5c607fee8fc914c9bd97b24fa3b07d49cb7bf6a8af29eb896d355b54b3fd75fb9e2edd5b110a5343d84952fe6e89bd030b010d50c5d2cf4013faf1d2086d40f8e68f2d38ccd62c1f809b7b6b1f314a6935f81244477a2674427380ba90274918d9cc536df1ab184113ce06db579222887b5c95c1712881b241cab11c32ab55d39131f08fdaef9374eae796e3fa9089e3a1da7c311bb4a304cfc0e6ea8b04c1b2cd5a15364af47f7f9feb3d2cc52cb12f8dfa48d7179e27a3f13e78478fb641f40ac6680870262654f52012ffe235a1a32b65f3beb7050209e34f10748d2da56d5be2562505375cfad2670042723ceb761ccbf3e958dcbd4ea8bef6706ecfa150ae0fcd162569515901911dcc6e633290ce4750fef1b4f612a7b91df83ed6e826508b86bd6ce303f61a761b3d37bd7e1a1850b6f19792802c0e939bc68921cbeb51a91d63aeb86fea6c723aee823d03f34d371c182175ebe46e3d7af9e7877bbd2a11304fde1aaf2d3bf3a0fd3ae80fc3f3ce170e59676409af86e11b734f147f0dbceb13e373d62439bf208fc3c4f8de09c7812851b4f01ca980fae88915e93a3c9ce5ad019d7e232858b1b025edcb4275dd5ba603ec033f14b489ac7823976a902ef146e6e888ec4dafdad5fc94c10883aff69b231d619053accb2c79bcb4aff5479c6634a0fdc46060bc132da5ca585300744cdf226628fccd5c8938126888d5b3d9ec804a04b55a7387bf0e1505f931f59df898d6b4b673719eb3841b8500b8147cb40a2fa1427b734b3ad85218c9bbc0967ec7d15ff745a46ad229a803f8442535b5b544e5ab362c3d9a9864d2a0e2c753ef8b4dd01b818278d76f6cd757ec38cc04a728278bc99548e50ba7c66cdb2aacccb949818764144e3691c4ed0cf81ef1d481bca6c1be358076c2b2555d3958edb9965cd75472cf522171d64e43541be947baf63332829d88893e887b614f9675c944ace3f52cdf5cc72c82b01cbecde824e614a9c3e8b88c3522a6fb3f789b17f0304bca521ff9da4df446433f2e449db7ca0d7a496e2f5a555683d97520a993f6e2e520883b82ce839c2148e53154030fad232eaa5d11402de494f7b6200cfb2992c9a700ea585edcaf2714755b192a65cee5d3280b71ec63233051b51695b8dce346f374fc392efd6b447aed577a821cc9a0108311112b0d082eb192fe2442e80a9dd7fb72c2f5fc49b24a5242e07e3b2508dbbd8419cbc97cf16c3244dea504e9a84b6e27211cc8d1545b24fa2a4fe95fddd410f37a071f09eccbd489e9df855333c1bac5a21f66cc473d5bdd86e31b11aec6a281e25da553c2ef56cfbc856e4e5c4cdf043496699d9c648553c92253b9b47663cd40a7512770e1ece2fdd09775a18aa3a5770ddd88133020a5847621417f368e5bb34d86a4ed13fc0b785204d7553e0b4dfe249482c212a859dde21b5721bd26c5b21d3f562e0922d9fe3788676d16e81bba22d4b813f792f9ad599cc84b0ab42e20598a94c27b04ef6f9947cd328ad75f073fa75b332464691035cf59e3dd892efd9feda20267070cfdc725ffc78b092e12ed2b165553aa5ebc5d4d7d9f44a2965c762079c776db6848c784f0822c8064649c4a359fa25ee0172a7a3dde8be99d08deb045382a5175cbc0295bbfc418c305167d2979321e68792982362cc0c7aff10d2620c69da165168bd703bd9b2113d947a3bfd3733f6cbd8818028a00210557fb2eaf460c0c4b57225d1a4d2638b6ae3c37d05577dfb61b8a6be0088598985cb1e9d886126055cf124616bf0d74c604454586f11f7950a7bdbb8ab2428aa4a53f0b7e2bea21d755845787701f621b320a503f6d3628388e3a1a51f80ace177eb5542ae4bdded2bd3f80542dbf1d998fc1f5a7764eff021fa5bda31ae7f08b91769ec0691dcfc643020a12b09948297ab36f04b4d8d19aa7f8d98c6d753205bfce030a7f917169b679826fab177c633be4abbccdc2915b27dcdc3fea33afe6da4e7d2dca0472170da1010e3a815d5ebc6f910715516c52914beea57747636f986e4605fff06c717a0970d06d542b723e697a50296dbc0033dba5927e262da63dd07ce17b91667d137060789cebbe113dfa9806a22e313e48a227a6f0ad98b9b0bd0a7b2b43d5d1972ce32242469f3a868be3066317832aeaec268ebae6cbba20a1c8197603efa9d02248fa65711ba3de5bd67b79b8a18b15cc62ba31d51633fc0b540b7b28ac8b19b31a3a090b71bcfed466aa130db1960b5c702f9d0877422916ea733df3009e09326bbdc8294571d2a52c6f4c12849731eff12d0ad2c9a651ce30b9cbe1ebf5f9fa0c5e11f6f74e61e9a8a87b48c24550050a4428159a8d4277645b2fbaa5166a6ebdecca57725e7215bf87a679406c7ca18cafdaf0424b45eb8dd7785bc7619d8589f4a6812c6556659a6d5ed750a1e3d0f95c005c9b475ee600b025cf2ba56c111c7adb0645c7db708988dccadb5160b7ea04c796b0807f798ccab3ccb3bf176a37d7fd7cc0fc29da426f5aa4a4cd41ff5b9f26bbe8d9af2f9f97a4ece4c4714848acc81a76ee25f959ce0178ec7d0bae3793c54f73b5e582a1db1f03b96cadc6ae711de104ea2987d0b89bac071ed3b39821ada4f23bfa8653a0c7f50cf894fffda4641ad0049f95b6098db21e0097057f375df80c47b97bdd8fd094c1fc0aa87ff11e6e86b79dfec68209d3f5a294e966b27c4ef44d652a5e0af9da0561a989dc1ef7bf1aea678efea8379a2cde74d5406189267aad693f68b10eb7432c1373b01b66cad85f1624089de80bcdfdbc0366c5352d813b796488ad75947dd2e4fc39fb2e16c6ab81be8e8f285168b2aa6fc258008f5ba24d889b479653a1240c87e752d69e192f3216b15b158683a7461169608005f1e903e9f5d657386efeb8f7e5ea9556931123a5eaf54f137d7ed550fb90f241d6af69c5390ef22cf64d9fad5a7d012b104accea843f576523fb7242014e31acd2c198bb599a10d5d5705bc8a04f224c68f4c2d936c4108341dbdb0297d9e3b3400efb0643c09fdd778865a8efbe2785de3f37bf7384f3fad1ab014d7d237af5aae204917589f3b60b6620926d9c574562383d16d4ec917bb711e3985fcf0b23f27c9c13b858c7394ebd9103bcfa533006505734b470334e07fafe5864b54869c42349eed98aac868f89f84727723fc9e34ed9de5af6f997042572a5f5f82d8bc9d101684de73ce217d31152f80b9a808c8c869b394ca05e15887f8e4208d0ced3b1b54d5b6b8283218c312a1bf15f034c86f94c57352a021674661fc43fbb829b2b16b622f1db542d093209be31a19c00648469ec9c8beccfd6b63c55ffdebc24bebf02d642264b3ee687075e3d01466f3e94847b8cda225a0a491886742800b04574e7c628418ec33a4b7eccb9ce938eb1580eb5f825b087d6f1e8606591bbcebced9b3f3e5521fd5f23680f55c6071ccdba01b8e67e2ffc74a3d7707d1817cfce6702b4a6f7bb91748492493f0b0c68565354beef307a3f13197620fb14b2cef35aecf54a999c73e2595a38f69f7d2096331bf86ad3ad778246da6084c77de2817e06d5908504328b12b495aeb6287a5a48f9183c0835955de5008744c69c290354cd722c9401fadc9c7313f62342e8c97d0dee9235fa50cc8f1cb6e744fcf5501c056c41725ace3a72fc035281943ca3131962cd9574d26232ad34590ee945259e770ec96f6d5953875c15e6bebe9054c8cdac77dd759ada26916c397861d5e2fe2ae2a292e84f96ccf060e4dd61dca920c7ae9e0b6736ed6065b2c44a8f0abe5993bcdea7bd420439438ece13a6cfe3d4ba05e6f28f299c57ce4cad203a518266c566fcbb8b66262f50b4ff68de9cc5049930df7abcf0091ca06c30c6dd265c20b3795dce5557ec7425ce74a8f6188a855b10e4c6b0e71f29050e3d5b30ab6b9654b22a883e8f70e11c14ddd71f871fbb36af05052cbe9ce2eb28fd358092dd5298d1c19d7e6572b0746225f5f93ade35ad0077f35474e774c7560137213ea01ae2ef194cb2d8d097abc8103fd3c45e4cc1bceb261141091b1308a0018b931fd973421b1be08bafd3c21800e09fb2cea110a340e746f322e6ae85ee5d00580ef1a81a5b79bd3559dfe5ae93e7eaad193d6d876e9c48300d99a18dcb1e7e8a3c60e7b909553a6a1c3c9e3fa84a662122be92992c2c62a164f3b9d16b6c8f289e8f464d374582d1cdf3d2be16a91f91511185deff062ad173d203d0fb6995b35190d3d886114f5cabf12fcc7d8bd1048052a86d62566bcf63c834828068cf0a42ae9a9a65a381bb4ac22625be36a4a1b1c3e1071aa8547ca63d18e752e7a2d306e90a3c416e918794dc0c4ed84d7ddb127a73cd62eb85a16c8ef769be074fa6cf7eb2a20ee3c1066c0f3e6500b353227b59d154b352de92118ef728e04963df0be3bdc477b2442635fdeb999dcde563eee8e8b00f3e5452f2e3928b302891e6fc35169ef0a7267573ff71d2c052181e43179a8a9455b4c2baaf328b8ac5c9adf1452dc0532c8fcaaf9592713a80f455a63a0336eaf0278031bf32d79d2302fac6edc6a222f1286c6c38a4dcf519d4b27ed512e8397085e74d2e1ce5135d41c3877855f6f7183cfcc44370966bddbab4f31791d0400838610751783ec87e38768065880ab8153d455c3e6485b44bc849c24cde6f8fe84262487ba4acc4f161c7e2eabdf79355d7ad6eb56c762f219d5101d8ee2cfde31582a5e47e8fdad163fb5a5d830ab9503d10b9b938bfff6a931b08b792faf2b6c69cebcb0e7c17a20f264f3287ac3fd89ce95c3e36e6bfaff888b65243b72d5e283c36f862d0a6a07a00a168456d98a4fe8c62866ce6dea947323cd7dff6df0e2c98f85e2cc31cf6f88d5d762a24521acdd8859249186207ad03392b6b66414bb338e3e97484e583f42ccbdcc0851d4e1d2d17ffa7ed085df7a1634b3e59defb886c4b4bf1433389c64838b723c38a13a57dc85efa0e30ec3e6f2420ca99f390c4bd4d5ffde08f68203e274308860d75ab1190ead8009dac519cf88ff1e5afc6a262b31c96f75caf802e9d1953ec0f76b2d25bac85b987ecef86328b43d1cd1abd33ab7be8ac0c3ff555805669de1488dde45f1d14a9ee5a36029a123970f3f6e1c36003562720352d48576b7024d8325cae97446b56fb6be2e0f282dcc4df434164974c895a7e7c3196180fe6510db9eb5fb3bb836db96ce6d9d6335940e94c6e9a75b1e47300d09651d2a28904d0cbbd4c88a3dd9e1b95542b24dbe4cbaa50b38593e51ab56bb3c51bfd12a5956c88848e755c7a2957cfa7c8e4844dfc394a1aba6fe40171195176a4142713f5a7682e12bfadc1826af34fc9223490d104759c5ad6dd43a5e9c4074e8df7a901146a08b428561589c2919d81c3e2b38d1c5cfd1649f8d50e870dfd63314f08febb675d7a9dee9af8e51db43891b756b24c68e9dd2ebb7391910791a01de6ce7aec0f5b51f1940fbf22680fc84cfb34061daa4f5b04670c753c3a8137d52787d8e6fca4a8a1dfa3439e5a6c9b93ffb1f69cdcf1eed6410de62dffa27b23eb460e8d41db93aef144da11b435951a1b46af3de40a9cf0ee3eefb960f6c73ed07bb5d00c8e7eb7493580015755cfaf222382313653f7e04b74803aa7223a368f7130100e29980b863211cbc683e91a1c9fe82eb8c1a1a5444fd071596c3d2bde11fcedc6c17b552020463ff02685983bf5d9b42bfe3e11ab72bc468724c5da1643b2eb651c3266821fe48f1aff14a255c90557f651ff959e2612791737fe34e93b693e50aabe9c4712fa66e5bf66ac38580f46b9c6311cbaa9ad6c9e143ec199da65e78058cc8897217dcadca29a00ae857e888f2d68cf158960254d2770a52644a3ed22da90bafee1225cde73fd4162001392ec689de01e13deaff31b489b0f248806be6274b6872de3be2c5844d85650db2270a7897cdad7cb8124beebbee874e05c6216194a6f4bab8f7e29d29000b6b21f9ea3502764e8acfb59d81e026fed3c8babe3a591009ad44673c1ddc7469f9d4288078121cad3860babe9daa8fe403f60e9f5935a6c55a4d8e1c0bbe6fd865d4161a9935e2825ce53cd53e3adaeaff641557b565da7c7c18170eb0175b5db0e975ba1b7588cd1675eb9eac448d48072f42225fbbc24422aeec8984dc285149d75b80d5b57564eac91189504f5facfe85fc38e428ad97b7e4f56ce07becea64dc9162572efd37194e1c16fbdb22a9f17fdd488945aa0c02132b1cf948fd9fc93c75223058365e35f6e1ca161db5f69b6931f9f361d716870dd2a7d9fc3ede3f55a080e8f5c37c490d94180a8f7247acf7455fb68773eb4edfb19e4de9a1be71b570e18bfc584e9b385e74a6910b99f2ac4580c9b7d648a997c235093ef0326d06328f2e42cce048afb40d0c8d9e22e5409c53cf6c1b67cd906be76899becf3b738c8da18efcc8b11e7508feb2f6a9c5bd46ee10943676db9975c073533004b784f9892206e40d1d279348a58bf95d20279b9282ac6d99bc35c6101729b228a695a51cb9b407cd2c89875e4a9ee65b0c65e7456c66b8680608a9a8af222607f6becffdaec55f533a198a431b63a0fad859be6bbe04d05ec2748aa55bd5c7fb80c575301bb525b390fa594a3c87a135a01ccbdab582fbbf8c82630a36a3a8831439c07611f849c9bebc34dde0f61e578d6336c5ee48b7fd37424f77b301ef26d731b2be530ffa17c73f77376b2190e651da23f744164033fe933200711093a9c601bef71a36c426c75d1ba4a5e71ed05c798fa6a8f2d36d9bbf776572d363befeac9d4a11f0e33f9214e47715cb74b906490a81de10b5db95d7bceaa4d74abf7596100b230b68fd76bbdfe77a602b00411d5c55fb2176505aff4b98735ae847a1f76ce0100218632dfffe5fab534fd37a6e15d658ba4a117f12f0440a309186e2840fe3cf8a12c86a84d2d750388d33ccfa531094ad90fdede3e1db08569101226092f134ee81ee44635a7f41bd6a0babb4835c455acf6991a14378fc5cefabc5fba9a894350bb8151cfc13e7eee160a317aa7a566fef257a1f0a448f2b5dc86fe85ebf543b40d254a60296842c930ba66242955d2fe633237a8aa94dd453d7763741d44cb21c3c78cd0b4909585f4401c8cfc0e6b612f65057ab5c1bc56129371e80df19a5250aa0df60005d26f6fdedd8783c7f7fe4123887bb8d546aa84ec5479376f833c17391cd3b2a29e65e503357acb4e2f81130a5da4a4dee7493c77df3e97e5697c436db3c534dee35a9c25560d04daf14d0aa988685f1d3615f0ee85e791316d24adf34a7e20356a3a13641e7b07b09d6d37ebe7d166f0bc06420674ec12a891075468a54c5ba778cc2d0e120b80e19f3d1b9c107a0ca3c85e35cf3286eea02fac7c107277dbfbfd5a6069161e832a30fbf354bfac1677a830ce47bdf095226c506e940cade19f975f19a56de3f2150de82bbe9d057d0dc5f6c60423d46b254d69cf121d160ee3bc4e0109ee76136ae2bb9c6d0ed1ef5aebc63da4638189c4f01b5dbfa4b667f92b2c44e8dad37f5deac13324f49b27805de78f6734152d8fd0c0c35b6c157289d4926372116d60aef40c8e25223d30c5e2f65f2907f29b87bd9e82359b5db2a46c3a3c29d74d45623e541bc2dc8415e9d6be7ff002a866f8435874483d9eb82a27c56ebf5de835017baa3ee5bd0208c06d4aac9a2f263486cc1c22a32838810b863e61e0b6f3e5345a007b8ba0f47ed52d984ffd4173239cf93c7f18afd8bad5705d15dd58dd7d887ecd85bbcba03f7728f40409b65acd79a4753aa9fce769fcf53c7d061bd9a35e2ca198d4139e0238a83d44a45408fedabf99587a1f028546038dbc250e460113f362cd1b745900c441ca4131dc37bb9a207598c59c036f84d137e37f29138f0414df34a34763b599aeb30cdab5a8511d77d03c2239508fc5a86b2a6ebf94238261eb82e727bbb162b049e75a37c990888c7dbf2d91c7b21c7abf0bf8d8901a05dab7d17f2f91391cb3941f314e17a6c92d492e53bb3708537f1e88915d35ae3437ab6dd561dc825cda586e78151b8eac4607f29e82eb38c104318f7db68969351d235afeb69b7496aa3567e7d63dca087bc5b7a73f05004b420fe0c12cd1f10e035a0ee6fd4b1d3a6ffe7dea807d9927a4ce60900b8c592d4272ff32479bf822f603c6eb0f48f6697904a9ce0f029e746cab9e306a4056078799f55d71937b403edef6b197ab95aed1136c2ce01664e7cecb7148c3171a8fe6b61d5f4f5a04e6eb75195eabb42864bccc0c24694fc81f39e313880ddd94bb92eb63f8e116dc9c94d59c022a54f09e4b71e766668649238acbb4b271816387bcf17e258a504ee42fd00db92519805652daa55fc4ed9505a2f47642a4d94dc274bc1570f0c0ee0efb9d2ac82efc4e514d1135de50c4f7bd585cefd086f8865ffdb57bf5259fb70718253388574c97720a9e470411bfbcdabb0e4a8fe9f64e871784488099c5ed74ee1dab95700dc25aa7044048e4d6c5209d4b8a6b573de2d1b6ee4f26f4d800a3e3aec25d903d4b7b9381aeb2d9eb6b80816b670ca54e1678a90f6d5ad68b73ac38f3a06c13cd58abd7b76a2df3ed40f8002f4dafb40b43fc4ba4ae8e2165dcb94701cd136dd5d84737de8f7dcdce4e2b43e53744bac0ed3c1049a0d477a4e9615c23bae9c16bbdb8afa34b89be12c826a80f7ae1aa202353827c5bae30734f9fff2eead336fa5271503f22c7d2ea764c6be5e34d92ba285eff9256bcad0530389ab932b6811b631e89ee75c5b6169f19a50f45503cd971b84799867cafa97db4a87f931d8041c70b2771aa3afc1fd7a39cf777a969df685729d67cf3877a7471e26148abc77b0a72ccc676539ce1c01fb85af3ebd830e233fc09131b49818141b09794deae39c1db552ce530aa8a1dac577659a0a4a7446feb8f1e2ae849971f04ebbf4f2bef576a7d200546fe6576ca9e1e1cadb83b22d785cc69ca8f7a3ffd65f91328998c51babdaccbbd0659353591baee55daed0dcbaffe462e91d63ee2b8e73bcfbb924b2b0b6e94f4498b5e51000b263f668bb02ccf8ec39d23ba00ff2609848153bd1085005390182f2b415c6a1bafd1a1e5b68e0d28b8836428731c06d14b9f14ac690481e35e009e39f0708","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
