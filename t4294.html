<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2a967b2d68838e9c2f6d1e554a9bc2958d893b2bb7edb405d5430a55cc2fc6633c61bd793ccfc3d3ecaae4fad9737a16799f26a34896a8c738a9a74b87b001313fd9671d787f87c6faa95d6702f636a5f2c47a4fb784ed4fbc4d90be6783cf6b42bd1bfb4b9391f25e663da573baf96b11767e3c881844f50ce757313f3a68208e5d6912c94e573a3b671b04eb8fcae2f3e9101f6c6cc4161887c9cc34c929dbcd132fa4d450f2a0958d4788ac57a876b6f3d216ce84ea6ded8e6b04d44f89e19c1ad19c1ca4503c0a5d3bd71a63848b8d826dafb60526bf12aa013248034f5040ce50132be7e2bbf4d684ad72190eb6d5f2a34210f787a1210c2195b4e87fee7afb159d7456986cd2fd670004306eb75155a8637bcddc543327b80f364da7e8a5ffd31e964894c22e71524ecf6a7cc641cd0f0e82e715de00c914fbef429d7318264327002e4d55ae1af0b5962460d7dbf8aa33813812a31864e7a84e3b45f42c7a52bbf1495e87bb6660d56e1e2fa1ebe137ceef35684f7d21eb53182272d765657cdf5cd2241818529dad754a497126f77cde0f93fa45c7380c9697163366ef5e91ec78c327b0af4d6d9c590e98d0f24796f112761b3cb184ba87a7358359e2529bea73f5dbe76c583aa7610520f00fbd34b26511855b27ff6dceddcbd21ee9ea2e72b6c9a3b59e4dd3ae8ecd1b04096408b1034544c2210e5d0a0ed719d4a4b154e9e6ee02a749c3338ba2c8e0755cb44f00178f59ef2475a2b0e709947a25d6623536f64b73bbc2266e0005e4cd197184ee93fba9b4a64b9c2fd748fc21681dc5ec6f98951373752be436f7cfb8adea1bf8f49f226c8c841e6fb55a53af59b65cb71c64a1fb8a3aab9b25df2e6191eaf6f19b8f956bb7e50030a0dfc3c5cc704ade383c76b8d63eabb4689e7a364bb7bff0ad1a6f235a73272b9a0c7686f7c23c722b71bd09636992bfa08c517b19081cc50d01957ac45ef0580127957b9118bc4e84aa43d3f26227bf40afb0a8ddd795a017ca9809790304574dc8eac9bb9c23d3112aad0250355226f96d60eaad8d408c4a8a05e5388b7473e0705426c98924cac5d8b6c6d32d805ca8da4944515ad6f4d3ce87319414dfd3a862037f76d875c3d356eeffd9fbffaf104c12b6aadce7e55b0df718353c5cf683fa63e06687e0456a296ce4b6f14fc15c44c71462c355c1ff88c17769f2ee478d3c47c7b058b188143980f33efd82909e72aaa9931d54ea4b63b539053fef5748a915fb30322dd1e81ca4fbc609f4714be55e84e0fd6793e536f557ba8dc66709f1ae6101103c0bb8dc9d396c81e672be2e2818906a40a125c414f5edbec101f14f8e7f4204c9abecd3c1d27ceadda501815958bdcbf329a8c903ee61fe59da302f344b0048a9d689222f10fcacb6d6397759ad5235bb54d7ba6196b32733e81dc6eeade2ddc0f2eff2143d909ee38892c4fb2be9b1e3af55eda0c257a848e6746b050130dba3dad6366f6124ff191076bae6dcac1558e79d1ee1592f8410b93050b461ebab6ddca01e14be71fb94e29baebebf6f2b747163f9697efbff95d50d5249cea68c4601d7b5e865fd08c7f666404540cce92f68c1f25f4aef63e2d313b61544d07aa1af00db8a76ef46b25b2ac194177cbfe4ac13d1ec100cd9311e954fd0d2af741ae58b371f6c2b24f133af20af70b3e216543c7e2b5df589063d46ad1f5758a6c2a352569bdbdf4a54eae4b6a8e0cb7a01d560d1a0b4664761c8c3c90454c99a7fee5a3d82d63ec7b100bc271874efefde8c40402bfb7a0fea4f6c3630a30697bd15df7c560b515cb6729916cb55e203e82569b8f741b8c2be8c60dc1c1d95f72a4f1b36a0e5c43a49a983484a6de5f262ad39211dc4da847b5a5e5b67d54fd083d4a8cabf69a30694c4af19c9bcd1f3c3da00bcc5efab3428ed5a87e04cb1d441c44df23141139b3c8722a7a4e23771a613d9edd13954d2a741fa68119a3a3070293c02d4166932cf2f134e906c6435c223d652679484b5037d3b35ecce87a0a112ade7bb623edd9e42e65330a8a7933a9f23f218018d716897c9d06c82faaf9c4ebe944fb33fd69d2cdd4a56c87374e528195af636ce9617c2266159060feb0fa93bb6ab1738d801b28042734d700099fbbaab83d22ba24cba33fac0f0f1c240db82b19eee72cff66b272be144b4720eb2ce5ca4df67ae285e7f1fa44f7845f98148d9a6b4c7ec579f6922e7554661e1f3af7b46e85bdd30b20ce97a72540c2d36107140417aea6f1ebdfcbd996eaf924db0b644f27ef26a1ca01ce61300bfa5950bd1f72268cb44e52df3afabdb3693ccdddf31747379e153954e532e325a64b710c48826a2deece8d19c39e5f7fcf77d51b43b3033ad839f7370361bc65930cefa9b48468f148d87a7724f790e5401281613bc095be28ccec52de9c63c2e29df4d6575733b908efab316fc1dad4ac36db2763433cd77f8e818a93c825a186e930e1ede7e5d0c031029673ca53fcb094c7e061670ffeeb259ddb8fdff89ae15baff5cafb8c683c3378b4ea5d3fc4e6163b37d099094ee68d985f814b49d298fa1368e8676f0c437eaa7753cd93f77c643f40b4130666c4e80f6b4a2d27449b13fd9a80ffd20fa331f08c6d09a604c3a25087e0abcef3ae9e6a3545d271d3231f814c834984258433ab47aa826ef6f44e3b71b1642f337d43905e1c2499383c6af5b10220f0e40d6dbd6c500b64e6001944ddca991c5f915215a47b5f610293a555b96a1282fef6da7e24dcb5f7bb6515a6123b43729c176db77d499eee8b0a38d91107d0fefb5267caa048f9234cc61cf35578cc0488b9fa13d671e4d87edf1735190631923fe95fc9d97efc796e38fb7d5b493599033122b97e9d0cee00a21338e55362b14d475962eceb62625611f4a89caa4f2ffcc6d6aa5f48b4a376bca4467e933c9af2bd3e8dc97a711ec7fd715df6a0a60763c352a1ff4ae8a3290ed57225f725c702b2cba3e85e5307c6cdf7cc9f72f0f7a4ea6d6b0c2d219b529619a7ce06752e07787722f63beddb915f4fe15462ca62c7521f956977ce816bfd2be31dcc04dd0322fbc825cea197ca6e16c98f34043ad9705cd9d5beb6e5f28b4724684a36dd949b158526a8b517129ef63d0452c595edaa052f41e66404763647eb74c4fc08fb3182de8b01c0687e35453a8ac236349d2e0494b995d7e28f7ed4421360355df7b7812d74b247bf54141e5c76eca45328eafb515978d87659e671e4aac28f1d80cba74db08e0528022252a9a7b020b0ca6826c0ca3a1b36d1cfd85844f5020f83393d6e3ffb3b3217e4d584731e142f88ae9846fb7abf4853710276c4619352200e86f6cbabe1e1d5391105803ff3f9974cb5cd9c85c0c624922c202f31b5cb305f3e301e28e6f5ab0e5511030b5fabab5cbad1a7ab22195d0e058973fc9a8a6ca3caec02ed8461b714012277a2c8d473c6b9be3f1673c13e2afcdf91561b0481eca4a643afd6ee27533a6cefc30b5c416e3bcadf8a8033acb0b9de40d241dd6dd62759d0dc1d8a17b542bde20bd4fc9cb9eeab6b94fdd0b4426de57c11c6568768468dfaafd9757e6a490e6a459526cbc7fe9730d14feb4d0705e63304c398289f55a42fe792f4d18d53ca882918af726195a47b5fde17c67b4260024b9bd5e13d207d244263cd24f95743c5c1678c38646c034e39fbfe5564e5db02249674ab75a6f285b9b679aa35b19170aef364563018ad19c8380e58eab4b22822f0c1af840ffeaf2873a1b1b27788feb556fd49df872820fdde2a2ec3c36082d168c1b61bdcba60728038c143ded08813639ce75f960fb9dd44d089ea00fa8df55a9127ce20b36907b77ebc9455acf2a65f5050453cbbf3187c12e6534f8485d94003e009506a86c50a0e2ee0c28fcbaae5d18146097c0a07cdd1bcfedc11198d4bcb31b1811cd2dd2e8459941ad9a1e0d8e369fe955f2eb1189a3dbd4df817c9da0a317c91115b7e5b0797e8a7edde55042b4a421f0fc4feb604a0b794c4045274d2f0f2f2c2becf6727ec3564f514a92ef24504d8626afe3c576152c128e8e89b64e8371ba89b0dd54a1f5e5e2ec6f14c28093f0c344715f021cdde658fab957a086e8b96543a5310a599bf9cfa21f9011b776705281736d86d5faeb9a2f38d1fa52c4c0b57db54930183a130abc283e087a12721bc462aef8a5accfae686bf3e623c0547c8de40bdf8fa3fe492a9ef0c117b419a09f2984aca4912c9efa14a52f381f3b5869fd690e57a948de2f076491ff8094c102f90c0e6b1a0044d8aba7aa68090baf207cc2a3689956d0c3a04ba0f6564f644f85436d16af3a319f9a2e7347a8270de55eac456cc511397cc01c199a67803e53ca903b714f18300bdaf049d3446fe25b6c99b69e8c4bee4fb538056f007615062a09f72984199686bec07bf8324ce34dcb45722ac4341236d1a6708905d2aa17dcefc87bf903a04949dba30bb9d41fc83a03d72770e21f5f9211006f3edf5c050ae603becd9d9d43397afd4a1f9afc8cd1561359190005b921a0b70700c49ef1db2644afb9c9d87119f5c0bb0505f6170dfa9d54ee9a169cff3058e35dc2ee71c9e788d582d339d45c010c736884436b33afde58c642482ae36ad53000688e097cb83add0bd0ce0a5c51856726d45d08a2b869208ff9af8d66a6397801fa281d9a9d2220722ab15cd84a1f00505847b2f211fe552d6fb9a5d567696f81c5884efbb1400fa240b43682752ef644fb0346d2714af000d45a0a7af923468954a2d746d2c47a2b869f95f4d7a1f0694e8b8134b71ea7e41ae0c59a71ea6159258b3604a6992ff1cea6daf7553b90c0a207f05b281a545b10bee78f69d8805b693ee066f91f126dbb59c06ba02e21acb95e222f447cfca4f9be5e4ad45b19b94ec0156acdbd4eacd73a9ee68e299159b3dc6f3dd7b3b1628886f8d8b8b8b0ad9223f4a4939bf4eace65f79fad16e6562cd75aa1d8e0664509c56e966c87896f7c580537b35f238910a478b6641667545057b216adff1a73196894342e5308e7bfa64c22952c47101d87c6f13c7cb857bd962eecbc72b199a921ab759e0c19f866ba956d43e6ea4e27d5237cf0c19460a2a337c4415dc6aa1f0f2f1175bdd31864210474b6f97416285894e6ba6535b1a5b32d13cf2054beb811a7085e38eb84602c8e1c842c0780b48f370aead985ca61496cfa6249a224aa20a0593ed50b3587b4f8fc0ebc2ebabe702d632b3f3cb523afb4e5e2ed55c60753c6f7d7f8e64306652c2c1357f962d5c679198b80d513382aafe20b093f2ef62ae1143799f6e0db51b48386a56c27143aafdeac6dcd9ae1a49b8fb1d158663accf3c808917c725e8895ad9ede5f2da854df9473efabe8d0ac37553dbed4935e48961f17f67ee003302bab2eb4b9d0b52b49aeaa3d7d793dcc159a8643c821df5a5fe9429d4877a48f1a7d42eaa2d394a8275ac8062cb1a427dd12a068e12bddb80e7f51692f8bbacbffae7de5ee9c1ba7f4c7a3cf62b95790a4ff834a60b1ac501399c92e7392d4c5b08ff9e1196d9e4a9874abff8121cfcd49461cec61e605924ff45baf5182e4816b930febaecf3e0d87e5953afdc14a7bd603a4d19905f96d717a93f4c7946bca2131cf7648024376b2f74d2571a4f81b1033d36e972403952622bb22f4c6940152ed70dd38c9a1f510d62414eb9f029cc1da0a1890484969eb5455011e31898188afad2c6ed872a9cf4b51e43e97263a423845b521a346fdbfcac9c57bf36aa1fbc3189ed52115c3576457d739817ab0a75dd1f3ce3713e4890f5893fc74a2e059a3d832b1143e2e1a95bf1f547879181ae6199820996bdb29d6a7d268255546b8546785892a532dcb6fc181fac14487d3545b4b41257be59ec608f9b851fdf0ccc66840d13bfd8fe7ff1a848788fbc0ca3adc4d9a11b038f0eebbec5194491916e1b14fb46578cdad05b194721adf9f2741182840a7a88b31d77f0a59a8945902d3e1b85b3a31f208732fab39297aefb9f769a79617fddf71fb23338f62e86b1720e2e5c14696e3e06ee9f0e66d55b3e6fdbd86107555f8c4aab05d1d6f0ea5788fff563d191247d0e2626ba2658bf3623e6635a65c2e335404db703b8cb908f96f3f515bfbbb9e29191fb11dba225760e8895e04a4ae36c221611c913a062ff00fd4bfee2034043070f046882d0c61117f7d24d770da4619964c02cac37d47e06f5798da6176c43fbea7a19d0674e1e839e87f4ef9811ae084d7f15653f44631494ed930490fbe81946d84007b0c4fccfa9d4096646d8042b970bea9e9b46addfaf993ad0418a14662af2db20f3f89106e6da05365e419d7f995be4cbdfaaa7daf7a7bb49bcaf98ff0eb5068e1998be48145aac36d64fe9046fd711d2b96ab2c29668f23b770851cbebd79e70c492d142a0e98edef2dafbd4105538563bd85f3594e529f1cf962e4c59ab9a446135fdac37e49dcd12d67044375ab77858a938ac6fa664259a54b70f2b57e57dbaa3abc6e7e0ff4c31a3fd636d5b0815598a5fd433a041e88e8886f9b094d2e716188bb1fe06d74bd5208acf7bf803c96e799a7da87aaf7a6b294a5bc912c67dcb07dffd5c6fb89087ebbb0f862a24a638f4eec4477a3e69cf70b059af32904d6fe00a72751d1d77fdbf4802c6a0cdc6355e982ee853ff70851f723092f57817e12bdb8aa56272560b3ef0c2063e523a714d604354f21d788cd234b229570b2b7d012158c6756520aed4b7090fb390269283e63d5fc6ac47e612fa92fa323a563b4e4cb22bf2d03cd10a5c5fefbd57e7ce13fe2afea85c5cdcab24ed4b458d1920f846383a29c1cc60d7bb348a6f30a4fadee765638d64af6fc24fc5ee7a6da0520c387908f7022e97e3dbe0116eacb44ba8dfee80191c510ac73c66d740f88d6a8d0cf8387594ccac18ad86703242dd0a3bdab46a4b43507ad13d5990fc4517dcedc058fcaafa8c0e9bf5cc8191b5b01c31cfaaa8a0d8b38b77438cfe26f3f994ede13c0d1dc9dcdccc89902b3db59948d02ae3bfd359f9932c3794d26f1eae0e66ddefe350d5f4da8c188012110d1c05afde3019ddd0e6f4d9b754270c047edee3f1323a38039532d6f8299e704dd84f1a39d7f3a5990a18038c204c9faa48e7b341aa4ce477adcd19a463ffc7353cee509375515eb085cf2a4028a7ff4c0f48cd73c810347be43b7ebb6f17a76609b51eb9e53aa6fda8176473cb20b98b27697bb6af9a832287977861c3decf2b494fd81a57412996d8bd57ede45501bde40c114a64da67e418d573344a68e44be98bf771cbf4f60695d2b13811a3c23a31b6c318f1704afc3cc5b94717ada49194259d6ee33264ea21c4369bf6bf564155954a4ee75cfe2930ad543bbc5386e31627a96454531ccb3ed10079a2d958c3d1146a048e661d76e3c4c1ebcb5e5f1539aac4cc55bc08c2b9af3da1d2583b168d71c8d6f70ded480c84a4c5ee991028e64431de5cff92769677c879545d5f33e60ff9eb657e1cc6ed005f10fe7a7628dcc459560a06953648748aa8ccd7bcb799a0a278709b8baca72564c434f60c96cc66f69338a1354d16212b180cba73fb6cacc8c2d19eaf1e313db2827a51175762555789cc99fed264bc3c2dd660219221c9b0d13f91c270ea4c1b7005a1bd26cc60d0607c68198b74ef4a0356362489f26bbe3927537fb3db0020d9253695057ad66d88ab8d64c3f4f1f3f9ef2915511b2752dbc3122dda6dd051da05ab238991bb80c20cba8ee9586a61f3ff42a3d4d9bf079c33099157b651130b90faa48dfd40fc612b6d8dd3eefd9f93c050b904891ab01dbb5ca3c5fb5008a6c2c1330cf077cf3bc4d6e53299914a46ded5b7f78208e2fdb8e9e7823c893165f1253d6306f81483686d8fbf3e04e62701046e0aa6663832a38531063b6a611dcc01cfd1b862e5a768a69f805e20faa6323ea934c74bc51a8132ea0a5ce1d7cee6f3ef3011edafa221fce32a49624c1e6801bc7aa1c2e650ee5ee5f9be5ca849c72b20b44284a0967ec0f1f6a1c87534023f54c2727638cffb8f4f90201f5c0515e4a1e71141fd10d6536e20b16ecaf6e59785a2cfc6a418ad46390442af1a842f967f5d23f45bf370f2f51e90215a553674c8d7fac21e85e6b4eb63bea03d418c95d0238d4a3ac9ef00e041a79da9fd34ff5f14a0ff02a1f83ee7702156061c0611ecaaa91815a1b0a731869df988a6b02dbe09fa828c045c76deed9a9b2c4367aa859859650aef7963020f2d9fa2f137a79f9bf1ee5e39a0e940ca5111f7ab7c4f51bc573aceca5f5cdebbbe31683f39f18af5d1f739b6cfa293eee3d2131a57210cc0b0fed64e0e9cfe5c32a969c04883b6779e58922ac16f40a218eb50c7c5708797314dabf819ca6bacba48d07900826ce2882c868e9ad7528fc28d41d8870e9fb3a496e13ac631279a7a6fe5785439838103d273a16486118f749903ed12ce58f5745ee9b281c7f2499d8ca6dfd900d3b303a3d1f27da4a64dd4936ae5782a6102c4e011f9b3f4f88bc06db8a4135c5b04dc3415bc5de3b623d616af5c9a7c14c40618c65692258f4ecc4c9cd4db57af1f9437d89fd7f25b1968b98afc9ddc789c618ad012ef7cce80e59efc0dd8d2d49897e5584634956135e0ed69c8fe66073ecf786e772826b2c75d32c26416372422f165dfad953331327fff2dc56201fbb1f2b6126c634394d681059093fab678b039d3484d6d3e1c67f8234b2ea4d0d0c1449bc45e02de5a00e6a18fae5025f628b8f97b34faa033b3afddcd637803ee06ec4e05b8266d4930c813f7d10a602b431985b036612130e253ed5bbe710d58a7684d83c4aa1d00b6501ced8c5f0605f6ac5c26d87e1f57bad7df16d14441969ecc84b67f50cb5872924d31c80b0d4bcef63b974fccd709f3b267814b4db7174fe80c63e0977f40b787e7b5cfec2e5554d598ef741d804017585c897254fd156ae442aca9884e6f940ddd2e45fb948a735b54d256f1a6f1e0c5cac9e3f8a23f8c2b2fdbda74493b906cd06716212d689b5996bd273c5dc3bbdeacb1bd46e9db142ca060c2a61c8ea2f81fd1a2aed0cc33b9ecb9c54ee8816708391f190b82e44ea4ef81444b60ecd860f85cd0b9743826f5c7799fd141104fedbe483a64cb27d6d5fec1d5d00ff5316e940f4d3810b5bf9d666995946683c44902399638ee287639e9ad6a7f0b3edcfa4544f812e590e854283d6c4ee5a285a22b917d10799352237534e89b27fc488f353d602ac6e4f51870716c240dab5e759ad5b7e8c1bd3555196238b9b09f52d35addeef2980c4677bde99ec68ec202967424b2135c0007708c0b4cf73df422659c6460e77ef5414f58e7f2841e6e029d8317ac3f9af0c41bf374db2b8ebc33daf19baa73383fb2bd682b8bd8de670fb76e94dd29eb3c70def223a0600f2256826ca46cb53985b4fc87f536b87cad3daff9836564692ac3c2e9224d1f03bcd19e5761d675eba51455928b978b4561f325ced77c924d186177304c5ac97ad44c1c9ce5fd3edef408e464e55e3b84e319dcf12931740e0cfb0be96cba3a3f9ac65ebf061e801eaa8159caf7fb8abc5075635d126e808b007f2b95b7a29df5475c62095e1b3d5795f72019d7b6eebe0ca672ec4611fb37b7f06e706cdaac31660c8253d21f68b4d107670af535ae87a3e1c99250c20f4bdfefd22bfb8e68773b77c6d92583db3cb08cfcd2e2f287464147b28089a8778260c9885f431c4caca473b2f7d6abc3df800158f77aa8fc08d27af6ab305b6b8ad54593730f539fdc2148530bc968b7e25f3d324074d8dc72a73ac0b0df503c2360091a9bf1e5c12f362046055c26d4281071bface62b8882df3eb5f7fbf8773c5971ef13b6bc0b9a911d59b0b376ab6a6f2cbed96d4f4977e73ad37e255358e9686ab3839a1334e57ea08b29e3ee6139e82827a3968491fb31c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
