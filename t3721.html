<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d62b40562a32ea5c1122a8794f79e6d235da5614ee0ed7ceadb8d632a7bc939098c0584a58db7f231b5d15a2ddcfa15b50789178fc92e9dfb0c96e9c290053e61568a962a81e1aeaacb38cec3a84879f3fd21c14b222a62c0445135d303b5182dc6370b65428f9621808f181fce6a4902fedacaec59e1ed1a987dec2e22045b2e68732a6fd0e105d59a2e9bcdf4e7621789985ad228ea73eb54fdf71434bdcaccda3604a0b646a30a687adfdfda531af64c09b29d353a984534c01694fe088ec7b5142ab053ca9c74c20b47ca89044a1ad9cd9c1e0a814d749057c9bf6bb13c564a942542749bfb41c1d2695aedd4ec2c27b45b1b9c65409f1b3b5ffb985615203ad6526286641fa31b16936514cf2fe3c8af2c49315856799881541695c10d02f6058b1010b7317930bb74a0f877c86c8286837c23cca06d3cffd6a55b801051a84bd5a654f7773a2321e7185c315c0355c63c46b64b9f83a7258b0cb0868a8cc483d2c4f47d660abd0f63b3a485b70a6e71b72d6282ecaa6abc067507dacb8ba46aaf1eb093c7139c77b38b4ff3a2a547a2181702d97bf3933b59db00e1976034b9d805bf1df786a302e8c6b5363308fb7478584d63dfed0404dbbcad044e825279c52c09965b2ed928ec2498cd489eb5e93cdf82b3b982622fd9db619b87802b84b3e4765efcef3f3f62a47b972471a7bb2bd2a1ca481e25fa34fd19df8ef3ab0e908fbdacdf5091e6595c9cf482b99640949930229fc1af017aed68fe0a94df9e4fd6b58dbdda3c79344bfdd8514cd84f74e69d50b504388039c13f85a4488aa0ae44042cebc2b482aac6eb30f592e607f09436c4d250c74962952387ca6d69d6e15d43f093096d7534fa48a52e8387b8f136aecf3475fbbd676b4193ae79f50edee81439a79f595c0168d18ae4232347b6b70b2733708b011f9b053eea478c21426f7cf8ab25422ad6d5a86fbf43bf24244568fc4ec8b9b8d45d5c5bac048874d9ecf0af7a4e4a83762ff0b4333d35ecea67bb9b6ed24fa96b33b211d3c0b03e61c9cf59f58cdd675c5145a7e1119f946f4a77a5167d02cb83e4dbcdc6bfa6b699239ba25a7aa0a78ebc28f555850acb9a66a307bd157965b5bcbc310fbf75f31c3a66b64434391c4a6e086746532fc6ecb7290f43fae64e1a129a69ff094b1ccdc331ce756976390dc1e53f1741d33d0b39fd50a82db789318d792a0406d471ab3c7dea6083c2b3736ff8edb35b6f5ef20c25d3b7433f2f9d0d97dfe94daa5ab852ab9c19d6db352d14aba37d6c4a14f626790a77dcba86c1e4a318db92eeec2d0ee78998cf5226c02346b03fa98967a489158f006cff52b894de434d770aea782e3cb26df5bec58bfef2fb38b82d993f01f82e82e970a8403a341c3f380392e6e76cc4d5e0e9a90389e16f2c9ba54b207783e86f02309bc8cf545cd4f90fc2b518a0a17d7f0bf3753155522e9f9835da2ae30dca5f664e6fe676a73416ed67606d10d24fd7f8878b4d2a00aca80cf3cdd6384e94077637efa8aa7cb4225924c3edc722a855eedb62a2a298460a50c80213c779c70d8f7814e5a443176a5b3941b5dd05a3935e1cce83b3333460614905e2a1631c08ae0085b92aef73e92b0e79d1247e63bdc66a88ea68a9e1f1563d78c0795ed6006988f84cff876280f1361239b1548a04a11164dd7505f2dd121dc7c5de4c396faaec03809188dc79274617f265b2f9f80bf71d58e6071af67efb1775112069324422c00c436cb85a0824c4a5fef0ba6e8bbe05b2118e6a62c80f6e2f44f224658f84eaa62f18dc6e6e0d1ae4485eb8b4d351d01ea67c524323a017d2b409a393979954f00a153b7e4c558ef5e3f9c2df29926f45825e0840c5cfb8b6e4c1bec6689bec181a244e2e216c5bfa93a6f1413c5d4e66455cdfd822641616bf85aedaaec4c0dff32d2ef101774418c3336c2d96329c4c3333de0de4283c6c1314a7e792e1743ff6c4dffbb8e96ad83d16915e10be33b4e83f26d44f9b35737cb2db927376b7df1e061c4c71b54e2c9b413a8e10b6be9369ebb1533c7ce52354d351f8d656b13faf5ed157b826cec743b56a651fdf4f2d6456d22ada8f6a6831a95e90947a1bb8732f205a66e66d0712f9296a47b5a30deac7c8033064f95547642688cb78761dece9519102ab138ec953fd6adb6fa8bd6b69fe47c46637d6b21f0a07c5b87c4446b59154ad3ff7c2c0d6e56ef710314ed7b0d37c11abff73a9793af5d23833d7766237713fcb288dd0943f8230b4495fdb5193f84feefdb6c35b08161c5aa40466ece9f7a8c4760d7a4a7b256caac095ee3e74f93b20b08ff6febe4fd096918dc702b73179cced690fb560400934914e5bf944df85f8d6c5ed355f32e58de735dbe1d0e86154f05d8a44d1dad8afeddafe1d0d9444c763da7e2756fc2c93f566f36e539ee265ed7e648bca12efe4acd0602049a64b53b0d5d68108a72f8198dcd0a1ef55688fdb20e82f9cdaff03ae10a8af4466e722568e11eb292518dd07be327881da600c49491a0e4bbeb1c39bd7742d7b53734cdc3601f3321e1b3d40684693391ed1e59f2c2d77e5ef337f4b333294ec0e249a26855b858797da7db62d7659e622ca663381c27fc770f1cd3eaf6184208ff9c15117b91742e5438ff60e1e184023a1c9a199633e1902896e15649ec5b7c69d6cb9b5c0ee12295562de5e0556037c23633bf9add21ad0df18fbf1f34bca0d7e1878b1dab6407f275c48a8a2b5cb53fdaecd3c6b113e7e8056631a8ee4dab3663a9ea11e715870e54eed15078c9f400e51ed3564bd7371ba14ea72bcb0f94a6715a417449520be6b82fe02a27cddb572721577995a916a1954fc21ca5f35ff1f373a4a02b591eaeaadb5020d8614151071be000e89fd359518dc681658f04f14771b38189c4cac29b2a89a4f203a2c3f61ef6c433507a0b2bddd98aae93891a0c32f19dbe1679ee4f6af1cda688e5135575d3048a091a4a56b0f9c32ef7c2df236a24e404ddf24da88bf709647cdc710f885c5cdd8c07b01eede85aa22b4b6250e59edb1ea482fd7da61495bf612b3dd7be92bafdabec8b6d1ee66af63340504ed22a2bdf5aebaac0288f165179e9b956313bc3995bd8b703bca566d0f84b5b169ddacd3dd397971a5a70b6df87a5185c00daa94960b5bca0f1c3a51270ab4f041d6d74b2065440fee43e47b78a19ac591902ba785f0c7f91788288d3ac8ec852d6b3e19ee35b3501fb72c3b9ab440dc26b97c8bedcecf1b8ccafb50904b4d4d6a3ffa9f8735bd845b6d799ad9cff923943430216709bf47520c34cd0f34c27c062e35742778b982a22769e9fc7fc5775f6c83b2db0dcbe474d3cb049d6acc7632eef1336c463f079e8545b43bee2496d3b7a07c993850fddcf8b83c7c75ddff2c83558e3e9f1016d09745b8b7d259b4bdf1ae99cbee4758061802d7f6f8da31a3f40682c617319ec22ee08a58f7f6bfe92bacd6a4603064331ba752ac26ba96bdc7f4ca2156b289a827d00152eef9afab9e0bc2ecee68abfb47f9e824d29b763909d7513f8c719aa22b8c7db0d502450a2de3cb17078b403b0813737fa05335c8f0958045ade0e873124d2fa92ee84236050abb6d20ee9d57f7efe313f067cb9a92dfd28749d8aa94e779dc2ec566c4545893f8ced856b40cf45ea68db5fad6f6c9e112dcfbcfcc40a904f0b19739ca9e28aa54457007f2f0b2decd0ab985c76a229ec79b6d968295f25989f8fbb1951bc92dfa6ce2fb9be28bf3d63543267ba02712a6ce91055a41a835f4983576e73780a2a390654028645d71a1173e16635954248ac5289ed17d8886df25c1cae1e51ef9658324ec2170c3c408cfeae5ede3161676617985e5c97ce9c2e915def7667dab1057216e6bd9e5797882a5ee1f3354994d0be1f48ae1a5a9df2bec7ad01c6dc0dd4b5d7c9f5509543c189c3106a81e73058d4f94a1cc9c5d0894301459ff1ce2400395f62a7d92fdc1b7337d2ef5f0e15368256709a3f00e10bf03457dd1385c36e888bf6ba4e5882ecd701597d929587541515481347e858aee7411efcd269ab4c7df887006dac7d9aa62ec94047db0796b4a9495b23b16fc048196c5b28b938c4e0772452c7251149faf627054e1afa7fa13ed138409f4533fe21b2c0022350f1cce23e996e5e8f4c1e3b5f9fa612163583653afe2cde0f5adcb737360ae3c97060efd37ec103809cc87423f6fcc7a29ac9c8de2d5dc520382a41408cc95f4093ddead9b1375ee691813384e08b9a60caf75963ff88dc3695ab00b8b652ec2165937a5c65c124be35797a95550b871a1f8352e35647c317f8a6bdd1de85dc7089fdbcbf88eed49e30c0cda070bcd1f4a98953e4e2d9807cbb0d3516972e07e9ee99936f88b85a213fe873bb57b4f6183e7310071613273db98a644c246abc58e19a2d4295c6bb2da1e5c36f87b051b4322a0f6625610f0c824a32e8f93db8f248cfe35278a475e8981fabc5cee36a4c03e5a14ebc9ff6da897d6b9bcb07bdee727b874954cd5b294ea089d475979627c038f1d1ead32ff4ba0cd806c024ebff83b8332ade90f4aadd65c038cd5f1e44070c273b0adc90f9dd7665e767037a90ef2742970b6f7986077041c9945047b01733f22d0ea8d9a6f251aae68e4d7035535e45045c912611bf5ee6d422e8a3b3447723a4ba0cbe6b476df2a8bab0c38e07ce5dbec91f44c4f67637fada08741141d122346cb6be5fad446c397753d19ca5e5262191c0dd39f1f843151f39a549ba6947651130c1460d504d1a3a437f0df92b5229f71f6d5835ac733223193f7641715101e8bf69b9bf3c4f686b7e5e2930ccb5e42d79fa91a1d0623f3ab423cfe719eb582d971668799588c6386da4533b92377bd34964d88cee5a8ac4f632b6dfe034ec1faa737b0323022a760004b6eb2e938c865c0caee7c9c4a8d09be97f3dda383dbffdc271d480a8d0304fc29de59a73520df49c2b9e22563d3e4066d484158fd3e44a616f575d40f673ff99b8f34539d6048a7e074a594da74ba02008af4a9ceb83f1c1d27aca4319e0db4da362f5e8319ab6be7f42ee82e601f122b082ad938b8de0738e9239974039e2bba156179443a259ae74c093448a8b288fe2cbbd98f59c07d22f5e3c575ef88b363e80660f8da2dd658d41ebbe8751ae19fd8fbcdb9f26858f0a6b909235a84879321bc9a2b2b4cf52ea3a68515604124213fe84d25e792139fdf310b9f7a7683236b0849285a0fa10cd8c694a96520c4030a7d292cb3005c1fd62b13549e5fc283531fe984667b2bee1e650a27831378ab12e3c26587d9f3c81e74b31624eebe25fc69ecf9bcf2d73bfabe4152a24132873dbe3daf2daa2e17f6995a891912442cb538e73dbfc67a95594d78307cec32fa7ed6a4a76adaa32e91a85edafc721c6c8e6e25a123a90f1c3e66c71bd07abf80b49df031a04ad817a127083e99cd4ecf021ff0a24a00505300cf44675d3e5d218c77b53cc5d6856aa63b00eb50018472de3d7ed42f289c00e1892ff298d81ad6c5bd72b8a16d88b160029cbd55276a0b7d1938b194750fc0f5235ab5d92988afbbfc71989f84b1bc33b41c1891fbac9ba62b28b3a07e65e56b14484b069a85b02b889725cb5fb712bb0285e75bf659d3963ec74da907f1ee1a757ee36f4d837dce1d68c2ad4829fa73c0de59e896b2ac2143c49365c979b5d484db316a5b56bf6b3118a2d6570916feb1a280b108cabf51a266a64a39f94479668a3a60666b3f7c247d10b2cb51c5c8686c37dbe3d1a519daf6e5335ea3f609e8afd13609fe69c106f568dd088fdd1fffb585666a3cdfb02a929f87aeac00177e1df227382ee2f73257b510e47c5ee206b2c15421adbb9eb2447e0c8fb563b9805af8baf3a454ba3e9d778a1d448158fd9a3b7fe9ed806bbdef54ee2b90d3974d743a2a92d14233e980a6ae1b56a09a4a2bd55af34ef53944f77e4e8f80e82d5b70915e10c6c97812b942ddd458dfb4841abbdf93114e65c5cc6de5ab35d9b93697feb7d5be94642140b95e2bfddc025000a9b06ab670de1c1640f80c024fa3caa3370f08679aafbf383820bad0ac81dca593338fe8454ff44deee68370bae4ce9c79a025a629b69af04ebc12b17886c14c8903b68c2bd5dd813ad1d6041b67fbd803f9968e545fd499167a0e979f810e2735475745b055392bee6e48dde50d60ffb06edd1e487a9c82d919dd77c8db02948109178cda972ec3f79acbc8fa28a5404eff879f77b8cccb7028b0b7e495bb527dce475e25e27761390dc45a182de0e7793c25249fcff5a7961beee282764b6443348270b4acc44158c47d224cde5d7111be4db37f6ed42863417e6eac4eb6b990c19ae3bf2a169e6b29e6c190fe54cd5b1918d4cc7fd6745e05f2e8c27f5d79e337cb86393da8710467a8521f7cf7c93ab0f8f1ee1107c0bba1159c0e8f09b173684dd9ded9a59b81e22aa7d02d05c4b39e395b21f0818a49d663ad5e26fce4ed57c9138f9dafbc73c81d237adc3daee1dace08e8d5bff7f74997f5ca7df8b2dc847f515bf08570487c8cb5cbda0f4f8dc0b0bb2197846371354eacb33acc81a40cbedc0c2513d35904b8a6f32a4f331ddeb226e6adeca6a17a2f92cdd102dc99f0a6fd38d2c7140340dab17a9ed231875483d15f84c90b2deab5523501f489ccbac180023eae8b3e3818a90e23a73b192c26696aaae1e9613fb22e08732df0c6da037a6b88cf188cea78459442692372c3df04d14756f7c4fe114ff5da7667830753ac9c6faf22b1633506ee2d0b53fa497cd69aad17094b18423a7eab3345438072a571bf2154ea4d5ab5c652b75699bb40559f4d021556ec6c299343b6460613b187c7908f7441cdb2e3369f5dfc7f67305d68c620c5f3fe2394aad3a42488b74089f816c655aef813f0edf94910221cff9f93f2d99dbcaafb611fe050bda936d35b5832fce333da0244ca12a94b5093d30a1e28d96caef2cffaf6ff35f32c0ef55329350478ecfc29d53e87915295af09c045dbb35492d8023d1d0f71ef89a904a77475c1840cad9f92ee348598dcd3d252b020148c5ddaf2ad7d01660fae5cc5b59004460059fdce15b95d53addf414c5a074b13b30e1f33a488a24cc1dcf77de98dfbd9b505806772636549f13a08f22cde499446d26aa14782195d98dedff192059c0b318d736a1751f73de98a792b7b01dabd202528cd79c517281eea26381b8e1acad5af93b22101ea6a09915dba11cb2dd424ed3ad6adc960f96384f2feaffaa4a778f591841dbd5b162ebbd4390704a324f73ab9b7b615527b339aa17348a4786eaf0d88540e214a1682c5b636fadbe6935012d33fc9ed77931bc63f2eab374f1a0faab1b165ce3e382a37bd9fa5faf13b4273444a77d939c7bc7d692d6253f9f321c8a0336122ada894e533f7cf5c28f1619611809b86012933f6490dcbdbfdeb60ffafed14353bd2f36c2d2cfbda3fe107e7f611ab9e5d80d671ed42620277c8e32a30a1885d66584f408fe63cccc3291ecd2c9a67fe093e995efd6cb60df03eafd41260edbd5b0cb3383b197f224d396908ca404f27094e859deb8ba9983b08d4820b1e17bd38ab4d9011055373a77bba17ef1d846e675a5768463c38a6bc0948a9cba41897b402485a2de5668dadf824fcd49f1a8218464d64c47399a3887f89aa21eef4bca5ed3f1e65f4cc5b21806ffa63d23a1340b5785f77c9d0016760722d77bd6eca946d889cc0a50323a81d776576b63980e4a795f9e6be40ecf2ae818ac908414993692b2c562948bbbe0e74e8eec03ef2089b8c5d6a30408a0cae040d5e587a92d67cc5a3cd64fddfe0962d38d0aeda215830090c1e955c737ab4608f054bb9d4418cebbe275f240df5de9428a4bbd0bfbe88e1c2a2d03219605292faa7d3f17267c2dab3e1ac75dfb88010d3b32a47b80730ba1f133a3524d395e2c830c55b28c0d904f773f11ab870dd2154f2a99cfad9de4d2262bc0ecf0f527031575f037f4b2aa8929d7cc2ac05d43bfc7b473f8a8f49435a2d7fbb901e3745693894468ffb8274aa7536883c2fd09a8b6404b48f0326e8881ea403840b4812bd208333b4798c17151e257fdfa7c13e69e3e427a3a8b5d759e863e5474012d230b94d9e5cb26eb657b63b79bf2ba4f44d7a91cd53fc077f8ec0db1ae9bbe225045940962814defa85361423e7e8baa30144143faca5bd3abf3d6a4f5716dc91334cedbf9f8dbe1340a16fcec06ddf5087bdcbfab6164ccebeac307274333d73a9ced6e05ba6ece8470692910bcf5f4e321a24a2a1af8ff108ecba6275996d7b23c510d053bc73e9f880a4d1178a720a23a66b2ddd3d0320965174ac56f5942e0334dec34fbadec6bb339ce8c6ec94324ae137a3749b672fe7c1672ad6b946acba43d9f6e2dbf5c03a607e90b78d6a7fda777f2201757a45e5fb31d7813aade7aed73d33356bdf09c939e714efd9c16e11d0a7dd5c1bbaf2186491f5d1c6c901f08a6a2a4ef768ca68f3f9d341205827e9aae70b10e50f21bf806406223634588cd0bcb5d5df9883d444de1cee53572c1244ff879f15863744230448e57687a3a8247daeda2081875738b3a96ce7cde1e5524f6d4eea302578e57aee3397c9385131adcef0471f5118cf4259c8e1e220a85b3c7b1117e13d12a6295af9fef837cff29d788d5b6929bfd2443b7c99125012680c20a6949869067ae593a22e7e896f71f5eab81ed1c3d6545d8f782a846908e2735a246e019ac975367d6c39f56e802aa79ccd5c80606b1fc1146a5f2c20427a59e10c7e09eb607318ec1ceb7597bbfa29a3fe4a6ee57ff00bba4e44b71d2a8c39d4ef6f4bcf78acd27289629fc2b53c004647d6689ee2ebe49f3c97460101552ac0de33fb424f9ca8f2fa3ae1fa18f8ef4c29f7212625840877d4d5a89719cf181fd5ae1a81910f4b8b57a7093388cf49dbfb68b125f534a00711ed82f61328391663e8bc3ec984b97547d4830cbca20a356b937f283538a57b8c91705db9e8e5f939a476ee3e3bab6919320b0ef04b9ec5f99a76965c447ed7ed1d7abd396ee94ed55b0610138804c888f8474a2169c04747fa9a88b336d3020eaad91bd2b1b447d22fb2de42ec7ffe29850e01923ab16a1bb23c7d160e3d65b520233e6746ccc7101a1ef22112d0f41e035b32fdac53425a6f756c846e781f3b3306708ef45a992a0e459a371330dfd96b4d840a211d6305f35e6b627b1f86ed008e6b17ff1497d6fdfc82d7445cf198b21017ddc3380e9ed6fa4f20423911dc8208cb65db75fa6507c01f30bb34f34332d003c68bdb39a558b9447c4c69ba13e1518b4c7431f555215dd008f5e21d9f46d0e43fe3f5cb29982c29cf6f4bbc8daa2e76e3f60c44fd788ef0abf1151add12f97ccb0e0cbe64f6be34fd3b62a0617475f73e06a197f5dfc1ac2a1bf9621f85fc8aeac58cc8fd737cec9e5eb4140349ea14f0b05131b30625eb2b8f1d6cda59cfd022899f0850ac6f926fc60a62ed4dbba5badf69aa3d290f3d5c86d8a3d26103f655173ed230c4fa4323dae229b99437906731efc995db1e2edf3dab8f9334b1a5c323a183b1507d29a7b5f533a443ff4a4ee297955c8f57553dcb3bf5d6ab516764a2bda1e1b367c72ed1796a8a6b85f7874bdebe69626729d4809de98ccef87a32fe456a2a03572c03ca2a2534418c1e210fb0aedb7a0b1958656b43a68ac6a841430e56db4e154ca0274d95fa3fe75886972692313ea71a91952fb89f508103c49a04d295707336d816899630462caf1dc1ac6e958bdf64e6ae20f5438a606d93ff3436f1624b34b128f0d70ae5de1aeb34e93983562e46a44db64df88198a6a3bb5e23e6f6bac5c451a6e28d6495eb026d69be6535c303eef11c233a56a9e4ebc1a8c72d8f8dca86b7840eb1662dcf8197eeb1552a4bec07a9f19c2d97bc3732f8514c1b4f0f775c6981a1e30d10058dcb854019860ad51a20876d4efa7c1777a0e5997d1d33e2b86f741fa8d56a2235ecb8e437a83e2e5853de9fac882d5fd476ec709f9186a62d41792c06b5e8ff3ed93b9dfe2866e8e9d779fe148f360f64dded9fc6403566678f0cb5ed18635b4dc3e0239456685a263b58e3254a3b10f2fc1001557d6618bed4c197d0504ad2562095c5fe870b49641e4c7b8ae6fe67e51700b66055b10d6e0a194d3d283d16c0c67614d5477c7b3d471477336bfd4ef5e6e0839ff045891b85b0f0de5323a526557612f6b986cf382526cecab26fb1d7128cb66862eaa837caa70728467500bdf031d5dc32a0ec13781cfb2c574b508270615e81be7d1d4c7f3c77de7272957e49d5095481c4b2cd136c89855c321fc84d884ad246eff264c704bf14159493dd4e7d32580bf22b2550490fb2b67e01398f222c3d1d1aeb9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
