<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a07ec13d456a614fde38b41e741ec5a8b19f0df3a62778f4bd340aee34bfecb165d85f39dbc136ac6eb0d3aa125138bfa6a04e21393658923c59e0630de2daf695237e2c523588c7e5d88a5fe1d87b03445939b3a2209a9b94de600f7f9abbad936010446e23a27cd6e82a41a7f842772edb289d5e1f9aad02bef3dff3ffb0bb178e3faccb91b3b5ec76b54f05afcceffb6e033d4eeab3f97414569e7588c96a028b8e7e58e1c418a57289232b42cfaca8617deef4369330f673bfeb619c7aae396aa6645f1dcd53e61d7e1429134e643058b7052e34e480ac79421e3fe2563fcc81e9c9b2110bf058df2fd485b894dd1278151316ab8ca69c80fcd84a963c6b4bc9b3ce1cfbe1ffba5c472df0aca7fb12159445635af88c683d5841711593dc0111adc8c704c18818146a0f6cc69df5561bd5ae14a0be43238da75fc1291d876239b878b1de7492aff22006057b40385f44c7ea60a12ef38303b26f52b2c3cc47c2738115edeb88ca40b9e0beeadb19d12e65781276abbc98db32adda8cffa53db4ae675e9ad853a08fd906ec87eb715446f31c66ad7739d6004063a297d4a4b01bf845f83d541737877597f4b2b1a865d2dea162bb837e6ba17f4ede891cebfff1f846074ff92295234a329cf72d896d303c21027ed6a53d6617188dc4bd2c24b8b92b9bde70e1bfa67720ea9d06e2a8a087bd89b3322339963d7c69d6684d2291a2bebf0683ecb5bff67d60f71e2322c81f1a69be9205b7496d1dcbebf458ae0024c47bdc314015f8f8be3dc7969451696f596adcd5422c5fbf0069ca485a29241d134ab4c482b1b2f85b8a7a11871c4e1f7fde25582c1cc9328d8661b7b1669dc177f1c302b8916fc9626f1a464f88d59a7ae4b229ac99781fd29257444e15acf3e93b06aa75597bb099a7368c1d52282d316248013f003ff1bfd6e21ff313aa97957b55b28017a3eef82ce645c837cc97caa667c580b2ba5fc5f6f7cf390c4e2b05eeb1d1aad451a8e93b2e6282509bd753307116a78388a51bff790592a671977a4c89e9404d84ba9dd14256d7cb3cbb542378a3c1afe0902c2ef2271ad4bdbc3cc568a15c552890180dee877121b3a03ccab77d611f6ff93d940e16af34ddec92168b0f0fb0ed20706ef56db9afe58bae034091414966574965c35143b4ef05404c0c271ce968d3ab43a395e2a8ee6bc324d1c84e3d1bd996c470ce8fbddca76e6431ff6bf89a2d14b5c84673c50bbabeae588bc94816f4ad423b58a24d3ff2480478550ec68ea917c1c3c754478a42a135ad62eb5aa192a4bcc4c265a588a591f195c14da449fff14afe721075297ba78b8295f788a24dbed52fe4725351ddfb9666e49c421eb8d7157beec7c1489fe9065be066f0e49e0e9413faacd69ad93fbce88933574dfedd56b96f734f185b616abce2a856fcb4291a14c34c76a9625e68775cbc48b8b870d49cfa1902c36ee32c7283f241236828fe3fb2a067ca1a2e82a0258331e138107f314ee6af14723ff95e7ecfce9bbe77c0c494b088ea2b5d5d83ea2558911176f7fa46d868ebe233d99bede64ca069850bb656123fd1fb4af3ece039d883f72a8af2d04ca848fa2999b3cb25b9af186ae03d5a7096617f719460b3d31d548550e67741253f152727b76a8d14390f2a193f89e0e545c81ccd77042b2ba837d9ec370140c7c5c0e49489fa206ff295a8c350766df40972cf778a6cfc3e449da201b9c5d82b856944adce392252ac340af928b882bdc09269879a6e1e677c843445f1096b006775cb63d5b9ca2c5400d0a95289471b5f021c9d29be0def117df3661cf4bb460113790c2757378db87b75b60ab43250a170362050c44c96a6fc76d10ae29901e2edbb439bbea66d1ee8d1b3037103d0a22b2eec41768f87845f532798c2d9505c86e63dd1e8b1608bc2533c16700d3c3644030e65127cb85e8453ec9504a82570146d4e83eccce234864153d4797ed131c4f8af63db022a94df0602e7078fe470eacea9127b2fbb0ec9e49044185dd9dd9953949a217b42d1b2592d651607217384a27d1078486662b598220661ec71f5152908a5f51dc0ef2841b71a6a607bb25a11d047cb2ea5cd7f9dd0ab2ffdf6dc5e2e065d5257b111960015807ede08c825050d16807925b7a2206d746d241b26ada1bb0f5121505d7977fde46abfb98a0d441c95e22188f027cd083c39cb127d802e5cb8a86d1b0eef5b01e2e9480634b5b6fde2502432686ef4b29ceff8805261912f5e8bdfc96c4c9d6c8b85b5445120d211edc5eb3b3502fab04c1aaa0a3dbcd7b2970e67e872e1765c2ecdd7a4986907ff120bb7c32e4a43e619186bd80a64c2a7f9a2e0ffeaa950f946cd605497ea72baf9c45f6757aef8964be69b1e287ddd7581dfe8afd6d0c47a27701943d930ca8f4301a11b0b34383ef3e692cead5bf5343ef9a4698fb31a5de17f5be6b123fc1a8eb6534f92d0df13ab2bbdf4662cc250589198122c17ad7c00ab04c7820d3ebadbdb07132905930363240206233f983d77ac0c25ad40ac7bb2f979d63b426522b8125aa57bdf9467d831b5732f599011f636e3f2fdbe3d2fbf84e868a1718bacbad1d0e1aec6379f9925badb950ce00e1831f7e07fbfbb2a492922f2cf8eb2131d7503222ec06532058ebc7071157bc026ea36cda6c42b9831a22e0dd96ab67b145f26dee54c42a7862bb2406e7d7410965dd8cb0768686822166a37841aab7866801f2b8130304c8bf971a88f4f13b2a076ae244077591bc8bc9d613f81eacf7260d4145a1600a96e2d1a08afba6f1a1e9f161de2fc951c775850ae2f26bc02d0e040fd063f4e37ae152e0e29d14439ad7b7a31f7935f35bb814e40fe8118dc06db17e216cc3c10db74d247d6455087f0f766a740f8324f5c64c9c98a8f0895cb0ef98292061c100ebee556104be5ae94232256fb1ea92f0d64e278341ed18f34a03deb6bb47adbe25b5a9d356e64fb010330e4f44df6b1fb5bb04957b45fb6a53fb802707028820652f44f72391dd9fd17f520ec6bc115c744437c55fd55eb33b6a205aef96204c5208303c93f26c10200be5b984f81b22b5e9e0799b6a4bf25eaca83ca2e05f36622a1ebb421f1fa4d63f1faf3c6db322427c81eb72e3c6965344ccff1fb74ffd0b619943f3f18d0ded97f28dd4a1abdca0d89cda127d40b2af1b2576fd60d8d4c242edce4628d6088016fc50ec2eb66979a2315260f355557de357428edb99f37fa72ab1997a43f7cee0dc71869a8d87682fe001a91d0acfad06fb6109dbcf88ff72cef0c32d54c78784abd8b517395aea40eaac2ffda38cdb29e9aa5225aed0a031645a83d34a4b80d1995c6bafe57e78ea460e06bb0cf04a24a3f09055646ce62fb080652bdf6fe66d0e0e9d5b0038c38eb1e34ea25d29cc2ce7e5575aef67b0c9663b1785e7019d357558a742b161934dd0d615e9043c8beb620e492244535867dbdece1fef9dec7d8f36f1103d00cc83011aec4a3a7c408116981fcabdb34655f6db1de3d0274d8615056b36bbd574d6f91fbbf6f2ad961db74fb51c532f2b74a75f78fb6b47c68579a9cbead60fccb0ee02d6c125372bd4591501dccf9d0630e6bfbe5408e5802c11da1f42c1fbae50d9940460407ee7a84ed7e258f15a8f424ac2548f53aaf929bd3245f79ee14b47dfba1b9ead50e9e47ccee51dea73214203421da829769d230aea0b7f506595f829b2afe1142c8dfc5678775ead039d7c8c268823f5a2b36fcb03d782f5691fe691aa8c8afee19d5ed413de1dda2774c791670aa74b9a9d9b3e45c072962eaedb481d5637561a90c4a5f4ec5ca90a608294c64de1b11596a10c82efc77805edb82201da1bb8e3a4807b2ee87c4382d8299a674de95e58cc6d7a3eeb06a32eeface429f1cf8b1b20a20c0287ef20c12aeb61d849577e353ad0b7d5eb010578a4531e0aa4626b7f1ffb21ad3cfc8f25e91454829daa8899747ab89bfc70f28b1a66068d76728f7aff6409dd2c00c55d08c7ef4ede7d09e4ffe41467b61259c91bdf882da917fce33963524da8eff99df7b39d3d069658954d44842e4a43564b582793e4b67aa3600b31a9a71af7ac4c4dc42dd0d33e54d343c41c1d38a334ea473902f2df4824ad74014ea5fc5c2528c42a94a0d51ca64a5a874a908e669dbe51f4e71846c4b7374d197895759b867fb244f88e02f519b84adb8faac7e65ae9457b0c36db25e2db364a82cde5b429b4312bf7e458fd85f1b4b0538775d7c5bf67ceb7785422e7944716041aa2b323b92d2b6409e7b966cfa31e901b55e8dccdb8f0d7087fb238d407d74de4ba3aa51006d06234a36ebc7e635bff4722b50aedca6177026db613c90fa76047de5a564f42266cf2f71d0e90c7257c259f9d58e17aa97f9ba73e3a4ca63759aab299de56514bc6cefd757205e1d8aab6e0c8372a75a5984cd6a374e157e880320195e7f8275012f6bae609c697723e348c092eec9a97cc67a9b870868589a41dcf726deda963734701797a087182666bc636f992f2ea509e1c289a91947c4bb2cc43c73c22e80795ccf151811dad647d87d7ffa3d236a35cba15936f98b9bcc97ba5a1e3ed1ebf2dfaa736abbbfe2e20d8f246e993bb5fe1e1e69536b2f04631d264301bf8ccd022c61849f1aeb34071fab6347dac6e2824cb25c956b00cf20462ed2d6ea8205b5a9c0db254005f632f319a7bcae640e9baf0cdaf44461b43977e947bd4e7854709f5ca21aabc1e65c789c9bb0d6dcb8915e7c7ca8ba9edfb58b96a2ac6424853b0d1eef63de56b86ded7a7e806f9b558f85ff4fc97c8d4ca66ed4fd49811e47d9689f458cf9e3f78385b5751c4dca2e030faa6a1df0f59c5a16cf07e7c948decb958d4a9b56740fcbaf6aea1e1c7d89a498f370845fa197e210189cbb33072d50e64832bfb41da2159667e781bc6dee824c756f93448cd3cb4eaeecb9db20dedb67bedcc9ae09fb77cdf2b9652ab3cf53c029b865456c5323a9f4af82a06f0180373caa94707ac48fbcd790c885c37c623e8c476bca51aa652542c819c1a175e731f56e38db66cbce691579a9516fe6b418f92e961ea93ca738b2b07626fa3e56a6a705c51380616e7757be7f70011d03b03027e6ee7a6292275be7d47b54204003c9787bd3f32f1d32a83c56ee9741a4f19ca8f4195d0d32e6dcc6c1b99532e815fb4a17edcd289cba7944f3b4c90dd5e97fe6ba206bcadd18078f3e786968d734ffe429ddf9f8390c9231dd80574e9a322cc85423ca814535a66e4c4d554ed2cec48ffef9eb1a5d923b03b5890a8de97bf6657d5a498a586787dc376a86f3869ae4440eddb0c95b4dc1a7818bc629a101e9301a23eb276df2b69645a299e8cc95c3174eb8de53630d8d60652d30ef08849bf29e67e75c444d4c868a91d6eb4ba6959313d9250c14b658570d89282906b1d8d1fcaf555ca55c061f1bdbec616eb47d8214a75ec73fa3317ae77aa9cee0610093358491cc01f21e22fb41dc46c49a44c6b68cc029a4a0b33a1d328320886e1642d5025d1f5cd8d13721a350d3fe4cc2ab68c2718af64b674f97da7a5c104561b2148a5ba878270376ecb3b7873b85fcccbf752cc5e044080a1dd262d453ea1454224000570bdf064b621b5b38c034fd463bc1f32c539666a8b8af9578dd0dede9c7fb3cc852f36321c3fa5fe9c310002c9b88c8910f9a447c3629d33ae0f51d4aefb830c65cd65f407a5d07cef257ae8415c5ce324fd9fec03727073f90df077931b70612e57d08c6841d136e0d11887c1a9e04fe86907667d495f8dd0df234ec1187a72855e665c761a1593e8bb74b3f728ca8605c4d37c5a3595684039e1e4608cd6ea886de1fbd4d0264410b085a6ed0e96c2fb71a78c262caf3d4106d4278bc7eb441cf57af36ff410ae426fcf4ea4ef65ec3602ee351ca1793178d31e984bae48081a09453fb1b90d7aa9f34e620ede6f5724cd397cdc3bbf988b1f0f0de1a15b4b21a40563c6c4dc45dfe902d2f69f0462248d0699f2adc92e1e0c9e13a09d438f719b9f7a4143408a797c5ae399b98c16bf9ce0efcc0791310bb73f42ab6652dd346727630de79281348f87893bfe6e870210eeddfae4ab9a00efeb09cb99807a2237af41e2945f2c1664d71e053f26e1a022c1aafcfc7a95174abe8041500be976e7310cac21445c4715c5353bcb9b09a0cef652fc5fb6b868f2a7a306f8ab015816e9df72d123812bc83535650eec54a770d5fabfaeb37fa22317e847b3b6e502a9475b95e158c0a32ac220965aed758ae58d1cfcb060a65ca5dee12c9b3edb82560569922f1e9d780f97733d61440e88fe99b8b0fb7c351dc4f86d232906e5f0a889fe57da2a54d494396a1341e727ab3727f96e45d7e42a9da7da80b377a30b93395e4371a55e1124cf632cf8b69b510110098df981ddf8fc979cc68474a95aa28577e35ec253dcf61024e1aa3048c27777f45e1693502bc319e4a94f57212ac381eaf366b034fe04faa2e0f0d72f9fe30206e95f9a73c52eaf2a7ed52b110a3a7cf2b65f24f30b605d12b13515e35fc033fad80b807cd9c225ece14d06ca412bbb93d1063ec1e0530f9518768433b91f648f5da8452fc786937eea52ec1f7c1e8a5ce001cda77926fd44f659351d405d0f67a65208818240bfbb156ec57768c41d83b983e385ef749e92c28d057fc78ce3b84b1eab0c7fef22706e7ce123621dd084e90dbfd8c6d14945dc1c1f5fc257af523992a3a4fedfe1295225093e7eab5ff8f943c4a45294db09628f04e805dd1a25e8c9d04047ae71e207d4006e29f9cf0b649781d52455a0694792a653bd673f61ba923d0a3518c5981e67661de040d941aa7c8491ab86acb0fbaa1bd195a4d6e8261272b826d3618c4f1020cf0a5bad5fce4af788a4d89c7e0d3e451806b57c2ada41b848ce5ffa9e0a80421fec13218cd475b4af2b4860fe5bd3181f7a8ffe72ef61f6ba2f05d457665ccb6a076141b91c35e7503137086dc381768f39cba70d6dc573f8c198479c8b7cfe51e6fb9b02010a10bd1a07ada14db86520b096a941966342904e1cc2b278105ec96737289210392691f6a201a591cf78e7117ad4a86ab56c911a763b3716cd1c7619aa75fc949b194dd705b0c5013d4c62916de0d39407d58dafb4eb7c6fcde93fe7188a73d191d30a55d53ba7c2ae8fea7ebbcf04511227cdf037b6b8956c49d6123f0b5b4f5f10a911cc5dad46538bef1fc9ba26e2fb8cd1b9b6821c69d55dd4d3730f3f801f87ef824f435cd4fc640de466a55aea16e245d685c42395295e0ccc266f1aff77d0ed88091c49a775c60fa088027835f95d8871b671db7b5d4ccfa0dea0a8c5353bf5dec917b96b6512174ca89f50d21150c5d4987dbf30679c8f71e5b54b495571dc804b0ba65b9b5d91e0b6c77e88e4ad613f443975b69647fe3ee5379b06792cafdc720f578ccd83437589e715b56db7365bb9df4c384b558f1a2d29cba897462c6f0c6f6d08c1de4f7df632da88b80ee64f30738dafc3a1b4fd05cd527a900cfd080a6b5d52a1d04f0fb4a3493c532f2e34b8cbaa8fed1b26d737fadad58c27d00ce4429556ae4eacf94054a6db4ba0063890371ec87c113a09398e6a77eb056efb5443b5ddfde6db15deaab2de1771859aae6950213b8613b3b7bc53a80ecc2e5001b231e6a8bc7d5924eb552474b68ec451cde29ada00e611fa05a6792ffc404b9e0adb6ac1b16366c1c9dbf2ebd694431f0846de583f547c0c5881a05502b28789d5d6394a1a0378f481dcce22a5b3f16b412735815a5bac6e01870e37e099f23c70b01f5f4b3fe1e8765fce18d2071cda8396041ac0a55f182beb8218739f1411ba7abb52fcef677af59ccfffd84850f91d010d06dba80bd6d02c9300700e89991bd2a9cd07d81b47f1fcd3e166e76ae582e5b4502f46651152c2fa0e1dd5d146837507ae1db5180e0c9cca9071b8b1ae9c5698fe33cbbf1aae055648892cdd157bd319da7d5db60f4f71cdae6fbf00adcc6c376a5a7b0ce74db285b52a348ac8190a319c7e50361dfe9624e24e7db61100db686518f68a1195996bf9f82cf1900d9e0ab6f2b862cd1aa1f00653852321973f47a6bfd6a6e6b05b5e113bf922ea184213b14802857d1b6d5f53c88fd7ca0e67732f08ffbd0b81178b17249cd57aa4dbb3f9549437a64c36cfb7a11d9689cc3dec8cd6a7fac127d507e0d6b680b85f9afe9908c8fc3bfb287cee37a327c281a34e213bcadb7793928fb91fc8bb067accc48e489d026d18f22b8d94934ffeb05059409a14a53f1c7d86ccfa517eede60e5e8481ca442d2cfef1a4e17708224c5e3c6f6d864d424eafb2fe4f3bfd5152ba534b4010c4cf201eb06403cade5a5155943eed1f80486c6805f6a476efc144a4132a0fedf470c130e19164880a8783d17bd1e9b3af6947c74bb4da8d10ad7018395b30ec98a0ce216cba22f6303fd4df1a4e2370de07276e0a8e62213dc0c4c97a5bbd14ca6cba8380c7ad8515ae085f57b8a7355137e71e4aac141c4f3da8db8be3f03aa5f056046d22f7ea073bf578118c8a73052036a08f215226269e86337b2a1dd7fbf58f380d86a0155e336acaa87aac714c902ee26b86d16bf0a20efe51fcc782f43a66dcb154ce12bf1f6f5c0802056aee5873946073206ad6cb431896959e12f843c6e67f21208f4c228c2c0fdd4b15d95f7ea61eeeddfee7e5b5a1b9f2f4e2952cc4238ff2dedd04e1fb3d8bdbbb055dfd0b108f3025b008130d4eb0a644f671eb1357b9d7875d178fe08c4b54f6952060a77059c7660f271388b6b8c9a8efecd75c374c434cedf2d369bf0e4c38f50c7454de8f07f322e70f378c7f49095f20c25224862021d6a90d237d7e37e46d587f903645d2affea40faacab5b9fc8d5c8e85bdc28a978b23aebe136920794a15486d44674844576ae1dc7295a3c57072b699e2e42846df2216d0df2980eab69e9d92dce1d3172c650ef896aed5e8b945575a421850022996a2bf1a0ea176d40523fb1895c5dc86fbd7de22da047ab227a652122b06433ab39a3ef9235492ec25bfb4d91cd83b7cb1c7aca24a72dec159a1698c416bd0f7387b94ca8dd7c4d8fc47e3066de7c96ad8962fa658acf6edcc834fc2a722fbdec31502612e52be2d419459db204a5ba87423d2b38202ade3d173fd30433bac980fb9ccde42f7dae580694ee8bef2e26796d7f10fedf81393fd43047e4af906a0fe686e89ead114d391619649c2030da8a409e885763562c4edc93a15f60a2255f7a0fd932554691a9e4be4eac82c305ab0ee8175f6516fa027bd8c52ab7f94a6a31982ef89d24537224cf70f464b2cd57e5f627564b2a06e2fad86f2d60e4ea8a1ed88946a48bd752faf61ef8bc1759469bc3524a5c2aa044befa83b870bd887f63b3119023807d2a88cc93827df66034fb16e2ff8c04364b0c8786bda25a1ae190c6a383c586e2dc6796e9be6cf768f7056ae01e5700f84dc1a5bb840aacd1cc1abb2bac02a37f87158feaf9cfd11db7f1541466f036a6ba311a7c8afae07a0a4b13a6ef739d8bc713739ee299d0a95547590b22c9d63b82d2aeb823fdc93ea99ba69397858c41872aac5af605c5692ea36f447402acccde733cbefaf09ab58c9f1651647ab00e7dee79ba5e7c08464f9ee5081199afbe83b4374738ac7f6db734c461ce2ab9e60cc902aeedccdacd4bf7d49811f6f5050db70ab5cc80d20b8e0f8708f334463d1eb13b1ed715842a9321545f2b4d01a3c323458bfdd03bfea495476cf8142ea082f16c1d752f239837a7b91a1a9cce802e7243ee8f945a0d5ac8af7285cbce83bae13babe7b4eda7bd7fae64528f6017e604963c193f49475c63bab04934c4e20ad80ffe644c2934d6e697b6cd27623a510b1d6f2f9056ca8c008d54a3f1c6f2facfb7a8f05e9978fb4cb3a9c40d5fa7130ffdfe77d4e85e07b9cfdd2fb114d7cbd3b0c34f7fc48d85b5d19194f3c27c485f2a7e57a8f0d2f998e3f5aec7aabf7a3502fe5b9c0cda9f835887d22c3376cbdacf284a12e10884f283828ca820e91874bb96342a1fcb162a472f7f8afc96093305482436f9530989ef8065e42b351eaaf8d7a9fe95ca7e1f4357e0176c811015025fa73b6256a6183e345120217fadd1d0af035ee25f015d5a6ea22ab2ea55256ff2e5a3d19c956d887fe73caf818c2b48a77df58d7b26a351effb3f169e99bf4908b2d7843d8d86f173b778002a124db7c19fa5a8ddc1316c570fee42dabf48d78254bd6f9a54c5fdaea7454a29a728dfa19ecc0e072677a033c281472347faa601f5ee1d1b294646ffda5896a7e79b5bab75dbeb72b90ea9716b9806a4ad5dd87448b6e0ecdc729c416a73c7a207f2b3e578317e6a71e77b0e120ecc0a6ce8e93176324bc2295bfddce37d6b22dd0aa2ff60ab10975998be4ae0016156a906134b52762683db8e58fe2daa1bbb6eac9301fd0be6c5357c14950dcf04176a23dc41308f4cd24823f4f0a36f4f94b8a021ceb59a577f7c3e8cd25ff2313b7ffaeb26ca504762779b1b8442732f7d079ca7ca113ea02558c676d0f08659fa7e10d6380e7b31026b22471f63421d62a26861048aeac836645599764a4cc900115ad2bb4cb76207e329b133b16c8d1f9bb89f25df23519d4b73e254257b1c30045f2563f8a0100896c7118de709f175e31340d8fde8ea5a6f2c9ca9490e5f71ed9aec145797ba18a43d9a78f853c0d0c31592a8e8b8337d556ba3392328d1d7473e44175ba3c3450f1d4f9b8580333082b145fa679cae70d90f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
