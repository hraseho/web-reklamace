<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bcb763e884e8e48e3c55c3895fe35e6201cf1fbc4bb051e461982878b36e36e83406876b504f2c815aa724b8ba07d8e1a5998bcb63e77b2923d2836e340cccdbeff3c1318847e48854b3707a6bdefab4d6343251fc175f031642682f1359b47ea5846c61cc2c7ed6de53d8eb208b83ea85a0353af8b65c9227327ef4de0af3cbf7a2b53ac97b76763486f5637e839eea81d9ba1725094bbdb87ff47591bb15c2455eaf81a361be42e52e9f2f0a01e3ff900bf0bfb898ba5030f46bc7ead4d0384b7d8fc0e2340c28b79cac96d2c128721c129fa33d91de6c2113ce086365ed8a6e42901e8a69e98eca6dcfb6d547542da257c40e6a6f73c16487cb89e1cab1f6c6a010c2e1911994341ee15653674f2ee92b991cfa8010964a4c006189f937c66c699a1358c9a15b41a6c4eae074b2e52841106bb0c56f6ef0e6dc8a3f74ce2d7bc8112c0b497214918dc3520c935d7df6b7daf9fa11f7a9bee5c2268ac02ef03baeeabdba9bcc44c702d9f42ee29cae9affb0c53a898768abbd109221741b7ccd91e82adb9b89cb99c000d14cd95d217c12b6f53609f47c23b1a48758b6e77057b4a61ed7a526dabdd75ffa2f0849bbc5287ddb55466d3d8cb858030c4e5c0afa744eaca7566d8e7512114dceda542f1605cf7e232dc6bcc786a5683cc4be117e0ae99c3c5318d0372bb60d37b49b6ba2a32d777d145b28eec1d2945e9731cc8ecc032a5d196071c8b5f5695abf070ea792ae3f6c3aebbac75cefb219f0b0c9aebf07d0d165b32ba127e253a93990acf4769e69c0c46dda1810b416bf1b869f3d1b8d671f7d37667b967cc085c10a9adfcec2ad56944566aafe2fbdfb98cce45175e9fc6f4ed68dbaad76d3e6f5f6060fb7174b794fca07fcc9bb30f45af82d6ff0ae900b8fa6becfa909ad2fc1e8920c380ce53809dc34cce747ee1e73a5a8776adf3242f1039d04fbcb139733c1af275788fbeb2f153191e668bbc3fd827d0d55d37302202d38e046643d89109712dcd9a43c522dacc22b285d0a779c2352478e7a544acdb27cbe1b370c03e944ad9a8c2953b6e59f59a3b53fcfb03375dbd7aa4df6bdc06677faff7459eb3f9ecdd2e59570e2827f89a8db895c3c97a25551d2ef3ea460c6b8633ee2b756483a0feb3545020e374b19267915e44a7e9e1838c489f947ea314975acc2515a5a600862eca6e86878338a403d75c8f378f536c31c138644fa5d1c7a7be586ddcb362ad273ba2e8320e211ade87911f99c7df5686d240661d64cf3541387b9f8a0cdc3359fc5cbaf64fd578024858cf52e76cdc4b1129575faf0558a0bab7287fd8f78487ad9ecc02602d034c81c7f9f2bfab868f7295601db5ce3d927ed871e65c64520feb9c5ebbc8e1f53ccde735082893981d4d5c66495adce75417613ff51855cd24a59b9ef8b46c0fc20d17cdf3882839371908e2d8e4aa6b0dd1e641f61fa5ab7884e4a6848ada6ee9c1b11c7deca6fb496dd03aedaf033add2c472e954824eb1487c8cde22add706779f767b3bc51d6f634fbdcdd069b311f1039ed916e58fa8d031ec5df18d0b03d0d7e64373dc0d1dd5f2248ebd77a8f95c0897353b2d80509fd8ba08da807a27f1bb62bda0806d3ad7de6922b21eaa8123cd019c4db94e37e8e69be9b3540f1c19025c9e55aa600105af5e4d820dc961f3c53ad27775f57ab214a00da3c2109a492845e4bf5bc3857f6c29020c841db73b2702dc095c4993fe15832da0fb700b316ea7389ba661e57e5d344667271664e5b57fd54f176a285502b9b875b215ff2e2e432d8c5de81a67fd25202897bda500cfdb686e03f372233ec27ce402b1bb82d9d9579512cd4d60648d83186f38d41095f17864311646f5861c5158c2ef3820b7c4f440eba24b5f2e01e6b6cb318549ae4194c07c1a35029f36df8c0c324477169194b530c95d94ef225c175227a008794aca3f2b3587fd28f50a2c7761329e861691747a1cb53ed0d7f9277e198f2ace195a8bab18ee73ee85db0b3938cde2c8b838fed1d94ba6aa11765e948a12a834f87a938ac178c0954324371ff0a4e53462e1f33697399d822070c0281f014162807431056e3ab4a53510072b6b48df5aa7e565a74cbaa6e5fadf1818ff68ad1b51c33c6ddecb2e67e6c37907f4649de5d4dd74e7693e721643a8f78fa57ce7bd12c0bb0197751b6476076be570e11c9b8d42fb853c7f9929837fc02df175fc5b3d3f5f6d38e9ab2d21f3463faa83c891cdceac5408569ee1ccf1478ee44eb5b1e4d7d3d581587ef9801d856b8d0b284c411661178d6a7be217e14d3de0b2148617dac5aabdacb9b481917c8eb580926b0c19e666c9c75ec0954a6224846cdb612175adb4e27491d9243c48be7a4fd34d2367f36ffa0e37951307b7f9f207c1dcce19036601493c1eb6574ec0a4ad505db27c88bd26e0f7b60714134498dc33c231833c4e5e580b72ed08389bbd6e28ef60da5b22995a4cc3c8ae4e655397441a164d0844d253b6ee90d33b0a3100a5fc6d85a59d505a77348a4a9b6342066743d7fad04bfcd0c5d75a538465a210940c1eac2aa291538287c64078d9209f7d56a7711d13810c433b0292f45766bf654bfdc2d3d6fcd5192837b46bcaab21d84597ec14d44fc45a9489110a6d2745cff93c0cdc7f5aab66b420d33cd188c1312eac74d709babe1e21205715c123ec759b6e31f4f9197d04e7bfa2d97f33205a061f10a766db8a772bdded301601d1dc3668baf085794de9383696cbe58a13385d446ee901bdd8f490fbfd234b3c121031a0af6cb7bafd95ba776a6149525efbf02560e65d2fbcd007b880d5fbe35d616cd50fe67c69f85764c010ca5244535bc06ef2cdcc30bd64f27318e7b87903c208859ebf5a58cb8a5d42599634d7b363f0033b2dc8e9c67cc33310be2b3e5c592af827d994fa4958b866b2fbc3e2689443d6f8ad6da0541c0f229686ba6dcdf5fa4e0dd33eeed19ec82206732a5e7a4a3301b411f94546da1bd2ebf16deaf276e921cbb7b85974145a7bc2860a88034f72d13b61344503efcfbb7458433e16c20a9af35c72f975452ea92e0acf287dbc564007c8d30dc5d2df1eb9922bcf49b73fafb688bd99efcd143265638d01baa8d7baf926765434aa93c97eaea4bd0a02155f883cd5fe663ed427d8993e0c74a2b86095cd301bd37638e19213e621f822d323855c60003e4651126a748600927bcee4a7435fe8b81ca1cfd15419edfe82eb00014b7d2426a4da553ed3bb6cd5e85d032b8d4af0b8b96b3f5129710ab4a3b7f343f909ea3fc7d80be7f14aa2864827fba3776ad899644242de37a04aa70e81c72da3508908bb32642e69c06beefd7426ec3a81c710d917a809621b7028bb35227e941f75c83fc9bbbca4389d92d9428b8d1ad799609f4d3c5b77ec8ef2c17799ed9bb015395d5f4bef3a048d33489eb63310d810b90a903e6c096c25eab319bf828af3a1781a02eaab13d8df0465fdabdb4e05286928ae539bd923641aacc0f484bd170fc3a8674b4dba3b9ec5e98ffb9c66e9bbe1dcd390d5a740128b83486f40c91101f5fb0204baeeb20a5f965b6931c2241ebc80a8f685170d5157f34212af173c7018929049b1916287b477312b97dc3b31cb30fb9cee99c1caa8e749d874121497ae9d455c1ad837ab200f045c33d12f33997d016c3cae494ef701e48e4ec0b993e2ed86b8d5b50a3064b2044a56223adda3949d55d775b00a58e744d386959c69966fcee1cead463c642e3a9c98c096404f444569ef70512a78d4a87d3ac3572bc58b6e49aa0337f001248acacd0d566349384796b338ae5fcc2789e87c3213fa29119fc6d3b008aeac196ca728eef3629d6ca1d75400e0de33182b1cc9f57dc83f12e92a965dd046f1765a9bdf195d44fc2dc97c27d9d3217e3727b42947eb2e7953648ee368d23624fde39e874292e22a46adaf64eeec8c8ba5cc4b24e84642630870cf33ec7d5ecb792a436008946acddd747b144702103e33712de00f5f1f54b8d9b0e35dc85fea9697436eae1646a5dcfcf05c0af00a358c2160da84461ab6d06f024b00b153ecf9fad98b928a75c1cbd40089e0ca5d17a6617a203075deb686e33e6411118441ddb7fd6ab7005fc50da16f315c91463b05b6b0ca9e9956a99a8bdd0564d1f31ce3df366884ca1ae7f60bcee98f7ab0e68ef835b0789c3dea83c980f9943510f50338f6101840a22c0815fcaf178d1a20ae07570243ca67a4ff46facfd0f8d495c9d67ca333651baba7f7a025000d51debfc86c9f799f73719e8fdb7b41f789ff75a64fb813349f37f315d0ef61fdf2fe9c8d48fba50aa9032398bad7b5408557bb076792fc5bfc9c7e79472a478e035fcbb5144a0a2aa58013924a118cf794e5fbdb44578685640ba1ac2e1016c5d167b398583377a829b8a9ee85b886abb1564efc9ae6592fe3eb3fc8a196840e8891255c2edbeedf07ff44905083bafcb695ec8fa8be9cd14dea4853e248d016826c8edca20384dc8fbc4198bf43cf46ca6ad54bc158c9b8af7070e0840e0611fed9b55a10c442cf1cfd1f5b5b0ff1e9acc3937cd07bbbb8ac49023da9583e3cfdbb7747b19e89ae987bb24ca8bb8c65b721894f71669a723c8b6ffd0d81a7fa47ad18131f2330547babfd12b9221becb3cca3072790994821bdcf8ceb9d0f6144f0f5dafcd0b67f9361e567596a9d1ebae4d6ce513f4958588273edb1ede50f6cc7ed613aed2c73665da0ded7f82523e26b062afb4b73a1b1d14bfe9a28cd5da5b0188c7e96440af3cf4d5ae83e806c0e2b32887ae4cd0bd2bfb8ce8175ed79b5f48f0fb1520187f6fe8254b1b35768111225c0d4e404ffe7c2c3eaa02de036fc6bf8b6496600e40fdf9497be6897dd2ef36d2639d886b2533afbc2581bbaf894a3055e924d0d0cd860a2b9ba446fdcb30caf95d92a2fb07beac8b1c93e13ab919cad4bb08b783a403e124ebc32a2aba9ccf3eef7444c41ff4464f126c86f08b0d0f55bc893c0d94cd3be9e18ed6256152269a5013e53ffd2cb917851f7226afe3b3bd6aecb5d818fe286893622600ff436298f682dcf2397e808c9832d21979122329634ad028639228ada860abc4f2545dab13aafde86fc73805374c330bb2d187988fda3adf44b324db5b12ae293f0490efee4f06d20228d1320595e9770d3c332f9a87394b22ed8acf5749b857b327202f91fed13c676d36c65a164c0be0cbbee1b31b5df5bbd420c63fbd8406f369c2db0057a21d1281c1cf4f0b3489861140552428a03f1f713ecdf1b30b2a1185bf979ff2d2470837e9408cab76246e7f7231a78c9df6bf79e1d9efe46ba370b8cb9b4e71848ca5b4e43bd40453b16fc4cc1c961ea348e9b542f8d4c7a778140a8e3b78769ee68837ec6018d4e9480ae92481af172ba504bcc40f8a1b27daef1c54ab6f5d471e6cc2fff4668d702e30563756c5b54629407e5730a9db57152907c9f3c2f4716706ba850c23d71978c8e769d36cc50ded544683d5c2bb82bb490196a8c4e6eaa7af9c068b672c46461ab45f74ccfe9deab2445549ab0b8a4f67f3c61c319771cb93c13d34e2352205d03756527c7c27b56f96fc7bbdef84446b00a4c9d1028c5dbf841565ed2a79628ed1d0cf73c6e2051fc8a874af0abc35767ba2b2560398c2a2c9924928bd767d532b2a708aa505fe5cd86cb1dbdbd1c984894a376c57f1b6d0be280bae7b4d094a0eab05f616d076f68eee4dd8620b00633001f091b9a705ae9413e1fef21ae972be8358eb6568fb31813e8a40c48a1eabb2c303a00022cadc0bf3a1e3b481757053c44136ced6ff7fa34364c8ab83b98345ef7ccc15b3cfc49491ac9158396722400dc6a1973e0837e525c40578799f736ac00869df9c031d83599a64cdc92b940dc4608e0eb5fde9e5afb996351bd55070cc5f5c163a3aa7c1cd9431012088ef49f42be3a326627c1b8f1d76a66abaf0a4a8c5831f376abc227de9c2606a2c5d5748217ce2b16a03faff2e716531c5ff2d8cbabc37924f4ee79785f75c98883db193f9851ce04e0a6f3f8a2363a5c9a6152f3208d7e873107db14a1a6ce37e37c41da29efb7755127c1c03863980d6fdb3346ead05925b05c803ad10adf9030391ef06b01dbb2c9c0cd58b33cbeb7295396a73e1feac87375fdc4097b9ee92d7b0d800ddf8d99d6ec9fb59a9df1fdd3a5103fdd52d18d59064b459faa1d098e326c0cd2123af3d28da8a48da792a569d7e3537adab739528675a81c9a420e5577c2f7f64270370d048fe2a467b19276e8a329bd7a91a35f0bca3499826eca2f1187b2169d133572a95fec2236060a63cc5f1cba93eaf6675d25ee80ccb39e0a9ce6fcd7ce7c46058a3495cba48a9920bf7ccc835f1437c99f26634d2e9091ef36f1fd1810894f76393477c67b7279694194f282bb0fd68244686fc9495f5b670f470b035520b156747ae91047768b8687e9098643ac2160eef1a5b0be564b1c0779a1b0b9439f3b7ea873499fe1b3890761c99cb11c8beb7796a7a5f9392d20f0e0381fe353e865c7eec8ed7dfb0b2a114432167ffc53e5fea8f7e214ae5c50fb4296d653b8813fca075b7e3a725241d3c01806456c5f98230c01315974254b1adc48a565b724928e34f154bdc10f943ee7955ab1ffe4837d422aba5ba5fd0526f278b3e4cdb2446cc125246eff2d285f9839b8e21a01e962476555c593b5c1038d66322d83e1c56588b78d445e723a44509a749daa8f08459e29aef743132b99db7f3e7137dcf84e902467d355e661c64d519d37d7555f1ebe75f6cd2dfc1b103e02371b40d234870f66a21074522258a76087cb5dec0802ddbee04c8c8304f30992d976e5787ed0ab81cdd8e757eb730b30d6abbfaac4824cc5809f9f805179a7864da8c202bd3056779650659e72e64e5729f25e86816be036c917bfe9dd89d96bd6356abcd5b1ccab5415de3ce952f78d64f0017cc4a355ab901a3ea27203be6323a4b773facb0c52257e6324b36e453e8b3e9e15168ee64dd2c03ee524db8c4036509b70b1e590c9fdb762fc2825e4739b1da2fe561a0a7a6a2c56fc486480a9b3093b38c9a3d5bf5fe13d0e818d4af72631a62ce037882eb6b87442ea91728c73ea3cbc4a00f8503230e5be936576ed7107ee740cd7d1126b9ff3de928f8f568a5f22cf5635444b6667c82dd1afe5900088195749faa1f0c19d4a2bfa01de1739fbf7f68378a981ccb940cd5fa4f6c170a3fb762b0008de2bae814ea464affba2eed46efa7316565f189a5bf0f0ff8ca99e2cbba1978f4ed50363a73c14995edba2e6176be80296cf2ead87807775e4bfe20a34594cc5eaff4b14be97906895ed5369ad8a9595c95ccaf96410b60df4ef30bdaabc49e9433f307330a31f87d31d3f14208e9a7915377d45cd3b091d1b573b678dbdb0e7e91ed39336c73b9a440effe0bc7453fbc40e66756194d339e94e3b64bc9af70385e63745771be35ff5d0a7fde7a10d8a695068167b2fe4c6440f9863beaca3cc1d4a149ecf5c1458f4d9789ee1ca02bca2f43029c22963f62003315e1284a0c2b122dc05a37c1a924d1adaaad7628687f04d41829dc758cc58b0e89f37d4d8c2c419c0dca9add20e66191ada42d235ec9d664104777b83158224f9340aa7177e8bcb02e664e4e4f362d4e317a8a0cb873e62301cbd13242b54ade77c8968930304a3d55f830ee4ccfc8ac8de22b843eeee31879de6f9beee44b9b9002a77f3c13143ef057bdaf905c2d985389288dd5c9aba948fbc7de3ed4826046341ed8863bee4e2bcdc52359af7ae05aa28843ac5dde8a8033a83724d83f7cf02ede4986d77d0483ad67b3a4a2c316ff5937551776f4c9861185031d11efbcee26039c9c1b69ea6b002157bba70ac3ce4b0175bc65cd8f7d03300290c74e02696b0dadbf633e3c258f424c050606b30eda8323a8d936cac1846bac0bd6580711439f009f8b680902c0114961b5e594c44cfff960c9f318eee8abb749d85852ae44f6ff4f0840617bdadcfe03b2c7144d0f1708aa0ff5e4ee11f3662baef07b8af0b6164b0e7683459b8fb7547542ac54d1347e9f802fde01c8d621e993b0a393bfceff453cd3326416a86b001e296a4799e355df0a7e6b2630982454c0e22414546f778e0368d5a6937479f743aef4a41a3d138a6381ecfe34303e1b246ef085941856cd2a974745ea97ffe811bd0b13a871b50aacc1f49365c5a34a58fc143b4de767e4eb4ed3a97a40697128f66060e2597ac6204e95ee70cbce1861c953e333ba3ca5bdfb0b7a54f1f45e84b363c25add4aaab578b6eb05ee7972abb3314f688ecbe0949aa9fa4f96e5aab7c64c58dfe2e9f3aaf9a0da0a341f3fa1b7e0ce730e82c3d7192ceb343cb70bbf97c129ffb482d96a61d115e02cda87789c8c451a0d8370c1463e5bd087f73f8a623c21ad3627dda4d81d5c64c661aa6253df8dff9e5d64c3b86a97faf35d62d6399a555bb3d1e18cf8fbe19358eb48f797d88f7a16ac38628944044281e9ca7e0af2ffb238dc3a1948887732e751095bd8a9da2cd5ccf0f4c45a09fe4cd02010b105b678d3f476d375f089cc9c5b1eb360a76672d4ff7044dc5e81ea2be8c317bd0b4ad8a43aac38501e76b5986c6788ce06651c17922af6082404d970431e28fa98c2de935c3615578aa0fa10f11eb703852aca8a65c1b068aae3b2d8de150c8cee137456b465d2f574c91160bf56a11381025fa8bfd6d81ae195fbabc5b37628594a4fad6f2be4fda48b7bb9adf750262ea10db1b1353a3a45e337a6dd9c24859fbb61f2d8ea6c6c5894bde8e0bbd0f2c6f14b7cd8f84aa3df2cb4bab4ffb96a71e148619e83cc54060a57ffff0e7da38e7606acb8757a83c25a814a9ce4994ffbffdc2cb80cf867071b43b1a13b9436c087010f32697bbad75c074800982b44e8f00e8caf63257ba016733df67adf083c619cc7c194f522dc9a8acb267e5458709d6e576c5bd1e1fca4e8a42e129c4343a4571e5ebd6fdc16891c8493114eff2c74924568f047acb82e8d267be95556a152dd519c85cbbc40db5bd7e09ff6cd5c0694e6c53c41891bea288c61e45e07e69b390fecbd394bbe6bbf667dbc102dfed7eb972c5ce7fbebfb586a43ce0118acedaaf8a65a08a3e7cf96465f584424fc67104bc92bcf57807142251c13b1d48e0f274511ee872d8c3e56ffe2ad4ec3ad8c477f54515d20f284ebc3667f57e90d0f5f64d8cad0dde265444fbae5619b2235259ddfc73661ddcf461873ccd197e2930539de1405fc028b87b15eb00009ff276448b77810f872a9e08a1257490146d070106ec9aaeacc4fe7acb73f72a795923ccebdc9d12975c967ed4d6236318ca4d38a30995fa4d0dab4c3e17143cdba58df15992373e48f559f516e3854e6b910ce7ff635a3ec0982f90bbd8429ec911f99e43df3abbe36c06d0de9b3626a31f1410abbbeab957c9e794b38307e72dc9b57d5a6e5834deb767a836049ac63095a82e3cc6d55122b500e292dc960d507088f61bf7f89b08f44897cf8e2361da05bf3a2b4bb54d0a75f535ec24b3671403f575d5637c17d9e5243cd5ada9e815ba78a2d0beec7fa8f41f2b823c4a4e7e711669a05c0f64a7db8a5ee246cbd3e83bc0cc632341594455994f7b3e672be3647b1570ccc7b5b28a4b27fbbc603e8164c716455bd15795c6c3edbffcba6818da0b4e1483ac8ed8e80bef25a59bb607dbdd5afaf7ad84851d7992bce204d734918b698708fab31f4b2382f34c96371f721803b3f47500930fef8239bddaa3a94a00bb076fd3f4a66603cb3268f01dd5faa7259d371146380d7595dfe5f94944856ff6fd63c0e01073683524632f5d4e16b2e941e4ac2321f1ce2ca2717b936ca4edc72d15f1afb9f341d9e1b5955baeb379360b0d79934d03b23233c2953d402248c6f82a00f619d6f2fa83d98e92923c05bb14121050d73a58e12d8d3ffe08eefa317dfd5b88f8a87de11803ec3e31d38267eb663016598514d55ab4772eddf3ec1ef3b67585a4e3a5046c369a63c670eb12f68e8cda3b39fe967dd03f5b942b8c1db55ef1cf553e1c347e36d6a25784979deb6063a24c863ef6209ce02c1338c90f937ee65bd8a451a2670ff399008e02655c14bbc24a771a1f1d83bede09b1dfd640c6b08e56de6cae24b8f073d2748b52abf871c06e555016e24c269ef115cc859cab5b1087404dce9aa4283d93c6fb32c1553ff477e7f4851ba3592366e66c65f290b5a6eb982e09118630123929172f970b0774e0fee022fce4ea9146ea09b0a0c538baeb0639bbbd19cacf581a3a938c3b93a9c06245b12a247c50e725a8b801de5ec5c2bc5607bfa9f9cb262935518d0a4ec0ac14bb5afe509aeec554edf029c1ad4690800fd909b90f64c11c14231cbdac1e327dacb7d5b87a9470fe3da8f6875b0f87d18336bc4aff31b77224cce7af4f7cebaec4a7173594e4b558d773822bc8334b499342974acd1a3cd83bf5767571ece01187384d49d190cf8ab3112a5fb405a1140019ded571a963e2daad5dfaaa46c66ba7d14b2763044236c129edfb1d99d141fdeb2131e57cbfb66f771122a46eed60793248e699dad8f60539ce85fae7f9e0d5ef2b2f2c9dd0aba8879f3feb35f57b711b2b0c03a6948bccca9bc1500485c74918659819269d49f5031a49ef587db7610d343c43fda83992dbd6983b05beac71c9fc4cb0ca67dacb87fff12b67dd4ac86557fed580a5f06a3c2f4a33322f0be6434b48fd827b3535f60a4e5cb3f2242a2331d5880da51b7d4cceb408bd7a33b3c31005010821d7a6299424ca9c789421796366e7011004a222cf0f52f80ffaa931bde77d107ea323888e5bb3de6b0488b114a88452b71110044bc8bdf7db9a319e4dfddd9f66da6d3179da72002e115e548d467e252d178c766ba0c00d8b4383c58defde73d5c9a94038939f795e894cbad593191b10cedc4e94176b9fa4d4989d32527f7521a65ee164e0a522f1633915793a23bcc8a3d2e6bb6f07f26185226379890708c02e6f874bc9f0dffa34295e4f78fc7da8729856e835c0f1e90f93738e78a006bf1ade5a77f287e678bdf9732990c007af94cbb49049c72f860661f571df0383593877575565bcdd5b06c4ebdeda79f17d8a2294cec7b413d9156ddbe30c96b329875cf9c4d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
