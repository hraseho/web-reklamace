<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb4376ebda29708b8454b2742350621a467f15e4f2eebe4850b44a0823c5bfa387e4b9a9b1c60642689da2d509cc4c94ef99940ee37f4f0422f0c9724665be63dde0c76f6bbb564c8b3248f924141f76d179e48bc302d60336c8cf102afc21ad16443c47ea2d106dea69e3f6bf755273f3d83e51efd06cb29dfb5dbf0594700ad7d607dab41e7a5d869071147aae02560b31365973970b6d7d08cfe0aea49e7953b7b1d80e3ab51c11cbdb4aead96bc871add4baa1a8fba2f85454d1e4c13efc1f1d727663f7207a865795373864d9f5cc2f4854e1ce05ca2cb4796d94a02db2b850592d29b603c4b0fad75b9cb5eacf50d77de402c32351e8a0842d6567f90eec8d79dd79c3921d7e66c8420e8b9aaadc8721431c8a5294d922bc77ca71567ef394b27acbb36a04c068b7cc32eff827d8a8fe622a11e84da567bbd79e616da108e4fd9afc82d028b68de526afa0733feabf8087a708927e06727498c6efe4f11f8705924748fc23ea27a32a9311ea2e74bfe005731c83274967e88266f07bdd3f14389e37f29da5e72e252e650a049e6efda28fc24c04f35259e216fae991cbcc9128e9953b39f9c56c459c4b0785780227c59531151f280cee4f6e283e6c378a4c8bd44cb030e74d8eb34e643b0917423b2d38b60db10a15c934ab23324b890c4656515c71bdafd79b6a739cdf0647f05155aa3befd2da40e43d36dec876677d96f4acbac3110984092947b5c51106f221bc03cb36ae4186173e598abe436997eb2b1ceeed5b9ce34033e945d046f0e22491f362d6261b9175abb6ed9e7e4d19395108ae14008c4508bd0b93ae657a31d0eec0f3de0b3bc8efbc7c79878954ecc8edd36990b9556341ff99cbe84a7d72cf5ab9dbd1a05ccfc0f03e056cd18e57178761fa2e6178612a9ea46fb0875f77e5bcf2a904b9595a95458f1c59350a15777e302b6446e2c52afbd4ff10229d7aa6af7e7a99967c04ad9453519ec3cd20c4d0635147859065d64123d74aa725c8741e2031f4aaeaf68a7e74f03b9c8d7dabc85c5e85d6168d5f1adf1e09fa869c51aa340be64e5ea05a0ed35c9b8cf87612cd75b0ce55a5eb300a11e20080c7fe45d87bd9b621a05ba0b0b8cb31a6a12b670fe55d7f894bc99e4398ce6bee99cfd1367b352337e3a1d7daee28b4ec7752e25f3f24565d6f0e0b66d7a09e9bd1e95cdf564e84ab3b04b7e05be39d04d5ed7207b0b0758fb87f7c55880fd0c1a1f4773073292384ae131a289efd59cbb99f0e708547490b7473ef58228639a8ccb962a3a1ac5ebd771a2bf325f408b8a70bff375494ce7cc21c8b42e34ce46c67d31797b6676723956f719138cc43b4a814b623596c211cc8875b911caf697e9af116e393a89384e9d2447da6e9ea6ca2333afa1ef730999e7868813cea8899fe50e4de7d02aa3cfcf3758599be44ebddb69dd10d721b12a6035331795f3464e42e553315ae11fd83aca3677cfda232fd5653606937dda30caffa3b9c673ad33a97f6dceaa27dbdc5b172417da9305371e9cb8bc183d7c646606f113cef0c9e8e012aad9b6149c451f35efed488f285f0d6143b71e73a2380b277d205a87dff420b5f505cddde43c7040ea48b0797f89f2fb9de57f3458ba0f6d8154a907bec49246f3042d7e529f5ab113e43776a760c423231065df4e030c4eca60482079d838f0a1af8fd1c1eb3fb5236fb989b928436a26cd1f9552a75d9fa53b46166a6fea7b0dde00a15486103576ccf23e006f6d723b7d0639598dd93dace103e91bfb27754ba9b1179da1071767e91e5ddcbb80974559931dc453c6b32f53bace85d795a5927daaa36f53d9621068faab8f86e0c6740488a88e385100601e3370a5deb9fad0f231c78f7151f6f0360264709b12a49e16e30e1d08ada5cf54affb2accf963155ef8056851f872603bdb52a4861443594b8dac0ba3ce2b4e606944960bd72822c48fed90bea53618ea86fa4da0a8cd93fe1eb11d08f82e099bf7687a658fee448064c7c81dc8b02fab7e79a6fb8fd32d66a05fed58291507889b4c5013747b68c48c082cb3ffae0d816ee3fac5c236de6c25adc9333ca4d8e45ed7b50c95585985bc95873fc97f9b4aed1257cc44dd608a47692156c94d0d0a72698b8d630b709e3cba3bb7cf4513555dc4e346e1908a04fc8361ab89444a1e1292b30a1f33c0a191adf4e195ac1a6fdd000f7d28ea4c09e91a558b07f4a0e70efdaefa7a2097e968718412a5b959bca9465cb554db4b93cc929b046ee3e1bbc63e550fc4f4c61f3fdbdde83438eed228634cba73fb737a48f629299ed2b3d0484add1c01e643dde680a57f642d8fac18de2b5dd32720d789e5dc4634b4e6e7ca6768fce32b30b07cb73a5f03721ede54a0f90cb6a9bdfc7b6c040f64d07056bd2fd7cc91792a224ce4a81481bbaa2a63b20b5828765f82c719dcde387918483f716ae3a79865ee32d09a4b1f8ab186b7d73d6ebc3bc4405f775570c612e35adbbb9a665cbb42e742bf13c0f3082977f3b53444b5cfb560761fe0402cc2ce252a0c653eea16dbef8eb60244d44025ae6d6102c62a97a83ee45b60813685516f67606be0cf953fad62ceb61c0d6fbaad6f3161c5c4d25825355ea7d240c9f33a6c32ff7f68eb765a3d66bb9727fdee673883fc13966cfa3b3681905edd0a745dec17b9460caaa47e63e496151f802374cd44a8855b46d52b285ad220b2de16b24bd21410801564dd731cf0aa4c3273f75e8d31869a276d38c23ff231e26e8d237bb5167516e4e267ecff5dba7904595c6647b214a244b4f5cf393486dae61923d7f15d50be2e6a211ced0827ea0f7099a88876183074362aaa98143d8c87799844bbb852219a6f9170c0f8fe33912822526c8d48f8360d2aa4e27ac2fff7cd41b4a265e4bef62382a58441ef07c2a7a576b53567c85c64679fe2e20d753aa21295cf0b87184d3bd6e3a6dec2563888007bccadaf15850a2b0fc6e01f70c0d91977391043f561779008ac5cc46288831ec011fa6298ad807395d8b1a0a8b6b689e567b5ccfd360bf055560ec3dc7c1538ebdfe076bce9c97bca230021b2526461adf3511d73083a79366eab7160d418bfe6a26f59618d36341d0b1cbe9da64779ca646bd99a2f1732c98b447a03386ea62f94f15850c3d58b115e1a6cf835665df00d89b844cea8bdcbda0e6f4209a7e700dec8decbf0f0b925bcff9740d71fab68f454b1b4e068bb145b69807d393ec0e4d499881b447361dc49922b8d5263489cf1dd284115d647cb4f1e8b174c8375108ac6165c4d4c27b1982114e42eded6c271e05c392713e15f0d7b39ef5729d2b27f3e141d1871b6eea8a6cf10cec8a58ea3cea7b776bd328e4b6b90d06d1f7d93e7726a2326dc8576f76fa90a8a4092fbc1252d3f81966cb6bc0d79d3b2571f9c72f6c49bcafaf455d7ef418a9dc06388b2c04ded11d5f6f0347e003c96de254c875f3ee0bd75922b0eba6cff3021309a777a6f0ed994cc84ed7628b0127b2fbc65d428436c8167ee0d67b7d1e556601e9132e4e80e1ac494411d264a40f433fc8b4d679e62aace124f084fd40c5195203512741c0e1b26ba09abcd766a95d424935980be62237e13fd0a4d630bbd3b71e72b6fcf5be34268ab44b1ed386f779ce73e53c45b871649e05b9441c4f88336bbfa4179d8a824fc5ed9198e482ba22298bdc20accaaa24f1dcca1242a57dd7ba4fd8aef7ebb94bc080f77f74b21f3f43e432f26ff91e4812cd295bdc1fc0c1de3fa2a93b774ff5595bb512b87f6860fe3687af53a2bf94c425dbcf39d0eaee9478c835ec32999599352f06607f162877ee922c60a003728e752739b5f79c409a44b7c6efac8475c3c87d9e807d8c19ea4a83116733cd94dd4acd0c1a2f74b93ecfebfac9180b99593d24713fd867f410350b7a2f568dc33bf3ca401767468188747471e42c9b097f0b5b638d02b4fe688e2d63c7e73e42ed6f70cab39e8bcb581a945a1f740a31ec345a09d3959a1f1d0699d40ba41703b4f34c63d54279cd37664975bef9949c5982b51a894f2bfc2b94b576328392f26b5e3a8460f636bb8f5bf15a3204cbd250fa8f2605bbfd323e9a0208530d1f48c744653581ca66202c4e843449ab97418247f076dce57e109788922769a0b9e34e88f3c2b26e9a24861cdead8d444a768610708ce2ace7b2496333bd6c879bf1448546d61f67512766d1cd6724ed37f5de18863feba7184392231f65d2e8a577b9fe6b264f59d7c8900af9c8f4158b7b5921e9be8369175e50238bfbf3c3f3a41c9c28a425a3e0d804b972bfa61ffac9e92592de73fd6d9408d7d0af6cf1053d27c58794f8b3568b579de60d177b2ea2e459a993512cda81e6e2922111b1a893b67e6deb4fcfa20d30d8cfd5c69f30a520ec721851da82d616000f31c47966443516c07df0eabe4ce20969df431099e66e5f34ea9ea399c498b362f1bb79d2919acbe936d110f2301c8bc925bd28983b2edbcd57f7265682c3414ed03142751651b4a4e8a5893016a0e4220d5f7a1632f7c9debc06667392f16a721bc829d8b9b7818610707241ba02157524a551f3b50aa418dad085daf2ea2016d4edcb6aea68a0f3f476c59908bb1d718a16b5c3dcb0c5bdf1ed779598f7def60d96fe56d94d110ec6fafce4b2a910fe0a325cfecf4341be7aa739db2c48ae571224511b33b59bd8b822a977ef5939b70bfe5e03afadc5661c3e813197d8134f96b0e44420bf4c96e010b2f3fa7cf1c3bc837d351d4fe822854996cf3c3a85fc7e0e585a4f38193079d7c31e7acb1a9ad140be91db289ecd32980118979ce535b775f20a56da041d1aa885082e8ec6ae298221aab3a17238e6af7dfe89740ffd64196d6191595c8606ecae173c1aef521be598c0ef94a1d66f467b26edbab53c2304cc5dc81f792c24c104f93c143e5ddf0759ae8a8b32fff6fbdd10e0cb7d503005c7dc37e4620fa2b2926b0ae107b8a121d31da6d2c16b05399e06e1e0deda850f1b92fa92f49de429325b5c905be103d8644236c6a80c4837b7e2984615899db45dbc51456e8e9b8c095e25467c13527d7d2049df75583bd23127ddfe915775a1482343f9b90c2c6839fbd82152ea39424220836d7b2cffbc45a8cacb8fbb7aa3e0295a8156f781b369b3ddb13470bbafb136917d7bb6d4b1a20c3a7f6e0717d2d63d9f3ba6378527c575ef2343ef095f81825436a3b6d6275de5aad2d8419c6576037e8b6f45bb89883af21495de8cd35e0fbc9f9a33994fe3dae1eac240595a7671854c259363ea6bfe98b113d8e7910d1dade91287b382d47d51c72e8913d47d6cd2b9c6fd81b12165753f82b752dc2c23a1b29faf68a8f4cc44a2f1c73390774ba10c0df2588f57b672ffec539743aa0299de3e8a7805ef586b791a2c3724e4ad0d59326e9e1af33864aa12134d3330f77e4f067caeac282549742122d442182cf2613b96e9765647d441282a0b339566900c038d2f1b2965f3be4c51c5431ae873d96342b768d1d434a43c16dacf444194a905b1a2a86dad31055fdb13c7c5500c809e3a36f683e06c22363b70f84a019c7df42bb0bcedb59cd8b670004a0a3f4ad54eea176a29f88ccdce3da64d5b73acffd94bb9e1361011cd358cb40fc845fcf0e162c50f6214cea796450dc56bdcbb735c360d4f22ae4ca26cd09e0c3730eaa729e08f0ad893723a2e92deb34bbd0aab16df72e7d462b4bae525abc244dd2c81b57a21f145bea005c5079b96b55591be786842543eb1903d592c3131e5c4cccf3693106e5a7129e01600b77009267ea43e9a782099a130ef28ea29526f8412fe1ce29225ea5ad2dc10933ba63bbda18ebd1b18dbfdcfadf53569d9908820783489cc2a41e10bbe62baa61b3507bb0fd1d70f7476b53440a6f30ef140507758361fd197de6a983f456580af3cc654a5e0eea2768091186a82ee259c7e57798bddf0db92b535d755c06c816a734bd23a5fd8cec87581424474930f2613a82bb386b2f8e48b306951fba8471127c5ef7752789fd2203f92827dc726a779b119e137fdc31d8e9acddb8b2239b3e51927d675078db0ac88ead7a55a4eab900816bd9e8c27486c904281dcf2e96f37216492727e5419f1801faba3971b7db23e15952ca04b4d9b055a01e38920486939aa26d0b0e89322fd41d91c9dd9cd5fe4e03bd368fabf1a03fc3fb048b28f5572a9bdf558bc404fa9b02a0d866e1b234a131b2233f6836c482de67b6f724cdfe6482a11f48837b550bc470717068ba07bb6c7a97fcc2ad8735174ec7c6339216b3e15e83a3331c8d9f8d2e37ec221c181fc5d6a43a2d3320b4cdd6d75016544fd25cbf2ed2a312eefb8b8c547f23fa7e9b6d3495cd8a924ecaa0a16f1bab7714163c1d040fb80503a44d357cce231216949b71f526c2f8742b40d719b82dfc1a009cd36e4e2da4b8a05aa5acf2c3c395d2ab8ae939cf8caef95a5f7a1a9d5001aebc1a2e91f1eceae0df74784a0fa082a61bb97ac0100c906cca2722841ca0814e22aee5b96b238b9d0809f0f907c8ff23d273a2756989705a25b54b048f01a706f90b0ad7fc42ee46e53e29100cdea01d5a552e305b8a23f4545e24fde3deb4089d5036803d74399b1467847aa940488d72b68b44cb84299b2ba7b745edae2ac2a753f00d2a06db57947e854b1e4f698afff6957b8ed2c1d81b6652af5c3890dfd4a32a068122397b63b24b2434644e59b09087f645cc5faf6444affc73544a2627fa7b7277c8a2b20b7462903685e6ddd4b51f7ead5c93e1b3479e03156252fc059945a8f193f9733ab35abf0a2c708b3e11b53946f5a44c22e68a1378b37562c66bcfe878f69fb53d181f35d4848a03d18739e1647fb4eb8dc36d6978c93203a78035cbf9da6cfc75b1c8a325b680f59e61fd330e15586fa0664004cd7b27827a1e0b5a2922f6cb19687ac7826ac38ec4e988f81830e012e925651bf47665bc7c2b34ee25dd17318e1d14d206a00ec8a073e90b010537f15881b18bf76fe463d2dbcc86e2197518ae6627b84fcd84cff6329f44acbc121ed501849d4a7d348779fd9f7f7ad702d8b38809e366faa255929c3f5894af6e53ffee5bd227063cb2514f5cc5c50a2618364f8fde8c04fe2ad5e30900ee17714fb4b23890191b61bf18a219453d60b5915a6ebcf0c349e978b966742832ac5241fff2b2f7f156926ddc15b2ae1d8b95775722c51a117e950517ce8454dbdfde97053760b2fce0177ff7b90f02c7efbf143707e7dd16894d8cf7cad3f59f566f3c2243f59cefd70ee9e9516a79a8c80d82e2d61144db75be2fe7533011321858c2c53e63dde6c2165ca7a0ea2799aa8709d230636785a4a2ebeb4519f192b48605e194e03378ffd263ff217075ee3f5ba9e0a98defc8c85a3b1512112fb3ab026e03a9f02c239d25f13992acf98c52ba173928f298aa66b6f78b0bae373e6bb47ec34e7b0d2dfd6d07b24f3a463ad601557af3b2f24a99232efca3d5be391d3b2a6da93f67ef764a06bc94207d875caa6ec3597fe9f5c429c9f7a5d5e3c2a81aac0a9c3401afe649ef5f3a80ebef08e3646b78e5a13b7bb820699d6912959eb7958ae5269e74adf0445de621c0b09b9b019c4026437ff90cdf5868f836b83bd284873d8c65f7c5987cd39c6fb421609fafaec4d0ba83f743bbb71e11701e19b4d4ee335054f4e3dd62f34dc1abc674e097f6a05cef2645c199a4a5410df78c506e3920c6fa441d98fbb49bc12d949cb56345692fb71f25eaa01a0e81a91edfe41b9ccd6e223d18c02e92b18c3032144f384859fd01ab86606fc64c9847676c67a80bb981ccc6b631228c253a25fa58bc7765990e1ae1dae615037322c87bd07ab6b46bf34b5e9db692c340b6aa82d76bf6afcf31c6783ffd779b491d5e2f99af30dff0dec1cdd48c46e520c58f893af83ae66967cab3f8143093a240d788a0426b3e03a10eea2c562967d155eff3628ba3915fe0d8bec6d66c2f958cfb0e79407b8d89d440e4d02f85000529d1a1d2712d6d186325aa62227ca9b96fcc58880c2f53f582e292de7c8f3519966f76ef23481666acd79a74bbf902ec11885789cbd2693bd081eaf00181696326daafa353d6c6b7fc068b6a836d4a143989f1013e6a68133f7cb77da060c8681a39425c8cba982288b982f761f9e71a6e18ac811909302cba239bd9ca5970a85adcf12f66e3e8fb01e4d47844fa86e7957ccc1464b94d838fe6d0e3f23983443eede1af063d6d3df53d216336dd25761e1b46fc19067370a8aa558e3da6b013b0b59db63afd7e8f15ad8c74f06ef8d1bd2db5309945ceb20216aa66aee657ececaa8523b116f000231201732d58e252c2463f01ad2c03fce434481f5775a783826d78f99a60d59c5215329818d010e0eb67286d607e8dec92d0ede55d481d6ec52f8d5fa6fb2410a64e8765cab1f7aa387bbc5a0ae96af7eed1c6ba0c6f2dc03445450bd58183f72b4b06c81e61f0ff814bd4ad2b578c35e3dbca56a3629b5afd41ceb7cfb7c19988ffda66a5490f8d1cf9d35d7fa9fd42a22c2a70670911a924270f840eff2350d229080eedd5dc2b871017e32299c5ae886b1e2905b93c880b177f7a4b82d850c519bcc76910eb9f4707949d9a8abef41b04cf7b49344b803940c1f43edf8b57e0564b36ff8e04b43cce042b4cf15e0ccee0faa0d00f5cea4eaef11c6b8a4b177c1fa671f109fc8dea1d84b669986a22d8432b895c4f5bad221f8f1774dd2824787ce76ddfa5c35907c5c90dce99ed34a69fb288a50ba4550582347e17e6db550c448d0a2061298697638db196b0c81ec54e0965823079e98b28bc1288b7e59ff0e2d4fed06921b6a7fb6f51fa566fd140dca10df9b5a0d0b45d699376e35bbe048743247358f0f2732b80cce8f85e2ccac4016b0216caa79b161b246af9e99cc152a4897e387e7f12f371005bd257f2c5e5a0bc393562406f7af735e2d9ebc4b73462ea2f0f08cad547a14ba5750d55996c27a889650ba0cd7a0eb62e9fa3cd1fdb71d63b59c6ddfd1f5ab006e7650c6ba2180074f2f4fce234240b3232609889ed0d48a47124739d4bef9b7cd58909260073543233f2277a6f8fb7ff169942d4b9a65e806695dcd6b9c51d213e7429f0bf0e13c25ef91afafc089386afc28a91e2c21b62dfb5282ff9ddd8a6c57817d1cad80c7e887ec1ebf1d19d00b56802ea3cf09a8799d3aee04eb02dd3361c2d0690ab81dff3be2294073bb84a86ef473e79d88a7de5c488a1f627403d8cd9e2e98f5dbda32e66e1c8f7d08b0ae376af77ca750806b81643e410949a6991208830fbb3ce3470803ad6cba022685ef0efbe8bbf84f53bfd8df1c8509d771a43f7d9b360ce9dc508d102c8214cbc7337274877923dca89fc8bd470753ef4a26778d9b6280250e0bc36b544585c86d5192ea8103398cd52e54929edc19bf72a128abaf4e8a544661319678d1800737cb968aeae7765b7fe3511b48137a41673289930a00b010c909eebf8c6a25287822d35e9a4d7d8e9bb31373bc50566a28fa6f4e0d838e68a66cadb9d69ab98277b245ecd1a25ab08cd61c2a8807931229c4eddb58d2d81666a25ac95e4ee9c92dd1fb5d5f2db038041da1f07f7d5e524ce3716e58779fc0ae64a4ed601efad91ae5aa5b97dca2e229f6ed09ca90d012611c8720aa29002d98dd00a752e145770c6085d67c9fff193662ffabbb4ae14056e10bff443a135790d71b84decd4e41efd88da2ee63f934c5c83871aefb3af850264f9b101157538dc5d3d61aa6ba21538fe29090c67a0f575780ac82e6870d06418a2777f65eb01a454f4631052bfbf17095594d7d7fb616a86f74c501bfb4aa51a960c43f66d30224c407c8dad96a6efc1319857184dc601630cecdcda30e6911960147892cf57b934eb5e7a9a8fad9b6ec55e9bc7cc1f67cab3e2608d280f6939bc74e5db0d14c704c9cf306ec988c97bb1bbf4b6a0a5ed637de6f81d10e64e721cf14824e819a69eb46d3d9f015f006f5292729c3a0ac7319967afd7bb98a8a802e968fcb3821a38473f85efd4ceb200c51b000c50d11ef22f8b719bb81ebd49ab0929c7ff0c1797cf0355c391120498529cc5cd188aca0fc10e9d07a7817f6d990fb76c8b62842840a5ac0baf632fa9c87a3cf346a382fe3b43249c45a6b359e399e3cd3229f9b082fd07b1fece7d1f2f0f2bc7165a785a8645b6e54756dbd69ac3d68cbe2cb29e499f026bb34bd7f7a199e1c2372e4d8ed0ceda018263bab284f58cb51bc562f42296c4fe748281847dba4d0107fab4ca9e502200b3b319b393fd50cf3d99634b66327b4b156ecb0ca7e2f69d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
