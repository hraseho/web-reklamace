<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28d1a868f1463295a0e79d3e06313afc92ab5faa018dcd3b724b2d79cfff3779b0ef450c413d6a4b27d8e91d906dde99b9fd0ddf474e09745daa3fb0c4a48fed40c47336a9e33969e17d3589fb83ca5f2c692da5c16c974e181e6ee2d25be08f1c788c3da0e385b5519ee42964db58a6cb9ff94c7b938be6798e4d5cfcc26f474cabef357e2d343c391001f7069774c66804d5176f261f4222be6f42fb00e002253af25c5110ea4e1f5d70f327ea5fbad8839b2a6d63b0cfced1d4caf06cb878de6616cd78cff9baa25407c4e35042792d023ec3edd89c900a2d5aabc1966b08ee62657c2f81ae6edb3a4445e213fa53f75532700d6d5689e60ed051a385fc25b8b4227253396e8cc81ad97a0588ec9634e90e02ed68fccf22b76adf64a1442a36eff90d87097b5c3cd87203c818d4a62d87bdd70c16e0cd8fac258b33b46765be39aa09fc2b48c7570a479aa36fbfc3e66853bdeaf5538c1f254ba53fbb067ed4a8b783ba494113a042484ce811a481ad49f95cb364d1c11c2776eb5589bf99b6a448dcbfa1473f46d83922bc093106b81ee310f1970f70d801321aa78efbff1ae4b12b43ad7c893885383f90d03d8bd18c4a99dee6b6b357a6894b3e24a6e5352455115400af2bc5258dd03e9272395170316127dc03c5975ec5ad37eba511f31ce35ffb62ffbd75e333a1375373328b78beb151b1991b5b82f1f5792214303bbf49e7631dbbb8550702a009ab9c0d60c36b2be6cc49dc91175e623c7e67f32744709d18581f828ff837bdd7b57e22173c3decd33b5874377ed2fe42fcc026a1fd71ad014247b3f59dc0912b43f1d8ecb1c99430d1416f8b62d36c3a32b042c01c8768ca4a3553aa3852be991ae5c0c2f9f33ae44f114dbbd3a0cd1b262426d98547e0767b9e00e7350ebfa3094efef8d1f28082debae71a4038e769054196695826677df6ffc83a9c4b4e3d80b8625bebc8e090e32980becddd7f525e90c725a3de674b32856936f6f4dd2bf0de76a3470c0fae2cfb7ccb4f67cf558e6d6de8f7be71fb9be97279562b6f34bbc0263b60b18fb822bb8f6fa196dcabd580c32fd034d5468db90319e539e1cd1cdeac76d3dc03bfd73965794ee4d5eec42ccc8a4827d4b4204b6f8a0787d466a4cc20d311216c6a4c02b3a0c77d0898b53aae8ee95ba0557a20b6bfe4191ebd866355fc8321ccaa3bfe9f23937aa9522fbcb2aa0619cad4ee16a538d9a06acd621d2d42b5bb73aec7ce97f1f9aa9b000fc205c466b3da12045fda168ba13df5018133da3d4bc7bf56b25d615508593d7659ad959007275b64a80766232da37eeb85b710142cb9ea8a35f3dc39e9d8f498393d480ab1a6ad56e86602748d59b87de3f498475bee6d70e3559577472d0a92ae5448d5681ab795659d9ae823e37158bbad4db867721a04639429f0470910dac0f18a976631c8275c7d7071c10e9b92dad26fd3441b74311109574bf59860f087b1efc4d6605b92d1d7c4f0df6e4ec69ece6edd6ca84165d209b71608f67cb869a0c7e4200a53cdaf89d51ed81889bc835e17d50f843162603d614634ac16f2236346d6d40e03cf6bad1e72942c627fa7169b5157591f2c05c4ca3113a4d999833a6fb185a876c348b0a53699e848159253b4b3e5c62661a71f3841eff3a5fb15b3dedcc343e718aeea69335f600e4a74d2a5f086fa94d21333505d69b268ea8b2ab797b7330e5f47650f242e50f89095cba55f574ce5e28f34a1ef9084ff772e0ab583a8189259dc18be4728e7244e4199f8cb9f31d600817c8d79e764fc8fa7a227227c96cfefd8aa81b8e4ae5850e212f8314ff291c401d99c1bb294df5f81ac746ceacac6eea29f4710335885ef0cd88741fca36fa2f9665545d0b083c3206c586754c280f5dad018c008439f120750d0d421cb6d6bff71301244729f6e32be1e2983172e0c9900510bced102c9ce8bd8de9f720f7ca079fbf81cf2fec53a3e89c71b42c221909544703312ddfdca522b750e338d5abd4025d2fe0297cdfb158ca3c5fedb2f2518573f82f1d4f919d953b13f6460de4882f2f64d4ef636ec03e86a0bbbb936433a051ee0ef363983e6b5beda1a87f92d315761500bcf3db160df50d9a5467e7ac56276c3a9ca8c576b3b3ae88e5d4d1e857a924b0320afab18c06a344d9508c8d346a1070dd04011355bf373e5ef3acf030c631a84a0360b133696e808f96b795563eafa0fc16ba7fbf794946bc6c94a7b786e12f9e76130603ad8c09d846b5ec1171aa56edd1d799e247d73a9045c71a3c02e9e4cfd9706818b5e31123f72bd3557a6683c6c31b1e915511541a5b2b9f18f1b433107b11f9bef05e303aa62998fcd198ce40aabc72e124f5a639770bca639ff766899c06eb84f0c273fd90e3da27bf80ee152122c2cd0109abab69f86a65edc1e9881faca8c6d92f89094ab59d4ad351b34eef8f1f8e6827a7c86605595836dabf1d36368a0b7ff465f224cf0bbb429ff595d7873b56af9e3f642f3d33cea1ef152324f4b1c9921e5c8ffc960cf403d573ed848f6da7d262b198244d9db12a01a3ae4ecb4e0b6c735403a153b50cb09c8abc0b47f523b979c5621fdf03ff44b8d6ab5cd818634c3341d0471b854e354c22f94fb8ad36c92c4a6c23b007803474f03576967c4984aa3a26f9d1a7152f58323e158d7ac079aab9defb2821dfb528cb2ffad605eaf49ea58c08b0da3b200c9fc126927e57a90669f09a17a24cf4d2f539a3844e7441a00785b1a4d75eb46bb6f49c302b6da9e98293f59c2638bc399fa120bb5af33500eb29f3500603a672ada636d03594bdd76f7acb1c4e15c04b637c2599df45a05d85146f60c90ec949203a5390de1565fe508a2a09cd3a8a7b7c7508c2a59cef0ef76899c9e351da1bced3d4164bcbaabb917fff0b899c912ab61835f2de206379b6ea003e38652ed1e71100558b77dc5dfc7c46013f3c91f4bc2b0bd7bf78135aa84b1d363b0fbaa5be794700e0016037f63d1979219b9220bd1d6f28ba4524e12f92d128b0fc39b0c0be8b946e247958efdfb746f38bd84147534d5908d482a1ebcd288b219309db052c713e228591b0cd889517b0885547304c70fa857d33ebf967a5d01f8b8697c8c16deda02d4340bb24e6434aafc31edac187c461bbfd3c1591baa3d6852c88b99c69077cd6b0b2f6896609c4fc1acf77631c536b3200de2398ae8628b655529c155003871da98ed30865d98f137d8717aa5c9a52688c1dd18b7e888f448f21a2dea97750de124da8e0ce56b167935797db29a94cfbe1f8e55f260dae4ab332cb2502ef5948ba59ad1fed7257cfbe94eb9f7eb8f8de37f5e18c368c407104eb3b2cfad5d73d74cf8af179f46cef08748e3bd0994226e7db3645d2f45d66635e875e1d6d92aa523de94032c17defebf07995f7a1c8a37a21902866646f10b88fcca55dfc0175081e0a47a19f14dda5142e7e46da404421b34afadd01f4e0f0e360e3ba8888ceb45599d934c3df3fd526827cbdaea27fb800cd8baf43488ba45713ffacc595c20f9df20879d4c801092d012a33ba135f0329017d8255ea605e91890b308a559a5328067cde50d58d87f0e5af29cc5a197a9ee5a7bb9a84796b92df86e27ccb9f3659cc080e6924322f8c6ab4904e4ad50163601bbb3cec9da501fd326beed80abf287888841a9b7c4e479fda341aef694218b77f5a7bf0104f744de07d1068a44c2e64ecc9783f4267cfb282af24e1393e00f569eb44764e574b32e948ce4d252ade074f552bbac65f51afd6240cb7028c41f88487c719764b59760dcc9a26819760e581ad3e99589a75731f57fd8405dce0a3f7f50380c093ff90df98823fee343647aea57cbabfa222cc9f24ff088a27a9cbb68c51fe5c6f0a0ffde05ae16b236a5d74328545009bc74fbb29b80dcd05925c2da98146a77176608cf20ff4bdf41ae33afbc82fd33fb93c00d3ceaa96799dfee5388bb47a0d51cca9a18ed9485cb7dfa5bcb4c7fdb53087337df93d2945592841bcdea20b6bc352a7b3cf7e3edb3cb71275a4f43f901ab6de59cbfb21c3dfc00b994e993c458a7454e967cec5d702fdd554ab0c7622d4e9aee92c545d34bcdd5d25faf6e5bfe6bb2caf90ff3359354f429f1168914f4478dcf239facd4886103382844ed4309fdd1202487a97cdce566506eced2d65c2484cbe30ea3ed5b8a1d877f79f23e54e7818f94d965d751debc783afb23a7ee301b9930f23d20386b0fa160dc95330bf7a6eb57c4d7acc94e0041f11f18050dce922e65b0830847a07bd1f2d6b61782d543fc356ffa5decb3fd6a7963568a7dee45ea2bf40c6e9f532fa73cf983edecfe58cb93cdb901f14d7f93a69f0ae0a0ea6655b63ab82f7043bb16745d451a9445c1c0b765c000ac878c4f78cbd789a98dde4125c3ff060564f2140723e0c4a2f7d9d6e505149dbc031af5e37076380fe86a843e1505a986e8508d729539f2977aef07837ef2137cf6f782e6452970c7cda49a0d69c7ab36825c32b2ab53e954d071fbbef2cebdcbd1a918f12d9e45bee76946d7cd2b12f6c66375903a4506cfd0aa44d0fafb83a7febc5775954da1518063d42b585702d63c00ddf0d75a6f03fb2b3d281eb1b1fa9e56b1e672d527d626aa6c1e1ca8beea2129351c83c99bf58f2ff6499f828a69e4190f7ee93e323181fa5388b6b3d6869b757b98c4b3c6e6761367c301675cb1fb6d334231e4b1df528bd4e634a8a2f5ebebeb765511435d64e37aa73c6ec8e5f5a03b46a78906b2bc007e65a28842796183e295ac54c7d2b2eeb2906fc0232070cd1dd57868bfa5da9f1acc6eb326dee115fe2a47bc3c87b4a0b222c8fd55d8e8ffc9617cee6571168edc5529fac1287bf818bb9e045ddb6e19ddebe8bdc4eeb94c1d6edef2f41b86dced909a57476cdee53edede4d932a339aa59345b91e4e596aeca12b310052abb5db42627e4cc7131e39921376e956fc747ccf295f54da75c6cf29b0f83f1b055444f8957dbd8efd5507f7f662c77faae5cbecf3693c74fe16209bc80f1d22c92a105e36fd02f095042f9357fa9c48c372fbd9b5b492cdce66435155d4a9f5980f824961caccf9fa36bc67d31274cabd58e091553c7360837aae6be426f57da62b7db0618b9d04e3f83a5cf142f36bf08d8cf56583fe26542f5717af1156cf0b93f14391e6408e8bd0147bc7759fc78020d782ec37c64656a2c8994d57f2427a5954a351cf0e40635d3d2639d8ecd70705b824369a0aefa3d85d1e7fea4c06577fbe17cffec86bc6aceac29f409f5b4696fb7ce92fc4098ed22600fc7bb9820f1b1a79827f6c06be49ab51b05dc696234dfddbd34748a8915a3d3e9b28993dcec517c9368dc251cc60f1d7702522dc434bcc1855c7837ab0d8db333c2847c7166499127252ddc59c3d70e8d24aa2d2910c2797f998b8e60c76239c7f82d3ae7874dcdc75d79a8ec7f8f65c82d3b6d28f03579cdc44401943ba0ab360b0f6bd3897b3d31cda88ec5337e19d573df6a3abf29a11803065c830b7622c5c7debc2a26ee5cc3181243be80e0aab7b1e7841d530eae5d5009ed6d4512a109cb709445f283f2c23f2b80fa64a587082a124019bc403004e5e10f50089ce9ad854ee0efca9ea50396024050b244438d89e51c299b37d009479fe7ff18777f9399ae4f42ca4c311910c1c52157342e82ad8fa53bb58d7c5129286023cabdf3cb66f60af2d3b45475abb2c29afc4953b44f76477e446cc08fa5788cc63e91d88f594a193e80cd5959d48abb651bf04fc5a0500bd515451a6b011cf9ab7728f4148d35fd1b1082d3b838c0e71bbd34405ef111f2fe21e29d6238c2902f88a4f8eb2ee56f63b02a8ff5877d854d9edb48af0ce4c76e2213dab3e266209d1ba5a8279de1a926652fb48feec26c7bad84d29469205deb35e439fbe91c39cace9fe21fa905f79d79ebe0ac0d62ffc528c2b0866e9f597bcea304766ebc87e2478539a89b4e49322b8a161ffb8075d3eb83cd6e3ba7457ed034af48d0410fd30087c213b4d0400eacb68a47c301329968d60c2fd7768b5717cb617d6edb884c8ea1f12e5b32bf8129c3b81d4af52b401ecb664e15cd0bb485b4bb1cd771d98341d7f8db4f3c856aa6dba311988822e5c1e3d1644504e354db2ffe9dab9d60a523930d08c68f7fb810be6ed628ac6a19913cae642e9fc53218494e597df8073dd387f65b40c42e7ec2a6434ce58e5e2d35fb54202385b68ecfbdaec7eeff79281d07ccccb3231cfc5713a9ba8207fc02d25cd3322c9dcc58a4f25ff3b42e5c1d90d842d4d5fc3c80c50594dc9ec2ae710a1222a95b6b3fdd8bf30f5597bebf7dbd682717f7e7abca6ac32a0f1dfb4fc9b1a5da6dd2dbfdc1bbead4ae283c148471eb594c5d4b3e6ed69fa97c2845849d58084264610aa6e3ffda0779e8c73229c30cd2a00ceae62efbb0dce20be5a70d52319860f89c7e9c200ddc9d9b89f2ffb8f021501de15f189ccace0822f70604e2337533d796907bca6c2929c719b7acf8307a80b8a741fc7e934693299145fce6dc03f4ffa24a622ab277e6456c66540b7d2e5add38571acf962bdaf55463b1d04f153a9a2c0ab941c42f1eea8bd7214dd8c7339edde0026369167c2a55c90d349f7eea3fbc53f48f64e931d06e39c08a9dccebab69b6e7d7986f7ad7895a8f404b207ad739cf46c663376b57cfa15f73771f1b402ae4683cf4090408a6272f14e1933e98b1e143ebeed2579417612f676e15b08ced4fc7dfcdbbc1a7932ee7c1e9c03c477705bfd4218335edd1967884d1c6ecae549e17cb435a8f93060955c840ac5e56501e78a3f7588a77528fd535f6cd8180ce8c87fa30d319ef791e43f29f99f7b0d9a7e6b67eff1101522594b9f7e4a38c3c412d9c5c0544d8c1f9f8f490b2b5720ba1798746e08660850315b85de9ebcb6de4ff61ac536243bc8d3e40d959d0ad39e13d179ebf48e923f87d06af686a5be3bb5895bc5d927957c067288fb9e9235845dedbb858c5cc68f470d94c94ef3564f3285f0d268df4dc7d30c71c8bbd22a62a5a69b36b968aafd47ab7cdf344ba8dc725eade5f91f4f3c99ed0a975b4b4ff7afbaeb920bc15363901e828f73e5c93447ba85b284a67f868176e1e3e87f2a181ef82d29825b9b6656cfaea7666660bab4f4c4fcbf17bbcf57ee7cda8f6f04959121b85edfddb17043a1a9d7f60d6610b806255c235dfb2bf35206e3456a543ae1a3a37bd040f45eed41920195efe64bb52448f324c4a0d90840533a598c2c06e0f08a004fcabb76dcad13eefbc6027aa02439ee842a3a14a840ea59555017bd791ad03a0dd4ad46534c38689b99b521c3319f3adb6b832fa5273918de0750f95f1de7a1970d276ea5e697fbac9985e01e8f709ea0fca22d3176377b068e86c253d9aac7febc8812fda67ec8a1595f41198eab4a625f43da8bed666029ee96bcd1d55dddf501bae91179893f3f21f6997dff62000b553171ba31fddb1f4b31f9677e63ab619bafdf7457141042925520a0f64f31ac46ae0c7bf456b6231bb6fee87f43ded75e17ef1b1e32c4145294dc83ae6aa71d433388d51e95d0fa379189228950a0e25b65c3b995f433e34a34e936ac365ca8bfb078b28e5f89526624662b8cdeab3e1724f844883b9d56051f4fbb1e3136d4c9468435605e5f504fb1179b8f3c3da1adcd87b0d39311b8fb632b8bd606943daf7850e5e53b356fed0d51b6b15058c08569640e14fd0e8f7f4137908d06e5b1ad92ee5724a3e1ea1b8c6f2a59a4f8806a0e438909aecc04841dbe754da61df0c678412221a7501094ae3ddfcd64c9ad901d225db1d0b4544a72beab4f69d7330881a81219913f493c220a49d16ea80bdf52fa12a6497b5c240dd6a1638d70ca7237ce5b4cbf2bc9b95a04d44456a88bbe847e0bbf8639b56917104533fd63816a9dd91179491c835805662bd62cf3893a3524ce4c20114e77c867629a4a7998be6b23e550d05e9d71e82862b2dbe1da6a6f874120f8c15719cbbb5ad4eb6855de9aa7c36233d99c15ec9a5008bcec330e0bb645169cb6e90d0247513f77ea33938736ba7da59c94fa4368ae0793326e4da38297fc2c94c5b9501de4de0b85f45af9022c098cdf56430290e2a371317eabe1e4a37c8c41824f0fc857b5b6e49be7071f670cdb15768568d5b95fa7b514ccd9e2cf236db3162534293cbe6c1bc4d38cba9961c198c8daae25a975dbde581bc8d48092729a76cdd7f2ed73187441ae57905832a1c7f5e930ba554e4dc47ae83e0ce0e09829f97534796ad5aeb8d5d5b6ce28cfcd24544556937f1abe62a225d76c10f00fa0df7eb6b56374268c39cd175f96599e0fad25a34ae4fdc07d7c302b4b4ccaf2cdd4af3b878acb3e777771c07318f75642d1b083fd56d2a3edbc611b78bfc3d48cc7d7137351e1ac55a1329aa48ef8a9d57c83d40049ecfad532cda7efe7f9517a7f350da383e1f1677f1483804c235dd14872a1b4c0918655b2e69d9eec3ed68cb21d99664c6a1b5c3fa7c3a6b27087cd9f69a6e7f242fba104654a5a5a545f5cf49aafae56ab1f4a448b7f5a8b3e6c61ea1868d95ae13df643dff25db8fff89d4630493ecdd377f96f2837f5b13ccadca2d0d0a74f49039e117640c89197eb6f48d2d209a3e518232042a292ea132f868a0a204b48a0101c237e08b4885f6e3b9fa805cc653b49e4fcb69fe927f140347f5383daece17f8805adaefd9f04554d9793120741c36e4813707c0ba09f06604e564717fbbdad57595519bd613bd8453ffa392329bf5fa260751b5ff70e0c00f49e6cdd5712d528fd2749305fb2cf339e3abf60ca19ae72e459e0ff960c1574ed209d2a850d35c2bd2495d4340758bae52b9d61afd6c351f1238f17a9872fa5222988691f97007bd34dbcbc8303b89809ad93161dc79f6ebd34683a24be005ecd6269eaac7ba8a73fc95dd558343b3e8791fee66e95e73b22a583afa4c09873e41e015d089bdff63c0644daaa2426cb7234683ffda1a2410453075887478dec2b4e7d0618d5860cf480bec36e597b98a739b52fd33a6992206dd967367c4d8b70e74764364d306edb2be22bde154a3daf21e5dc38e6702ee0b1436f60d1cc0db2250d306713b61a38b87342d168fb36f1e66c64b5f667143e61e0f98b7fb5a1d881decc21b3c6feb274e549854cda905e2d5627756e00fecd6a1f001c8cbec894782c49648e1eab3585458f7b6b3508ada252fa35e5efcf82f1709992ff5d8f50f2415b58a650a4e2e7492f2a27dffbd8d24b266bfbf269c2b69719952a09f366c755416a8b5978b16392640ab0a42213ddf1a1b8d2005c93ef1e6d74c8556df8986b7d633cdf35b1863e3b58476db2d8826e4e7148d845808febd286d3d991dc1bf820d17c7b0d89d3c561b623f02d1cc46ec1bf2da8d48d8c93bc6a673f062af6920379ef1bebca48822c242305d2fab2f5739255b7ae679bb3345b53c65876aa25fb3f208f1f3fd68c4fca6cbeb2f443944a8a6f64e3bdd2ea97c085387ef058634fee0650a61291ff5642537e2f5ce8b902e90b5a2621baf4c7c07b0ad0faf0fab53c7cc6bb628df9e501344a8b6b6c1ff0eae9334e9b0a45ee2cff64e145099f4b8d72ab37ac6aefbb72c967bc5e34682cbe0bf483e4483448bf7a277e3f54922348f8b6236fefdea948092c420cdefb5c5699f1ecfffae5a906b35dc18505a488016cd374e7877093e2d79cbc64dec9927f6c1cb143c9f11e635306b0c1f2a5b33ff35800a957c5de47edf5844e0fc5ed5fc0cfbab1df8ba9a6cfeddc1fa6f53c9e5310d59f2e1556ae17866e8d509ac4506d259f02e2518c6eefb5cf5aa766cffbb0d50a675ac5cba86efa2c5bb2f618b04e5cfe3379ed3c4a993b0b84eb256a029175c620d14ac376bd1a1c79b8132b9f755d6439301ada9836e40d09b3e0df3199dacdcef4adae154aa0dc76ae74f901a4fa8da4c0e3cf08f4d0e0e037624a631ebccdcb49340a91352e6adbee29f78d4e64d740dbb4220ac6cc62bc21ff4a357428a0ddad0547dd30a49a2476a70aee9aa9d05fb0b58521e22382d929ee4b78c0c8dbabf689980795535875293d801626df50e06d3600af0af4ab633af13cd8d3bbaa7d3513c4ab5133864a09d1764b85aaa057d447ca66d4b1003d34e9ad8df04ba7f98919e164f2044483d869ba01c78cc67943111fb2de81572d353db2ec971670481ee780997ea85289928dde81b87285b06524f17078a527e3e3836ec04563a4b834d35ae57c8fe3138c15647580a42b91a46ba74b607e118464b8f4585527cebc6905dccad2a1f0e7caaf177f3f0226790a370b1732c9deaf0fdbf33d6fe739445812ca1addc4fb9476971959bc8093eb50c0e584bac93ddffe41fc253a1b0193d39a19fd647fdad0954d1a5fa6b6d2d5cdb5c7c595f07eea941c1048e6eb57da62ce3cb13f8b3e5ff5406490876892a376669f382fae12ac9c5e7d3ad0dea9853f95c42b9898ac6baf21422272671ef2d8790434d2a71bd8cfed110f38cb82bf24f57f93b08d8d52047af6e83541fa83ec61958cb906e19966b37b59a007ae29affb10edaaa6214a57280c3ee06bd5f10b12c639b2fcff4e529b9954e8d1202a5738f30cafd6bac4253dcc72522e514aa306782f2ee90f10231be275fa75b6078983b298613411e7f3fe6e4c1ebbf80331e5f1af89886ab7f3d8ea221d8b00e030f0c009d3382513fc1d1255f2bc3984a8b3c090aa86fce7efa87385f83bf7a9406189c80393b031708f3db578bdc50e489b2749bd7a3a03f8b709cdd12c3887a76575d0381a08f1b810bba2e41527d7391d62b95176711ce9833b7953b8c4845298d10f730f03ebe2a058dd4dcc971053f2c54abd6ad8eb5b0a005dd6d34905adf63fd364b520abcd7d16a9688dcd4f4036ca9691f84f089fdab286b33b522e2f4de468f5af655df521eb3de8a7e28e1a4dd6d6a2f193199bc81282400202b903271bf785ee474c56ee7ee96e290a3639f95a0339b9fb5c78ca6c22976c7f157dfdde754ff4e6d4d7e19fca8a66a654f8067d7b149f2a3a5e7b01e440a75f05eb8fa0ad4c6128de3290ff47959178a46238065a89ce85339aca66a8c69adfe6fef6c324ceef462de8988c9d1ce31a69044a038b6c59e656a1c7209f92f3d02af87488fc95c5c5653387c1cd7035c29981c7128efacd2ac9cec8a8afd446ba4d7048f6c02b69b1c828f64f0664087d134a9b941cb9040821b6dd6dccd38f320ef9e2189cad6872c0010616d5f9328727d59d67bf2797de98a2637ae90a4825561e1f40246ee1c277fdad74f7fc69db871b9a61893248764b1ba47b5d128720dd039d8c105d71b7d24940cfa3788daccf6e89","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
