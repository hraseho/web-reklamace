<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88279ad633d72b8f0104be8e36e3e8534da659448b7a7f02c29e0a554aabf1f70c370e53ee9104daebeac69b8d8284afffa9e46cc0fa1873d418105571a83b0ba96afce347173077430700df94f69269720eff32e89e140329fc2f74db90a28cf9a9a5b19b6c299bb36f11bf14a491a5662a8318e51a48b4da1ad6933b0cfb96c2685741a5616352242a0f62c12c2f87983f00daeeda3fd9b2301b79fe8d88c08434b2d72626df8553d78768cb8b5fe714f301b408ed6c9ecffbd79ea72a6ce758996d3f49ba5e24020101fe3162377b2e07ebe7d13160b920dbb3f026ce4103f3434e08a382ca789decdb86127d8bc9fe07f46e319ebc6c2c8ab39dafd3457dc730edb187eb37989e6a03450090278e2c0b1888a7ef38863a3413ed458ccd90260b98f14682dc84c43c4dedc691291b220b24ce9ece3f1393730ea8d1c4db1418aa668c097a46152a10bdd616676ee4e959fa21a5fdd0263e405f7087ea66921c72b1a1b1a01a7233dbd5e277b6fe76c4b8dedd2d569faed0bccb4dab9ee4877d25b06111f4946243bf565516aeb6f3db42db8e35d07b4a87440255a3ae4e07ae6dac43eefc67012cf10393968c4102c56d54ab4e657d4a34a3965ce0d1f6cc7ea09186e27d2dbdc4c8423099834886b0852cc5b32a7599afea14dcd7830e7ede73877713caf4bae25e941835f8913f9cab506b756f69f9cbe0e575a203334258b52a4bbb6977ecd88843e45ef4cafd3b6c2bee52f17aaf8c417643ef694245a6a718ed1480e496a5f4aea57804152150990dad6d13b6e0bc34d51297ba8d47095558016b21d280c46049f9588c5d8ae0dec016855290f0cfbbf1cd11ffc64432f1161a565c414ea14fd2c5286100090ca64fce31ac083f99b3b1467a4b7e36e104800ae99f2bc15b70993b3a573d047f2c4129cde2497011cf6708d00a410775e941b3d89a064d30cd6f4eded1fc83080ed5fa3f0068c40117a386254dd78ae0349ce9ec48851e27fad46bf7db7fe65a786ac1f4383b99bc1e582f8f3ad4c5e30e8b0e34149159a304ffc7df0d0651b3d2ebe3cf7a11b7adbd867c581235712108b439582217d130d89e84c852b2f49d0783ad85c0ac9f0272d2c4e6e962322d988cce8e768ec5cf5dd5d5f9e9af4555a286a0567920e4e1fdb04c33c98c5f06e1abb21c915c8bfb0e58e436abd91d1aba4a910b4d676ac03dbbd830aa0383e456e3994ba82326d195a4cea079e5b1d3caca6f383c11295011115f36a7ddb37140c5375b7ba081b9eb6d1636ab15bff456d8dbf5071a186ee002628a5ac2867d6397aca8d047519a7805388aecebebccea579d75eb501e303ecdca9dda2b8778faaca67a8a3bf71de45301d00415e2a44101c368ff716fb8886812e9d3a0d914857413c059e565e4a44c58ac4d2641bf1d9993be07addd247a27e49ce05fb30ab2cfa80cc7e5e8c666b421369b0650ae0596d6a8bab9f15566c2d83a8d019c6f623a36c33112e9fbc8fd089f99eda9b7f2192e61a57c1fe8b4444cc91cf718c86177c72e94363823796c05c4a2dd326dc26e35e1c3d9de7851939a647bc7c8510c9e00997d7f305565836a01339df1edb41a9d2fa9d04e40b2dbc2007277ca6954cf06530a207e439c0328c5c7784acb1535a1ed53978cd2c30e83747d04e671777d22a37f7ffc3a6894193da506d0b6707e9020d833503d187044604deb3325b42b0a4223b54ab5e676fd24df84974031548ac821223ee937dd545b67822010b12465de5a928d451cdf0f79b2c63867acd330126d779b518e77888589d262375daba603ea475d3ed3acc339b7db09d1320789108af26bea542e1f704a9a9530a46c0a42d28a4b1601b19f9bc8a57ee2f3fde0cc3197c71329d32c72f4c4ecd144c3b5149de16e7086a6a4297370831ea713d8d8078ac78cbc47d477fc1f18e5d5e1ac97a2864b66bc4224b20d00f6b1786f96e14de743c7348cd59203ad8e2c60d9cabf5f2f1693b4b42c3c560e5aefb964c58307848d9803dac21b3f7473299c94df497965007689574d030a684a850b5dceaf79a99c63308d6c97e41edd1a029ac371148b6fb0186a33ae6fb307c037c2fd9fd2ba91553535135fca10d792e604389d275a77fe65edd0f02c9c71425e9f384a8cc319f565d61503abcb1125c20fab643b50a8a728c1dfe17d5f4561b4a986a2bda6143c15c528c81a1cc6ccc40ad628776b27ef87ad5c0b25023e574d1988cbbe3961b11accc7768350f8767c334e1afcdcc21a6fc2ad954836b83464bfe8f3565ef665ff6eb8a240931370bea10074cb33bbcf80774bf13a37cf8e2f718c99031ba61f312d999c0715c151078157a460ba07e39c8c9cc0276d046eed638d886dc1919ff5938bc69cde57343d43d9e121f1d6e47aeb41c994a5da697293bd9ba49e072957ff9ca69e71b611950e08d2357943be929da4d6a042b511710bbf052b70bf302d2d9f257321f196b1f692cfd65f70113439f06401762254a6d3eafb2c8415a41a1160d9a9ede7a095695b5c9af370ac7a46091f5e5a7383702dfcb4437d33abc87f649dc9cab79ca9273d2a0376a12bc1b7f39d2171d8b69198b4acab5ac52501b5e178176bdf7b5a0bcbaf53b5414938016a89bfd6c6630ebb84fcda844b5d7f46a372599da24fbf0ae42f5a017e928fa4a4b1953fc7053143e1827b2468c198bc458eee1f2599ce1277fea1e846de49f3677b2e2c0b31d7f30fdf380136674c2c7df7cfa6e72a4359f1d7bf7930e3356b82b4593d223a2fb2630680717c46f9cf70b3cec9cd049e7e0dea011c49d23701cdc43cc9aeb3f56e152c595c623fce1b64f3b86d5c63302d17d190e4cf8421ab3f851decd779f26f47bcef25ac466ae23b0128a00791931c270f4a7b3cc8558d094740ecbd219465eafedca2394feddf875a361078d462b4877226daf092b92636ab1dd93e2ff5eb3494464388d74af3bbc13313709b46df76085a221ad9d1ac367d3b90e7b34dfb1cfb9aa56fb171ca80425c44bde91dd1b720c325fc26eef884c444edca0d85ae63675b2875a918e074a177bd37e70cb34ca711c49f3df30d64a525cca7167522f95753b11bf366cff8ae9efb78a6371827ffded90c70aceef2ed4c0a42099329428d9256c425d7ebdeecae20dae3c99d37611dc5417e968b7b43ed615b96375f6ca0c46aa687c0eef9ffd128c2f25a597f537959374f58f49aaca41690117c562817c34d39da1d5a990b798b45fbf2ce10bdfdea632f92c1fb068c279d141eda22f32b2a28b5965b07233a458d8a92392a199b3306a1d45ada5eb9786d6bd9dad3828b55fde4bae0ca378e0308ec01c8e7e4a5436aa71b1bf4da73641203c3ccff734de6af40b355c45f5dde564e79561ba687b380dacc91007d3053f63ba60d5490b4afccc1a4de0c509eaf3faa513b0ee8d8567e728745b524961e3fc394dcd830fcebae278ccf428f80399b5fc7bed18c9f5577420adcc426a142c54addcc51714a815ba21ccb2049e3a492165d336649d8b2d96f823959e33349a57d3eca4d82504788bbf5ca230fa0e376566df87bf1f3ef9843a9c750c1d428663a1c34e283f2b8e56e9e3630d19dc7a3728f5dca2f7410e0ee69343ae4d03e292b18c7e8b7bb72f0950a2c3b32ea73fa3841e85c5be106bfe6acfca6a9cbb8097237aa7419febfda5c6d14e669edb53da8860b1d3e122d84900d1287e18984067d416ba189df8fe1e02aa5cc0e49dabc824955cd26f544558f6b27b2f40470fa12a81b65aefcb9dadc865311b498966a8aa51b4635769a5a5b231f2ed36e4b0335f5cc606cb9c76a1bd678b79a7dac17cf4a9e5ac1389ec7f3780c2a1b7ab6d68e0a9b9fd348e769ec753cf812459fe0337990b88e7eeee6e47ee09be2485de7afa0d37c6fbb95d63f2536619a9b9bef45edb944a93a441c0c1e79c04791f5e4cc482e31c2186e683a18b367afb2419505341e5a04a27dfa1249ca3ea71166c59e9d48fe09c103c55ffeeff8e43b92e70efad9507206287b20dd6b9097131179b103ca20fa8db6764c7cc06c2f67c134e4be2962b60642c70bc76543a78b063018679e12ab96e628d5d8939cd251ed23cbfe1f0e73dcd2e7ac9f3ad046e0ac90fe4a8f5e81dee4225207ad66a397a0caba3e65cba807fd433abf05520497b7b582abf3012970912e69c1f216a4929049a1bb33a3682fde78b0d0b2fa3cc51606424f016bf8d223b14be5fa903bd6292ff9f202c962be858abc7b2a504e302a2dd9aff24db2c22d71da2cb6aa9f17599fe05ceff1272f3aeb32f7ad7c77843c5310457776420dfa02631cbac8c4687185dc83feda8640cc87fdf6987a7c65dbd3dd7edfef5843c52de2c3a5fe157329d50475021c625b5f407ada0aaffb130c00ebb68f8a3558171b7ea8111d84e993cc8498a758209a5f5954ad0ce2efd81ca7b4563e79aae713b9880bb09158387f89235f89155b5900760377e9242b6f9452f4f8d230786466b87d3ed0175422c7822a43263c4aabf527c6c8be5c17eea38b7eb2b8f7f34d55835c18abdd27fffdd06c6232ea3af839ddb93ae5a3e6594cea0d8dd6fbb7a33f9b0b27502d399b465370e370b4ba145f8a9debe97845caabb71a7fdba03bfbaa04e4d91601d4a75cec8e5e427952e752334404987823fd43b27e5f9a321015b5a496c3dc63fb54c087f8d6d1c5d1c3719994d60ed8b2352aabecee3d20966673829ce32be99454bbdb24885adb5c62933ecbdeb66848eca63b932a75a35299118f8f6c217ef2ca920e14eed5ddc2ef80ff017ef14517441be54d646667af8aef1ebf2e2adb0b020d35b77de3a854775d042fba2833acf56f2aad0196b1f0e2f0164b367b1dd2e2ce7ca025721c39539bf6d4359de546b0494bcd6f61cf5eaeb6548801ddd82de3ff56a1e6f0509bb7cd2aa844009517395ade5948046027812d683ed5e6002001456d88bfb00d9108cd51ca681c3f780e0d6050c8452e1997aed42c8909494794a4f6973f5853b724acb3b76199e1e9d3330ed0b31f8d173e37ae746dbcfb622ff3480d734efe345569acfcd255b495f43162a1af7cbd134462e6a6f4d94eed7852a1dbdbaf4ba487014418e54f4a2247996f9923a1efc02ab261b2e183bf8fa2a4c63ab4eb22b1e1706c7d936109054a6d62fb88a1ebdc2249294b030abd08baa09cbdbb6d0fe9acd4beaa1a862cac217c7adf62e188b08fe16d1d5ac13474ffcb7d95828d37cdec47273a00235d190febdd085942114a126aae77e9c1cc7a73190d13382c58a02251c313ce57dd3238bb358de03b433f37583f2d7eb6bdee34dccb55846f6bbeb9aafa76ac6deef1631a69cb0b98dd80f702b4194c97587ae0a088e120e0ea00dd43b40d18e3ca7b9dd4c1b9af7e491f19b8fd3aa3a7365eb5fca0f76da4620d0bda2cb84658f3889b8a37685b64169d2e7cf40fff15212ebcc8f99886f81c7c45e93e0b82a4460d79d5cea0ea156c5f8f1565caaddf71c131e86ff0529337760768ea34afa66db09f693ae5760a2689518d5e022ef1024d2c629e597a6f08e6117e0d82fd625332729541202c61add2fc3783409773cd3479573da838fb856588cad2d44677ae26ff8df4cc97e572f16247a7c8dfcfe1d8cb2d9b201369331da359b00c607d7d9c87f101770021f6eea726885da72f47509d3c30b991fd052c1416d8db01e0f4802bb328513741de11765013e288a1c219a6936bb76c35002d3ffd313cfc5a0f7790d5f05e64dc7feba5261f327265e0f709b1750943137e2a4bbda580200eb627287a7a3207da0bed9aed1165dc0d31f8fbf294bc19438b85e95175ae793121edb6889543fc1cd5dc1e007a283c936c99c39c145d4df881f419eb638a5a6289ef0ef281e54cbc548fc4c4c52206fdb80adb0217a3e0d176410b054c597601a448af834424456db4c27e7793e1705af1785f4676ec4e31196e843f22b181d7a02f4fbb8f8fea37453af802e1869088eda567507c3277ccaa68372adc175403ac0b8db479b7d607e454498adcec00b9c525afe14e2fd4460d3a6c8b03d74a94d432675a4f24642c34e2bd9d1e5c54b6f264d69141e0655c85e7e8733b3e72e359ce92a207021137eec4fb845027756e7166e42a9462c293f79e8190546725ff141e39a2a7c4e3a9cd10a2982ddec4980658eaa7af9eddbcf36e538642c36f3d07d3223f560c3a76084117c821ca52dfccdf05a5d98db71a035d1abdc419b5f5ebb6cc189256379d9d4ac948a1dbd43bc95ca4012c8b7a4c6578c75d7d6a5b312cd69f94863de0fe700b3ff12f2b8d281793b098e8d4bbb590e3360c8e245c69f9e96f7420cac3c567425a045592373a1078f3a7eef88db5274a66245f135e071a578b8e497089bdf46bc86e1a6fe7ef9213e92fccbbe5c460cd4510cb2b18fad380a140cf4fdf9cbab5931d108595bfd7184074d7df53c7fb3800c45b355f01c05ba3afdc01cdb81df32f3f8264835c3ab06b8895269dabc1f7333dc4e46c9ea4dc09d872c379c8cda9e8e3a937db96841d010ca9d39ca67d1e1e97dd821fb4f020d70950220274b3d0c5dff68ee451e05e09aca79e58da9aa1adbcd49146f442ee3c1763050ecf5e3ea0c7e2ed030122199a060ad4370f7d48fae7863910651fa51e0d80f9ed0038fc248220a3169ca98397fb37a9e37ec82029bdbb19a60d8e7a4d8bf5dcd477f1beac0b47a24202e9ffb28c7d2d9694a3375d26b774d41cfa5ac6c89d3a51ea54badd02a64e8ad375bc5fae89075460d967bfb1b15ecd9f2fc3c2cc1843d6e3faf5b1fb1d140cae450516e345f031a21956e87c9948ef7b7026d8b2d592462067ce61d9c08fca898f3257d99fbc8cb8f3ead86b94d2a45f8f75eaff3a3a0b4fd2efdda8a36a83c99cd405515988f1ad860452f8ceec08657b5bdc68fb3340353cbf51b657f09b87ef0d2bbee611160d81248bd9f75b40be8daae96bbf2128105f2e78dc2def05bd96335194bedb702a75d12b16eef853a050ec033670715e3d16227781e5d396a4466c0d1d81fe5b373999e65196505d4f0661f1d43b295f4d838ccc15da474c1bd08aeadb9e86b60f6985fc8d0053bedffd4ca7d47d4404095b16b454f42492933f8fee87b7abbbdf2699077e84edc71c673cc57f045ad250f2d2806d8344dc43ca7582312b0670640cac418f7b8831b0375d3999718284362faa3b8c1ac84a1a1e3638dbda359e8c8d159b2b969bb8c0bd752d21644a035fd8feef0c7997288266b2396bec7407292e879516bca8d318fa50824baa12b95ab858af4ab3cf20a3ec2781a03bbfe59908775d367831812f8801693d9d2014072767caf53bad2f4307d55f44606970ee3fd1ad4767cc7439ac3bbb23db092db8290149e3ecae46ee0a33d7b72e23d2b6e36785b30f396eadc2fb46add3b9d9b6919c68a8e50d5f4907d4c8dd133e3c8e7892b015c84b885c3888d34a9e6651cc7edf13190df4a54cb0e8fcec4e182b7ccc76668637e0edab668a06f7b1cde6b7b3f9f965f9474873d212a59e2958b149d5300aaaee5c5c954c3f0844a1d474451c7d517488b463300f3b3a18ce42007395d8a37341c37d5063ab5f60451b0e8366dd445a338b38f4c98b2c0a13319d5ff684669db69d9089dffafdd8e9ba3feb7f27483ac06afa9e951cc86c4f9c2b8c86b14b8ed05148c7a45aa9124fe31aeaeaec5aa5c1831f8aa07a5403692f3f8c5015059372b9371fa22ce763296084e361771cb65fc5c2c62dbbe55aabbdc30b1d54a21fa1dd0ecb67731bfa6f93a17c000fa059652c46d03c005eb3d69de8a25884ba4d85a45b2ea567fa8fcf8003a04512acf1cee6d7e56e6673890dc21a8ff304191a8f0ee5566fac083f533e6c6787e946c06c7ffb33a6d514728c5bc19a9575c9ad27723cf957258fbcef2e3f45241f3d1a174fc0eb6f5efe271dcc1d2df33d587ef7103e5bfeabab058ecfb7304be28b1ea1d7f9cc96549a2cdbbbefd41c0ff5a63c92e5775b0ab2ab3ed13ce7de1f9875ce9dcc9f0b85854d44900cd878cf5fa5b46375c606bc9be81914c111641c8b1d84d6a2fb060531992783138342ad9ee96cdced208bc7f3a907dce425828fb1f67d652eb6f8db58d7c2a8194fdae452f8ffa3716a0f8b71efb0ac6626057da6396eadb00b92c0e9b770b81ed25f43311b331d3381d65b8aaae2398ef8ae2c7e8250821892725c2c292fabac8a5eb603ea293d17a7de623189c321e437f2972c576a893e930ea10cba3b1ec916153bd8e89a3cc64ce77627daf59a73b0045190b35c28b5ce358869de7d70286dd3b50d3e55def4fe010c67675e27af56f376b9c42c6a7c163b557ec96cf189920565886f2ae3e8f6ac6e15a6b2035e78961c631a40eca85ad36fcfaaff2da6dbe5b79efee3645cee5c8b00f93c05a7f85f25ac02cd2960d4842cc80174abe229b9a33d239908a10f1565491a996dff289e2e02293a5064fd327108b1c4298506d995a98ea61268db6aeac631f381e7c11b4de8a813dc4ebc069ceaaa962c99058ad03ecfbad7ed2d19fa5082948ecfdbc4d636fc218ddb48973691ff2c5a0720c6682f0835f0351f42d3e5db1f253913da3e25f3481c0732500babddde729c0f016feed49bdd6e8fab6d5891676396e1ff8b1e8e112654ec9736b07b51163fe580be28db80e317c9d84bbdb4bb3e1e94f8adcf927580151d168c68250c3416caa42094f18f4e9347dc9c06bc3abbafc4cf2e9d5626b4e7404e23f24a61403ff167b5987ccdf00f4534d29e43cc0b437e533fea2db7197256dcf9d628311e7d20716f62462c360306788d605892e2491473f2e7373fd61d46c80a057313a3364531d47a1b870734061deaff16f52957eed6f91f496ff366439e5d9a04562614487abdc6256021258d1db943ee2676575755074c0ca08838675b02b92ca406b861b2d5593356fe50ee801d48a8ee97c5df120a57498030c1a930819f93f97b33ccb9deb8294dc93c0c3f029275942de46946563d775af0ca4202d3d5ccb121c3646bb6f6765ede447adf845a32c155338ea63afba14f11d9e52cab0adf30e1638bcbadbb357cd309cd59c87d293fbf828e04ffa40fc7735a67486beaded1ebf156054d8f72132dff804bdbe35ee9a7821f1f69b0bd6b8262e8d453e10ec7d640c14f5e48f855786dc7981f4baf365a693dc7c095b759d98c9166ea33a0824a1ae3c33dd9e99cfcb7a1458ecb70dee1a0df738e2861270d95f6255bc0659b979ca6597d5bcd01f71608e26911d9541de9e3d3a9e5af3678e5f454040c260618e3472192e5deda51cf9a372f4eb3bf63a8ef808016133009cda95cff1f1cf71f02a6a0a6234349c678916821a3769659f01aefe7f00dcb8910b757b71b5c3709afec863c4cb49649a9589116ed5049d892db3a78bcafe5face00714feec7f983a598bde2d7d99fde775d63090cef59fb151be2a83055ba69be65a5c37285a208cc01387e2a1673dd99adbb63499247ed9cde938acf3b98b7ce68e6697c3447c568d0dfc1360f8d07159c7bc66a479da4b9b784fa485b8b0ca47317e4e3e14582d84bd68136e3a4944e946749ca562588b0fbe79b074865df34d1db07290c2b2aff25b77d3e62d6a2c58992f4c8f1f7ca2d577fd6a5a309074bdb5872b82f9d4195233a0f6a1f5e99f24fbe877ec0d9d64b746960623f9c51fb3b371c428b07732652b7bb0be230a5d47229a629de9e107dae5a9aa3824eb0b47c317f7f75a7ad5b2b9811723d768824845f12cc9f1783e1385eb5f1777757fbd1ee820d16404cd64ce850debf5353a5a6c2e2b7807bb94ac642d269fb9a66b6a0f3b70b36b361c951474c3e19c78d680697bb4849d98d511cf9cf493d66f2da0304681cacc9d230554a159fc10ba03f5175af1c8693afa070f5f2b59cad825ac255f7f89149c08f0059ba2bec87892ad941ca5e5955d2c11f220298170e3988314a66860c691aa7c633282c3ee20eff734821b4ff839431717a4a5341dd4b085445885da7dc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
