<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e981ffb43604faab0a322d5b1a904fbffd36c9c049d20dcf0ac7eed9792780cb6451df14c69025f1595d1cd591dd96245f37964098b5cb1a74deb91365c45f0f6f142583ea6f286cdacce5f3f24ce9a314c0d9248a1a80523380bbbaf25570eb91c891466ef343304586340539f29264020167c40e811153a355559ebfcf5d7c6679833471c933c24be6890739bd3bad191b382935718dfedf71e092eb4f72d0528dfd2382c31713656c99fbfa43cc25c70a4d6fed22d6d8eae8ff44efb6422940c0e8d0dd50ca5cb04b3e1f64dfb6c5934e8afa68f778063a0df3522c338e3994bab77c0c90742cbdc61dd09a0fef299f80f2eafb1f9ef522d210721094322b4b9b73a12dc5d406873e64932aabb2344aa3695149d0577f970aa0a4c0a5844060ce6b9e92cf70532954644598e6d44694275273ebe8dc2bbd0e9de76d65cfc8ca36ac5fd593753c0b22ad9ac1327df378dc2790c0a4a2571d58bfe8f46be25954e595a0e4f2e2db76615ad27a163b38c309a2417ed31dbc91c18a7937833975ca3e3fcbcca76ae60752a61821b2ed2f59208cc4ffcdc977e3ac3265853fa4596bae9ace11fb7da8e0b3d47aff7f8ad8b662ec691dd26499cefaffe62778db48a899bbb2f1b41afab66b6478d9b8ddb479ff444c201947981fa44e9b9d35ce773965631ed3c57e171cbc08082566773167db78be305b10a9e10cc955e197c69bf8b42a964d0488fccc4c06a59b1b966611b334801463605e96a3e999525a59105a52190157e685fd1f18fa99fa29bbbd078404401168847a64d4af6a12bd87f49b53ae09fbe7910dc755497dc017407801d24ffd006ce480188465a66d06befdf9db9ae5252a0b88b8fd7222d9b25abcd58c5ded0df36b8c3ace3cb5743b93c0196673010204edb180914f4ea68baa4a719da4c7807d216eb7df024d459e06d6c1b86ae1af5295d8310842592cd70f28d4adca2492c386e4a5b5288b9d370ea61bddbfff59a34a6cfa18064e65f6af465117d41d66d6f4c2490898193543558fc18e35c321cea9f71dd0a2b0fa99ed1ca77aad40a4b116f9d39ffb18e915f0eb2325941f1d262b06834691963bb36fe59cc97fbc3dde3154c53ac68db59af727cc1dff53b67d31e98bec90d51ac7cb550afb081d3fa94f365f4060ef1d7180ee092b3be0177b36626a0aafa84275736efccc81d67f7f934b5465529695f34474b101d4031d262d7f7aca52639567d802bef3431c4666a13f134de2cdfbf7c6e4c2c0bca045174e710e7145441565c1533b8db26e525a39f9cf638453c334117232a5723ed3baa473ff2a6f0fdbc2514692dea3f45ea262c3291989d39d0e9fd9972b1a4e2a65fa1bb89a1c61337622cc68fa932ff790ce364a7bc991921dcb9eadf055d9ef0807ff99aa4901f5118a30213129f4ea508fbf8d626c625cb5503e4df863a89f9eaac2f809751dcbda5934402c831a6227d095ee0eb2921f93d38a12e4980989c4f6a5d5d8eb96d2d5156af9a4182709c934d829bd3c72a1c224a51ec4f819f47d2f0c50e0e8a768bcf611fdb3dd12ab9906842e4d3cec4385566dcb14ede197ea389a06640fdd7c5650367b0eb3b33ad3ace81c150a41710ca30e9de00c066a43ecf80a33b90319334e3370c3f9786a6cf22e17d247714906d7a311e44f2596e7ce2a3e2daa76716ae938a9c71cf1b1f9961a5e281530dfc53603ed831ea17cc39d6d85a4b7b0ec5f1098489d1514947cfc0e33c6ab55c95f2b057df6d3ce7f2e2997c4c7a07fb2ffae33781c5b6de7b39e5baf4e70c244eccd7811d2eff2c5b723d24ec110f8695469dc83d9eda93caa9c11d5719035ae21ae76cd82ea795d1f201ffe0c26c4bc0bc712a467bee4334d7fea7e23bb263a207b16dc1e2717cf51ea7a8dabdf87cf32d6078c184450f0d387c69bd4d7ab363f7d618d794cd03edec8c356ebe64736721462e3e4725fba78fbefec245715f649af49b9e2162ce26347b3f7c2e803db9ee81bb42aa95788e94be457dac9aaa3d74f0cbf53d4b0056f88016e8f32de115a9e44c4769748171512c605a97785bdd5a8c7ed1e5c31423e228a0842ef447f278dd8dd54b00d56c2b2e4b17a6661355f1fc96dc50bebd0a0e683b1e5c392d2e9af85336e4981c5b1fd660f84c12ab62fd30abeb6a5a7127b5111277f8e9bdc5bc6ccdb1a44519aa446790777e3b22df860cb5f69db2633a5ae35412dad1e9be51e9a943333995aebb3d4f1b190c356a9192b3a3e62ad04e1763cabf4266bd0639a83f22cd2d462250f732c4e27cc27fa5267934c1fd220d8eccdb5aa34d4611b9fb378c391abae316afff86c8fc79ef4b4dafda43eb9ba85607e8f9111539d8cbe51d264ab5347a9b70bc919f0fd1efd61ee084582d987ff7296cd69d14bddefab9a32fafd5863ae0aa630e3d3dfd4a3dbc2b61dc013ee7856d6a7cca8d45fa13a2f22078a6b303ee55fe1793dee255022e99b99cf95b5c6c195c6b3439bb74ed9fa0c17b3f021e69de4ad75e682a04136427ebead6d0abb658904749e46f640ec4ebed09c6122db8940ca04837690c4458223dba51c6d57a77a1e4be00e8019fa63717032694fe699380872d9fb881e810732d04a2bfd7998e29fd64eb741d7fdb1867a7b9277c8f4e0ccf69610e2a1bdb026182d606f29a91ebc32efa461ae701dc9c4b9f499bfad01b49563b711f403bd73ef98ca613c1afb8cc2f376b1e11cc6235b58e38c43540f7711079c91bf72096df7291537504264ecda69618c27d2579c8c5f045a57c0556f0dbeafb70a8b244940d3a20418a206f3fba977623970a76a09632bc4467699b9aa2892111057db4bf11d1c5956ea750e1ec1f9b5ef6db17e6691489754cab474c59a1ad3cd89ba95100539452a6e7a47314187d6f1f84410eb6b08d6970bf7fd1d87597cfb5f6875aac5a615e590a771a515cc29f95d3116759c68d8f696a2de724d9ba193772fb12b400440a494a38b4b914d1d2ce99a80400fdd306ded6200b19f5fa769f7ff44870aadf9ffe34b6c4a47fb257b769a30a1a17640477a64250b9becd60844c4be2a6dde40f2a511e6e64e6ba73d1f8a73ce95ad78626b655b9843a5481c4ad9a05f8b316197d3deb366edac7ecacf6a6afefb3e9af3e17ae801a92cf1bf1eb67d8450bf118739e6cf179819072e98791220f43cee0be63c4cfe933b597e73e7c61b5e0fdbf92cd8eee1c2cdaf6fe018bb99af0e27d54068cd4327b787cd03a45db4b8dbb7eca7c96c5b54a9235d08132e5a9c8e4bf0248ec189174d54b3aacd5c361036fae705781884feae67096e44b8802e2b624657a5bc3a53c4e5c0aa773acbe9198831bedbba746d13223323ba3a3d0ee0a1179759f7511b07cbc52aa19991fe16be93040b7ae527e225d6f817bc425a7f96ebf1cb1845243522d8467756227b8889d56e482a5fa249143386f517066e279b32a0ba81ce445196065d854be6d05e4a43a6bf52aa694162a79f9be6c9b1de9b4ed59430e1f7469abfb3e3aacdfe24e4d6489abf7b5e05979f156f69cd002ccd1557b5a9902d2989d8d6112e5b0f21a900e4a9c0585c7085ba2d3bd0bf852cc2bc744fa3e90002dea57ec73578085398e83f50bef502752b070b1135884660aeb8684c42fe8396dcfaa3d674826519d7dd211aa2242f88040ffefeaa1620877943bdf9c1bf2c23eedb17f047308176997f61e6bda6bfa802f3d745b6b11ab1e25b5876fcb38516ebdb7d10897e6370c724f5ee590c8f0deed4b4cd55a257b2e38618af6499bac847e0724ecf6e56015cd416ebdbe1c74142990c6fd7e3f72df97386ba284399e543e4003305040e48b573719f480d117eb9e8e7c711625e2ce5a22d3d82ec529c0823ac8edd4d1cd4fb81761e97ab484866e0ba1037cec00035e262108fe2da698b768fc8543827bf2ec243f9275ca422dc7237ef92aaaff7e113ea408d5b76dfd0e7fd0d91dc6f0e56c594b2a485469eedefe74e64d8acb45cda3ba8289eb8f469cfa307f05d3b300bb26a7b7452239fb2eb6d573f745a36d8253503d470c37938c290f41fa628986eb7491ca6c7405c6fff33fa242d1fac50584f82a1aef57f849df1ef5e8db623f9b27f42d95527504a1e1d4e983876105441f127aa8366ce75a0568cdc04fbead58d31b13f9d5d30aa3ad759f663092aff0fe1b97610eed2589e609a4f0cbdf988208223b85d3b3424c30cd347426c5699154ffe054ea7e606aaa92beca8cb7e7fc2f6b2e13f1dd79c5a6797bc0e6a65db6ad4542278050c6dff68c7b7bfa48cb008dc316c9aadb1adb53cb8f88e48dcd194db44780e04e9f18da93c381738f71f7b062b84a1ea93cdf5676110ea8e7e5d9bf854976658ceec25d868c62b2c032ac9a09ab7fcc51cbf28c45e9e195be29820b9f31d6eb163bf19c793ea5080726d8d7eeefda5b738a2fd607b5703b9c88f995ccbe300ff1762335c49edd2a77845ff96aa03a63cc5ee7bda21b7d1f2e1300c8dc044d272f8366a2e21f0a52f63b75d8f0f16cf3a5bbd6192f0bfe389a1192340adc7271bacbf128c1e5a9d2d30577812450255906527eafb8fbbaf6f14183c361c861179511dd09687769a9676a25de1e4e12693533084d75320c0ca50d505b6c387af75511c958c1f18bfbd29c52c55182c5f45c803bd4ed4a38475d33766861f21f44747c15431543f71d0e0b7096e4c471177ffff8b4d8ef4587f65c4ff11b73620f5a2a9dc1838e9e862f08e090e69835833afcd6106ed9bf7719002ecf496b179a5b127a0d62d400ac071c126d40ef4a2a5bc458f219847e6987aaf92e1d645edbd0319791a3a2aa97ada15fd88d4ae18ab61909d123bafc48df5a6649bf7597f18ddd45fb8c92ea7e992b6d5d919949665c8508fb17bc6ae86a91408e47c96a50e65ba01acc4108d0ed76518f15ec71541f5e15ced5b82edfab1171780c2170e60b2f7a1880cebb3f32215d0f6e05ef89adbbc803b9fa5406dcd9843689bcbbe1cc1c4604e9664e18ddeb0302ff0330dc48b8f5bcd48c42ae95285869559bebe9e02c7d0833bdc304578ab3225e748ee48d8307684757483a4e89a940ddb8e67ae2f2f49a8c7a7d65e63b4002973808cc2443ba11f44e4e754475186a4aa6fc9321bc95978ca094b2dfaa28978cd26d645e168807262b2d506da96e450bf0ebc2c13e1c72090fedd8fa328378074bfd84fd539d52b5adc386969eb848a9429b37ec3233210935b1a43121d71b926ad1c30f8b7a3a5c463900b48da8f6e5d04da92547db782ffc11d09f9a882526590b632f1d4c8b29a5efe79488552d898d66bcdf1294724185a0206d856f3ff688f7e68d9a46bddfc183fbf8f16fbb3379c319f2e8b3a67b67591b2e1f99cdf6313e4bec1de8477aae65054f0342d18fa5272bde1cec1ffb6b1bd3eb23de7a32ab747eeb2e38b1a1dd664aec9034220a5a9e9b347184d4034d62d3ec11d91e28869b78b5fce62d2606e443bfb390c844e7de0cc45c802adc3b187f088b705e3ae377e4aa624c1dee4b98f5cfa757c2af9a30b52e753af8b78c49f68784e4c43f39bcfb7a319eb7e2a06d715b50b13dd4461aca4d353f36a3d6048c7157aea22f0a4c7226dc2d192b4348cfa482e60575d1a4f4667e4c07165360d62e118883e59d0a350a7818637d0915640b227e57ee9d6fdddfd8c515ef62c1e767d5c0d5f203c9e3d1e962511c366690331652a6241e1640ab135e951b4273ee4dfbfc37f1c0e6de11fba49ee87fbdfdb954014db5e2de573e57770ebc291e858190d06e9389921dd22888cb0a59bfd5814e535812557785fb32d33cd3e9f8d41cb6589040e945d20a1e91e0fa31c9d7b0eae66217d90c12ee3b16e457bf1bc3be97ec1267269978bb80d0b9e643f236b51cb968e0d7dca6a27028e7e22dfafd5159018537bbad9860c2c2a31b03fae2660b331a5e08d3123a5d2b250abf718735ee89d5403bd3c9536012e1a6eeed2759d5310b223e0adbc1057a4d6edee3f87d0998fc4e5e3a57234fa0e9bf88e99ea34a97d6663ce0402b81b01be643bdcaa7115351673fab28ee78f18c0e301800eda79c4e329bb1d0279453990244130d82f33d57dcc9ada353c40ece35ee995e4aa62da989e32db6e077224300c6a9cbda6902ae09b9bde414f5075cd8aed31486f14e111a229a2a8b00b8d9470af38044a35ec90bcf342facc17d2a33587d818872f01697182eda4e0b0e2fdabdc07756c919f18f8d41022b3bd0caef3be37af4db1f64a5dd98499dae9aa1c9059a42c3ab360c5f425e671274706afe4cc15b6b7f99499af4ea40de979c517cd4b0cfdd9976b9a2f1dc8b42f09143265666999028a4cd27e10bdc39439c25024ae92f5f0160f07c9a5391d9b6d433e9d0632058dab6bd4f3ced3c906d18e415a5174d4c278c336ab19928cd2b9db8a10b1f888e770e9f9f95807528537e89e4af414e2ffde6813b89bb74bee67efaf31741b14946a70404b6e5cdcaa7243f2964c5d00da9ebb48a7bca264cb3337a7cb3b34a95f8ab90ec84b664f63912bcdc12138d44dfaf23d0712c0e08e22966840d262713c37be0f170e8228abe55c28f0759a22baab744053df5b83cd9a8c4f84c7b3bc23a7fd4133b46ef343b16dc93a2624cf36afce07b933d537464dc349deef202209b68f467db04e00d1ec04c18ac60e603fc1dce7dd8d5733a15d4fa2a7a08609ee5a68c54a41a93fc064918704922e0222558fe3ada29d2da63293b07c057799b309820088ebfc86c4d457b276fd09e3724f0b8a51b76542d554b61bbffb3bc14caee339a80d34d29edeb2e5178adc6d0e58dbb2049e12cc91c5c13c56a17e9a34c85917a80f41b0c9ef423b3748017889e1dc6c9e4d4f3f10e0c22e8c329659df9c956e0cc984667918fa8cb6837aa1d6f7ef8b883c664a8598725ace6d7576a9df28408d54c5942efd358fe71ed2b86ddccddd08d4cafa579130c54a17a3485c803052a138e9b79f1086ecd5e12568df1eb20047f25f2bb2835260345ae63195997e6443d0bc9fd98058a74d85da6f25f0dcceddc66dab637925a5979018a4e83a80dab96ed6683b9423cc3b6a2cd429412be0677a1700b6ab5e4983c7599f1b0ad2f03d639a81044958b70075407495200457be2fc94ada0ef18e7b482e3c4a58389382c066b0466ac679c46054d250c2df0b80efe5ae053daa281c3b8f7c8d919022382d5ca2ace3487a8b5a0fe098e331a4a973b46ca56b59a64778e1400319f64e6001e1fe42cbf7de04f5e75bee25aef48a63f4872e97921c860421bfa9cf1faddbdde0a1efffb2dd3075830b9819cdbaa52b6b81759d14aae632fee6e422b177eb3d5040dd2fe99ad082814a4480790648f85fa1ce6c2901d2a158987d3a5eb39055e5df2bf19efe6512e3ad18678c5fdce5d1e68c470c432b61d28313e659c686cf49ec0766fe0d0cc346aa61b2d243078b28e192b4fd998edd75b74525d984b74e1f7ec8170eaf5fa7a8a8c3dc8b38524d4705a1bd3e22481144e22c3d810c70bea8370f9bc2f0717e880e7c50725f350c08dcf352a6245459263a638a6b8139112338e3515823e75dcf0a4d92fdfc950c17b2bb812939095e021a8cc30622ea2e67d16d43be7747e1dac34626ed40364c634702fb1fcf49acb9c6c3636cf28276ad7813b90ba0cbf31ae3e0ae214b12fac984131e47e2e8fe9ae8a13ea1a7ea8aa08c594019c3e2648d6893532db83fcd7e1249fac3b04c6349053ce9a38935ba35545a992306bcd7c2846d924351d2b1df814777f6a1aaae5e41c2b204cbd8dfe685fe585eb25cf5ab91da30adcc715ca892587267ddb2b1ba7c41b70a25fb7538dd514c0da7a122e1bbd071328524b23f1ee5ae4007c498b50df820e61b91ca1dec5878b754c04e344dccc0433c7dcbaff2acd273491e87bba388ae71f05fbb08281a1dbb76d2076e32fe92a5e9aec08c2fa276f90661d47e7f6f2996484a5d5a3c75f665c829b1463704eb3ef9edbff0587f3afbcb44736a28cae2ee394533ba27377f8b2947ae99991879fc468cb4f51bf5b1c048296b7ef6c784eb206990caca86d55320e6f90f5a6946c519981cebe62209e63e815524e7c5d208357e660f79dd079bc63217e126c0b90db20a77c3fa836f7fd1d0feb7848aa951fcfec35adc0c30726f076ab43f1020e0a9e8d4cfada4225dd33f3824e598bd4ab423dbfae85f04286f1d77698872aa0e22836ede620b6fce40610cedbe0c41e945449df364ad5bf936d4f41782d204371407a2453680beac9660e670f1cc861a56544bbba84b34111922c99161826094a7148935df576d832d2071cfcf323ff1f0f6027c5e29e841525ed38d8f38b7e7286c96903a092c2267d28d1ca4523ca72fd164f1ea61a8d9155ec31648e79068369867dec6bc695f0e1b18e0a2e054332739ac201bc1415528e0f5539c23784ef8844c1892f84381dc53b227f6ee7a36e7bb4ff41297ca652519d47797d5d6153d9bd5613fd334c4ef3041c367b41805ed4b30fd3523d84d02bc46cadb5f5104a763f96a83bcba678294241d9e8d34370dc76f23dd722cfee3b1e8806510419fba4d982fe80a562eeeb421ad1268f2ce529d53e1ef2b74f5503e6f98e22f8114d35fe1ff9ee216387e8b75507fd0273f62f6429fde679c53fd6b267b1740596dfc8d81342f5de99b5a3d852cce1239090ae58d8a9fabeba4644026c4c2faba03bcf35bedf551ecdebc66d2e1827774ae23975ce95c953191b7772cf45b216e10f29047808c19c7cbb6f49be5a005b9ba2fb9f27ccfa5e031bd94e6b19de56c666d2cf220f86f81b9688cf54d3657753e303b534ebcf027664f5a3f30c896e63b7161d1b56a3191cfd4dab6eb4f5684f335a3ea9fbdabcfff95276f2e55fa3d51ce169f7b50092c4edaf801829bbb70bd6d7afc1c6839199402f5aa1cdefe96a47f13ec41da0b3df1f65c00ade07e8f4e8676902dd16d67d9f47259d53583a1df1c18ce0eef765d28615d652323b98f0e39a606e089d0896e5d4c01e9ed9d2cc34c813f5dea1c931dbe4c8ec6af57615a7a137072b9cb9256b27c5de15a34963ccd86b200fdb22236f15a38bade3467c62b8aa3fc50d9d252e380674b6fd9da53d9201369fccc0b49c7547d7b7550ef23c6c4b0a084529209997055826ce1e38f8db746669051d2ff0a2bc9b94b1129214a098aac8d4f03a4efb097944b40cac0ebbb8e00e6fdbfef4db521d729e4026aec500a6d39ed4f9c189e2f90bb52218070f92967fe8aa279b42defa5dd5c27750030b530ceab7d45e2758b173fde2cdf4b0281b5a14761ae8e2007371cfbe4cb837d87939e4e481a9778d3f1958264a391f9c50c3fb65616091b2ae12d0f3b149a195835f16cc05c5420cbf5c5a23a4516ccff8c8730dcec55eb63ae115ad2e42c0cf847ab52c0021cf571a1adab2b7cdc6752ffb471196a7ef0d309a6a86299d9a4301f625f9fb90aecde1957788ce230da8507ac02702bb0405a2d0f759327b4f977037a94c67f5ad8058a56df3e863047b6a80eeaa555c8d9abbcef6618f39601a72b7f495125449918ebdbb29ace11be00042203d9e92fa5ae613e47a41a250e484aee87f4aafc8f4f21c59cd0edbd4d6e972b979d58cf9305ea0aa28526089d0fe4f3eeb62c93b28931da0f693e38eeb9fae50e2425d92aba67415e81881e65299daed97154a9312c96dc7142aec7d3f45f53816750ad704a4ed963e20f188b3516a2bc4490b9f6737365120e675bbdfb9be6bb889801a5d6b06d3a3bf1d65df46b383a4a604ee813efa2079e07ad1b1fa92e0f4aa0e3119feb196651e45a52c56aae86f88921d30159c218e5e1a5cd84e64d31b45d8f877e86b6d1af2d0abdd8f0aa77ea9e4670032176dba4bc5b9bd64aefddd8610900978b9d7fddf0a906a03fe33382d82a97b57ba778967000f9cbceba82701d3c168b4a1e8b1282741a8d739ff25d7640d8c1b99ad6297379ff7dcd5db0646befb54661e2b72bc1a5167b664a4a6103cf514d36beebad822d390315e484320e803e3391a52de1cafcab1719dbe122632ab1efc1b1f645076c20fbd180a0af8e9e47fecfc4ff8611a983fc817d72c4a679e4809562148c6a921cbe67a051e8825e176531cce94ed1b86766b0ae04e28ceb15b7e20e1fd6950004649649c21979e55637d79ab63b029d9e18ac0c26ef02117b7e8e16a5642c7838130d1218da9afe312f512d2329b89c52a18007b7887d97f95aff9d675ce6268e3bd78746e6847ce08f86e21f72ed0b0d97412406e652890339f8d81bb94cbde4eb962da94ca152980bb044da70380460646f2dc57995e4bfba606c99d9c7de631b000f8df30c40b2a5da150e57e46559138f9d3b92d46bbc88dcb09b71ed8161af2d3725c5e2b5cb75b25af5c73775b443d178d557779a84e9a2f7ddcfa72bdd194144625dd212be7d1d1f68da079081b8ff3ff57071ebae05f0880d7ea9e98aa51567355dbc170509e3d09d6630f3b6f6b42af36e87517f7f3786f5cb71a5d0e6c25286da0ef67f4ca95a48a000136ea6ac058e60d8cb577274f7ddcf4232bafca02065c681cf8a6e74d1d0ad4787ad317523f630dbaaf3bf1b047d46247ba2326b36d142737ba17be6da483dac8fdaa28b89f422071159950e29a47cbe44312cbf24b71554058d602dc3dad79d16f62952fffd3fe124b7537cf4d4eda8b9f2af6775f512623997bab2553ef298832390569b1e8306c9deeffb427d29dfd56f9fab3490d9756b8118c426148559e7b74fc43ba3ce8c7c76cbfb328c18714b2a8ead1bd0a5ebc71dded023e059919240ba12ddf3f21eaed9dd588ae1bc42191d5364ad4414ac6d487f0aec08b53bfe73cf4550697afef1fc06609c7d23e86710d3ca0da319ddd7dd72f94b6d047e5162bf837c14e91856bf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
