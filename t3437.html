<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"778673117f033d3dd5aea1e249fd432a6c8ff8d75ee43d003061aef5f8d75ebdd77d0e76744ba6a213579a0dfa1637969f2de0cfee0ce52e66a853f126889b7223d5e4e2d88cf7892553b77460ca698b77b4e3427a71b023260c11acb2af3ce66ec4ec6ef322c27649940c97fa9115b1c60774239ea5bce9f604841030db800a0c9a05035a45ccb62d19fed239977a77756688b89d008745e511ece3228d22d279a1caa29625c988303bd1240d6eb756c9e924bc1b8487a37136ef9d2bb60e8b8c5d1536b703c61485323bc8010b509de4483cf8119de5c608bd59985eeb7d9d5eae43a2f1deb27ad6489e0d3e7db7748016b9e5e2c20e7a0fc41ac648070eb15b7456eb5e6e2f58b7f28c2e851fc6c54e27de8e6c15725469e69ab4410e1b356713b0308fb45e4a32461c2375d79cfcad1774ad92e3c182561a9b75e0b21042ad1542d318921e4e6c661f4d380e7cb5250676c0a44e4bae7e2cd301353cd67f91e2163733448c83277fff3d175c10070be37a84294c6d9e776e0853d0ac3ac1c84be8449fb2275e3d265f102e0d524c6fb0dc040f83c2f36b1e0f661d38d396be130af79b03a1cb3994fa9e916706be450d7dda57e9feb77d4f6fdf91c8511cf73b16110f0db3be3f3786491448e65ab0652c8db811fcae19b2ddd151727ae5f4e4cd24e9d047496c0b5878e7ab87e4d0cbff6e3e71679b971a5137b6ef2884fa0c8cdb49d892e126a89486ce83520f96ec3b39b3a09ae19518c89e40805e727f3d69f2db05e435f2abcb3ddf301ad2695a221ead1381eb85ab3a7419f823f60f9b1900b32330859e4ebd4094749ac5d447ad0146ca068723762787a7faad4413eae17eea884b931fb2f42a803253c94fd20ae9b8f1d1d88ec1ac36ba7171f30dd41e8c4d2514dd1fb76ece6fcdd239ea447758185cfe6de7a8ff2bfc73f19cb0e0bfe9a9bc7dfb97d91510b03abaab1f2a1e43dafa3f356c3280877b51334651c7c214b9202b14430408b2698b5935aa5f94202fb4ad6a9d9e1c2faa085f654ecfefa63edeaa349d739ef216150319e005b68573a9a12b8b367c44deeb0a9043afd744ab41bc7f15190ec5c09ded6d2ca10838dd40fef255167d6b4fde04c1bba97323aea5cd3de9dc689ed74c05ba856b9ee63412820ea19f67b6ed6b52d37f0fe98c5e1141d1cce46d1cc94c646ef84a5f60a6521aeb4dccfe4d2d3bc4526e2a45f7959398d590dc02f6207509fa6d5bb8915f3db744ac3b04a7419980d5d56e0a47d79aff0af2da5aed26d0e97f8b415cee72d2c316b7a9350822bf48b4a74e38007359604e9289af4aac58088f16d594db117ba811e1c69ce58a1b9d1daa6b24e4cba2f5ce8c0d684fd07c0b1cc7e607cc87a7a2ef97809254a9c740958e357ea728f285118177f66e61dfcb761d70375bfda7936eaca9b7de6a6ca0581848ec06f56340b41c978b90e15bc80bc811d69cd1c7b6e80995aa786e365020e097ff5620eca6701d79e12d52a2ee5764b7a2687882d9d09e37f35044e4792186a0f6875dc70f8ad41bf1386bcd2adf527918e799c638feed16cd2b7f7cae398d0757731789bfa6cd47975052390e0871afd3c3fb41b5760c025dd5bdd424fa6755ab195a2e1a13ed3d2bdd9f2a851b6465935fad557647da23ab703ebc7492ce7c4fc5e7d2a8b873574b1e837e567bb50c3baeb54ab0c9648297ef0b3ef8d16014c3da1250292f3bda4049e7172895227ec3e9e27cbae853e30139ee18660c368447674912dd1fc1db31c146ab4f8d31747ff7b8bc5998db2b7e1f5fe2698c892a7a8d831737cb9df6261c4c2307716a1e6893fadc228492ca2224cc07e52f97185de9076741197ae58565bda8fa2e921c0036b5d326d662801c22f77680e846f31e8ecbbda14e432a8432948c9cf5a83e901552bf9016f31f6846553d6b4499ddfdb43d16df4537ca3d444f4344101a91ceae4f92c5388510bbb79dcfeecee61d314e6d6503e0f07c6f37c05e3b93cf72c90e5fa3a6523dbe0be0496e70a43215f14db6eb3d2afb19edf5cf6fd6b089c4c2fbb7e5775c147f9c9a3ad2a830c96b1fd74cfcc893211253c26931293abe4ec646a2ed035142a2761c4c53e3b8e7df55c3073a2090fabef0543ff398d9c7c6689d9a9064e5dac7abb2a89a1ee59341188b66ad3eb37a5589498d666ff5eccb18cefd1546931f20e81cf2745c765fa715e683e7ef584f832c830fdf064dfa95efea04af1154e0ac2e3074570f7a514abc311061667817c1b5528f4b3774c5e88e1a0c2c67bf868c9118e3aac5f20d565175f33eeac3e8a94239e47b378e778258990080b3b1d251bdc18cc4e2cea9cf7356b4d3b9a840122e2edc96065398792504d07c83363ed401ccfc5400d9bddeac5aaebb0989f0d7caed29faae71c302a02eb81e48d4c2384bbeae2922b5a4620d33d7be45b3c71a1d21404fc13982620ebf595ab0a00eb163efd0fa5288f21f27e349a8a08edf0d4f00407cee93d3cb9755f97ae14a0314b0f3a0f37246b8b1115f56a364d30a7aa7f64a6407d4b1530c5d70c92711fe0df960de29029a57e18bce84d5b4aceafb2004d227c9b5fe206d7cb2bd7ff8fbcef893efc0b12fa902dbe8063e5160c1f2cb71242485cbd4564155b08541eb804033cd5c5036483ade637fd9b3de1c6bbefbd529cee58337d55bacc18053b065ccdbb738fc75c646bf7b35cc0e8d23e1304c62948caeef3e94b5614cc338eb6c405e6a0bf4fbc4f86ae3bdd73e69b8f6fbf0c37d96658f0b9f2f9f6ed059f9b22239ed2409a4d112c5f459fee069dc4333a50039dfd86c44097a497fbab9c1bb2ed849a4e88653ee17a375012581a6df8cb8431a5d35a0aa05d3c284ff2a3573b6454bd07f67b2275737657c32605b425750dd11940b269eb1f58b7ac9e332643036d0e871361add6f0911caaf6310971d413609ced73bc658883c6f5a3c9907a473a17504d96278709061de7877f8fc2b07d2f629aacbfeb4bb4fbf61458617d20afbc4970c03d900a68c63787ef367efbaece052b9b815bfe4d7cb9a362262c5f486c51018e900197d194f74baea77176dc0f6ea83090fd37ba35d9d1b38b149e86941fc9f148d966dfae20aad73ef9367f1aa924b38797a0880a5b9e95217cb0cb2f65e554bfa122b0c319f0b6ab72a55ae5028cc42fc965c77f583f07fbeba7abaab6d0d00c2f92f63593a8285b324f3a584b222f4004efb46867b4021e9032b5cac417551a62b3d71007102ffca17f9613bcf6336435fa2936c06e3032204aff251a7e427dc514a2fed710e27ca08ccd459354433e5f462d362076e9c0f26ac65a16afccc14b3040217e883082ace8110b85caff163c0da3d882e819dd6a9de5414c05b10c5c3c715d48c625111420c3f30cf518c42835a8691929d046fc2d53fd24ac388baf08632f58f0733b93a98435b08e77c29907bb69d469fd7b88af42974d919f125a44800ba9af39e5755e380b5b986913ff17bc072650f75ff1281fd6ba5920cb09a8f8460c898c8fccc4ec81fc3fffade8411941a67962072f83241c03bf9f88720040fe76fbbd7ffb0063ad295cb3b3bc6131fffb87e010916cf5ebf60f15795d7683b4ff30a2c5c92a8c3d63d102d8f07f2c209a9a65367db70b44dc1e2597a877ad1af7530079a87e99592e4680a064c852d13bff09a0d182d61b1696397cdfe72ddd861e20644be809b07210b94f197c5e2c969a49f872b981a4a5b43111530aff15df064a61959b661253be78125317a4e9b23c796cde42af73fa9c755e0aa7f90439e14f5c84435191962eb064cf70593aa38e6dedb0fa84f6b008668db5d5f9648dbfd823d132c4f017c323d37ba3e1a711b8f0a50b513c5331c11d845106235ee54eec4ce5d142ea3b126c742d139144501b99bcc01c5f8b8d8fad63ecd24ed08aca683974e0830329a8e74e1e35a58ba1f9579cda35cf59334ed6f39585eeb48deb8a97a51d8baf0f376159107763a451de8d09b5dbaadef0e02b5e790208f950864554d7555b74f1170722d31e2a9d0231a041b09d53c10bdbc2a469ed182a1fbc819eaada6383a8068e614b98e228f98a2325b569e3385663a1460fd746bbfe9697daa64d4df453ed83089902152dd10d0f99f6eed6d00b5ddcc29525bf6fea5f78f95d62e68516bb1f42ef44de595bfa9bf631cfde1f16ea87c6f4c46af60b055fa271cc52b1e1e5e662e96c125d227bc29d9febff78d18f8706aa4c8240243a10bd487fb8971bbd7584240041c31c1a46c5ac225aa7ee7a79f5f653f7c87131941bc1e39bb8f4622a5880b7e693d53a064cb12924d1f196196b81996580cdf9f3640be50d68decde27862e99991011549ea79b079493df7567935d152959bcc0977e32d80be751d1cac0e51b05146fff4f21ed45a8f89d895f6a574d3405bbd187288a6115a39b24f6ec59413adfac5fc2c749f3fb24fdda8bda9f42ff58ca615e58d84e6531321139189ba3769764fdf2f95e8ee3ec5c43fcafaebfdd23de715403c725ff836d2c4800af7c07d0c9563d0c8a915bc26edf47d9ca2bd6a5e31c4749104192038c3dcd3f525af8340e4759b9c47fe5b19473a89b61294a8353da1003c1f3de941f34deac896d998ede342f19b3c723c7a147d979d70c193a5984d00824267d88f73891cbadd51ae1aef48b00925eafe99615eb67ba2a02a0c3c6b5b09929dfbfeb295a958031e814d452882279c49bde5a4531ba02413029f2aae39ad8da9d6c83e9d5dadf4bbad724f90dd8f6ca90f21c6bbfdc13793b8c53ddadf793e7e74d6e4fc3e1418e1fa113e2112cd9f7b554eec811f7215fd2522f0298d963ff5102380de20698347dff4191cfe203d8b8a98e7d153cc8a315b6d59666154e0c98957d2d63f499ea9a6a67bfc94e307a065219c698bf85165403eb7d8f0f6e4dd98702efa8a1d2ae797ec1e62ebf31eee04df7028a5e0413fe03777c2e51e72e814bb73c42c0a4f344ef650016131903a37405a065e5b97913e8ab1478341a550adc14eeef5d7c2620021a91275da1714b4bed6cd9cf86d3aa284a5556169d349c46ed628b3cfc4662da5e869cfb8bb427b69e8f420aac2500825a91d37a84111c3907e15c67e30b6d87a7b308d43518eb076fb2c020b4f0349e4d3c37882275f24d25bdde593abb1de42f043bd88caab840c0c64823a19891d9a9c8f974237c148bd9684786eaa0360d4ba1a533336178e89011de433d9685412ac910388c4eee82c0e8407ffa714ac0a9f627b7e74291708dfbce5eba1f3449b422b9e5296c6de5846dba5091ab21508fe58c8c1c8783f4c4d13666682da7a716cb2d405ab0614d580d168c4cb3a0d8b4a220f79d9a658f6f0d7d30dd769e74328a195ccd4b7b19066f1e6e88d0ea8544111be70e86770283db752d256bcaccbfd17a83dcb229da2d68fe3be3b93dd9efc508017e3c87e1b3e4bcb2d19d0e20291853219c7b08f067e3635c7ba17f10d835c4a892e4f7c600bbd858124ef183596052280c3cee1e81ca43e58cbe921d0f87540643d3f335d9c273f148112302365455ddcb00a3f18b8de7820bea5c76b520cd6cdbff5a86e4635a276f68447f7780c2384eb24b9154b16754ed604cf6d3ce1e931165bc1366b24b2291d5be524912b6dd01e9aced1fef5c258a592c8d23c33da9781b6543494a21c3b4dc106f9f37cd00b149475baf99632d21d3ff5f7437c8cbcfa79c7b7aa3e5eb71dc8abeb2ebb013a345d8b07e25a31aff5b1571139f9a067e07611e452c98cddeea1e1c436d7f027cb840baceed74418c53ac2afaa8cc0a18b70c0991cf756cdb3f32e03ecb4a87d2b7e6bbdbf15701022957cb7046a1ce9e687b62256f514dfeb10785844bf2b514243de735915ed72d8d8e39066c3ee015874bcc5bd3eaf05beba4d4aad400c999bad255d6c6fa5e35498944fb8dae1310237617c62600082e12c6f4e993d10e8b375fcac6379f2a63b34e6d9c18308512af61d1a2ec3030eb89d1d100ea0ae8f516096819bc1399e34474f01918d957d5f906e06e6b9c048ea3f03b30a1a2e2ff1cc2c4d637eb42843ba7f229ce3db65e90ee0ba75336b531743781f2414fb9f531461802a77d9af32a0df89660438c653f9ea9f9227a613a7cb4e3c4aa4a1625f81b59882c23b928fae689e9034ed6b8da834cbdc23535372c0820244d22ec44672a839bf36494cf2dab0468b42a8fb05111512ab1d335ad3c5e2d210e19150ed5f3b399231c1fefef9e290dc51d0c23e6b733af3f013fc4e93e6e7633373c732862d6f4fb3554d62299ad7b845eb35d1bcce5dae5496315254e757cb468ef43d6d288c681164261df2f2be3e1e5f82f64e87e74062102355bc31954d58ed073ef68a052197fe01ea3602e61366581e0fd6499bef53d9ba449dba9682cff0bdb2629d02be052e08f9d8b917d3e82478c7d103366a2e81c21036726c0fc78b4bbdb1d7f2cf7ec5485d53d02395cd4fab849100bbf6d74cf29ecf900146eb75c528b8ba99b6bbf8919345ce94b148e6e0730c98b2c7366b70c0451e6d4f21693f34daf2463f1238864c64b1ddd681f72b2af4a8546e9d410a60167f213fef0d41a2292ed38bafcd59fe91b7e7b73aea4f31c51226f727fb54ad63896c345af22274b61f48317a3f54b853a259e067b41c59bb487b5b0a3b6887000c34edaba426e5b5a5a90e5acf2fdda3dded16451569be930361c42cf422b8ffefe2718f9e36905baf2f33fd9c2efd7f63f8f396503f773ec900a47af2f83628137c140d544bf0d53dddd684a47dc8a376579b19939f306be47e66d2e216a83545cf6a71b04dda0e406ea428ced28a25e44c2afdcd7da04d0d2fbff4b9a3940da858394d6982bdc0c12e1706ab3356097dd22408be731f8202c47dc8fda5497ab1c0aa7219664d85ad8ad9b2613141d5ed780377dc1d0bdcc48dab682a3069025745804fbd23d8ef616026458f325f2dddf6c387efe50456205ca275be80a4faa4a4dc9ad505eca0cb0bf9930490919200361aceddf34feb39de3be76f669f93ed5fba163e2dd52469db866e1fe0ddbc813db6173828031dcb5d5a5dfbfd21dbb221c972e9d79e2ed514f698e065d0c1ee54327c9d533af2d7359120606a6862367b03b5e3c327d1e6947b5117097534fdd28e492b0a31d8bbc016cdf94ec13de553084ecfdb520ced9c270e0f05987df54628d140bbbbf9282671612c68679126722450e5fa81cd1856abb05e2ead99740ddb82ca58024767066c03591e89710ffeb235abc815092c658f96e8b280776cd78df1f8c7633264cb67999f6dd3c82a5d437ed0e9b53b4bb4dc27638a27ff59fdc85cf725c10d9ba08ac5b189402e79a1c3f11cc4a0dc2e0664882214e2880a7cc19f436d153bc84781e6c04b7c2f4ffb98c3134964f64c5e6cb02fd92e4fe561683fee5eb94f778192f45d4e158aebc8849904b4456990cee9dc12a25a1dcb7bc3dc5f06d29922aa747af4a1da5982a7e4bd02e243ff14f2745fe9407c1c755849bcaaa8968ada369742d09a2398236049982fba3fce3d05a53210692b1af61e6df1039aaf847f3dca4a15df1b1cb3bd5b8010d558b59df66a6a0fd9821df4b6da6dd8f92a054e15d17f785ee1cddaf21c2b4f26cf9710b80ec5bf1f3ad3112b810f13e50b1b8e7af08e1d33eaf249e8466472caaa1df4d1923d8a75e385c729b28b38a8977be060bcbed918b509755e05d8561822e737403e387142779171d51469f52597bbff0471c8a8bbbf802073c8ff4790cb5e715b795d5c10f74e0c8f0b5255e03cc263b491bc47b07d7a5e47604e5c03ede3c5218bab396753364006e52d76e4bd29e714c0655ead401ed16d5e367f4f1f7f61fb8d51de819cde6f62bbf2caad16f299b647847dc8f8b2ad69cb5e91e6c0628c6d430c7c85bc92a0a6cd2d96702230e7f063913fc62eb47dd6ae1df1d5e263a91ce6aec1a1e44237810351bffbcd99be18fc91f19330fc3f4cd240b69235c4d0c3209f887d87a403ad300c588d48482e8f81c954880973b47dfdbfbc1810a82dee159e747371351bf7b28559a68f15867fe39329b72fd5871d08b0c1a90a036f58c5511b2ce304da7c15edfabf932e83aa0fa6dbd8e0b82063489d74a68ba2e771ca1a9b211158ea6282dc371f9159d2a96b67445f662cc0153531af173cce8bb514cdd042e439dc68ff53141516c0e38d18f7549fb85d8984d85511fa02565032d5039dadc60e688543ccab2bbbae439b7258d2cb50c1a9296372f1ae377908dee7accc6d1d0b51ccf39a1bcf428f2980fab2efbe87177159691b25a49460248eec1a99857ee9df5e319f9f1002c5d4ee82f6c1a3ed8801093c51452bae49d57dff7e3a012cc23c0d96c73dc3dc69ce2a4cbd7445095f790abfe8c71b37d383ba70865131104ba791e5ddaf3cf8f500aac199d7117070f572b1ee60477929161790f6e4944eb68760982f512c16de8b7eb039301c377f9979416310ce2941cdef913921cb3d09366fa8f215f23443b105d4272ef80ce526f82239cb1e8e05768b8452eee52ee83ed85329022dcd14ffd1a411a46c92367472e610abf57cd61381e91b6be8d70bf34e92f10303f66980aabbe68e3faf699bdd489453efb3fdb2787fde833577266a46b99ba6d9a51fa7fcd0013c56560ea6c07465a1458a9adcd95cf3eb50e486277c8d14cf33ff5c233f51ff1777e8f867787dc7d6defb650a48ca2224320f5a2f5c6ee7e37fe7ff47ae8b4770219887b8ce0be69b004b3f63c3eb9fc312cfe634333ea63cbceba25527c8dfdb244ecb8f33d10dc9cf40dfc3ecd26320af6f8fe1446de4290226bf14c4ef99e18db97ef18978fce91a846f3999efdd4ded28c2e46f35db6aab6b5d3925ae1c16315ee98877075125172412e51a1c9b70ec0a4120e18f83da5940f64a47967d8bc5f33f094f1ab6d525c0eff79f02ef9076eb0131e78d901eefd8b00b22b6e564a3db465665054df8e95e662b373b5285af10e88ec829ff3f13a0f0b15d7fb9067ae99974a3e1ced10957b426f2f077d0cb673fa27fa71015332ed76abb3fac806823c7c15a925ebbd6e786e7e51458043f5c55e376b52f2664fb4636f53887641290a76ac4b6c1522cd8f0a74cea2d8824f39056b60fefb9d9020567fd9a0678aa79a9faec5bd2dfe7fc1983c2af903268c06a545c2b8f4d896dfc6671bc4ea02de436ddf5194e1042452a43266b7788e809e5a3491b3cf8cd6a6be70a5f1fb19f3612b915c07910f924be9a7891ced30386558aeac8f3472b262a10156bd0b458c5a68900cf28991b7b9d2bca969aeb2607590edd8c4b77b3493af7427dd15ab1192b545c95381ba9d386d7118c0175e32e7ba3e4d699a5144d194e1101ad7c52de277ac5839cf41a15c60c39a255ddabf964dce86aae0c7588708c81dd211a8ec37d3d843df0de3ddf3522de3f13eca77e7c316f3cdc67ce1b8c0be32536e29b996e6aad13a6837f0f2a74aa58b0320f1b5d24288539790b12012e654711b6bb893ae4302bf436335c6a0db2a40d757ad3624934ddfeb4ae19137dbf8c5b3ff29044df5ba1a7477a8e8dca4b35df88c11e32849b1be7fcc5d95c9b2b0db4fefa563e9bc8a6c6d9bea0d7d0072921cf5014be6c559e94f5dc714fb36a0b68433baba7353c747012c029fd871f9b8cc4197eb0f38034b9a98b98fdb73ddffaaf60904488ffb45a880fdab37614cb1e6de39445c4f69b98b1589932f8222e44a13b623da6f600c84f3f0909d1c4e3332ad9c520fa7f1634ffa574f1d3ebf8370662722b79387e5e14a167e0bc7cb8646bbfd8d32d291d8e45f761f73f90365deeb2b0b6b6f529fff3b53357b25dcad2358cad9b6c8946382f49b28916f09fb2eed8e49b946e127fa67b495380db8e692ceb91869c357d56abc4994e31b25bf5145f4c1631c67cd65bdd99db89e8523609e09df3c6d7f434bae6e1bba377dd5657bad8f67147f1238a71a765c712fb47d9e13a434cf792e09051c4f9a91c0153acdd17af335a386a62c868fc964008177324d2e54ab3bbd82a696a8d73e9bfe552e250a2b2222006229cbd7472af43c6737527b7d300e8d95bc7ed93535e0fa354171b6073ba9a6c5866b7afd3c4a462a34a8057347c965318b3a1cbfdee8801be8ef9879abdb1237822cedbf46a3acbcd421534db9c2f5be442cda65312f4282c65ba6e927592fc7a76885b9435d3198322ea247770e2f90cac28bfe966bc2d5a15408e568c8608f4396752882e906da005e35e5a86abbe70faaf828149aadbf39608a7249a345cdea2469592f040c2546af7f823fbb6a9576d8bf97cd5a757f6c925ff5adf2c20634414ad26000208459fd899de67beaa6185907d086cd3301a769735386b8a83142735c67860bfa687d29cabef60a29551c2e9340b89db07ed8eaf16c3c5f33deafb88ae3b8fa30ea4b0eb65b9551777bb83d04ee5561b4f6554e28e65df77c344da809f55c9223e17c278d442847223f1f50b7eedc48128aaa756f93bef0bb93d197d3949d8842ab9d7b00ddc310dfe3f32f6cade2458cc2f701012278ef26acb6f0b60ff6c47492416428544d08cd1e33537e5a9a988389ed32aae96d34e2c4d9d3d0a733f17c9f6ae6f8f1db2eaef9ae3494a362d2dbedd4d5e2c16951562c7eaad2560ea788403e7925a5c3eeffe78374cd1e32c4b12f758a33b6470eb8cf5d18dbc8a661526b05c9b930cdb28f0de2d4b19f65f12b0ab6d6569602eb575c24a7ea67190dc594425e2c966b0dd87ce976f3bfdf25708b719528db4797ed8cc756a7a5e5d91a606f28e30ab6db544cf2db68fb12201ec8c540b50d7b5bafe42f862a89bd88f6842e60598379135ee7b747b4cb020deddebf4add762915ed50311185cbdf92cb2310a6ba3e6217f5dc8dad8290f9ab716446354aa804b4dd9f9062b076e46f479ef3e95c4369cc186732c1985933a80d549359f67d2237209329edd236a674aa6d514ca6a59ec827d142c8322922ed1482fd3d2540586929242878918009cee0586ddea71b2f0e9cedebec9669e7ac4c5a69f73fa680e2918c7c5fd9fb5563fe63cd8d4e7e02d9ca5c26a392d0094188af988886edcb0892265bcbcd7dd437232e01b68d8ecd2db7a5d6e34a2a9e7d66ecaf00a661d6b3c90bc865377c3d83d762f4421dc9d4ddfe747b596b56fa2c5eed436fc9cd1b0990f8f9979ed23f4b02ce74956660a9c3e0107d6ec1c7d041a8fae18e75a09f03ca906dc07bccf0fd250e35bc4f0b48806e4c985f2402148d193d03603c50a6b67e5f0e104aa73b239e46be1eae0f0557e0f62436229cd27866ac0737b7af3edd47a6cfd187c4b3eef6bdd736959417500eec07606573fc2d02f640312cc4436825670699ce57470970125b0c09f985469b834bac5b33d4963e92aeb29c8ca8ab371b0cf325340aacae817b350ad54ebfc94f38471da9e4a1ae48cc5278ce2263b52fda91c5b2f750aa54212e28820715232dcb4aa1abc2bf2ece57ebb30106733d0e7c392f8b4b061ea206d0372c7a903fa1a4aa871374f7510dc62e7fd88433e1a37ca67302d041fa006f9eebe46c92ddf097883400e4a708b7bd2d7647ec5f903780224ae3e88b49cd6539a41d3a939eec513db1b83e60502863dafe1d557cc1100e4da2202611daeb56da2e6b70757e35a6f2a0ff1d0a55bf8d758a7f65e0c24fb9bf70604b68ba4629d874e82160d94e5a6478ab2a141dd4094a760a2fbe3e2312c3e4690aae32bce2b19b6f9e6f64d06a9b24a368b9ed373216efae1fb6c6ad8b8830e8d43fb9e785a33ec166ec4102eca850cb4e9563dded0558f5bc9fbd8def6a5a184d0b55fee0e8d2db75dfcb89d556418f32776e2a39a9007d2146f2713309e36f61165fe5a9cfe6bbaf18fc7387873f1e81be3dc9d44ef190ac3065b0448b76ae72a47f978844b0b20f4ed72ce342da45a91c1025be809e0d4a3ab0c68619ffc13f2980e497812e2c72b4307b87625b05fc04fb6d8a1c77db455e879af9bf605938ca26bd3fbf686dd92d52fd7cb50a7d05cb72755869cf5b53d5889742be19f421b3c11236fb975df4e17c98b8e20d29662aeb7b6674c65823cbef87ac9731131ef04ecfb0cc2d1216d6edf9f5d8ed84c53b9d21428d75d5eb25dff78a8e65f0801d2a3d4bb49fb97f86f8969dbbd51efac41d483fe1c106961ad015bd7df85b112d2e08e9bf8ef261615c22d8de28ad924f0bf57037d492c97a89fd32349dddbc3ba3312a590f735303b13315f60547155db2d247f42b1f9682d037d06932efdf28533f2c62840fd6322fb37074038f154077df5b35b0396a0a7e0bdede7ceffd3c2837aaf37b48397a4afe9d5bf8d2160466aae9bd5350967e8dc7779ca1dbe08acc2da32a0cb779bae8821d9dda1a8fb852267ff6cc20fcaeff53bdd4a09ac2c55e8ecb0bea769456927b27ff4211ed39c34381742c811c5ec0b2d2e71c10bfe680973f08af759e758401cd37b4b9df31f565cadd78ea8966c4ba7d2af851cb5fa84a60a0cd21c9fdf8aed63460622300d1611a4f6f4404e3c24015fc1887d740af5453d889153d23aa26799426f9b0f16c1beb3be2f7f788ce59907711201e547491c97fd7234761dc458934a1cfa8b68d8d0493d0df032b29c2e91fc217e9f5775d99bf81bf8100ac2ece0ab81692a170ca9a1c73416bc2b5ee132d909bdea91f4e9aab15d950b7134d2bfa815ff37f6381ee4706b355052dac76a308a30f05613c77a243c9d2b8eed6814b447d6483e3e0ef0fd78f5b26fed2f7f85cba48115a7c0d9f4da687fa4ac17de9346ba7bcefe7c8f99a275eba2a5355fbe1fb1f9194e729e5a10d9ac153dce3fff29a174021febcb4abe5bdab143bd2ca602671f621ca221b1addbc933a7a7395f6d08792a018e3e76e190920ba1d9282a83fcb013d21ac8344cf9b9b2006b841c5a251f38428c1df57c1643bae6d1fea73803f2a297e2c7e61c775dff5fcc8bcefaae586727683cd19b97afdd3db3bd3e3487162e5499b262356dfe812bbaa8cb61132f4aca5da9bcd7f646e4fbbaacf25185684fe9bfb36acf89bcc2f2cd22b4a3b5d0519da8b2d0378b490bb33f77cf0bdf7602b75376429ec21c342ef943ee9221038324fc74873ff37639b91b05ce5e4cac9a29e4ef2e37b88f3fbe8fc8878f3b81814b08f80e6af49ceb6cb543146f7e4626c277ac611e5b8364b33cfff5cd339faf8b9a4b2b9250f7375db80bcccbf46e50babd6af8564fb0b6ce5c0a18857f115a4b6d16b5057258f100b8dd94d9320f38e701b26b750713cc0a6e4db6df54868e907e1a1778e12aa01045245e272f8041c97f9538d076865386b257897b9de1faaf89a1f6289887e6ac35c774ef03f6544f0e92359a3eed3e4d79bb52339d316f66456932d4b1f74d884380b366db882705243aa745e6b39f991b988623e187f3ce6f00dad3f3d50863b6f2fa0d5df8ad4946909b81b2d31ececa726687a44f5196c6bdc0f778c25cb3ed544113ecb654d437eb055ea526a16805b59d1f7a5b3b92802b0f86cf483cadb96ba15dc0193966368d0d3a1d6ec2f31e94cac510a96afc7ef002548eeaaa121a2de07c787fc0e5047a5d76b8462c85ff9eb8c5f8ac62ef38953c95e47a270931e18002b0c97e941453de7eeb65452d9db82e82cc04134e503e171e0797a0d983808bc496162541d7722b19fe5bcc87b976e8be6c209f4a1eccfa58d6860b9b23298a5c40df2580726f8108edfe055086c5767b7ed5ead81c6dc4f235b15fc69b7cf2f14553ce5169739ddfdc5abca43d6c8ff02d8b6981945f7320294af64153a278686d7679230c4dccd4b452ecbf6f79b5e768729b8b4e98a15f07509c676712ca969ba428177d8ab0fafab92bbd686902902f877fd0d43084f125e1677918ae7322dafe9921954bf791ab74fc1a46f94856d53b31b386417121a8aa676ad7d0bf2aea9b8445140ca35cf27c8c449f58aa4874634c94f032fec7d8926e304d22449349b0564f05557bdff2df7c22b8f25f0caaa9fb31c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
