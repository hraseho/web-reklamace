<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76951b86291136ea72c553ed8edb923e6b3fd05460c016398a72196636f902b32ced036ea6f386e9e6d5990a6ec843814b7855a914d7f17cd49827951c820656d6afde5ec9cfc18dfa496415c4d0865b824098fc5ae684d57c377b442df9787dec3c6c87e2674ddb96e87ab049be843575d1917c26b3b23e3ecf351c67de08c28fe3ea2b58bf551cfcf477e054d304985a60585abeb7a4d18750832c92c937cdc0e3f191083d174ffcbc74240f2433abe6c15c7e7cdae6fe721fb4c491acc506f3a1430fe44a7f9d0f1bab8924dc693ce83422ec166a1516c8282cd8b716b17d9ff9917ee566ff4757b7ebf3026f5e9e43cb1419c102eaa4c6a6e8a186d21a9db7569b5f7699677e0ccefe553ebf7668161cfdcfef2e4e4d9894845dab0bd3ec8b9be3c7f225e6c56ce509859a8ce2d0a61f48f1c7d71512c19f3a7ac7a74cad74f58ee2e17ab7b3fd58059ddd656b3fa42997791203c1ea696cafcf6a1d6707f1564f4b936cd576c93d782d73c3899e2405be1ecbde5c45cf81cc53920ffc81cb56625381b1151d8a0a63e1240c8d794862c3b339a5fb441fb9ef211c2937fdf5fbb6da9651dfc0ed211d6b6a699d15315aa4731b1e349479c2689e7c88000163a56c37ec88dad9942806801b950f1cbeeb0806dd6f52b2d4195f7894bd838e7984896da434e5f33529cbf3b2967c012c0faf19e956f25e171ec87d36bd004f4cf7727db8a5c4c6f1ec05cc1930dbbb036afbffd386b918fcf812c5aa2d29e03f9e65959c24bdcadaefa0734335c00a6bf82eee4ddd1e3d023906264672eca145aad1f54fca025bc8f2f2739e38d95edcee533e114fc5dff1c205c98c6bac3b24354fef42653454dc78e72a467834692820a5b830222ee5beac3429cba83ee5160dcd9fa62b356e261f392ed2c966b952364a7fa144eca333cfcf3f6214a370d2a4847f542f972118b2789319c36a2fac5e4b3837db6d3b21bb2fbd6f627ced2e7dcdab9a0d67c442112ed9029ff7caeb142b56c8ed60aa493a768195f7cdeff0be1599d9a335c692870047ea22c359a2dae7d5f1f9d8e0435d449733d0cc72e32691cbf700bd6dbeb0dab65b3dc091aff0efa992276376b61351b766876b133d77172322d4b40401a5ae1dd537416bea9175340422775dbda88bf91d880157dc452b63d23fe9f116d15baaef05a43d4339fb80364419477bdc39be6c2d690bc0bd093ec68a51fd6e399b266b87b989006a6b2ad4e591a874a6696e7dc27c5b8b6d3eb2049da43da2b837db7931d4870f5945957b46f7f3685568861c6705c4a46bb82fb740963a4c14c68ef37c12eb2abedc2d8a7c457c58dbc47800ec2a968083fab1442537a6714ae42f04671b566b39e6b516f5bc9892525285c8b56613328e94d7d6aacfca03e207a51e42977cebc0cc02b77fc42f0723f58664ea3b1281fd36e549857f0754442ff6f90bd66abcceae3dd9f36d45b52185531ba7ff33349a40b2f1931b6617815d0abfcc4977f57679d479d2cb503f2ddb2a526edd66a4080905e98086b002b4cad94fbf66e13e22c4b070370d827e7648b5a31d61a5aa4ebf4bba0623f3e8497a33a6993fe6b668d5cdc5638613a7ce3dc364dbd90a87179d930fdee8a74729e642c2e502ffb00ee5fde20896f0c5ecce2c665dc001a587c164b519335e03b375546962f282c0ba3aaef49652fdee750d73b4cc802890b24edb2d7e17b4731732526ba9e8a3f7224368b8be5f42bdaea45ccea705ef9cc70febe405ca1fe9c32759fea3814d7875fa34cfef85f01f3f195c04e25df79b5451935494d0196de01b17f1099a75e4696416f98a166416fdd19b2dfc7484d86065b60bca464dd9fcd0c0fa2c9f91cde5849b62e039a0b5df8589ad45da8b186941c41dd555fa690a775e50b1d6afdbd94a0cbc5b1871a437486907541d596e2a0d31558d39c9224e3a787e7f7e99aa627030c061d39ad1b3586abb50ea45b29f1bccf762c68e8e4abaf4ee45fa3b18825623a37d088a4fa0f59d66cb05dc556e7706080311e01aeb9e7e0ca8e509ebe01a6980aa3e9d7aa41cf10f6769a668f5899828d9ef820c562fc030bfd0c07d296b40d9669b218422285f555695b796fc2d391953739edd514208f79e6a615fba4a12cbed3fdd6c264e736e3652d0a8cc3dd27a6a043ea32cc8388ffceded5d8c0f93ccea3116683cfb5b6c54fc2f9707fe56317616d5a8754363e6529a96beff3a9a284d8519a720a2b3dace3c2db7a7e724baf6614b5def1463e669cff1f1934e03a6bb90a70e14c08a5d10c7d51de175b5471f95ad2215d2f6e171dd2d938d76d8469b0bcbf5e2224ba58f3e6063cb062a2cb056df3f6e4f39c81f3a4949392bd67cc1bc1362e8db1912fe4f2078a4ac9a764d2f67dbd8924b19bc61af306d8dd0534c5b83465f4580a2dccbdba13377e4230e6bc59d44c509d53c1957da3124c246dc4790b811176a5f3fea70bd8e20f16bcece237407bb91df8bcbb7e6b7a0f0590cb610c1a8c028256b01837dafcbff48b6858c413134991fb0eed7f946a34762af8c06191b5d975487677cbeb107dedac31237062a8980aa8e1daadc7788b8544c48fac88f9d3dd1430254bdff15c676818963673c7f5488dcbe412199d833c91bc929907c85e483e794f47211a9859e1472ed3afcd9678bfa7a98750e5976cc5114d2129cf4e121333ad070c8d2ea74d1ed36272359f31ce715d1c1443f5e09227876abe33666f5f0bccf40201c6dc15964144804942e6ffbeb370918729785f2e15231a2685838811f64fd512496125ea009d49054964b049bbf969dc27a8a1655c70b785b05cc928637feef927603d353a890613b0cb1d0d4b4a8c45c0d07c3382f5ac871b3a72fefec89deb74724f589e6540393153ca8053fa0a09be14ec066436c61b0f6e13c34f9a3f0c971b1968e3e68a36b26403877ef7c699a1e135620dfb0ac3b941de1d12f01c3fc1c5687e69cfeb7fe621b71b043732702c7dab6026640bfa04cf1bc2c4f42d74dfc703885eb74ba6bf76f70e8e3948a1a9d03693b427fae3208c678354949c6488ba5afe962bc74d47c14926c4eee079e54db4aab6b3dec3be72e2c8f98a9616997c2640ae83569cd1a6a879574c92e0546aed2ba0098999b9e72adea92d934064bdb1a8e2b950ce939f0eac5cb6b080b662ffccb70ff7e4e2b250b4354a8094c8d21bd8b353ef559dcd305720e651c5d1dcb25951c983c4659c0b25479b1a89a4071b4d56e84ba313d3f5d4af9512b955341ad4fa7d709631ea31b7145dbef4049f260d6439992354fecdbc61dcaa7a63638e391b8724a2765777eca3edcb6e74dc2c1b493e5211c9e1deaf2b20575239aab64c9a29b46326cf0cfd0564952883e2376ef829b9d8bd764b9c2efcdc954974297e446e3c5cd8ac7affd25e3ec6670be7c8ab83846937e7d466aa4d14433a42b7dcc5d2c13af0e955de58b5fe5e017fc7617b38afb8b138bfb3617081bf63d4e3023f56c087d72f187a0f2d4fb6962de2ea1b11f0e59599e373f7dc3570d6ab02312da3697634a5989a551f24a072e793a23f1db69e92d0043f740eb2dfdec27377463a3e44d2b9c6e1dda7f6e5c23a9db1c7f04ef29db90fd373d5a45792ae9cc0aa421d0c9fbd685d86b38854aa41fad9dd9232392067e614ee92fd7e9e7503acd12b7955b8e44bce6a41da3e49b4bf8086c9d0def07eb7e224e2017dd8ed6a737d680c51aec5c977560729d1b548dd32706fdc16a2e19a2e38ab7de8b5848e939654d42e715992fa9e85ed80d14e3cffe50a85de40ead3d562ad69e8294733717d3b38ffb6ba4307b437681c3d95490685019a410c5fae682dedc7ad845cda7ca7a7631796a57318aeee739ca49d94ebb02cb1eb73277dcb509bc1ebfad6a5c3ff4a23f541284dd48104c4643700d6abd7013ff5b7ab2863e5b9c1ea2e53e54553659ae154c2b6fa8da651068816f4b67e5ab5cdf09cd095e73707aafa0ade5cba124a8138bb1da24c3679e06c44cb1f254959e4fa56900260ec5c1ba0eaee4711ca350cec3ba63d8883bc04224116b838fa7f24e6b2ff9a2415e3574001f1629a84de929f5479b8a590da7bdb59a8d9f85661f2f42ebb93e9c33d23d6680ecf062db7f1deea5e412f7efabfe85b6c3de568be24b1aa60052e425ad70443c08c90b109945f04a65fe222f7113d593f0f8a5a4544e3227713566e29486bdc790f2e8eca219e8f06fdbd81d97de0c21265b574813b8577c9a78f046eddee975a7d9cdf7427e97e3f4ca15330782d1ca0cf0850a64574dbf8150cae8a3f376402fe70713f098246a58225fe5f22b0081ddc8df00be44045061010130b57c2d265c61cc5f787aa631e3246f234e6600fd23f5ac685c39b2902f7a2ac247202412ead981463b93fecab4a747b5b8dc7877dc2363f6732e6a6dde6730540eb0e6a4a34f7435428834cce42fa17eb6635f50563965ee0a36993ea4e41711b28f4c9df75fe44d73d924eabf7822d5f576a090c96c4b06508313c469f0a1d365edf3998b21fd44e6580943671fb43731146d21c728ba7fa61e2c8cc4c81c584b469c361110ba130d2dff4f00a12a5ac2e30ce00dc2221f52aca31d0db516703b43c2257bfb81b8178557794af773343bb5fa8a7644bf58a206ffed269b98ca8da138aa45ac13dd137c5e74178ced6907608205dfb63336c43329f9e7cc1caf284b51b753c8c3dbe1f9e6f833407da897661cc86bd4137ed58bccc1a0a9374220614058e783b7aad45013773a23c6afd1ab87c48e8a8a44b275f570372ac42628e04c7a225958e33c8816295ad32ccdb1ad206dc4513ed60c6a5c592dba5e3fa50f6258979608e2812b743b43ffd0353f2ccab5c17f54225ed33e071abf1723f5de8b452442c1939a05e52703b8ec478edd833f98b743174303460d1e0699601b0eaca5cb7146d04766ec189eece4f1aee2384bb2833aed3456a302884ee6d1ce9fe5525c8a53ea227afc7616b13284d39fd28d6152e33ac0fb0689595ce5eaf04c45b76a22b1de1249a87f7a9948a17338e68d8f534659dc4b27436a37dfacf22bd6c4431574b7161d340d01c50f6de286e69927fd1e47168f9aee7ce039eaeba5ee3f0710234ec1963717a1f887596e652eb14fe985eedf6249295ee46a831490766ca89734cd60572ccc68d06afb87f24f5297b7b4134741e1625c01e14475894ca7b60460e8dc84025a0c0f036fc1cf3200579e3d1ae648ac618f5d950389756847ef144945ecdf95f7a7850071deb07d7aba051ea8175041aabbd115cbd82e634fb37697297fe40512d9c1e04a8c55791d2d381d39458218102f3de32c8d05fe7dfa21efcef1e560f20d1f4a67dbe60a925954a3bc2a62cb5337057bb6fd006361dcb9641bb5e83a8298dd6feb4468d3dd6040b78ec5bb56c3d6ff9cb67e953788a13a73693ccc74d51ea6a67cc4bb449b71c49d8a8d05a65f7264e11184d30cd62ed1b01978988489b993ab7321f5a2f1f37c7746c9d13354c59ec3d8c2ac0c6a99395ad9bb68e982b868c4e233cefdec2b0a49e256df5df228aeff2b8b6aff0a266f858df88fb416b70613b4ebea480ae36d7ef50e88a6376ad436b7ba88cea15ad1cd02d5fc7ef68632e89ca4e218f578109e2f5565963ec1f59074c1ec4b06fb95992374c010bfefc1cf10cd36d14e21aeaeedc735feff9a711ec44e52d818198b3539dd67aca4d33602edfa487aca0b0e534bf69cd29fdd06df08abbbde401710b48f55810c3be090e4926adf14113216ed9c139d2f288df5661e94850dca9bd5dbc4e3dc91ef6a86d5ad677b9c90a45024e9f40a87342377976e824271dc84a9d1af6ca8f3cfb7a070b6123bbcae001c193d5875b6860ad8ef7543c6923afb7a9f5ba5f1ff6bc177686cb9797afdf42b1cedfb8d2a706e47ddea47a2ce240042ff424ed28743919e1417928b7c609cb20767884aa75f1b7c7a4c16a4b57422320dc708548ae975df7c785698678e725eff0404ef38093603290e0b7db44cf69bf655fc9f18287cae7ad865847f663aff991964fcd3aaf83c985ae9c8eb13af82989bd93ad9d3e82f108aa4f0931641c6ca4eac060b61c6117888236f77a87e32f6e419b198c7614823f7c46c1178ad525cd4316765e62655eb4c360bf282eb81afd114ba30ea2016e84c09a53546cd9411cd2ee64e55304b1606b361ce49adbad8e7bfce2679313eea136d2c9e89d51b05a101c19aa365688336f302e5cc5016ab21d66971f9b2a01afb346abd037771f0d5c74d63b3a409cfdf03cf6741a91decd6aa58a84cb9892529624d45bcef033ffd3fc769060e84b0c710b368c9ba70cece74fdcbc174789f56c636cd0d815af160f0bc6e577a693cb795196cc751018903acdc7d8bb16c38f34349f249743f7f99defb70c2aa15fd8ba02b622f83c9adba95420b4c7d8ead2f449b5234e5a5e5dd4d412eb9820c7f2310aefad015a1246409199030e140f4dcb559cae4481dd36f989306f2d386d1661a92a6ab956d5a3ffcce459f8f8248ce40ee27296535d3c7f26bb9d2134291e952b378479115506f62840694a8533cdfc846135dc09a4ee5691f1d2093d1e9b6e44697b5fe8e21d9460217e747461d18775db0d66db056363015f79fae77bb53f83dcb5e2b5ed1a9d420715df828df9e91b0a13b2097efb562caba82fd48c19ee9a2addf647a1f3f07809535e3aae64f8fcef912881a792fef03017e2683a687bd12893f03462deef9798a0fd83dde844325589f3f30ce3fc44c4006ab9e0ceac96bd9be1cdf0e135e0520285a38edd5aa010e7493ded3cdfe514f2492034ef14278920064552678f333d56cbd6fe4ff2e74f580c6aed6065aee7a42392c72753a909d3bc75ffab1d78201064ad32ec3b1ad3cab6843a103bb8deac5a532b08517c83a3c47f990f0d1a7e8a43f261a21832808814db18fc1a6ae324c70a556cd3b4f4f0f8c945901e56ec0881549e1ee072fd978fb1fb8dfe7975eabf5ac3ecaa94b295acea586595397a6da67c2b527416ad2d119575450cf127784392d292bf40053fb706a42167a9587e514b6e7c815381f411fd23195ada5cb0be84578c8305e111be3cc1a0d41c21dde1362db7c09539b1b09cf10bbda0bc5064a441637b9506ba8d6d40497fe5915225147042c7ed49a898b1b02d353187dd308a6e8228406c1c3f4d392f5a88182296decfa83ab7b63d782a07943b1b4f98daa7e8735a6cee20a3a8e7bb408a9435f2d388bf3d3d161b5bf412a3def95e4bab462fbe359185e804c057ea46af1f22704e667b47959f8a34a2d8b3a6cc1a0d50f4afc4051b15c74768874b110ae1ea3ee51f8eaab70421da39705e5572087803a980e0041e03ca76e53644b5f0d800a6be1209f88ac9712556a7d35b8c2550d103c86247b13afc7459f66231be7c4d4c0e040bfe284c60ad6f892fa29708763689a339032e66469e69963032a1571cc5bb01390f2684b9201c98d8d1e0b42ae64520a0bbf22511c6c1f03419c816800c69dd23b9b57cd90321b426ddb2135f15afe43c530c4fef6fc1c06db289842abe1d0b0b9cc03cb03e7691737526613904d7eab2c0a3665d85be5092a622712237502fd2ced5d9d78cc86965c6d271fdb5e6b52910d71709ddb5a282e43992cdba0c7cf7df5304f8ebc1360ab8a982a45915a9d348c2dd62f5dba587b1609d3899f2a9f748ec4306a60ab645be89edce1b90c311a02a093d22fd7f82488538da8c6617f98e7a155aff5aa14a3d4fae6d866b14cc3ddee1bdcc37ecc1e9b731c65daa661a345a45a00ad021192217f228b28c58f2e890f6e7e0891c942eec111e886aa03fe34932e80869a5b60f1e0571e7878f61d147d4e30b397c737e4a971146cb82a4a6f1a51ece762ad52db9ae980d06ba741714e6cfe5cefc5e6ff4733a48bd128e06e2401ad27a387ea52a3f1ef0962a51728ccee48c0f32ce424047edefb932ee24c0e8d018b4af12e278d5f8269848bfa161844d2171e99e46721adc1746a4cfa63e17cfe4ab4da8d495f650c70e72613aba65156c9508e91b94c4ca714ec63a87a001594155510802126926d02a25723154b0d746e011226b102aee68f34cc70689c18ef930b57e0cc3b00ccadb299d96b2e2e081285d57564c71304b2e2578dc88a1d888f606b6b65d11dd16a5a5fe6cded46270e8d122268e1947d03e562170c21f34d53b5238f724a1484fc679093994762b5e90290c5501e7d01cc1df4c99c58d3536f6fea36b9f1177a534a283ed4b39b2e5a6857cf9ced2b7aa68a02e37b8aa9830cd432434abc680f15cfcb86f94af00bb303f4be78ad63ee1b3ad16c585d332cea998c75aaadabed3c80ccd586f3fa47648e8a65cafd872522d2494df68a06d494e6e8800b47da3354857e1cf8a169f00aa477c40c3e8f552994cd1e339e04d4f0268ac2f3c1c3ee8305457f8ce98d1e45a9697fb087fe2594aa8d029c9d6999fa4a0d363878d08149b154b0c3d983389e248fae727107c054ec6c8887d09ba967f4f50d15bd7e7ee9dd2d2907d643e55b268e8d65b419e8b36596d968148b57943bff0888fb55cb8a650cc0b72eafa4a19a261e6b6b8da4ac49f910949a35606ec7f0f781219c646911babc5fef80322ac36588075ba2cf2880af13732cfb99e91e0e4708e0c801e692dc1558f99ec09b986aedbd68b440321d295d36c47b437d8060522e662287e94d67e2304292f8b61212183f128efac3b1be20ed6d07cad3634a2004e7124e207c23c6ce275949bd2bcfffd1a51b82f952263fd4b20d87e8ad609622c167fc9cbf58b23e3b5720e32e874b56449225c4260661d9916dde7c3e5063871f528560adc73f8620a095cd86fd8f771e017e87caf79073469204878c2ea67b96e76df16241aa2becd1ea9ca26e163aea75a92ad12c4133f75bec32ba2152e2a3bcd610944b5ebced06a28d2d24b18f15de322e0d1fa18ced8cbf2081ae21e48831997ea4b997f863f5332e207120108d4279941528df28fe3377837f97bba280408e4b7f313f89c43744fafabcc8001f82bfd46d9f23de89defc93cda226216d1cacfaeadbebfd677f73842d94564e71a738a6c989daf1335e7712edaf9f98813538d027fc6b0ae94910bf7885d15dfec65e2c107b6397934e87d3da5aa8a22ec11a47e55cd3d5533fafd19b3b4773ea32319e57732514b832aa9c5302a9042c7c8fbf01a95b7afa5b61228b8cdb513d5388a31ac8af9ec3af9fe588e5c98f0199d00ba08a2e3bda883db22c1b0d0f363883e93c64638e02e76f755f6af841d82a02b1820cafb6b0767f83db4b50f90daf30b92ff9e79c93bbcb1b3863aa49aca4647b90e398062f3df477c199032ced2886a6e84aee96886633a92a6069c226207b046e4751d6ed7ddad7c6b6b543b74eacb3400d73697f63e80ea6ad97b8f0516d1a891b3a152d6d72e461e226fde7759ef3930a69490ba184de2737b5d5510bc8dda5a5170fd4c0c5cf2ff4926a9b88667bf306f9c0738673ee22301f122226afe57fd243abb1f2e8fa07d27912ec74451f09757306b0d3ba091fc12f56cff8f7612e7a972ca9dc59e660bfa5f0c0430df50b03a37ec24e35995b273e6aabf9466bba248e509fc165c0267f8efbcee88ec22708db2c54267df66f53308340391f7dba99ebc9ab362dbaa8db3b93617a575a205c081cf9c6aa47a66be5e476f60e589ae4b0e13da6d050417caa68360ab728eb5125b4376af2a6921872cdac8b920517b4d53369cd3649e10f2deecc8056bb30bea30aea035cf6611b97236314d86821abc7aaaa46e6c2fff908b736df080b40b56fe89e1d7c8f9883c2083727ba7facfa2ed634115b143f0f39425997cd89dce2efb0872e91f9cc6c8b108752ef5c6003804428e1e0b95d41a62643e409ce9266f39af1bee9e9d20e4d11af72a1a19a819a0a2188fca430f14e2a1e0d31af0880432bc2e6eb6893abcb3e3dbc01daf688a2150cbb525cb205f0770409c1dfc90400786c8205fa2afda13d5fdc1e76293c529f6397cfb9fd06d8254849f83397a4873b385058958e701fe765bc44e69dc0776d39eac3f04287d60f3efecc20f2ae2f35f5885eb6f880a84baca2fe3c0f33f9a445e09ea8d32195d98c430306742ad06f81cfba9502b88bbb3e123735f8fa648e9bbacd9be1a642b1e10be6d90292bc3bb5291a78059329a248f3183f9ce1c522000c6b2325b2137545daceeaabd4e5d1323acf6d7c819ff41a641f05a446f816c45d0aaca1e6f4f96c70b92544295101d03235307b2683fa4c55553f71a020f014bfe8cb5b39ac9efd97890bda73d4d50d3b3f8708af5a09b22c3035c80c679d8dc10f72e5cf970725384abff0d9af2f57798aec108925943c3a6eef9877c1bb08d75932b776423ac1c72e0a85e4969fb60778bacc77e4c2f9b49ce69ba17fc1f1041f9d37f609fce78f5a280b48fcf2892b69391be0879fc347b5ee4e3ed305a9b001f51a0f6d6184dc3548771dd1a598e36e2d2833937e042c0092989ee0b44aa1184addc7cef949ee17940c2ee1a2505fbf1f41698652a4df97af6aa00bdc8752c07897a17d4a06e0c7c8e146dff74a0ce6991f7ce649d0f03f43fb2e2247dd9e29eaa8714bc4774aeacfa4ff16a4cc5c2cef75ed9f7756169d20c438","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
