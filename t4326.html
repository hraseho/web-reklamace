<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"952683ac0a7a87d7980c4f675ce3d49bfe2f2d9575f1554783ec55a3eac9b09bd7fe3edea0f5b0e7adaaa1d217d54d464bea2497cbacea5a4e25d8a0ead9f96b5aa93ec402070ecf2fb32ff6c69614fc5b974ec97918dd8bcd9624eaf80a067dbd5eb230c4baaa852c30dce79a4ce7096bd8361ded033067b0bd3efdfc2a78a77d56d4d9e06d2c8462988823879c6e8751d1ee5f4a5619f65d45b20d9fad1463b05af525ff5c80b8d79f4bf9f74f62cbb0bcfd4c5d4263b66ca6204f5ccfb05b0d397f01b9cb4b4a4258408a7561466559621e74ad8a117f8c7a4bf607ddad018bef1ed7eec5e11544d98632a4ed4d116668e9ed86f0d766f7face4022ba5ebe6f0b522ff3f1821543da0c621025a93813a844b79fac41c0756e74b055595d92a20ce500a51233773f4a79a75aaa86b9971b6dd55d8500eb415fcc265296095c8ae0960f573bef9ecf220943863aed234bc8738195a811ad772984cba3ec85744c4e9b0c753619a27451c05e0d953e29c482e22b05fab9a2b608dc3e75b37d45d647c889d5b6a4252b44bfce24ffa3764d62c3f6d9b29b9d87ede53bc0880fa94169559b2bd5fbc662435fa486625044a25b4dcef693db14fa33a341455f2d25305fbecc42a09ab2977a160de54376e0139b7b62bc138b9cfc87e235aba2dda270aded8db7a974436fc94d46788c592c71676a13ced2287addf16712eb224a1b1b8b01f61291498e2dfc6c0a7db3b191c970b4ec35b37db00f2962d780641aa72b9d3f42015f1e05aa55f9b84e98886bce79d5877bfe843078989eeb927a1e451ff9f0e5c9865934ac0fb68694c0f66fde140fce1c9870f8b9ef78cd0f5d49b7dcfbd836bee8939e311278454c3a58e667033eaf20debf41add6ddf8b2b6dd0fde3f7f9a0e0bad85bf9988a410da900c5a8cca045cf0ee59c759540829fcb448b897584a722bb1d61ab00ebb0695de80c614608fc6089174cac8435eb6cf46ec560a489cf69003fa3bbaf57b1633553516daaf1d80d0c8e777690bb38d4fb266d9754028a69d6231aff515cbe4f1bc5df2ce5848493648fabaa29acbd7a7b0d5bc54f8596e83ab4115200e14a246c685efcc838262124aee206c5f82c4e35b919a30c37e66c0ac813a6b1922f03915acb1c70ad3736df9f9125666206355b0089f7d93b897ff2f1e28ebcb555c4985def71d32a84213859601ca42f71355cb6e1897942be07cce71b8ab90c74e4ee746c71ceede4b29111524a54e8fcf917d3a262c7ac88d3eaf2ad7cce752a5302cc7c2aee454f540d41c1fb1260a07a822474711a90103f2f6a98fb19b085529835cc6f91e81091d134a6d1ff0ab12d06fa973eda8d09edac89f250a87beb53cd4e9e45bfd03381d0302d427d3129b20cc0a8b4b92fe7bcd12014b879f34a5f1b00efdea5281ba7e2b7cf641d61205ab44b106ba7152f95fa6e970d37097b8ca2e63c85feb5ef33d88f4bb43822d13d07b081df1cf83d68410f5040cb03df96300e964e9a558889bf6b822b157a12b0bd4aab64a2f156fc06fcf937bb2d7ffeea590dc16b739b403718d9f13007df57bbab8e7bbb19cfb9fec5353eeea69c3d238b927ebdcc88d48120a4633b8627561727cbeae5e647f8561f87a4ff96121294eb4eba9da1019574ce5e4c3487e11e6b282682b5fb3c12376867bd639eb3454c810233bb0c55ebb9a5898480778c46cbe1d807879650ced35a44bae74049a3a09fb8539902fac66b5ea003b8f194c0d1725f2d171bd0867f2e4a00fd90f760061b4b9d39283e92621735c4ac5b9765000d0464940b6be6de774f4360090b181c09954f39193122688ef56131599d2984bee0d58e8f9600ec393e7fd4e29f2acc9b113fe6a7ba6e12f3c460257022c0d9a5f01ceff0236fea181263cf1a9835478b39cead6318ef2835c5ea2cf5e9892466b43bac2bd62dbfb848bede55397752e4ca181736975f9bfefe3b279ec035d78ca99ad5613665d37bd7c83afc0c1404b4fb80a9f7783e729325421b2da7496183f82c8c106ea42270ca6cf47bec1d4854962e7b4e40370ca8eba788c6dd1ef29a8945e681630f170dc9b672612be23db9c812960d3a9cd9747ffdf7378f1a7d1ba7ca928602106c27183afe60081cfc56d4a61e922b1f5883d0dec6d26e6ad0e80c8cbc7389dc53f93189c31f85fc16877db4c19bdfaa5d72ebb069c0bda1d30960a25be6d92d33bd1d8527288c877d8f86ad7cad7fb70effec50f9db55f51488e3bb4daae35ed273036718e86353afa6b897476884f6bd5da651cbd55d53ea97db5059f71e641020e2a21d44085b9bd4bbf58a0401e100f0c3905612bece7565f60b0e83d519b9b8733c45d9f3b0e316501cd487cd389b14539baf6717948cc016ae67b154a3f0a47b42dee7684d776594df167157595a81587c8b1206a53d94d6eef34cc5460f02d4d6863ce9db98c79cd121f8fbe7eb4561679521176a41c2cb655bfdb0a7877d55c6e143db34e7355784324635471ec5f625d127b8292b5c3865b29c81b4aed6f39847bddd257ca3d970bfdc78d397d40bf21050d0c49feab58c163085fbea158380e9dd8eadccc8888a218fa711215a61262c1e3f0e7076bf35a085cfc868ada4369026b6984a366f7f4308ebaf1fc8ed259a4d6ab155088c804371b6c4acf32c1cfc455a6c18f52264191208d6014b4595aac4c3de34a54621129543123d9b209a42a848b9c4cf4e236057c1225d2ffac9867fa16feb5e7d006289dd3a310efb70216714452001db7b6e1736d183229d3ccbb61a1dfd3627d253d45927758a30bf9c1ee1b885d0bf18416070de1eb3f83d282574c35fbfbc7fa58459e416be85da30695fddf9253e8cd0dddb454586bfa0428a34ab2ff01e4d284a0fb1b23f9068f7569f2fa6ab183a42f50183e69a6059e1bb62a8a015c0d8c16f8a49324764791a65adcd8889178435d709fbb1f380015439729a081b76b7f35b4e84289bdc2188a418ef368911a06f380a1c8500b346e40870321e60fb1443208ee0235ba9c9578fa46fa284e66a5adeb428f492394f5cfb10945e7f39c9865fe2591e2be75cec16c7db551ea23e32c34abf80a93cffbcf65861558955494f4ddb29030bb4b518a9f272f67d814959132b4d673ade816d8bae09f2953e3ab7f72f7d240e7e6711ead6d9333055eb0b418cad7a058722194fafc80c8c5513e2a26caddb35fcb5cd8469cb22b9759f6c6e74de4542067e2a34c499cd82d40ef29d512d0d32d9e38bce1d109a2b882e39a474aaceb422cf5290ee8f4e614e533b504e1b7b965a7b851c39473b71d1eb2d5ae93edfa468ca5fa0f259e32ebcf581d1b762bdd98468a9f93cbe7fb2b4171f3c05f509cfac95d8442e13c46405acf11dcdba80264f72f646e8e21f148d9806a32ba989323cb5a2a8e54423441a50f38007be33e0a83d0ce2c3f2aa90de2f08f97757c9416f64aafff657b3ceb78f72a97ebe70a2649936fa9cf001677632c4afa76cb4c673299f10f9f13db2de5c389db554ae3d24fd6896ce26c25d820451db982b0232097a2c3ccd6c2aa3570d0945341c3e38af35c267e29c99766f3e41bdd41dcb14ec3cfe9c5d7ee6b28b79905128b8743ca50de732c625be153b14bc6a05f74ed70ec5de1635230b91fe83e4ad7000023678cdff811428d40f197c1e24fd7189d2df8d5da7d68588fd4a35b78579defcaccf143e057cc3f3dd06b74eeb84038e5a70e1dd8e21d5f97ca05e1f9fcfc2bfe55ae530c37abc552192e1dadde525f8b3820a783a124bec2efcbabdb404b76bfb1403035b3bd3f2ff6b879b4a91702e0c8a9b20179cffc2f34e5d3bae216d4ffc848666a5ef96d3d0a26d31269dc2e12362cd5474aec4135d88b28a139a55c06ce0101b008701c964ca342525fbff9e990a676a2bc1ec4e886cc7253d1eed5bc0523999bc171d66746a79771d4ad7baa80f762cbcc90bda12af805211919103820d57094edb00264bbd491c52567c0679734a1628c915d5cb6c5c93985ee48e30bff909b47bc1934d59b36306f9e330292b6828f048894286aafc8b15452c08c49aa6c43a856bfcc3c2eb6dc722463a8c0929dfa9476eaaf52b197ed92799229b400095a6b8a6714556c44af18df4c7e5bafff5fa89eeac2ad714307c7c22a21cae0316136b68e49ed3787fd6a170ac8600b011d292a3befb5ee6edf8915ee092eaec974dfb1a849e06499dabfba09a4a7811610799558b2b0322c5368befe4a817dc5f9b0048bffac22d997b57931980dadd7aea4dc70aeb004082e59d7cc9619d0d31252a42deaf3692170f20f02d578551c20f1cfd624622cefacda6cad1190a2f11d4f5a11b7f55582598cd58c482df749b1274312e644618c84799e0a474b5714af0ac6002f442fdd300e1157d9b3b804092199de390e6bebb9e48c1770ae517566cf2ddc347142cb3e4fb9842e8eaee1217d38c70a07749d62153fafc25ba7672f1b8cf05f599546e477890028a26d371c3bb8b559ae6929693c7dd11fce427f58657504158d59ce49dd59f1ea5361a78dad813f51dfc1f12fc49462386af988de3c790dabe2feb240baca83748bf96605a990cd6ee495aa5a1ce16b9fbdbbe44e4935c7eab820372b88abfec7e65bf587f400c5f7970234d0a9a60b9c6ff63d23062ef97f8acb12ee0ad403dc9623e66ef4c0caf372301ea87c310a748103d818c609051c0e9b97784eb2316a632e30b30918272681a12df5d35901f3e4dacdb25d673973c83b09c0c0e8c6e41d943e8800b2b73bfc9a0557816d23ed2247e3ca4a946949196a244975f3cca44004f6716a0d9c81c41994c09b0291c33de03ecb680c6011c04543c584cfe944adbf758dd6786c58b76d329d2bf1329e98c85eb26b42d75fa1da3d57737a4ed8bec956f04575874dbc4876bfc6557b358aaf9183f29a43c1847d10d9e53b0e1cefaa7ffb3fe77e5d91c9d4e7d29a10452a8b00b045aa2d9c3b27e3243b311ff521ffad2f1ffaaba26964612401bef374865034da34f42c950c26fe56ab17035fa93786d0769d3c77c5172940633dad2b1c0e17cb51e6371eed615d4072ce3cf3d82de4397cb7ec027f6e66494b1cde96d05ba13b1ed4892963501f6fdb938735fb531b3f8f1b1477d70b8c7e219b84fc9286d9c7086cd2d7871c63ba3c88c7e912a7f2742e065bd92e6caf426f3848cd6b26f239dce78208d5b567f2408651c213ae4b719a978f43c3183853e8e7718dd89d0e8189073cde154de56ffe695c15579c63e4cdd570fc5897f357e9487e2bc5f015217938cd939324752e113f7efd6a6d70d1a38a0a8640466989fe93b639d59c6245fe3b530dfebadd41087639af4141470f81be94c24c93663c8ea4b665151a5d04a2160b00674535dfa4493d7dbbf052e698ef5c597f53d31df07df1d52da53bf115994d4872f4f1d43915549f7f582f178545ea262b3ff40b2c2591e06a587decc50d2f69a5d2ed650f4491a427da56fae21f43e5bf36781643560f28011df4008309ea4afc8c35de286e90f16e9765dc1d78eb8bb328a2a479d863707ab7f5e06930b5bf65821f5bcf8ddcd0ab425a359b88e7ed5be394950f0f544c56a66969f15359ba9930349d9c17bc81c92012bb88b9cc452b3f2ed9bf04b0f55df85e4175f649cd814073726809987b79e186f38ea2f2e0d9e5032124e6d7154a162f1b56138c7d2d20c8033823b92d93dc5983c3d69a68cd3dd44748c6fe0362ca3fe37f7f8c4e5f8c8b0552105a9c8eba17fd14ded5aa4c4d4c0e3ac3ea07b21bb58c8b4483e2a53ab4b3ce1b81521c369fc33597afeb419daf231bfb94d155e59ff580836f36b52339ab5127a5a7b0adc94bd672e633bad0562ab873db8cba961edfbd23884e4069cf6d6feed5e06577109e4c6965cef13c22b1bf4b05af0f435373a48d51209f22d03021a42989e8695dedd4423acee4facedacef1724f8785be7c32beaafc6fa2723aa61cc0ec6780171c4f770dd7cba9dc5386273e423d5b7b3683740a28cc1aa8305ed900cfec8c4d988b1c2190ef1779494dcda2c57fc77819464fce06a424535f49298a3664d177fe6f68c34c50fdefb581a43eb4cadbb4b617cb6aead965ea7492b05a3066a840e51d2163f6969822de52612f3e59b44e8ad3ce49776ca54ec59a36b700fa1dcfc70fd56db4ef1f26593474f62680268ae261aa0f9ff67e29b14041e4782bd675043115f35835c4105ea29d568093e9ced80e72cb416a5a93da1389a80af49b4a461ece7f31818bebcb7f051f252bab2f4db5566bb9204e63b5ab317a69a8b4b6aa85f1b06e3c0f2e8e4d7761f2e47b02d8c00af0dca2352bcd3d725ed5489c29931573afc713611db7a7225df6d054a99d7da697d18d83cf4c3e5b330df2d8eb006410fc939430e5f02ce4d57ea5579fd2e91b69ed660963615e3e8223e35830826f29c43d40d2abc105922db152d93489b56d74a0b74a28ff749063d53a31701a98509f1bd1bbf9f858594d0c6fd58f88bdeb10415bec6d574e1189a1f6ca13aca7f9091cfa2c2f2737902bc3258308b3dac663e36751e976d3f3ea0aeaf15dabb78200345de54b9b0d08b13eff90419ea6f1ea870ef8f584f9e03bfff3cc97ed7fecde190f1b0fffa0f344cb04f72c3995d199352d862bcac33b143a44012b84045665248729c3bf6272542047247dc8cc1d11cb248bda2a770e63c097be24a7df6808a6933c7af7929259224eff879d2648b64b54327108966e653d95b41fe70cf003bf9d5bc02038cae26500b7677a5c759f11b0a58fd6929d355aecfa334554d8f7047202f87865e6698b001c49478f4d403fb77910386a3744348c9ff8d3ff094ceb43d9c1c827733b4ad713318439ad3ac8c57afa119cbb333a72131632de38451d1ff12d4675183ebf65f805c6720280053cac3fb27929fd665c17fd7faed80b75134d642807c14e39a407bf94c86eabcc7e12dfdf44d4d417e8ea4dac4cf09802b43a770cc809fc2c9d5556c805c90a80e40112b18c511e41453a879e3572a2c2022a552d656b0d17eabf503bb7913587603ca50092f356eec10d96e8298b46abdc21d32f288f300bfc00c69681708c125cb1a958794fdc922cce45d8f35189b1e40008d13a94a8cb2bbc67b2517a604c100c14201490dbb31ca827a5a6f1afb40a08c3db5e13434b03562165d34bd25137852eb74a607e98d0c723ee4ac2756faf6f1f72fbe0f1ad2dac4940c0224c149e99764b8b628c4b943395c51c792fbad5d0ead1aeec373db210142912e0051f4a511bc6a43247437728d81a610a397e6f122e5ae7fe6de29343778515ebef6149998259c440ed05409093db19a238aef4632409faef65ec07eda79ec0b3295fdf3d126665fa5640875d28d5c84732aa24340124847d8315edcab4f7f3e0b5932bee15043b2dcb6f2699d2a5c20c018385574bdb7134e0f8caec5dadbdbe7bab0034ab1000394ed9243d9fdbc4804756e25205a063fb62f03e7787f2c29a820133e45a6f2eeacb00d0f5b2706193a16b6f6c626a873ff473f0fc91f2581904115e4b80b28ffc433b75b9b4e04d6aafa8e1f946740a985e618de343c7df5f7e1a60ad14dda9114b3d207c3b1016b5bc3ae4a3b3661231e7d3b50cb90520a16cae5988507b40fac4529b10d190d5b9afce9820dbb6935c6b4c136e74e0e8e3ce8b544ce48d3ec57fca2d8c80979ae270e30ca0e4b075d2d5b64e83f2dd7bccc5b14d580aea19a7603aeb83d7910ceab69617fbb7ab14764a4c396bb2947b2cf6c139c22ff419c4db20ebcdde44b5626b7ab7692ce2109e2d01459f546746b13e552e212ab81fa10ce4808553e8f95bdef2f695f052dece5b95c5c7484521b7c9950d67d99267bfede3df10f4b70224e57458904435babaa173f4df7a6183716f05839840f4c087e6ecad2c3653142c27b4e82a1d0f931554c9f6bc0cfaa6f2a7ba61bdb3c3be2e1766499f44f8acd63a256e10778d583eec5bb773d8f4089522220528c7f67edf01258dfd0dcf1b5d399cc5ca78bd401f374b68cdd1be5e07b8eece77f4ba0c8ef0108040d605aac27ec74a0278adb871310bf0279464acf9938a9fe5e738be8a18661e776fd11a7aa9dd78ab3f400666ea1f134d4dba70fea10c63a6f6e816d9b3f7e33ab00fd9e2ee701f3ac9a0e4d939d659b40d4495223493883266d42cd41fe5ac7ccd0f8c5c25da59035f3f8febdf9d522a7aae3d336c152e3a60e2a1ffba53f51a36ee5d737fad854911fe1f8a1963bb41f25524c096b85cc3ef8528fc4c8f0fc1b0d5835107698c3c10377c7b4dae0c541c45d04530f7a2166efc28d9f9a4d9bd70811dae295759e1fe931c9ecdf13dab41657080b0dce2cd1a7611d267970ee8e51c1d1bc37943b7af0a379f025420b3fa58f7230e4a6760031282538337e4dc8a6367380998f2f02306471683b9f3ca5de7d0b73801fdd2f14a863773802c1d283e6bb74e69f47cb5e1b192212232c26cdded90cfb30d17aeefacd3c8d3d6733f37d248d0dadb7574ddc7a8f1361256d39fa724ac6a6c032a28a3069d38590feb5b31323737ea8dbb9fd3df9e1d618fbcc40132555ea64884dc0049c5b71d5ca727c41174ab98248b859a3fb71ce52574f9df3216ddc0d099271face3f5d56c1cbd1210cae4ea0159e89b5fd48c7024458e0802f2960cd877ce0431ef1556fbb6f53572e8fad604c47539bd5ea34cffb1d40e4e7cafae5be6cd08f7f59d36bfc14c0be86d4fdcbf9facff79cddb1a968f6ebff584c2d138e2f76a8593f7b61e7f4fe6ce4445fb7e68e7e859e9abf35168e471d0b01f05417d59110de1a13e590e91329b2fbb6da3556898638534547f7daa990275ee1bd976cc29498ab99cfd4f69f3c8738b95438bf86b86a1c7d1dcb321129b53f785e41959361a4b74df4b0262be3a18a67e47b685d8f6677f7a23907f776536c7c2f42f7c809b4b1df1814109563b154698424549e666a7f1d147b6ecc789cac08aaacfb2b01e73be19da52b67a77e5ccb0ddab8667feb1cfba077dfba4d8af09e81609b71f214b34b01e8b44505986ed4b69cbb36675ff0bfe2d47dff7f4a3a6c79ce892b9fb98a1ff63d3430963822516407ddfffb218557d6e0b9992c65093830ae8231384ba6a814fe24ec133abf64bef767235e6065c52429aacd98b457fd9543a3aa5aca1037a34bbb9d22b5f5c25598a628e54f26df4fe5ca7d876c6d1c345ac1b834f363822f9adc86cdb5dc853fa4e197ebc1aecde90dcd655b470535c58ff50ddd71b1eb9e6343ead4fa867e1c61773b37bcbf047583c7b172798ae186c552c13c4b9ce6d7a254f1d66efaaa448933bb83a8719f177b22c97b8e7d52c3c9f8ca9484159eaadc96c02ab54c5c0ae68c499dfaa045918b9b36ea3d55741146fa7c059b137fabc18e6cd429610d4d0219efcf0869852d57e9f82ccab814846e2acf70c0b7e8405945073c42cbcd102500b450480e39c2e2ae89324ba110defa38c9b3395afc769dda6cbed5ca339c369fcf36bf639f021fd71c2448961037e97cfbba08b104017021d65a3074a9934f3ade0323b973545299f10225f9d14d69e007a22a65775d627dabb570697f2cb56be3a43055398a0622694d986fbd12ad282253214d827f063c73e03468d1ec6b7e9d73b4f07cc82bd2e3bf836148b83b5e773e494d668357ba5ad249c44020a4bf8d2a18ba3e3d193d1dac8351fe5fc9c10093559219679156553b82af2e00e7bf202347ae763a10e5bc0a8da4d905d4d8d8c2bc3aceb92370785e61c9170dc82a90b0b88f4267fa10e6822dff4d53e2b41386eb4fe0cda7c396cc5faededf1dd5d6e7fbe3b889d06ad2f884e8d96ce11ce51e457a79ddccc523555cf1fd3c85485d0d729aad360392fdfb19b7f8ecd896925b16bc939d296a7dad4f709cc45f663101f80d2804e2c36e7124d72886e5ea36471366df5d7414bd2915d76a918648c5f2d638a180ff83db78e3f480df68d20dc46f94e251cfa93f7393de6eea763ec89cbc85085f6957a9c37372dbb1a3aef9e726285b729ff8fbd3f0c6cfeafb3c9130d5b811258c9169072d863f482a5715b8d5c4d5d29fd55b983d4d35a398f7b37d1dc53a73ad03072879e3d6a44d447e60d61e9180ef7d7ac2d26530fa8fafe36987e88ef687fb6d1286710eb21bb84edcfc45522d507ffe31639b1300c4508251b2211737a46364a2828c8c53ec5097591bb5bda165efc915e159f9fd0ebbe2fd1e2ad88e1174dff90ebfb116e2451b5018726ffd8a9db4411db2710454a227a5a8c53ec1171b13057bfd4c133beb83d27d046368d29fa64599d87afe23b71504760d4a28a9d71b4d36ab790fa4f84fec95dcb625dc3d59bedcca68e678a5cf90dee849969f3337a482b74d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
