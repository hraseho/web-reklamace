<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca9e4cfd57a6108f8ba8d0ee6e0d7db955dd28e26c35c3db0fe9b764ff31e03ec62fdaf53954efaa264e508343e954846ff776f8c6d90b84e418fdbc1f42f858c94e86ae9b24e817bb8b99d55305ba00294e1951272b52bada7817eaa7eebf5673901e83e56c77bf1b1c37991be4d1c24356edf1cd3dda8213c208f71aa3713cbdfac46e085dee57e7bfa0ada9d5256999d9c7f6249f3b5ae2dbd7573f42b70ed4246c944b8ef1be6c8870aec0cd4b7437d8e0932f5332207bb906074b36a5c5a96b39c9a11cf68e31656564f6466258a992bed1f0c74e1084db19eb60425de33ac4fc82e90d8dd6039436d4ad2c6c9ac36684699d89480eecbe045c96336c41b5970167a8da2f6ce558f9b25a26c86dcd8ed59f0e500a933eebb79094b66c5fdf71ff09c1c5650f5833481bf206e714c99734d88da10a0479c9bd68bf339052ae0c66c68dd3088710c4d9d4fddf0952c006ce9478e21dc4a85960aae3a6ca41c9b7914b4574ae3e8d67879a3dd0a8596db640c7eff8de355faaef7b1d6e9aa3d13da511f5e0265d09e87f6848cd90be289299f69d4cfa177bd048211f0fbc7d61a63dfb18d36c1f8fbd23a2a5f5c909e69f414e58d924e475841adfefbebd009a13b7b0ee6d716047a405362e89afae9ef361a0ea130a475149b8bda8b37691296ef5cc4261f5f0b2cb660fb03991390c206b683bfdc7863794629a6435b918344bd0398da24c76c6c0d6d79f1e3d57d875a559e6421db631f75df8e49fbd01119c732b3ef74bd5977f96b39df8b5019467bb97c5b9349eaa3ff0cee39f61dbab2c4b314da631337067bf8d1af65930b611a2316349f2098f6dc4e653a4561385b816a88f7bf233330c5e8ab899a1d3ad7fff674f6c74a6bfc90ef9f3153125846bfd3e9974bdcf01a761926c816b17f02d1d14cf398631645ba4a9a829b029ddf2308712c0b8d986e9af9e97f37c7a2d3d1673574963180dc70d0a766a1f53c8933ece106e8f0d744a60339ef3cd39606cbfdbdd863ae35cba1afea52f095b3712e5c8fb8532b4f9fe86d5f57f59f102836decb6d486c4b457f7a31f019b87297c9cde2fb3c7c67605fecfb887fa653329b2c16f3a2a4708cac7e44c748bd9d2966f95fd6a4cb5c1f31927f2278b5aee989c8c94e051395b5b4e538bba9330fd22e8a38a9df067fc16754e2869f02f2adcb2067acb4e5e1e9837d2ffaab14b3f92d736d560f3f285214a7936ef3249133390ca76fe8a52781b411245ccce46086ea3361d94cbcc4071be1c6a6125fbdbbdee9012f19a3883f15f117e96cf5c884f3bf908a9970c5576d177f18e9ce7b198c2859128c585a711b6718b4ecbe436d73b97e6b4ec3b7b967d1668887d8e424c5bf1a047b40b067dec8d7914099a7298d413bae5c811ae4b51aec9ed37cd9f0a6203650c6caedbe44256e5f3db95fee06fbaf6d704f02a396f6c9e65392583cbbc7928d997116ad10b5f701241cbeca405baf9016bab4dab8f83581b1d4d95a8a83b8ce9e7ba4552cf1a1b0801183699d97f51d5c7c31527ef3364badc1e144436090abcb60a8889544761a329df3ddd53d1a48e9d77e1e9071a1b9dc1be2a687d549149c215c4bbe434833fa5b51cc74be135bdcbd1d474b7f196d692ba46301b17435b59c8861282a8e10601e8ed976c25239450a15b59b286c89551fa3bb39d91caadd52328fb78648b936fb2ead6697fafd5b139a33415d45d7c06fc7846c308b2d1c9cfe11a7e38571aa4980aa425075b069d83ea2439fc6be5b3ffb4c46f9ac605ebc2bc3453e32f00d67c0e817b3b609840ef7ebd397a8e464ab3766d216f3ca44db2cc856133fc2569e0b5b123cf27d3d53c674ac16bf1e6fb3649e058d85fae15f5520082a4365b5338d0269753d3d383cedb997e6923d1efe9717c1beabd94b2c42d3bf141b1657f46323bcd6621947e6a9bfeb0406bfd4be84bbd074555dbf5732296eaaa176c85a0ccabe3f42f3decf7481c3211a5221cbfc17228119d5cd2a2ec7f8c8413b50df2d765e65aac7ed30dd8de0185d6ddfa687085f4d52e37c09a3a66fb57cb493d09098ce00a9f941b3dd6cfd0b12a8a4dc477d6ac160ee890d6ed41107af0a857f513f331ff23023b19fd9232590135c077cb07bb721c6fcbbd633840e6463308770016f74687439a32dcdfe930c57066fe18f0d903328e131a1962242edefecb3fc40880eab992c45927eea94ce56fac0fdb5c25ff2f76077d02ef28cdc4b781e7304fd7c53773399a6efb53c633ebf07adc880a75af6c2b20a7c387f6b70500279f68f26856104d14ba2083de05680c453890f85f8f7aaea35d90418b01d36258120f511235a800cdc33a8c7c24a33e0ef6ef56162ee1c195733ca48253d4c32901db70db1bc2eacade5e91950fb169e023652114ae0e05304a0945c8b7c6b4be57b2648550463a937cbfc4539f2e7784059c78f8b8223b6e825c67ec998d1b4a189fd0ce7ad630d93d857fe58879520ca184d25057887af7540237b4c05fdf43a039bc06118027f335bb181fded69eb85b9baec659975f6f5bd084e630bc7d3c3f02e850e4a99be36ceda987bc5ef54c358078e4cbabce4773dfdf30c494ea77df0651b770bf59d05058253c91ae0e87e6bd28dc9562198c29e3906e42cf09e11d0418547b8004e370bb6b06f134a7d38a37c1a4b4724fb75d88cc4ced9069ab8a66abe5ff377e85e69595b127acf96b3b4dceef3faf6af3a1cae5080e065354d984d7fe71864e963bbabebec32645f48232fb57c64eabc3ee7ed2d09a16c11deb63e19cc1cf058ebd1d9b0ec361822fd3d6be3fe0bcfb0eee408293b87926ba33be9d052aafe1baa4e88c6023053291132ca17f69c79f11155f8cd7af969bca44ad320df89aa9575f9d33f015090798839eda52c242b1d55801186f057fc6b4fd84460db89f355eb3667b36e74d2b0188bb227bf3063d806a791b621f593683d1d6a1849b1349eed795345304ac0f0e7bb2e03014c2b947dff782a2e8b01cc604f5e8cf3bbb4fa6537f4c871e88bd913c556407b67e066b7ee104469fe5625ab71c8760fa517644df8c24c7ba4346e01f57d951a17d0cb4fd9b06f05f522dc8889f894a5c13add984f9e122d5b3405bdb07466e3e1a2988e7e2ca0462536d196f36504cfe372d46f92a2c7e9834b127d6eb4ee73257f49bed208ce4edec22798b096d2381da8be557f8f86636d0dafec514e72170ecbe67f293bf05dc49578fe7f3ca1a4c94fadd571ee068fd12765e66aa0b95e1167fba9fdf1033229cdda8b5bb181db9ec646e6acb55fd2080c6190a7707ff4f35ff8bc3e08d53a12a23da4b1ccd666fb60a24663f89506140f51f507620703cf455f690ee410057547be1661a0d72ed9cc4c1088ac98401d8304b59d4ef056a27a5bae5c664ea9f659f1a7654edebd83c4e658f1fc00013fa43afe93625a62aaa375001681d440f7e8d7a3dae7a8b87eee89c39ed2e786f6669a2a8aadc380b7e1ca279044a9148f527056ba88e0f1065b603050b4ef37d1315621d10b04b1c2ddbfa5393c64bdfed3157f3f6b74c7bf79f2c70d77b8c28f88a9960a45d6fde6a556855269be93996ac0a568172d61b79d678f831bbbb44e98ebdc7465817235c1f189649242b8bb95cbc967b051f28dcd9b8eae1d1fb2b34bde778164a7c7b46ef6f379b988b417d4161f62d4c3fb9d5ce04e150259fc70b626eaaf303bf9b499043cf478cc5a18c6cfb0c1f719d15dfffca68e7500802aecd3920b71a7b0f028bca10d9368859771c6f3be07b6ab57df3859491931eb5c0c3129b19dd96e64ef35f2ea7221aad6af572fe0437f2f10cd7876a5e3556cd14e3f1c77bbeaa77f6fbf0505adcdbcafaa7b78940be0db0e7770632def4241b451e7b091b36a650828bbcc7d25dbdcc530fcdc828694b2c9a8278931db60fef0f3b471122e5e89529eace5e39f44da18f6716e1fff5b98cb114dc583ffce40337aa77f4cecd7df05c5cfe8169d06ed668f524ce8a414b0d37dd3a7ea58c46c69e79981f3bd18125715066c8a2c25a31965ac95c3633e8eaaed084883b685e156119ebdfea4d72a3e40c5bdb7e9efa098dd0dab1f8b9c5602237d18eb695e58ea899b32c4d0e4311c97c2dc7a390fb6ddbb867cb851017741bca8596c55734b507133e19ce6f0afdb0cdb2a7920d043f7b3ea67e3c620f8f38701d50170348c8ef2d26bb4e955be69485788c747c8397ed1ad026fc0b1f9636dcb93429ef0f09ba522790304468b3508030646b5c5528e9e90d0952e28e641c33e38f38ff9b34fc092cea807cfb93c7fe14cfcca6bc4132c43de9300deaf1eefccb7ee15c66731f68bbdfedd146955b0c813239e52490916c491a996f35568ce35c9839bd840b16bfd30c5f3790170e9b37deaf55032c44cb7db2fa36f578545db634bdba9cb528ea3cbc6eb2b881b6bf762aafed038c137e53de9787197efb87e609dc4cffdf4345b20a9d56239d733816acc1117500ac70f19a882790696390b64cad2eb31af3324c3a54a5fa59d8de703abc813795e33316d43ad0b210876982f8273c8bf4788521324e0cfb0eec70151157a1a6fed73fc87c44c52db9269371e8e5d029b3581e118ef988d8ae70a36eb4246b9044fc61f081a08851191c072d4e58702ead9ae69cd263d74397c0d7f43a83fbb2780ee2adf35b6f4b8256b5952d1c12503004837deb5bd1c055f987f5fd86f12e497f65ed7afeda2a29c955499373b9b46165bf0462de2f38478e6e782c6abd29f4c10f5bed40a39ad857b06083313ea08dcf75887ef51edc65242f899ca582b9bdcac6a7c9c01b07ea4f4b5561c7c33c86f371296e68eeb739e28a0305a8dfeeb9ef0c8d737386d3b47d7866b4722e53383d3e30e9470bb3f6a930d578c311d704f2d7b42eba081faee631c80717fa1201f67d2d70742675044d65818c0bc1227ec085b8bb88714328759f06a54547387cd6371a8cafac4fc81a8110d1bcf1e55238a250cc64a82b12ab861ba5655a075af6b5e0fddb771340a75044c8cb277918e404e2199b5308a7af34991b58d177276e21c9797e2828a55f161a2ec851cb64416f1339e838ed421a9f2a2908712bcaede78b088365e4d56e537d7a54dfaa04c17a3d4293cfed9977cbc06f4752c84209f4c8f90648134850d27fcc28b657c67fa09b54bd1b8dcc7723014063969296ab545dfb51c7a80dd07aceb06d76895279815adf48dc6cfd73e5ae1543b034b94147e69cb87f212808bf187bacc46814d0ca14d07fbe0891713e0abbfd15acc88acd9049b302d47419a5ae1207b120b5cb692dba1652aad71037917ffe756e874e71160e1516fe8a461e7f01208664ba171936596c9245872d46cc8f8d9ae1f7c30d2f83474973bc58596c88e1b24fd076f78e8cab360612c5a752a2267ba7f2f5df1a164aeacc7fc23bcafba928630528abfa8fe77d48b912dbd8fe6d394422c2b4669d4fae9cd938a1dd7597139e17fe1c9dae078b46032110dc35a77d56848b25f892b10d0b0150d407ed4a98983e93a4e8aa69b9400a376331655efb009b58a0b34570cf24bb635e0f6997a49aa7d008f307b78817e4be0a43a03db07dbaac4f4628fa13559262693b1da160d68da1922168f150ae9c8b1713dbcc21821bb5849444503d5ecec0a75f748791cb1c9b5381a4c72b248f7a6509ba9334ddad50996e9678c8481b261642a6fc4675d8e02cdeb2c25033aafcf94faa22146351f1fda83be06fab7f94a47e9d989b2548d1516bf4bf3a0199b22cf64cd3df713f6dd09fec09ce76a5ce33bec18e8b65f6824869f0a7f816ad0e5097f1af93b0d7dcfdc11ac9fa9ea599b94e02fb0ef5313c0522402c1bcffe31802d141acbdef8256124f95ab030c6d7eed86565260b7dbeb74b3b23e4122580c8351c13adbf5aa60a23936877f6312eb59ed2fad614bd3b3a741ddda2eeadef8c41235a96e363e10988b59ceb328f570b0f9f159e3700d1fc8e31f3bc1286e5144bb96ca842b055ba9491c2aff49d6b4c8c62755d7f00a8217dc1d611124d96e20f93c1556a645ade38df48a87c31047f33cd9ff6d501f22da44ecd83a99dd2d241843a7daff8a2f40f33360ab2f1096848ea1362dcd09b7c8b480399de2d47eba4f149d13a14358977f20fe6d6a2782eb81a7d6e3d7bedb229ec70ee9cce421ad025b303623c190bddab386443f7ff20caa89fb26432b7de7d81342e506385ef81cc2abfeaa103fe94a94faf26728e20c3009ad8fe735bc650a71dfa041bed421e9353384996a903976199768971e95775ccd5c65faed8312b4b879a1626c6a5103a6238c5d2bd1c89d89e5f54af5d7c6a4e64430df5cd4ea0b62eaf5ea558f1c4b8c594b3036dffaa19dee1d3844f362a9ee7df87b1f0fb9484405e26a9777eb9333a4d89fb6c6d986871c1de6148b1a8d5e90ff38d33bc05c91e974d20c8770c55f6f21360227b10e9c6a6a8ed5e0370f2f65cc299536a330b42f234cb4fd01aea00a3ec811bdb3283217c8ebb5a90ff3550afeadf7af7da125d32a74d47770c86046ba2cb282929be4533ca1b0f9fd82f3b311e56059060d8b68c731b2f895dfdb4e32bf22adb9fdd9c76b4123a49273e1a2f0484d9c3ee7f0a9247c250f4f3c00fc266517ab1bd2461c8c4cf9e9351f1ae827757cd64fa54569ff5e15616a81c602e4f695b670c31c27daab05442bca5da289e904ed954f221cebcd8c9280196d1c8c9443fb9f4d31a2df8a0c3dad249a5a3cd0b8af1d870ec90c3901a48e68b350ca7afcdba8cbcd59e890db49b79bb2a952ce68d592669b5cf640b95865959902448fe301d4f26ead12874b42089ac800e07666728792716f2ee0770e508f4c81519acf41da5133e2e4d8be9a04b06c75a69c75fae9db371781f5972f969d1c18fe8fb454bed340bc8a95937520eb509efe03e8c9fba3882a5d98b096e94a0be71a5874f2955e2e83e60e2a64672bc277520feef011818e7687ee1eb44dda8066c25d95e9c9f54310e25b4f9a8ec39b02b754daeab40c688c4cf06e01ed431993981772b93637cfab40608a0f2bed7ce5ae9413159608af9470068cb20ec18ed5ceb667a47843e3bb49ca248f0910689eb9d56f1aab308c9a11ec9319dd5c9856f8a5383223a3c826a32879051b41e4a2497843d31a34368d5088c1b154d7f12597741d9732df7d9d62adaf2304baa1d5ee140e71bb7ab4b327c52aed569ddef5fae1b652949d686d42134ce664ffe0b77e0ba49fe04a4129ce5f50ad57d016c94f15a9f4a345239aa49a30cf60e7ab8a6000de4e3bd0ecba8d4481bcd7199b62d327fbab61eb7306ac97a6bc31f9dd8f4ec64e9a8d1348fbf965594fe1da05584ad35ed2dd8353b2ecb49a2d6777939f51af290e91d4efc94de4a5658fa99b305e332a5003a03ddaf8dc909aad386691f551af37367eebfc074735b4abee20f1b45d92339106a97045f5bd42f05ac13881f00e4067feef403f548bd5ece72e44b6ace14bbca177b311ff3e4f3377d46f9ca0102df79a71348c1028a4c26065b857b34c3bff08b5144fd04963d006c56c64df0fc950431034e781ac6663db640f2b6b080a69d1943ccdd6bae12b4945ae9f332d82d3685877febd50db55dd654f97e3536bf279806b5e5b95eec3699db1fca328761557c9dd2821591257148f40fd1b70c4d84e01ce984ce608b05b00b164c008a769b2ce9935bc2b1af01c015bb1738c02739fec19d40eb05fe258935b398f68d135a016fa7bbeaab2bb124cde303e5325b1dca980a2a62da1c22798b61d6abefafdcadd9c1140f2e8d436277b6c2b3b230cad52d23377ed4bcd6a4d0c30b46884c1be428514376686925bdf781dbb8a87444e5465729ba4d73023015476b3e2802cdce3df2d87e419e0c21aac9d7183a7490d3c4fc945ebd7a4af382aa7fbadb76e3364b52e725ef428a428ff843a26696deb80e6c95be96ad4118f00988be713d579ae0fc3bb9c8297bd65a92158e3a0f12328a4f089da48747a1ed00fb03f7943da54f0cbf4bb741d33821369c83cd020d6fc6a12911fe6964a6735a320effc57dbb014bd97a1f1608620eca4c22b10935bb7a7aa515fc9d59d3ddfb4a47d5d0775b25f4e9ff35c7c5dbb1f4a0f4605e4709e1486d391d253d881671872db366cf1f462b04b5211d67e2a54e513bf0473ad99443a622a018508bf1c73846758851bd6ff3f6c4a8a3204efc54d46a0c8c0330ba8d03c1c4e49644b5c911ffab9812d40d8faf507a4477f9d2d47499c9de3ec2094c11674b0c6c520dfea81462591e8e5126f0adb4a06271af59cc439639b996d20beb71dfce1e40d36f093b794847fbbcc685ffffd84455429fa6ac2fdf06cff20f3890bea7372ac6bcdfd8a9b2d47da5a0c20231418581a598237906912a0e93d787e1615279f9dc608143ebba8920aa86879859a27bb3b134c5f9ce2181311690092a5bfdd21ed27c51f96510b47f77cdbb50a6c917fe275fc17a9f28f0821a48fd5eca5a4a247b67f136cbaf7836cbb29273b7c8f7f4dfedea224166c3e33a6bb30daffadb7e6e8f7d1201bbb3adbc04d7575e7bc79c46f138b227a44ae067bd8c30a6b2a458a8a45bea2fc2136084901aeffc79b2752cb7e28d872bf0c7cedff5efc242fefb867776b90c422baa024de8cb787b8e8fec480045dbc50255549b548652204e6f16ca92792efcbdd2476a6c2a7e521b0c4591a154aac5737ea4e6e3e16f115e00e950a188656714d1fb5078be3965c91c372e4e7336a2d1b84ca96450b470afd3172de130561bc043f36b6d7bab68837a8d58c9b6f7dcb877f9324fa3cfd4659ca78fd34dcafee77389b3bae37861d65e7a0b5ecf0022e438325f22bbe976ad1632a5cb9b409ae31af3068a7f7400b13cb241e144b4ecb2ddd27e02b6ab258e1f72f16ab2da2dcd2fe66416052d81bc8d59619c2c24809afbeee46c38c14951ad7f2f17e80f8e3e8edad10b598a82422ee6a555f03ba6d726c0d308b7ccd9429f7209222f51d2d901f87ef8f7bbb52f06a9fd1a9e9ca6786c6f53cf400231334e525ce745723ee4b6e4a6d5574af1c5bacae4be6b613ace562f26941d0bef7aeed7d0104120b08eca16a1f6f500e7e1a8acbf5a5758608c2b488a192a1cfcc2a07c5552a104f2066579f8f5a8fddb9298a3e767eb5784e552a76fabcd920e637b283f765b3e365db9f43c84c1492f6addf24ad79eb0b64772151a8e68b0748b7cc99f6ad3ce39d9205b4296976823dd80e1bc43c77e7602b49175924461a51445fd9d8021e7881d6cddb61e7c277a708de28adaa7765b44fc5b653a4e898366c6ae5882eb0fb308abc350b915c6ffdf422561dc5bdb2aff30a5f09b2ca743134633e852e23c0c37ac6e485f1819a99a607f42df919df7d0232b33b9888a3ed253a9e30013182e24f09909ae69622d28f36999a5298be9e94169c25d43a76e00e15869c627dc64a4bf5d60982671c6d4160dec34e6def9e8d0fe1f0f876e59bf7ad38a34d83780fc6971a2616a62079ff1263fb94326a480e59df508d7d311a78739f43c3ee125e307f81a14f432747543c35a6309b3677c0764e9290c050738338d3d85f8cc13bc523da48e098d700312df7773863d674431679a2de1bca1d53b8d6fe59a5c2528fe0c85ec4083b3f92f435a334bea1c84ae351cc95796eac945d194901ab99dc9ee7108a74cf641f0bef26e0ccc7abe4ac387deab21f93b16ff77a27f371c8a5869bdffab1578fb779f1991717faff3ab31fa7f1fa1ec6e89a9e407c30ec9e2a71649a2aeaedb3e52e4af9334042f07a92f120e0e83e6e95f4a953d1eb1b50ed11ed80b51207644a1b340a1784eed2f0244c79566dbd43fd2f3cfd6bc1d71a4a6734194b055770f3b07f70b82e7ebc599ca40885a061828032af57cbcd1d628effe97e7df3e651cf6f318e9d158ce95489727582a43278a87a0cfd4c5af1bfd73a6b153bdc32e17b1eb53521899845f42fa0aa3ba65d96a344018915108c107ec0acf7bc0d9fd6ddb877731020d9aadcabf84cd70b9b00629c9865018080d0f5551e1d491f4364bf456efd49f34c8a40c9456f52c26422a5fdfb48373695db247a1682d85428df0ac401640cbc00a83735dbe61f3ae3f9f8f8dc626de5d383b930d99a33c4f94811658b5438dc9fd716e7a7e946091adace105ad0ee90faa26390f595ce98dbe1c9c01533d50a581662c90aa3b7ed2c001036b504634a52ec3f8ebeabf05f698a5829d3fa5b2a423e903841d9908bd1a3dc3c19338223cb3a00c56a71e6964940eab2713a98eee004b81b95237d03c469ef9c9455dc8e931bf1a1aadfdf6621ca248b667dd857b63af1b9bff14ab2de7cb8d83d22361e6fcc5b622f9be9864ecfcd021a9b590dfcf2b038e0db44c813c148446aaf65d4ada9b190051c3aac84f524b1f2ac441384978aec3212ed0f79f1c42f2f4578c8dcd294b13a4ce0e4d6be9b15902e58235bd00275824fea99b9c6dfa416897a07392b5e72bd66807d86ed676591a05e6166284908fe5d507887104a959192f1fb504d1853f3d94f7c71a244245227553d1c10538f4a10fb4645712b54857d5af1876a3294320ed153701df643298e0e31526fa8819f9a49d737c50077de8a7f1f8723647ac35a8ac4ec809599e2f3dc19d70bdc851e676f11ff6cbc48c0ed718f1fe90c10f2d18f08c98e1fe65594357b4cfd3077064b1239472c403872e2d1c12c2f0d09c627d3946356bfea1a55483311303a6db7128f93c608d92beecabd975ed2c72a1855181e80eb56ebc78adcba2c0d2c5f647acd41eb31b0ecb57affb90e74f2ecbb05a08433e78ffa3b3a685473feb42296add888d272d847525ef654c805d0008c7b011588ab19cdbd9bac2c5229c378a547e4a02f3f17c39c7bbf860ae66d43a34144214079c93ad89ff8a083ca4f3e8293527e96f3d3caf726858745b3d67420ac95e6d15fb33ddb7b15f64c510d40cb3b0980371c4a8fd1ec32a57395ee77d395afea313d3821c3c41540712e9873beb2768c260cfb1eb803235c91b21f5562beae4f6bf95098a7b3ef6e5a2a588cc21bb91319f210e9023baa17e5be0b618b3244f057c4fc5c8487bcafce23cc50d77e4df386cf797be0855bb5211d8a73d5ce1206251335a473b0e3ad4bde78ce7b16aad4c38508e3ae02226da0bd70e5d9da303ac26c277bdefbe1f5defb78be57698e525bf1cb46901a872b379867238387836242c3e67944aae564826c2554559139fba6a1e0cde765edfdd4df0c47f66fde0cc0d8dc1e5aabf69e35bcd687f8bef0151f8e1183b4e1261be8c4c9c59bcd52c3d06a6ab3e0e597f89a4f1325a6968647eabc92dac582d8137bc013cd36a8229292bcba2a6360153892de08a65ca5c7dc771c16db58914e20abafa073a80ac89fe9399766061a944a7906725e5b4f3dbc7adffcb371fda698581285a6df2668dcb6c45ff60cf22ee34507db2ec682d3761415db0199e7fc8a8d4ef61e9a001e5df6106a27ba8280e72ff0ae48a46ef512e40b5308ab53d52b8eaa56b28503ca9b5cb6aa67369d76cc61116445f459da019b1d30e790df53902604308a1172ebb894799d23ea0f04fc784cb6c8e82ac9c65d31da2172b0fe444b7eacc8268d879b52450ebaac5aea088314591b37c89e31d3ac1152e8154213a0d9229c0165b0bf075b057749fd6062d2cbb181278ae6c8a76f50adf67f0438ec62783ab570c55414660f1e6364e99abdcd744e0b08bbd49f2d052a01702d27d456f7d0d283c1c7300de58ba707849c78fc0dd3fe37365fb29788402b05f9edf99319b837be36139e752634f14e6da50f52843ca057d2b492355a901917f8c4ebaa0a6383ba08502e78eccbb6d81b858e5fe06bcfdb8730d2436bd6b9de884805fe1b1543ca39178c659154db99620ac3ef7cfbf45469a98f2a39e7a983ab7e1e0a68fb9f2fccc82f71aac06599e880fd3a036fea3831a7a5a3a3f38fb03f54fcd98e73fa2951998679decb50bf59b97175e43650bf5b6a842be6aa0d79290786d6bf556512522eb25e24f937b974892e6728b65c925f3f047fa196d12f29a1b32bef48c9cba9e5927c0f6e85b45a061c95bb80979aff2819b91181b07475a1e0b70fe2ee0c057bc3b0227f17290ca084c1cbf503fb9875e4ae3d0c0f1a5b4cd4fe4ae061107d3eae8f987dfa90a0f1bc124d4c6723ea8c9d190e71d75d160c3f89a521b52852d9c388047ce15efe8ea723679f471b7202ce8dc736d143506ff477a7085ea3f3b95cecdb8f6645269be1154792b35251fa4ca8e6afd892ca3cef69ed29fe1777dd8e8d9f70bc05594452d46523ef6f9cdc956d4203d8ad8e142294586c7a1a4e4e721644d075fcbfaaceea48e39ac6c179c85bb948c224107601a8aff7dae3614e9fdce91da6b36c8c08966768422f5ed9f35b3ab56fb43209733c8897e1321d937706bbc27a9e7e26e25c8917ea5021f1f6600b44e4dfe0ca011cecaff0914a7dcc9678c9c35c1ced0d3157043f63142ab7b91c059f5ccfb3baf3536a69f045f8dcb71b5ceb14efe1f022c152a3f1beab32e27bb9e523572d57051bcc50c5db8a7804263361d28d5d2c810f84f669847da7ca2f73bf42e64d9187a959d7d2443bb95ee86faaa45d6cbfffacec7087735729448723841d391a33bb35e8821c808e25a38117f544c66cacb4016165aca4130a998cfd2c0a228f062bbcc8e718cba3fa05227c52099382bdcc0c4df4e5ab166e4751cf066987c9aca0689d5b63d7e947cb3491dbd919cf812cfb588779634655173fb9325418ef38f1edae9d682d4affb9d19ab0976bac0e47d39df930a885969963db731d98481c58abaa89f712735ecc04668fdc58447007c2527c1168ccbfb2e49c5c6ae1a27928f1f8b698102a170f3883092694207b24ec1cdb91dd60e8cc42c142097c97a7f141f6ba0a4352f931e34ad04e249a3d78e647b8dca30b88fd5b10d504a62a1149a06491f136237a616cb44a158a0cea07c7e73ffa77b4ae3cf7db9ff677feaf38501b716497dca031935b7998ef0f4af290bbd7902a003782dfb385dd5b52641957cb9848dca06ed0efdb8aebcf156d397cf173726363920d7fec218284343d5f597ea79a018be54329f8414ba95e802a3c07dcbac041bfeef07cbb977b9c3a6f8077031de350561f607433ace3ebf2d65641889be6734455468aaaafecefa6006b10617e04d419d12804c9ba46b1902c10722fba89ee842232ba2314daaca8fdc5b3a6e89bce49e590dce629ec0f8e97774aa1584555480a97cd645a7432355f2c9301cb0c34e95027f14910f85fd6affb6f3650e72b4899d68a7702e0548f620015879a07198536f368204e5ac5d603b0de84553152a4cda723ea32c01bb89eefcaca8d16a5e085b9b6425d68b0054b304c6502d5ce101700b9b02e407fdfa9993ff1c9ddd911370542027bf8279d82a5ce5ebe4311f26af8d6aa845cdcf4186a9ef4a6c9d69f0891bafb2247bf78a653e3b40806afaa5495a651f6bed96c6c45726de66522ca7903355d706baefd0bb9462c88db1b6c7665b898800f97660f0791f55ce36e2d82dcc6b11bbb0a4b2188b9e024e5284b7d5bebecb1a6f5be4a32cdc211067f692c0a222b88290aa229daa212f6b53bd72250e07ceb2055b6152232d687a313712d67ea02634726bebb06f2b94454cdef343ff9c1c232dae8eaf25be38bb8d8fde142461bf74a8704d53b68d4e7756594f081818709a64dcf478148c1a8290bcec089b08f10e176c7acb6670c646a71c72a555b386df96e494df5ffba5dfaebf71c096ad86022cf42dd632d81bee7df59e56ae7f002040981ac2e0e8811e6cebcbe88d403d1562d33c2761adc21f34dd94e7eaeba6d899dc067ec62574fb3721211577c072cb8c0684093d937991023812eaa0d28afa14bf85f023561e1cbbae909be5b0f592c1d74f5f6d404c2b38d4ad63acaf7fa51cd5de14ca9b01ff84dd343fd22712558e5312dbd4fc5250987c4c02f7171f3dccdcd6b18959f31519eefc9a1a5c3f886af8cb2b007526d1c45f8e63b681df277469e8b1f1fcb34b13edc494b9ddb8146e819511e3610c6ac20b30b902493edabb845873eac6fe4798ed99c7596918caef52e2c0b7be4bec6ef8803296d4669e7698ec57e3a834821b7c3d05e162fb9407f9cdca480c548e6aa52daccd6f18aba860d07d885702ea2fddad938f498fde6763dacfd8213ecfcfd9b1a391c395b00bde41af62a8afc1cf75dcef7b56a9a015d683481cf8c0a89056608f0275827cffa747c22605b2dcd7aa3117d9f92b2484adad0c897173b1eadcbe6b96b7ae9ee471203f383f71f7a2f6504a179e1a21db3e9a9ccc917818065056a3b25ae6ef241215969bd7a917b4306c09bf3a1b57ac3b7e5520cca70077b6c69c102bd4f2c6af57b78528856130e6c6fdbc8ca64e3ca2b26f92797ab1d7469ac86c3b6e29e503a81bc78e017134fab89d4fcca1e65a96c245c4a2b43543393b0e8416e29b756726dc685e3e5e569416e71e043494ba5650d4d26c0d4280f9344b6f8a70b24ec71eba0a9b786bd13454ba4d850cef5f42e7e758a26c1a2896c505bdd94ac2d5f4814c51ae5df6b374466ddb5c3341297f9dfca063cdfaf44a864c6fafb20815330b57a546771060523011404b94a562e2509c79e1027a4af1cc38709edd78f58353adfeea3423d6559e1dfabf579b43f1905023e5d4fca00dc3ff7d8b1999112955bb466f8539a378088c6852570a0c4f6ed7d52934e77700b3463acd12efa8c4b2279fd7124470a7956b2da7dd6da6d0c6df70c5e83131e01bdf490969f57c6d10c7ee1d54af1e70b91ecc8460e27c2115f2505318011f696a9e1c7896f6e2ad824a15b7676b558672072e9e63b1e9894f65c9e81ae2c194790a2d90314a1dcf771dc98dad896784da868669dcbce88aa31d7f18a887db4c29ee888a855a1fd8045e011825086cb251108755abecdde4562692b2b321bbe9cba94266695cc1194e527622fb1cfd971f67cb9bc75449a02f463fab0219fd304e13425b8936090a329162f0265c9e2360c25661587d552510170cd78e42378ee64406a8ed904d5f02cb5fac0c11629dd6d3e662a8db94a742fb5597b6c1d5c9ab7415f17a1dcf5f7bd5d7fcd00499ddd5f497ceec8fa58a2adcfb175e34362af3e5824331411a1d2ffa044ef32201e4bc432da43df74968583bc5359617947ac8b0ac725161e329fbf1a10421ffd2eb21cd072aaa14d3740979daa226f4ea3cd8f99a1b2aa20a0970ce717ae752cb7968a3e5946a936be9a1ab0d6d8bf563124be140eb5d769e6a47dba32a145dd4bb12a71f3b899ea32da30d6cf0f755576edaca4c8b0d85aab407ac8b66ef9db9355baf243a4f5218631812ae47ce0bca9791e1a5630f5b462094519605810392e99bfa8677cb11e6d1131fd7a514aba7e2dc3480f26609c4042b0ce9a84847ccc29ac39048c8b20b043ac801cc3da4eefb078d59246d910e752f22f660798645b6a7f934c878ea8a08576c2baf2220a59b6b9de35d5051c391ba47bc3ce10fc8e0abdd2beaf7ee9697275109526203cccfbeae4b47de82dbf6d1aef78a1b7f3958a7338b8ee6890c426c22242b8eb9bcc43bb8444a04be6c6a3a4cfd8f70b8ab3e40025943e0e6bbb771451794fe6ac5d90043e16d4bdda91bb50f92ee15185519dadcb6cfb6600d13c0c8186839ee3a418ed081f0c493a01a646a4206607609352d97ec479c7d8e30e505b712b11d028a5c48d0190f6c02adf4f565cf211d377acdd46288ee7005e2e3c65f1cbfaa8b1406929e430db1e7fdeb51c368a8433414f67985f282011f5d6b1c33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
