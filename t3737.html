<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c114773bfbb943c3bbd0c61ff1b2d96bb8f50e7814fc92515a81d15b96e9f91ddb85bf3a6c07abcb0d42ef2bac8c043db6a26aa1872abf67dfc6f29dbbdee4d59aa039137c11b6fec7b08f3bb05532955d815a0b0cbd2f04096e7b224948e6becb8d0c9869ed7848231efe90a70d4c4009f27a76f50a8baffde39400a03f77827ef85cf2d57822a3aaf827e5aeb1fdba948f8e542b5a1dcc878360eee20ab30ca889b7f0eeeff417add076d8d6dcb52af9e876d14b588029acb6b41f78a5c9e1c3e0e7e0e59f5c70fb7a01d142d1b1fd31111c1ec8542717f22cff8ebdb64be3479857ffee090226109f72c47371d0761288cafbe852b8bd284587b9a25e8c248736f736850e2b5592b1ca90067c2e00eaf345ae2da6b95b5234fdb7868e6d6bf6a28d83f6f2ed97fb50a1fe56b12740c13b0178c4880a885e3245ab9ddeb1b674083517111be810b603af048e3804bc78d0360e1caa507a3648e17b4c6302795c96822a884c2cdb3ceccd3b2a0b8d4ff996598bd74aea32c96872b666379306fd7d4c726405d7e23c69cd7ba8c88e599447b46620975049ac9379bbf134404009c80c4e29e40dff9fc4c6a0309cb3754611aca1833bfb7f734d8848da4619897f212ab14048e507ab9ef7860880eb0d830b3bfe240a9b0d15a5830306ce8a133218508020a7d564bbaae8fbad9c1af1b3fa1ac5fb711381a9facfcb8ef986170e338e66de87bd29ec7eaead66ccb42167820de275bc33c2fa80b026d0b76f6b2b76ab0aaf6b73c8d1ab964c0f1c1eddfe294633d4ef31898d168f908581b7abb0d2f82688756c33ddfb8537d991be003371a08c125a746d054e47047a83d858082ef7b4941ec087ce4f3da11fcfa2cebea3d2c7b36eb722426d3df612cb9bd5c8bc2fee73d47488ed680c3c21ba9e17e1677b4ad5a6726cc02a1fa19d055b45607b7fb2b5023d2dc2d886891b85094c2147ef94993eb5fbe50f49195bcc36705bb7c79a1220204f2dc86f0563b73b91fb0536afb2ff0665c497970f953c3cdc79f2bbd6ee5bd0b3694d965d3d491b5f593396d5521b0892141dc3cc6f5b4fca8a2424241fba6621167acff79f712daea64647c17902a6018da33a5b0091a255099dbee65d32ba73528c56744c56a4c77a7062a6a7ea6bc9c16019b8130cba5e9a9b814d824c3c142ef70144798bd10fd9af120a741fa65e45da49ccedb18a87f2999f1991dba068eb6763315cffc0bf6a37db41aab29d27a4c9343d35db01d1030df137e2d86d2ffc617ee89a3a5fc825c56a03fb69c238ff29d1795e57b5670f569863c4540b65a96238e1063b5beacb637515a40cd002f964fd848ed79381796c30845cc1a6b094fd344d8dbd7f03219c4ba5b40efc3c2913bec78ca898df5d3ca6310e83f6742c8b1350420e6699490660b45020c7ef32f6ee4d6d2a22dcbc6458d85f49bbeaf152c1140e2936733aa9a881c760a9681f39fca240f5d35ffcb06094c1065912e3b2296521d6dc831bbf328345db9b1277e1eebb2bff83e7c4f7adb33e0c2f7365be01ab4f649219352b699547d7bfde6e85b6b3ad9e8b96c8d4b716f1ad936181a0eb815b022563ca9c248e58c45e5f5c9a277858f465dfa62c205dde15f1d4e0357e0db5f8611cd9ce5cfdc9c76475fe5c9bb938a2ccc8c187011f80629484ec3eea9326ccbd6cb57b5b3018d4138183578fb3002f07b536469c03c80a048e237bb7961fb32469f85f852b3e8eece2800c6274edb058d7646bdfc707ba944cd8e9d64849aa3b00ab2962a21acc5490a92e02aa4e9361a4f29309f69143d0006f8e86c44c081f86cbced1f17c493a26b87248f2c9d78f525edb2feffff3ec90cebed927739370b144d90af8d5a03b68e8b16a44573542bda2527c1932a33adb4ca673e35fd905b07c798feae5300b0f004ddfdd39980b00ab20f315a8f7084a65e32f518472a127e3aae34dca124910f66926970c6992e59b2b620ca0264b2e43ff30aa5838cbeb63e9639ad6456ea2039bf03dd9b6cbe68d4d1e6592aae03854ff306db757a75bdc342342aa4d6ce272e60571c5cd29775b4a555a2f88297237127bc60777caae78d00bf9d5d0cd69da5997b5f30112ac147c77f68a020cfd00f2aa890bdcd346d55e65019cad539b5eca0af970dd24067204124e0eb248d476ccd06cbe50e4fa8cffa9ae917c64d34e43032fe159b07e6b8c87fd63448c5e00165c3a66157a5fa9f88c22936526088862f9c368313d539f4e987446ec93757808e1968077a7eddce7341d1737dcbd9f7e7f406a45462cdd473e31bc43cbc8b1d97bbaca6c5f072d71865c517db6d2892464276c5d49c78bc59573777678e1b2850a4866a41238c34a13d23852754659044903cae0672f208348d841ff240be81667f9ab36b8e9a438a867c88011c9075e944dd95a6512a2d11b6fe5264855a02fbdcbc8a7c3d49e5fc87951e407acac96ac3092d98354bea27a00a1217d95665d5967ce3c84b8d370864fbc42f90f8648ee8b56f235ec3d82f63866610d96af4070531af5a9c97a52814b520c077d7fd79a6c65acad62d293db6d29897be39772ac569b6ecf5fd0f6f4f477ed66a67baeec39b15b01aae2d34794601b5a1c819d7919eb4afd7a3f2aa814ded7e2ac87a66acdfcb74feb1b6d0882e4a15c58f0bc7022edd3b46c1cf4a5c81937fcb239c2a1e5ed1264f3d125e79cf6a9eb6ae3ceb21f8e3922d67ec88a0a4964694a1f3bd0afe89b4c6799c4bada49f0353c1a1216081e561694015ca2f30583070c4038b745216023b295fd5aa6e4ddd86c1e26126a7231c63ab8bcaf318754b92adbdced984bf9120e54e4e17816b23746fccd2816e9903a581eb6433c0c511d006c759d724f12342c0fcb7a6ec402d56228959e9f48b24e247ae84d68c0c623aef33d66e40125fa0b0daa4c0f3b64c6bb69869d119a21151c761041d2de5a25de8e36928c28cb854e6d63418a57133a889fe503f7d58e3d1f1cadbd0c3922f14484f9be231d3ea534cdb7bb7e5e945e68487ed69726284fec1abfcdb6530686bac797c3aa427add8f8da4162f166d7a56c5f3314f17f1e233c898c2813857b8336b683ca2889e4fe30564b228cc3e62b8505054da588182c78634e4a30013ca1e0e1ba8718997d8da6794166437e3ebb72b2b076dc9f93fd6e6b4e4e4086678e86740e01b8355c0f445798206cd2817e7d51c509e3008ca224b8c8f928e820ca4a3ffe3cb0333297b73ff996722f54e8ed7c24bde2031750100a5ea90f0f7702bc95e789b79777c8d1b11e714887457bfb3087c138e3ba19b164d99ce6427425ebf420ed4305c146d2b835e913e91f8f7c6b122cb2723ee7afe3f22d4c905e11982397023fb8f95454a509f802509250f29e18133f1014ffe9c5af39c03798aa69f1c64c3b581917093b17aab1a997864effcc84e712b5354fce4b1ff9ecbc35f3d77e11abcc1cd8f04a7a1541eabe95452aea4b6ee3ae6dd2f291bf4016e99fa442383bcc6cd39255cf63d7fffda619456a8e43d74afd36627c2721bcdb3eecda73652737400adf4ce72bc6399a73a23cb25d26a5f1c1f5ca93bd6048c5301bc12ef09413914807e527f68989f578bafc62f39e7064ecec1654088c9325d824f14368dbc9d1c7d5234ea247874668b0d6fcec389852fe2372b5ce9dc0ab3f53a834969572e47c4e1be3f9abb6d4434ef54b66c45692a7025a54c06aa23e9b0de3b36db74b05d1b02b979e324bd5f8876249c3fc773943573eb2215947f68a21fe90ee9a3a450226b5a17f7c1df88478c2dcab7fd99c9c5beca08870377d844715a2004db9d3e639d9dfa240be0e5fd39ce7182337d41a80bd3bdd100f482bf99a408c793bccd6a2527fae49a8896c6f55075702795aac25477949aea1c6aa187d5f9dad53b1c2762748c7af1b51f0cfda60c889bfe95ec118b15acb2676210b7f1edcc7a45327ed99f4fa2d7788e91cdb3907461f71ee8d1e17b2851216188b5888e9d5d106cfe72c5c1c6c53b58c8c5fd4851ad0db99323818e652ce6165c21e5a4632bccf6b75db8480270f971203667900d8484cd7e1a8c944db451191ccd0501353bf5e3b75da4c193104d835f4b4810719342b637c43896bb6116e472fb8b7b5ce3c9622c8cd1d0d27d08a1fcba8c58c8d97e3ce9a928d1be646fc93ccc92ee20236f908ccfab44be095ed553a4b9a7f9805d326c0163b271b91b22401fe7d963f7dd6f12aebf6727f1ed7ceca82df75ef3d6d072c0296306d77114d593b08444b5fccbc874cca990d733688b05ace71231191d0d83f79420450e83d92b869778ebc70fb42275bbf92ddf7307e025260d14ca23986db7bf7d11782b1097a0e82480646f53e5f4faa66c7eaa4ea78de2a1e68b919ec5fc3be007703dc6e5aac15cc27342130612e9043e225bb7179a4fe6322b5d3b3e8fdd9f27a61d5d6b5dcf4f9514b5504aa844e30f4e877001b5852224e4e5128f641f52653679e23dd6bc3ea0f923449ef5a6319fc5d227684202f32a4cc3bb5b2ccdaad09a69d1753120c10bb6b31dc81a6219288b3392b4b1b03a8842a8f6f96f67af5b2545860ac35aa9002091167d152387e4859f1019889ed4ad1ec57fdb0badaca81494eac626df2f8948a7a80bf43bfb62c54d11e1d2e6f6172cff6ce9afb6a7222dfc14d1e63ad7b121476102fcb7f266e4b972e56eac01851aa5295a4a09679b9f87a732273eccda829b0eee9438402dc949b5159f7c1ea0e61b8ece5cdcd4f20aa5e61ff27a8080884ad951d5e372735b4ab1c3e3e372e41224d6c7c5abec96a04a222a5fcba4f4866349886fdb67bd0d972a8ab17bc3652e46541df8642cdcf481bbb486100b1df12ccb3c4bb8a7fccbdc6dc5c10ecd18b7a3b8423aafa82708c7f8b5f9939be835b61758c5222cbe2187fe791faf380fca0ad4f2a93694cf7faec4f172e651d1a3b026b077639bab07ee18572545db5739693f83649f15cfaefdfd972f57ab3e01a4623e9a6cccaf2b83bdd1b87c84f26901890ddcaa179f71d1ac601617cdbc838a81d416c7705ebbaa47f991cbfcb7d66a3001d8eca9387610db8b218ec7ec5f646e1e551a69f1848bd54bbfe31fc9eaeadd34bcc0a6157b0808938df9e744f95de5e4cf6b0d908504af3a54c5bf94d126e8ebe54f105df5eb8e0c6932aab52e68019a1e46cfdc57c9e879bcbd6ac1f675e2d1c8b55ee0cde0baf27974a0c34a4f8e68d71e939b461db0e3db6604e4d6600406e22a22a8650b270d824a1c97101a3d3cf276cf8fbbf1ee20e66bc509b648a8d219d69a2e42fa15125cb874b2122dc0a5fd9fc3ed1ab7338e3661af0d47ab8da5ca6b639dfc3d01689d16f5c9f341f0cbcf11e65adee617a1402d1f179784a055ebcfb386aaed30065348e1026843dc546b7db533234cd84ec9bbef063d0660b5b6c423715727ccbf9c7b91a672f5a3da546fb9d37ebc4cd7f27b047e4cc4a8bebbfe355588860715fcf6e65a5e76b375ab31a8c7a07d2e907e48bab13a36755f7622b1b895707a69cee720c12050cfee582a142443ac870decb5dbd8355fefa47e215e297fc4983342d0f06a18e10fe7ea7928eb613e2be45508722606e50d5578ea93efc00e2a87b47819258197116ef11f10d10c6b07bb47a5513498bf3b704e42b210ea7d83d8a6a3faf1136aed754b931533a722649525a8ab63ffca7072d35eb8d62f74a95b9341e6e4dacef65237beaa12ade81a369fed7848888c4adadfca5649d18ac5150d23c7226bf4ed7e5bc425fd9f3be4e972be0d43365617a585251f64a8daba4d9309a3c76e0021a75fbf88b6f3384ecaa09853e79f85c5b67331ba4896b1d902d1a18fd867139f610ac6f51addb9c4a86c19d47853478c2c6b575370573d84416110e1c72f81e0c4eb5bca7999c2328c65c9094241b0cc2b3c8f5731525c99d4062f4b67e28f2044e7fe838305a58426b95ef564386616a68c047f6ad585ddf8c9835f62916f530f8abdee97d5e3a5575326cfdb56ed89253ece5d259a13cac63c38911a10278bf3171fc7d84eff5c8d36a3015f1914d1ededcbd8e8dd056ff7c781e8ed80a354ab11342174eebbdbe8e1f512a15f2053fb0a61740c91182f398fe07c12740046e5566a61128195615efc6d9c9ec1b72fc3efb359d4080e70ed6022dbf899dd4e3ff8499d2feec22d938f2b781f85346b69a861d8256667cfd40a96e81a08d938551c86d412edf400095dd9ba52e2874410bdd755d553459891e94da3e095382e11ee61ea28b2d0f86617a0b4247c38e0d7606406ee0a8c63fb8c1cb9997e5d7dd6cd84668401b05fee04422074cfe5fb2be30af1b1482d3661a873231304134e5f1d209e451269dd8b204f6fcaed50db8d7af2d9ea00a98487fa979a57cb99ed337e7161e8616a33aafe0aeb7c5f1b45f79edc2661c93c36708e75daaf2513ba7a2b5d40731469be26c44a487b9d18095a9661cb7ad85c3cfddf91cf33e181263526803376d70c8f82bfab4169a4c3cf7668b520c53c897f30748d4bb7b8fe483cb1946c25515938c16e4cbe35bbfb9d244dc93dc96f941a1e16e812b4789d90792eee9b7c3da62b749632e43922e6294c032718272ecb757227e5acf5f4f1f2c09b79550c020d6d00c7a3417b8777d25cbe2dbe9f6c38bae813be0305c22b40e4345f2eeb6cbe02a9d8ef00621384cee70ac29a2d2a5d6b7d1e4b106eb933ceaec9a3e7b569f40ab8fe982c41afb196be3e55dcbc9811ac2a633ffcf302e7b8775c8b35476e4ec751091fd4aae8f2206efb7be11ef5f0f77a958a18d1793f37d464a64da300b4dc80179b2d1168535841fefac77de871999af6fac323dda21e057828bcbc2a9f97fd7b42aa29e5eb23ac09696f50fef71a0f2a8e99c318dfa85136fd380f2e70b3fa4074c0856bcf0edc18a4732fcc3b0124f7942c56e0c30496212c96db3c050d9108e79773d315416a2a08803099b2609fc050f611e35d2bbcdedc54b33790c741c1532ce8df192af6caa3fd486e1dd6e93f569060d26f3e1645301cfc747d4921ec919fca6b48bd90caf364909d7503503bb28b57bd06ca134b60b7164c7b8e5aad672cedd3ddf61679121575723f40b1d328ea9665cf70c3d9e6a57e95b99d0190434e6ba26d586729b4ae88ba605d682e6c8ecf2100ec9dc259bf03f7d75efc769f554d5a44b15af201daaf5b55796477be986d8c7ca98a103e77974a8b5b1e1152fa53b7577c5a228aa1e0cb4312aced99ec35c8bbccbf669ce8278def3c53caa90402b6d730b54471349723ddae42951d60e8371b981e4400316f9418b5874cdabfbf179ef3f11e35050fc5890a509048a8a646056f55b0a33a930bb017472835e7cabdd4ef62f0374d7e1400d9ab00b4a80e9e1dff2825846c470e7f39ba10389d0410d79ec66325e052944d383d215bcb47a6c784547287bf5bb71fa1d91240b990b89501dc625cfe9a125bf248b642785988508f6566853a2a9f2f92d1d48d332608cbaf4966df5947035af0ba216b143bec4a28eaf3837f778c451d2c4e5231aacf337aef21132711612b3760459d8ca75f74d81eb8086438ccc870eef7cb8266ae528d450852ec9d3f375f8519d0a5ed36111f31d66d51aadb17544a84be4ba8e195d44edcf585b773d48a069d046fd83878e4618a764346691e12473119b5b73a62eeff6d0a495574ce9feaa6b869e02e104b635ce0a1c470e500941c509e8dcc847ab5611b96e2fc138a53d61bbede5bc814afa70b48316e242209335bf4cb8637cfe16b96f9eed0a73d0a0db037dca33b1cfc57ca44fe17f9e7e5ccb0a2a52a30c877bfdd15030ec496d9f53ab7bebbd23a829ca7cb5cead9847bc76898f98021892ed8b72aa0f3ea659479e1c82beb96d79abc6ca35b08260d045ed1cf2be0d9b1c4c54f12f92a2733a7322083d153ab4acfe5717560e021a432c898f96f3eda175c5bdee904f6a80dbed6cb509cdac996f617d8de38fd1b081965db84abb33cd8585b432c73780eab0c3bd229c21f7360222108cd934ed6a47ab7c7bcda23302732cb8ce9224f734558dec2e793d531b8e8ff1b9d1ae5992986697977546ff5d9c96bd0bc6b917db8b410e8cd8902602f96d92487338186688d61499f3ddc7778c23c40b528186204da56cac35a9c1a8d242e0af2932724490cf39315171e634cb64a48e6fa27dd154fe74e3446a32c5e4b72e84763aeb2426fc9d3bdf7c8b1adebfe3ebf6b04b759f4cbeca849019440d9196231aac2b48731f6ff8d4bd0be732f7f09fffd7b4f497e78612770ba0c6208453c853ed0f0599bd46922f877ee2aa308deb99cc36b734d5569857bd475c518b2b5b07331253687cba584c4ec6b66492b0fe82ca8e96e6611afea4754a5b085ad28db1a438da64c33f18d370e5e39259f1dbbfb670b50876e495d5bf841bfec6b2f92d27d3e147437e288fefa9c5f89ca275572015ce996efab918ed28aefb38bd81b478c4acc1819eef676206e8121965d0f87eac34a2c43537e9fb42982c1a52444c4af0dc049b0b4d9d0e4c9a6c76765bade6a221e844155b173428b53d24139e105fcf76c11385b130b02610a9a1cf8eb7a8472a442524debe5c650ea2f4ca78543444791f344c26ce535edaee543bb421f89365bfd9ea3e218dd6015aa0e984a75e85cc48f0e2485bddf1ed289e061461585a1d3386148d6fda694925d36e424fdb9921c6561b3463e9f3aa89c5c8777f60d54150faf96dbce69467e3c09447bf8ebf5ed1889c3d5ff4cc5e95036ee5dfb408c8057477d4e55ca07e27df8e3a8b03a0afef435765b37f4ea9833be6447d6ed910c959f2019c30d18cf4ca02f480c5c6b0bb600a4af92f58387eecbaa09c6c3a246b2880837523592b716915a01a371da16a749b4f1076462229a42f5dc24db2ccc52b900af7d5c10d29d773233f5115e29405e6816aaede2ca8cbb35c5f48586a64d5015c7b8f06f2f4ec9bbfeaf4c3fabcea708cf9fb536fbe3aaac74c34faf406f43a9f637fa54f24533af1cf5143d41f62f81616167baa24336989d77d3e380680adc2919b6c5fdcc1dd5b7f82e510acafcbebc40d39579bb5b726ce5dc60dfc994f2ee784ba60ff7dca7070b90f689b97b26235efd9b71720f08ed5256f978cecc6eda02a82be2cbeb184a7d8ba02b9e2b93062c4ab500318d0476d07ef054bc3f0c6f9ea5e046dbf4c8d74b97f09384cd5b631209a724db11fcad252fc3e51ea9cebdffbc9dc4f418bcbb0d3dc0a6ce723a4aacc47c7b4ffdecbadcad826d6ba4ce9ea9bf8bfe171683a52160da8469a843c16c707e0616243d856c5aef00d5736057d3a728dec894dce541f207f71677f369573b38b4e5600f867b66fbfd65c1b3d171a11689c1ac9a34f118eb6139f56327162e08daa2aa759786d5cfee65ab367ab5b0739089febe9999e56f2dae9a720a727f7d6a4650bc92fd903baee1a182545e2c15cc7586135e2215b08df95a04c54fbaf450ba3e2ffa84725efcd38e23afd9be9a5e64e519275ece79833d2ed3809ccff560ae5433527a1c42772a080df2a289ab29a8d951b5cd56dc46a329ba8a07d75607ec3c2f864245eb752a2f89400d2f965ffdc21c1b6a6fd3917c5c89aac91470900a82b0ea2d807452bae4d137a644b0c4cf8d5b9ffe8eec9c6a9348a3911e831624fb2d033684ca9e25fba13dee8f1a9473d8c8b9b86fe6c8b09e15e249ce7650ae7d3329e1ac9755817fcaf695d50e9bc86b8fe1e25255bb61fef2469dabad6f45d685d860fc1129913639759fc734148f29109f5082fdfe2c861971f0666490b45e9d186997f3fa85450fb54ed03097b4ccae109a30b461edaeca30df9f72d0d3d63177d6649eaffe8e50f84058e4f5fd3487eafd262b935e89e8407086ac3e53b8b866680830f6475df87b8ddf405e1072017ee8243f23782f3ad13ed5b2cc19847ff099a0cb51816370877fb6e069059bb51becd94a76eac3da137a0c512bf0dba717e6a9ccd380a55e322cb360960ced370df8b3e60c9e9b3a4b571b70f60b8c195a73514bef05365c27081d5b8ab52fd04b99de935d247d6efa34f3ac1e5720b658af060e30bea93063424c01a67d8574820c126fcb4a9ad2501de6c4190407794278ba8da8c4002d8acff65a58536deddc5dbf40e39a62f33092399e2a65104d825afa92c840aa5bce62ce46a7d4dd9032f737d14c688bb329fc23993947bdd3b026ca295a245457004c04ac64881afe60920992f97d3924a7ac9bccbeba1fb5b8024bd870df4c074382f0de8a4b262cdee173da858599569d83c6a6be62aef6e58350678a511b0fea37a104b13647d402a2dac26cd9bf6ead65d0e7044ef23528fedf07cc89b92d1fd008beb0bfc81e68b2374e47242162e1073406eb32cbf894149305a178ecfa49f17e4a0d5a1b42c8918a2657d7be619aa0f4302ffc08afe7beea0427672bc8487055573e3cf28b71984f53a7ee4d50cb81af0aafa0611ab4499e3f71d603eaed7b4b1c2f5a3de53a927ee34d96e30d90b7cde72b28b5f2229c6af778dbca2dabd72621c31be810f31b32c11391939688a7c8e14421c45fdccdc81559a8e7ebd303e467e7bcde8438dfc0c0cbcf370a1e9fdee5c1a1a2a4ed391a0cb8407635f683b18c48b3ea8204ab6dac3d118cc08051d2fb9ac36862cbacc1cf85390a780941dd5ec7ec56e264f75f0809a11e83c272d6879d46fdf0ad331eabc2b6ed743a3275fe1316753feb4bb02b7a8fa4728c15c8e983db25cdeee06dffecb4f6797bfcd4b19b1d79b57c6b6b955a16f60a53bfe86747a05e2c717735e56fd31d8243dee4b730590961cdda929472e16b608425e7be6227ce794aa4022db0ca4afcdb88b22cfe0c0720ea7b2ea7ed3374a2fb6c625234fe0854aa21be8fcbfcb7461bdc18ba6c824a8ee5884e83973ebc6083cfc337e7f19d17e7cb6935aa957038bd7ea774f8b13abfb71da0d182e74e2343274fd541318f618d9a7e4dc42e247093faa08bfd2d342d2e5586e124dccbd3a8f5a357840cf609089fcd04d35f7550515bfb47f90b5ef48f00b37fa2e7992a0c6d9467c8cc4f581946bedc5e76af1306e354888d662eb679b1afd185265bb92b306d07305dc695beef294dbe8819fd22e9380f7eb39408e2e93a0a6fea47bb79187c4f984e142933ff0a6629e6ccd5d08cc59754a56346683d8a8a2cfb12d196f420c89a15a97998d6dc97aeb0ac38ab45248630401194b9fcd5db344cd5dc3aadc8184d52137e7214e861c0860ca2e121a8dce30859e3bd60dd1b46cde46aae8796d002acafeb9b850e717f092ab22965dda85450d51738efd41ede53dbd751cb9cd6542ee9cdea33e7f86b67ab5686f518b3f990a4824d719a42e3072bd9cc5559bc146b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
