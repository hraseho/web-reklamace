<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6caf52ca0074a0ce96167837dadb5097e752ee4357474a94cb11f4a31537c3727bd40f4bc7f08dac5dcf33efd2b1c410e5636bde230a1902ae9162633e43b3393510e694c195c8d9625ca7a8ae6862b0f3c413e86f9f8acfa5c0deb33eb339a5d52daab1f9ea4e0a9579d932911eb885ebb97872596da2d73b4cac20a3210db93e1ea77c5dba5df55303f03c8d933c03fadbdd55c84f5d5d68957901f3479f70937dc95c13e8e6798c9927fb72989def3236c775461ae9dda87374e41a356c72f5d745359ab3d8692de96d8aec9c66195ff2aef15f728d7b6f6a19d66c313e57e3967c00795228892fc6ecb6b2614375f317fb14f3e4b45df7c8a8ea33524acc018b85e3e1ec50206bf50778b630a8681c5aae804907c3dd7a7e4b612e5ebbef6d6ab22862c1bf7613ca6eba84f73dcdb5c7d1680f996c91dd621dfd0d67779dd64efe1b7dad7fb91a24a3d668b44a0b25c3385c08ca6637c53e26fb9a0133a430e721bb64300c366efd56ad45c08cdd5267a73803337f46582b51f33335037fab18fb90dfa92d666590003358de31fd5e0dff0498f6e4725a6ce9b157e0bc8f7aae03772a75dbcc4a4783c8a3d4499d43da79f7f394793163e4ecf6995bf50aa2f8728cf0ef6b6cf15e995170af377f1aafb2f0db798d20b0bbb0045972c5786ec4b4dd249219b7c5415148165aeaeeb6adf4281ec832970d4d7274a8d04dad7634dd581d3c8ccf0b623fdbd53ccd1b262cfc0ff9b77848aea99d9bd0a822799175fb5ca5844b510304c50c241c67c3c9cf27d89c1444cdbed503f7f54ea367846814c71d488f3309b97fcad333cf34a6e7c1ea7e3e592dcc3657156c31b276b81e1b07a0c423576f1d50fdd571f57bfee5ac9ad3b165613a4aa28f32654ad37a82b5f4af522533e8f7aa36b4eab93204360d6bb4b2a7cad02d4200a19182b03ca739510da6743f36e35cd33d0ea69d375f8e0ad4e6d55644e868199834798585618f49954597ddd981c5f07da7e7b3d1ce2c0c62198c4af7e7f28d54e5f5606ac697180902179c97ce4a5b16966c2ad5282a1d42a1c344fefbf192d3da55d5bc69fa37b4efabdfeef50dab4d35b5a099f9b7ca6236f843e7876eec261b0831b79b505e05c3728c720fdb6d326d552bfeb61e6ed6d16e31458e76b7184de636319f3aa0286b63ebe5d9d98cef21667d9aba60372772b6667221e9c3ca221b475cef14a52bb02af34e3ff2267b85946aaf61b845eebe06055cef24065add90dd1281c4d9a9a50da7d171d4ac1f834fb8bd24816a99f5bb2fc70d2dbe6be9e7eda614ab246028b160bf6c156284d2461a666191ae7bfdafb6296a01639c220f729c0424212f4a3f8edefe148679012c877720055ebc20789b959a24a0eefa0c5dde86a431424a9b6f20cb64bea2bce0b974030d705f9639940e0ef9a427897d113773bea32507117b2d24c763cddfb068133b862d3eb8d2b000369b3e4be6e396c43d2d947f4cf5ef685f60325c9fd95d145d0af8b2b68ef38221025cac8397778f5f5220f6e341544d4697c65460fa203019b24a9cc4b919cc96b739d4c37b7868e5f7eddeee24e232a38076ec015ed7dc52833729ea74374b06a12b4d7b09196ca6830ef9d218b001c1ace09a88dcea5c1a45e2ff55c2c0c7408f74465df4e66407736906d359a3a700d9927e35a268e1e8d5d1cec47d824e6ffec985fc4f3747dc53781e5fde2e28b1f11b35ce9ccd3a6f75dfc95514c9702fb53950cd9e2ab16bbf3a0cf0625b9c3cb716270d11363ac725af5072aed8cc32ce485b5ce72fef6953835fe74374e8130f46c05b72ac89625f77378afa742f4c2f2f2168e8f9c275e5defb46dacd9ec86a9da5bef7ef9487a65ad23209c9771da8dc5bc40626dadfe2a9bc7223b33ddc71dcb2d98149b277940725d72586eae24766f7b3bc5c5a9f24f9e0582e37eba105111ad7b24933797f9e190c38fb40b91c9005766fbc0d16955f6b81a86229dcda9f8d3c8a8feff1b0624fd965fc2e1608cb2a0187c5eaa8e0c8b284b7611e9de8208607f75dd041429bc7e4fc8f5607769dd50e58a3ccc4705833240ce8f272fcdf4d9669df1ae1f47abf2ff58b05ff32d3e194f9a0663c55a324e24d98d0df467486cd22831c0d99b668077f9454fadc381fd061981cfd8aa9e3d688ae637b919769e0145866165eeb2968694f6914ea8b999e9324ef73865b6f2370fda40ece7a47ee57b060cf80ec073b0276862ff714eac534790c32f0f3002b2c685cd4add1d100361329b7d5eea66b69a95869aa5449e64fc7c0ccbc700be61629bb2847a9546f8a86f3f7b5fcdf703e62baf049868f5c5f42b65db653b3a763a2ec680b34a2dd8e89ec95b2279e09f47a35dae8af306d8e88cb9428d4f3ee36a2654daa643fe328ec91408067f3d7fe137e0f4e49bbafbf6917259830ed7f17c05fce339f5b38697fc0ccd7d2146200bfafef57d040ad1ee91f60f1b5359b44500dd88960939a5a908eb2e44a16aa56fdaa4551e8468439a5a43ef4ff35699757f3b254db00c46dac1a46a9cf7708c359e4b881430ce52c3f6bf07e8511b18012c0fb437a06cb4669fb1dc805eb9a305555b9b54be1a59f60ee3b3aa4706d68b826cea3864a7100c87fd3f0c1f068702ebabb8b6f224231d25868723513ad5fd5ddd4cf00448fbe08e7f97a340edd2e5e55eda0d08dae6f5c394b138493aa694223218defb2db988652cd60fde6d91f016f5da9465bf650c1d3526c887c8f30f2356c287bc5ab384d64f91096a5700b83ec65ef58fa19351eaa515342ea65fc6d8a03b2de0b00736898fc2f75972ac5375ebfe3a936ca374a5bbb89fcb229eb38e33177d079078984e91954edefdce77c1c6ce19b9e8c134d187dd30002ca704364f3e37e05a3b4a1cd80b151d601c88ce0e6303e37d18cc9ce11e5860e9e7919fac5c6abe70ff85a73856beb900c3632e07cd041012544aba62a21d67e3d761730c0edee9fc9fc85992eb4a67058284d2fd0a4dbaa1efc9a5ea7d36651bd8397f2c419581b8554a0ccafa10b322c9ff1ad3f28d4aaf486499c2965fe75e4049ba1bbd6ebcbe6774b1c5f9307be3731f3543c3a18d3aa72f499cfde7746ad729ec73719908bf4a710bb5d412e310b001cbf5c33fa5efb8d45252d62f2851157732ce8f6064c16d60b23bb2fedb1485f0e97f42e229dfa17ea0b1a6b347be9c4e77bd067f3f9216c63aa692339f547cc7a7cffa513a7ba2183062d7816a7dd28e743d8d115b0e76f5de6b1cdea79f48633442627593f7fc2983dc72f7294474d23cfa0d1f54c95866ee2fcb16bc3d1afac68cd7c32e0c37337bf78ba26c16e83a8a6191911b4064705cfc86e59349f178d487fb8823658406ddd3a3fd0b9e477dfc565993c1d8c98692b75f24a12ae67edc0f5b193921e974248451249069e7489c8adef90533cd8491fc59e48bcabfdfd96e5b2a4edac0bb10561b9725f9a14503447bd86e51f8f306d71eebf2d3ce07fec6515dbd192d05f26301f16a0ed7f6c4322e513914e15da92b3fc18c4599e490f02d7024ed2027c450cbf1e60f3dddaf627a2ded8086e91280d2cabd539ab3e2115c1b480aeb2d464661ba5e6eda5515329bf7edd7fdd7e8ee99270e01d397d0fea9d23c7b7fe80a115601842e1e1eff859eb88210a5eb9eea54fbc47db8a53e128a298bab1ff935b6832d25a0dad6a7c2288a39c1b336b550d19758140ee93477976504209994bad8a234f9304789957c2a6229ccbaf78aeb701ec82f35a7c19bc20a93f618ebb70ad0e2b327980b9fecb687a970556b10fd3108f21e754ab598d1536bfb5eb7d4dbccff40d3cc52c2d8ddbb2dc5474ac48539c39dd63801382885905707bf5c4b7fcb1468542b6b02cf519f121ff723d05fdb1cbc1a09f9038c0ccfc924e2522f2d18ef302b89f758d0caad251f860dd6efb8f1d7a2702cd6ad6e2ca63da80029eac593114e859781a9a56b83c8bcdf1f38c0eed187441a55c1805a3c4cf6ff823d0d4acc7650156b78a1df04db5c41395f7225be20d3af4a4bc4b29573d360f3f32ceeca62d32e7c8312b9155de77641f3efeed52191d1bb1882a2c1a0c7147ab20475ac1ca347f26f088fba1d4c43b6c95f519e759d0265dcb14cd1507c75f42f6de84682d4c9489b314d9c8fe0ecebaef2cb387d44f81f9c154074ee3d5ecfb055c1a6dda80d5a38599bc30ce674b1a467cbaa891e8f604578d6dce0a9dfe15ba340fd756d9d59e5f664c2b777d2e5c749a0f0ffef47e0785decc32c5f51397455621561f7fbf6f8f7b10b498f07c1281d37fb4132fc645ebdd321cfdba2a173c9e22f3873ac78137fa62b84970e2463abd4f07dc48bb3e14242767fc2b132316ab3867097d9b42fecb7364d0849b50c1bfaa24b833587c75c9dd290144fd10bdec094e10591e0f0e3c671daf74f642beb2a9b9c15e133742589d9e7becc42d64fc68a11064fbcf25627f1658545b09eb9b3f416cb959e213f560392d4bcb479cf03557ee3cc01fc3ed71eacde10d822d42fed0f874ab43cdeb46025baf9dd89244874f9b69045c1a4b1a3e410f405b4ae91c70d07ba992a934354e253f0e5e0daaaa3ed2d119430bb3ea75bd7f49ac4911f68f84c9b9c2d6ad41c5854b8e67cdd308cc89640576aeb47323d81105e4cc28374c1dfe5afe01a960b866781658bd10b141a2f934214e6cdd9b50005f00694103a61d8b303e772bc514720bec8f49ce9db26a5a73e091c2781e041b7d771bc667cba4cac3aa0872dd8fd12c9ce254e6bb983ccb1a56662b102d267c1dda334f64472de274b3291cae3b2ffd9aff851c2754c7e961d10d077a26b95fde84efa35a08ddf22fd7b52ef819fd8e148f4c3ef247955603176b81604fd1eb4fef4d4633a6d703a0c86daaae2b43ea1e1086575a1dc9365ace0fce8a41bedee3918cbe695176be5fdbe4fecd5b03bad6e98e409182677bc13286b04daa1101ec46fa5f8167ae8f9da574fea24264b17bd019839bf5328c4e7fff302529887de53444f642ab057637d90400727fbf9b84277a2831d07d1885f3bb57812859ef155331d5b89b75d2364d9408c2ae8f9051ff15bff9c526125c2df08a85fd4ec379c18aa658d3b2256804955dcf78db08a368f71a475095beb124c6aa4b6a515e80234d36048fa66f61249daea18e062e459403df2dcf48f4c6534a767842d0ae27e1d82df7ad915b0749f0bf76aa869592481bb3381e6895a08c112f0c4d6fa9c2427c7aa9d5f572ebaaf6d3c37d0899a54f0a3dce7dfb3b6b7a5dde8f86a9d8648f9b3d9a61355a3040f5b995fbedc4ba828a0980922e19e27f7d8c7e06f716053ff4c555693cd0cf13fad76ab68562874c9e3311565e289c6d65e913cac72a31c17548477681eb49de80aa4518d3c9a03c9c3807ff8e9846ee0c7d1bad7d8eea4cc15cc8e1f543b9c09830a887fda87e20fcee03d60afc78d09c6fefa9f929c68bcd736d6327d8038ebbe286b15162eb77199c17ccd0372ff51c3c2a3189279d2821c007e6cf55cea965d702c59651d7a8c48d0108c5e55ae3e40f498a88c2d8c933efd6d14512572265ed2aff15b9fc3d9eee460259103ca81a64597be36c9658881a547c679f1012dc5d7fc113caebb6f0806b0d844512952c8aa761f2c8d00155cc5a11bb259d2208117d676cdf207c56c012f3f5be3db7f4f59838c4fbbe65ecccaaa5bd165dafb06eded6582b5fa9ed691ee9da3985c34e39e476cbace52bf52919300bae8400ddd0b29a87b9b9b634dfdcdca277206ab90fd0eefdf9fe1c8f2f95a6520c6302f565901183e7322cf4b10015bc82dd3a19a37ef814fff12733c557962d595068a93bffcaaf6c2a727901b354884d81c17cc56da05eee6ab7dd9e25527cc7c24da05274503123291c7cac5cc199878270e9e874d523e470283b01391fff9009ca27aa15a918ea83313e583efd9aae97e721e33b69f2e44562d5c8e6a0889ca57918fff05918e528ce99ed014ea2c8ce9f11d15d2fed885cd31b08b8dbcd94a2164e2e3c814def93831a133fe3404efea5a2e6027e5b37c644e4fc4311cfa0b02440eba713804a4de9830dde656776a991b7b138bd8fefabe5ecdfac65defa7c698cd5192b38462c7bd9447aa3412ffc15ba8ce9dce82de331e5a4179367eb031c2a395b669cdbb53b587a9f845bd2407de09cdb3f639d09625dd13ab94b4e8ca66e3beb51d5030ddb4917b7f7146e443125f92eed4417e02546a9feb13672cf0b11e863dfe802c6e11a1d7597927772a1faa6c5d30b17eab36ed08a303109f8cc9b19d4730b7c5a55a6cd748341f1c5a938d5bbb548c6a908d327c005ab3585ebb3dea57706ed4e4fec061bd6f13bfff8ca9ccad01f32772942392764d7e99aed10db36c032d668031658bfe49caa08c378392116dc605f732ad24079084b5861505d1d3ab8b200a585eefd15f15516d7e7208a9aff73b206f71522d5c7a6424184ddae1908f355ee96ce9612bdf1d1209adf7629e2ac93def650900623f39278057709d069cc0e715e2d0cb5879131a8fd1e7adc4cdb6f55747b6f00b45823f645bc18ade24dfee3dcc5164dbcbaf71e2d80f2a373f455615f42a45fdb851bbe23aadaa0004d70a5ab0aaa9818a10201c4f285dd84375d025ca7d4bc8312fa23745af8c5fe2dd626fab12726b83efef09d451fd46f7dff8ebdd4dab5a109b7651412fe7164263f602261671669fc45b5b8f3f90ce4d8244add4f53583b7791b1730b536fa7f0a898469d801fea265cce9bb89a909670b1018424e71223228cafe8932f7b6738e03cb860b5892bf1810993c8ddf734407bf935396b95e03e5389239d81e02fa4b6f6ec80f451279c47ef6ad3e974f935c876c4e8aff0a77808d54b28b5205ab91d99d678febc3dc9b64a08a90f4846f89305100c72c050fe9d08bc82619b8a6b1b6c778f46c62bfbf819c21545c167b3a133b60ab3c591c50660d80a75b43354b1423c9f4b4633afebec397465db522fb6d78dc8872cff0c7ca8bd945cc8b3a31c9f3d366fd35ad4df88f9b93b26d9399ed17a43054c6f54d005955bf799ca1f23af1813473ce738645c406a439ff2b4262766b70661a3b1fcdf59ef0df022b021be20a99b889f1fe4c52a7c4414c2f0ede4486f85fb2289dcc684684bce9a4ef7edfe1ee36ca1b82443d3aa4eaf2b334fc7708de689e64791a0840e3e939db9f8737aec9ec0e341fda125bf95dc5ab320e1993596a3628a2fc8d8029cf96114531361ae0245a6667555ae4bbd862425b583824feeedddcb09dee5c60c7f3bead4832bd1cc0b778778da00f935c08d4864fd88aeee367df91143cfcb20cbc6fd057bfd52853ee57aeae91ba2b7fc88a3dc2eaeb47666c7bf761a5176b7ec565565d4d48515cff592e95efd1e171c4a85d49d97531ccddbe678ca338ae93088b783fffb17aaeb11a2b0e351eb6f9aa7dd56cdedefbb4a5c176761a3cf0cd4aa663854f6e3581a9a6172233532cf5a732c3132b40e3231c95fb4ee91cf7258d7ebbc975fe9ec62341922b6c2891e734c4080500200c2b001cf4a50251cd171dd81f174b2038c4e05706af04f0ae21d2231abf62ec6b75e568f971d035d8337c55566744fba0b1c4a81df588f1aaa1d476b113228e076a49238d115b9c1ec38e78bb70bbc1d7bf2b75276d21ab2ec980a4e929421dd04536bb9578fcfd07f63735e0f7e33c459dde3e19960d374e61808678480eab5f65bca9fb9b62a21aaec69c0da195f8b7170738229ac954e5ef7e7f1b13d0cece5bcb7faf672dfb467569073b8d9a734053eabf9aaa629b26fac5b123c89da7bf6a438e62721aa18cf0463aab6c73ffb4d4fd60a35bc1e0610f3ce1f07524f8c48f0000a59190c71fcf1925943cf7428df9600b54a620f616a2af1c09f4c6a15dedcd53e21ca8e768136af93b4642832a2751c0ef755ac447a944ea9041006ffa16cd8cf1f77ff1f694d08416e909c18d4d17f9f52c76a88f1f8a8c72d208659ce24fe8efc90c9892926a2b1d9f2ba22fca1c5baf36d25d710aaf4a9bec10917d561a302fa3f765b9405b5d5f9224902ac49d8cf48766fae3ce03e4c361d38462cfe50d8c06b517a727c00f65673369e1ce9638c79637216dfe190ca15a1d5f8d09f4353528ac9b88b85395c12b79c8beeb99f4a45330485cd8129af5b4f330fd1e056616cadf5ab2870f77e874f625eb7d90310db311db2775980519ba010a9bab1c74b7560dbf55fb11960c0bbe6ea32250f592ee09b0c679b63b413accf9071ce3d91b272cc946e88cf9c4f2c703dac7373d61ffa1af5f6e569694ed7ed095e6a94c98de6a7a9079a94bd29e95be25a308ba9bce4f9ef7239dfdf481ba82419e3244beaecb3bfbc8dc146bfe1489df49059d6490672dc3281c8db4f2c3c9de38a0ca91c38bf55f662d9f28c7ee19a7359765a5880775bc3baa4c5115471b6d3d20ee200e212a6faabdd72b0217818ec5df46f2ff2e8c1376cb71395e6a76497f1e27f61ac091cf459c87d831ac447eef95607bf0f9b67c52d59b612dea324093a26f42eacef8bdbc40b5dd0da4b27ba1742df36f93bb17bc4eaa809f914ce28c4b7161523d6671844cd79388c10f057e04f98db81959f77e0a0045db4db35bedf1b1a853a1827fd734779bd7e27e2f8154df1845a6b358867385348315342b8d6d3515d2fed3db7e331f68f834dcb9f29f0e42ab833adb611ada199a0975c0cefc08db15b99dbc07d14f3a72cebf2511565d2b32e080e10055ab3f23a97ef86f4e5dbc86deee0ae2d55bb0a24acc94f3e2f105cae3a417c0a8ffc98d1cb42bd3dba394936a1b73738a9edb4c6766e2824511bdd525b1d01d06626baac61c7bfe8eaf3522f2e5afa0480b2e8d78131ce2db71646b3c2ca4cab2d2ef1a768c4b099a18e7a20e840fcab1a25879c95a49ef8825049f96e9a59fbce8a0a44778dd2b234e137f6c9a8d5f2fe3cf2a1c3c9d4b545f1ef5f1b17459957fa0a18133104bd936c5809e5b7cdea9c848c46900d0e11d73204f81f6341562970ea1d3fd0fd607d954a6386e402b072116d513633f7e265b100e1f15e1f596ed8c14ce12f58f36681a7ecde17ec3fe013b68601c32445ab3ef643324f21f3c3df43657781d9f404e654e14d770eae2c80a8c4b78a5e3a944e06d3b97a294c888e4a14c17ceae86f0d37deff7e15c2c4a7c543d7616453395619f4866242ff149d64132fceb2df617dfae759ea1f8e0ec7847f1677b38ff50fde2e10f0d7aaba700b6156caba514e45c48e8e873ac8fff8b79e537ac5ea2e1e016ce47e1e09d41392e2e9d1e4ef686948ca9bac3c76fc172b070c0ca4eda4416447a3781f24ef337c9877ab940d3f01d79fc0f4e3e816dd04349c89fe659813d855c7d5fab809042554275ce9b64a62e8da2cddff59481d63ea87291209d214d6d87ef9847ec5a437839f326f3a7d91f1c2af249a41fecbfd4f7b187433961e1c3373cf89dbf31dcb0a663d0e2b870e2d270e4d2ebc4e3ee776a4a6305cd75421c29f76b60bb013af9ce3460abde644aa5cd3fb279c114b4c4eb863d91428f96c2a225d671b7703f79cf0234beb04adc783e54adfa12d0348dfbf094274cee9ccf4a044a08b5203d28725b14ad48ee1325c7ef80668b8e44fb3e450265330512811c45bd90b8f946a578f83077eb0b89d865618ca250152697295bba0788412b7250ed68e3d658f9fe99ead5206e4f7a0bfb9dada4baaa9030840d96a8bd7df8efd196a404d697341b69136f9f7744644ba3975f00daa841e9959b3876bc4c85d6d851d775695c0a164d0420bcd69734ba87212b8042a82cb13b93ee508171ac842cef1b60d5b19e91c68c6c326b38c21171d3bfb3e18a1c9d3fb18c959f6648d4df1fc7e9a9cf13553d8789b7c4802a196996f7cd40da09090b407358730b157e75ccf38eb4ac3b2a9ec46e8feb06b93e1c68ff73581f7fbe89871a7c9b94df8265b337ce2774c39bb4899b99d0f16432d27d6403225079d8c4c2bcd872bf48530141c28429eca6a48c34a62024578c328145af21800f4f001aca61a5ca62e8c86bac824ec21ecdfb9df3d09237b1a0d25f79fdb5fadf62453758a0585aabe747fa59c85b5227ca4128e04581a02195967a51daf590a02f134845774cca93994233b8ebfae78da5e0762071ec4a7472be84c91af238e0272632eda6ae276fa8f7e75f528e865e26950b96df8403a07236f23724ce8ece381410eb91c1d2054005789f23f630e11653a9c8cca990646b03b97011cf3410718cc9222aca789a713089975b0d92be7c479a654bb12604240a50882b88851048fbd91adbe781ae6e2dafe1039e3c598eb835f58eecc0a037813e679f1043d7cbdeb5826981d244bd7dc094c85166ef43b21d9b15545bb5f820dcf547c601b0ec8c8701c3cf6bdfa4cf7266306b121ee668d0b8a5518ee78374702e190432d93055e133694bc3043a0703652820d449b72ee39caf168850563c32e221eb79e86fa4fa43e3d51e0340c0d1eac2c1516967da0475c5d65f231672b608dc72c8e05ebfdb694733ac6b37da667fcb1da6553e1480d92235da93eb3783ee16cd1c236285112d450a6d9173ab017855d46cdabc7b54e06ac92fa30d5badaceb76fb94e27c3ad6cc3d69d95add4fd4c61882acad46f877747f085a8af9f11525925a40b33d9998f91ab88467fe6cd6b72f15ab4514d20f909ed44a638381a739822da715390f4487b2c31dd3b8fdd1eb739cd1bf1fb270b0242ec6227c0af780693d5b7091aa3f60c8f4629c6fd5d1e71e6b8c1c9a851d3bf0e8a22aee9180dc8694f3089bdfa3c2e3fdecbf64180b328453ab056922c8278e1509ab19bd35fd572295cc18faad3de2f97936449c45470e7314daf4beff7686a6460593108ceb94f68225329208e7f9b1981c22154bffd851984548554f4aee2b54c6835ee560b490ddbdf588977bebc13a2e1c68fc1947203954ef21d7c1378991a9b9fffd677a60ac019c32e1be76d7571d1e89de3e84619bbb844f05a0f1b1c4f60b8a985b256f772bd4256d06d221af61b6a9f654c6946da7425756970d86c0fdaede7e716e050ec7773ba36adef000acd6337ae18abd77307a8101afb45ef7f83eb1dfeafd0900a2ec2cce3903cd89648f91f48b239681b194e41ece87f41af4c51339159bfbaac98605260ee150086a3cd2555ed9a61ff35f64a3d0e780d5f298a812e31932559fe1c69e547085a7fcd22f0597ae005bd3cff47e7be52cf2a8e411896b83d47b720137cfb4db3e4be0c9cb2e1999181c68edbd1c31f9fcbb31c3ae51b9c18c4bc68ab1a39b62896e4fc441b8c8d7888383a83579021ebc1cf41ed1237ff7cdaa596b6ab4ac2012246e0a5b3fd70572b90f014b13806c0b1be9b9784ba955b4f499ef702fff5a562aa6e7a33b771dd5e5b47f7a64ba101767051dea8da471f0fe6e7f14516ed8065403f6c80331f311aa80e6d4ab154997e9ce4a2ec6a78bc635c8fbe415c3649eed4e3f2d295927502e0028c1031fda80a88434f8c2841909546f3ac104951b7fe314c6b16b5eef9c53d9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
