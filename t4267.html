<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0fed8d52f22842734a8ec1ee6811e8d35c42159193e91fce47e76ffbd4ac5295314988efa9d42be7c73139ef2b9878ec353a90320f97144913ccebde4a9eacdb531c3de840056f489e630437308740be158eda6367984752e8516084cd3bcdde9eb71674df55b45f3b8c41f8ba75a48fbce842089a1432d764528b27dd2c37799f8d86c5aedba52251cf3115972c5477e109c2765f98a94d1506a68927805478f6909ce45dfd4ee71e56170901e1597af6a41b1b10d0cf270b4ac2a91040bd3699503f9a8134c5dff73c45295c3d5e8229badb8511cafc3da564abc9229312ac2812b3d0873ed10cc9c9a0d084735d39ae438b3914758eb07c6f0d717c5c954b6f313ee1bb09fb00b79cac8e9caa67209e652976d62f402b3b3f39cd6def4185ebaf4d5fcb859046f73effdcb31089d5645c216e538d8a221de836adada1eab864a389103e3412b49579e9851d2b191c617a5da0b7d409fd9f5cd6f1c84f81e415d6bdcd76631149c23a791db45e67a0f518fb280414260401a3844d0872e755e08d7ee99e11a246b6244952853acc19d9cc341b6b0322ead5d5b5887373049f13e060db089cb56101210b153f26c575526cd9dad5aecabbb6a29f8b7718b564bdc7f170397a163f2f4b0f85714d02a3511e4e70e7d3fa6cc8ea8725401d9ba15699bde6e6d74189adf4963fbe60b89b922879b9392ebb2c65e64a72f0486a90540c650df9bb39b313d041565224546dc4037a9ece2b25f181789f2fe614e10a5c5a40d13bf8b629f8bfc7e73a61c431a4f423a08ed02fab58b3a6a4380bcf41711afa744e9b9814b3c1e8a87cefce6b5ef6eae1d8ffa17de389747e09b0ac80dad19c684ce7632cc19b8c22a9b665c9e250190cc8c68edbb7664b2ecdff906204540d6d41958a385faea069021eb4e8869a2126a223bfd1bdf99f6c4f07523df6d79dcf001d964a4aa8f8c24b0c3a6b3dd30f92a393993d44861b8cbf768e7206597ef363248ba66d59b6887995f4ac22f0a0f4ea45bf6e656d786a1857a914e022fe862fadfe93f9debfe79fb0c446befeb9bc0250dbdb6728fe566e948cb87810afbd0c3871b0587cfd574ce3080c9b62f4d7dcc6b4bb2a034cece6c80fd39c91b04f8ec144183e6a8c8b708a9bb6d3c0b9647631b5f815d5d811a209af76ca45b42d791f808b71226358d7f60b0926ce0c68e1d2daa86d02f790ba8e7ffc21808f16d2c8de58ffee24c47c4d76627fae9535359803b42963f8b7633f9ab25ef7d3ac07d14d6394bf265eec954d4ddfe636a9d1b083b9778538190dc2b8a5a2d5b607d4f4a46554f833d0d2c5396a91277feb796afb117eef47587625a657adb0bd58da9725c669813c629bb179d63c52477c8a525aba965b9bc3a4e7ecede28170414f4f0662d23b8df9b932bebd98d4286f30827d51800f119219eeae43387f9a3c1a5508d6e3363d1b44f7b7d53839cf8a49a00356f4dd625eacc193d5d08dd2f6b472016d69688671c3608d6a2d6c1127d03b41826d8b9b0e352a17eb4076424c5af4b27628d1e69cdeef120c213ba83fa9fc3c90a176ce1b22a538f22fa888703d92a4405a86da66663bd0871fe93c6ed3ede45dc1588b42cac671b94b6ab54daed796e738341009fffe966d3ec08f7021cc461737d2ee69744948ee5bea75610985154df8966469d45edd0bc6b1f5180efb02bd11347be2bf2b2867efe1350a7fe2ed229a190f9282db29bdbc82383c34c7c9252c431a568d557550f80ba7024924d0da2f05f9544a0ceb5a488af7822a85422e7da634cd7a072cb38095aed4694013229d93aece4fcff101aef578e1023082f144cebc331f604aea3eee1d0ec0c7d033aefc648d0f806312bb91a7a01de4aad945741d6af968d92c276452fac19caca8b103d9f26cedebf4f45819a267ec61d4994fab72eb12c14787b59152b10edcf1b0712780c430dbdb2d6ca3eab6a55da21b37748508bfb08094614bcf6b5c4ac9d031685f47c35e3f291f788dc675fbc94a93a59493da52ab092d589a4533d8eb956c8972d3403dd0cffbe6af263f9ead6bc13e1dea6f283fefcc688de2bc0514b8726e0a7196a1f21d3abac2ba465374109bcc366d958ca246c091a61fc2d43ee5790a7bd0fd1067d287f8732c2c075032b34f422553da970ece72f247bb293b38bad3879c5ae745448670bd5d4158a3b2a6143b4f55ebd36623276bb580fdd51a55e39ee24672b8716adc114f786f957292a137300a6f6d12b3c8622fd1c363a08e11dc4a49b7d26aa72b83cbfc016c8d4c14e8a233e830756f7874ee1997488d3ce39abcb1ea09e220205a49086bd1368ef68c61427d26bd23dc86e1a421df33df8b759ea51517908745e118dc44453074cf252fcaeb6f690884f0f7e2e48b783b08e302f5b08f8165fc21c828fbdd58bb4de9311c0bfca8fc1ea5c418b3695f5b39db09fa267ab5e5c9c83c9ebcba539fee87784859e3e006f6e8d62e34e7ca24a61c14b7fa4039de3129bc704b39889847e8a828298f751b6af04dbeef1d1d4934da03ad69b1462de96716f6627aed6585bd8960a3b20a63e05a9602168283b8d80f6fff18160b9ba1bea5be0acf1761b3bcad18842d3fa29b3ce92770249d199a7fdc34b65282ec8d845c502b0681225a642b8f9c33d2d5bb4e4f0fe243b38c83d326347709358141173a988843a159a6f3909af2c1dfda8ea93f92e436c150058608fa3face0a581f506fd1cd09fd0e2564906a4486910225e8a643ea405daae706cb7ba79502b4c428b8be4897960746df7e7ed160f4f61a5d99baf212e49a20638f0b379fa247c1c346e78cf4650b323630fbad26e33e2c0d60a7a813ecf5ad343cb21b2db2b22d91959917d554c6724fbba66fc856235ebe028aa5c4e53456b3d38e6bfbd5dbfbbd82c95b9c458ef7ab9cb1c42cfead799052560c5281ea349d9702822b2ca39017e3b9bd89d6ad3c6eea623dfb12cbff6ba3ae2df7979354d15d2a7fc2c72f08b58486e91e6fcd99b2cc858a380f3e5f567875ed9aba001f39164532b1cfc7c9cecd37b28012acae5bdaf2f32643aa10f201b6e6bce659d3bf569925401a103a10ec3d28c50af80f23d42fac9a92b9b9cd9ed388f7139c0af5534d15ec07a997ed35193e5d831604dbef597cf5fa26b7bd0e8a3820259327dee5d83f0c3ff061157cdac44cbc41260729606d20673761005dffc24aa5060c7807eb97c6db0742d6b3fd1eb96eb2d1d21cae58bca113b2164ce0f81c65c0aa5bf4416bba245cdf715790985e6f5f741d2a1be23aa63c5afc53a7737a7a79ef9d32be36b649d0dcdb409e4f146b8722043c25faebcc9cccecd5c7dd5f8d8cbfee3cd286523b85698479a02ee18bc46f230551650be98701d3b73d24d5516017853dbe001e2fc8bbea265d99d788a4e3afae1668952ea483ddd7bcfca8f645f521c51e475115a05eaeafdabfd60b05ebccf9fd0f11848273f4574ed0ba8c85d0bf1bfa38adf4ea563ea9eb961d60d9589094b617fdb224c4c9e813a39687d76c8868fdbec440bc7ff8ed0fa51131f56a3dd078f4e0523ef1fcbc0f9a2c14fdb38e7580d6f896276aae4fb9f693d0310f3f563b53f6f0269e2d76603bcdba2fe6b949783444d5033038b9a3e1a4486e65646f04bf4f600b9d1a32a994bb8a4513411e9b59f76292910f953840f67d396017a47526784a5a06cad5b9b0ef889148bad64a3c9aace819f1daead6da0b4583bce1ad9ef860b3c7d9f88289b29e1727afdb637cde54244ca51748aefb397f2f48fd3d0475dfffe9836cfa6b7daf99d9f01bf27510afaaf788b7596916190de50f60d419b573a608a91841646f5dc8881b8545f75a522fb67fd413156ed9df262bd710519e5a1c99608a3e3298ef13d242d26ce6b856dd6cf909881a1bda7ea13e127d2ddaaf6ae672ee83c7dd2ea1445faeecb21f0fab0905a2131f6eddcfe059000fbe2d630f86a62cbec31be916ceaa44bf1cf65e7a222f8ea595b0944c4394ac3dcb4f94ecb702dfd34e77d383349f1f2e7edc29868fc2d6aafd156d55d3038309648141cc169da741e37d7ee6a47a47bde0b6b7e182c23dc4bc814a16a6ca89106a47d0ba6097af36d55ed1063724e0e469904627de81cb96af5ef530e6f74df49d2bdfac9cf7a5244b99e51585cf8b9026ba8939ab11db7c1653e2b1e5ece69d5390e346432d0b0eccc6c4249abb85643bf6ed7911e292a4615ae04ef98a1e88efdde52e5f6d99dde8d661255842a34d5da2e7b342d0aa150153eee03ccfa08b4b84684ef3a3a2803f1894a0fe06838c191df8e68bdfd057cd31c69ae406188bba8ffb692665157697eec7eb538fd8f913c4919140b83533739a9109fcb0fae18f8a66f6a63f618cab1b46a32c6ff7bbed28333e8c76ff705f974076cd27c9d71fc889c2a85bb118e61a221e1111c751bd7bea22974b2fca35e382f46b10a1a689ce3255aeadde883132e7c34d3fadf95e95fca62c25500598a2f6b65fd3dd22ff98057d12c6698e1f829d362cd494b1053c7aaf022594f5b50276fed0144d1147936f1f22da89dde8566ba6ef6759bf3402bdf9214fb0fcb8c7378a5edf35332df573b1b8c35b03e05bcb918cc2a03f4e2fe9769bfd98ba49af98d82e61603cd5b29ee9f974ac10e593cf9d2df1cdd297e33b047acc743dddba184dc115043897ba60a4e0799ccf59f8d294ca62b626d5006ccfd678fb8a7dcad528c7c2466ea0f68e0b4c4fc5811190e144527ba00b48c04406131bc35eac02bcf353e59feca64acdfe2d9aa5e22f2856355f1dbe285248d4fa80a637a0ab0dfd27e85026791653c61ea94d4d458bbcfe720b202b7ce4cac60d3d4340790dc529c45c36b63387e0d1e61da5cd6a3c72fb4fee77b43484c6e1be6204ea5757d971b7f6a176518f55e3721a131ab1bf1de6d37102822fafc41824882f4ce441217e5455c419928f102247ea51a3a22e706dc1776a47571da7826b48f9019d784b7ee2638ddf61544dfc49009c1f786f89bb74f5f7434f13768cb14ad9655b8d8fd20a7b13ceff4b4506d9751e4c02e91f39f7ae7e51a603be2e7e2d6a14386cd197a58d3b59adcb193c2d8cd9afb0314d3c2fea86050bff0b51d370f3911d437fab0a27ace40054059540198ca3323ad6df3e5ac27c264bb62ad3a1a37dfa9a364e298b53707cd3e402a87d7031db8be0b43820746ef1fc3b2a5f875e486f7941a9a5e1d4988b87c5acf1f22c2c3d5d47bb8dad4d85af70e19653a5ef00df656328aba13d9f62a9124c122fd7e0860f57ed8ec72b08b01ab021cf28daa9d4777d97e2755e2790f819b14573dbba6de6341724c0e5acaff3a15b0342adcaa8ce31d1ce36d8ac855599b5aed659ed58dcf0c0c4e8f6999cf7dd4a3e27578206a29d29c306b3331261dd380a8513c0d2dbce2f689ba31bd5baee14edf04d1e56673c9e7ebdee73aa774e735d9e6240bc28e206333984f93af2f0e5c3b97d00d9c8dcb9cc5660bc4456033a0ada72594dc99cdcf7aaf79354b33b6ff54086dff02ddc53f9210bb26ea7527e6da764b0556efd02c0aadbbe43a160b69ee88c61e5c62c021cad4eab958a9acfc805c47a8ae68d1b2790a0dfcd7b989d04364a11944e7ca825241be53ea5140663b6057a24fcf600a4c76f820a35ad6fcde41b37533e31ee4fef00be7d95b6beb65874efd798efa687b4aa92bb935946465f78dbb8497a658da5d4ba0df96504b10bdcd4be8f5af1fd2a77c4ed751068a734fea696c2deb9c0ef3329e696b4d57dfb41d181420697d527455ba98cd724a280a2051b0123553046ecfa209afe0408991d90063a010409fe415c6b964007d747af06f9967c4c037b9b8946f9799c8559d6e6afb87d0c49212547e0e8b42ae2abcbd6eda14973e09deb3bff15c7cf25054be8f5c8de185c3aecdee63a000a777ce13e07085ca6ed3c39e3d26d80c89cb1794260ee19d52aa01e69b67b7b219704268ba376beb8380166cf1b5b1a8d7acb9a3a946d4b58617e3782faad383c6d6654d53dbb968e70e349961d6e85a26de41bf832591b81d3ccc323f0f2c338f975ff8634f0924e83fbf0a474d58f8ea25086340f1f5e399e8bef6de7202233ab6c3fea836e959859f724672deb7db29482dba59d681f16dd5aab57b11aa24adddad36ecb7fd65fd073f5390bfe7538fb66195f608dd7c4216874bee4d14a691074da82a6825858f4a252dcdf05532dff994a9c21206ac7f96996addfb3de82a661df6b1df12cefee421a3dd6082a4a7cae1f1da5c5aadb2b12dcee8668af192d285bdbcf96ca1bf81ea5d88579c376d1907c180be4cc8531e29c6f89ed028e7f8774e3e88544876369854ee286564afaf19100a670719f56761b18825fd2e8f5328d2f26c10a6593c1c0645adf11bb47502b91d328df58a6dc1d2e06131bdb31ab637a0e3fe375e37f698a1163b0613b7fb1aedca3788d16a55d9c7335cbc339ffcfd263b98df2bca8d6c161bf0cb8152e0a46946871580cda7033640a809c588a2553079222431269edf716aeaadd8fe40e4cd2ff9dba4d9b1981b394c7405b3c2549583dd94311b70329e4aefb4a9b9eaccc451aa49ea3b6d0b07c60c37141b52d275b4005ce357c68312ce60a80dd7174c50716600a163ee74beea34b3b7bc9c65556cf50cc3f17ba63002783d1aefd1423e97dca79f2b61804e2199229df3c4099a01e0ba902c1d6ea1967283ef1d3324ff4fab82fcc6b650aab2cc75a103c252b461a16db2a2fddb051bb1300afaabc36415df6ee5bd1311cb0c8ab99360c97207e614105f81866a590f7505c10037fe2d080503faddc74b8dca1530071aa13f76dfd0c81a883972b0e04ffbe9f2a777ab5b3ddb88532d41697d3e02cfcbd2389cc93d374551a779def763a7177316085343065d0e739b2f03fe78943b1763b6f0a88cba5c54a176284ed14e2f5f3163cd765011f25489bd0135339aecf132394e78b50c67edbede163e762bbabde2feaaee6215bdde7a0c304e042ba6fef21123140cf623cc22f573543dd0bb26434f57406fa3b63ead828d55666f326acb19e1458d797f76997a8df2b7d4debcc7d10c68ff6cec0f88160e4f7f14be25567d081d12a8d3e34fa1d541550f7b93b466b0bedbd6ccedc3a1e304df7ecafebf70558f007db24d37ef64af7e39bbfc2b19e6b3e8ecbfa372906dca50d7ec1c95912461f4767881a6e9647ba7580a71760cb9922af54cb6eab6806d874f7807d1a00589126adecac00c025b56fb005ff4e0c865ba22c9ab6d9766a45933aebd2e87caa8467aa1229c1bf246e1d8f10997341388cc1a9390833176e4d4829bc7ab366ebe3b76ade687ff36777977c19eaee859c70c3e51881efb91ea2ae8fc49d3e183d7275d4c725aeec300a13c37b15b199f64ab044fbb19f25faf1b276eeaaa4a624261177fe9090f2a63c3e7a87d6b5dd938b79cb32a00becad48eab54c22ee4cfd5783a4d928dbe93ca02761e2cc9c41a6753e757b97b6a1e23843a2c2abb36f359490b273baf1434798e4dd65adda61fe7415a1c0e9eb54db715da5a1a0a13578827f39a7b97fdc8cc2ba26427a8059656e450d4afe057f490550912c86baa0bc78eed6844d89b6cd2122b094a7cd09503cbcd7da1e8c23e4238d8ea5403922fe3b5a9313b2866d93d73d4379d4a6fec1acc06c2f90d61a693f285ebad51e3d53b221a73d73e48ad3f71938ad59950f470e31b3e692ad366f81936b9267ea0e2bf3e2a79432e902eb8e23f745af9bafcdf795bd33546ba9916ef3469a79d30cc349332b12cf49620998553f07ae759c7ce073e5b388f839fe1bd1080365fcf81d1ae5e9e795e8b12de6323ed724d897ef9f1d86c5f4d54e99bee9aa807565c7d4a6f7685d1b8c21b82f173caae21111c972adbd43ba9a57c000a59bb8b7e50c18738a1ac3bec757ae0d8571250f95941aef847ffd73ad4e9885400652a23f8baa5f8ee6fea477501c45ce766ed50a3980548b9d0a61dbb055f7334d18e0ee197871b39d3e82cf05661207b7015d05e286b44cbcb129ac1ce9d234b72e98195909871ea1afe0132ed851f14c18db2431d91fd00e7d0ee773a287aee437daf695f2a1a343f965974dbfab9d9b5757e25ee93dd4096572995f8825d4ed3a23511fe7f0470ff719de6a196ca78784c583467674a9191b2bea19e4e6ba2f1dc8c63df08d604ff749c5350265ec81568e25aab969e3b856649cf4b6f12a1cc79296d39cd8c629154797c7fb8c9e254ddafcdb674e37a499326ae26bbd2354a5156fffbcd2e4b3a2ee3fc141747fbe8691083c5e2c8e61d8adc983da0fc2aae436c41c9fb06b2bc689140743feddaa3dfaa4067a36e1fd7f315c39a482ecea71dd22814cb9c56b334026e53c5f32e58534cbf9487e887d369230b5cb9d7688162cca4d02b2120086701ed236c787f677852acffc429a5ccf8b6e52f3d4b6a29e819ec7dd5c46f955a017cdd476d04a24050c683e4b6278259ce4cd194227f67d6fcd16bf93c8fe8ca8c76285b682ffac3c561eeebe90617ed992c67cd90a0b26e4385186a2088881b11fcc736f8be8624828cacf11c16e72b50b5e77b064a4542488a4c44bb6b19dfc1d94b9f5646680b3ff3d6405fc94fa04e2864cb8fbfaad16034ca5a2045b7019c5e8a8668fa6794d9526fd7311c6a3b76dcafc7d03be90b9d29c6ae248befa6d2662e2e1354e047ddd7a97023cbf1053d252fca7177f3a8089292060c9ee0b008d8a8096a6749361b80eb15a071681f95e708f27bd9244c7dac4d412c7643f05496357290890d796a71a79698499f91feabffa89f7d909d69f46c9a7766054b88df54d2a442392d45f2f296eb43ef8d09df8b4efd9c08847c44a6363a6e8d551916d0a017ac99e74f8012db242344ed0e016fb53da864c64fd80af14f2dec9b27a2e76d261df25a3b7a7f3d28fa5692fb8c32782f5bc4df6ff5dad781e9f61791c51fd72296b9a45ffc7aafe442d1cc566d6f55813e3229a20a8c5a42dfaa4dd54710cb0417feab818e2ca36635f363bc1b04ef9c11c54171cf020c14ba9ed47e64a493a4e9c44b3c84a07fded738ce48ac72b4363cb2d3cac7675bc24e9078f4ddd5c84429447fd2112b5bde6eaf3e3db2ee626b85795f01421c7df17b2b3bc193a4e2a24d505c72654bcce639c1927f66780a5fa43897bfab1f3bc8ccb320893e86b9d3e7f0658add2b46828fed98e658e94d0ba51370b87c99d18784de1cf61089f7bbc805c199d81cf2ab749d266dffcfe1fe1b407c7fee465472b5aaa35101c63a77dcc7f946361ad1f73bc6e48af527344d7bc65da0c4397f3f7aa8eb54a414b6fd8b56c6a48843df88b101ff19e8d970b5c0f39568ea858a44232a70d6c4ed9e417db86ae98e06be96cf93a026031d8a08423bcbc588147bcb87786abbc638e4c7937c4dc4d2f45f936cf4fc2bff41946d23cc3d100d48f4b20988c6ed17d53901623078dd46f9c9676254c2e9d36bdb046641a76d56364b669cd395b8be52eda2d3da10ffa98b5f7963306bb1beaef0585cc2095e4e7a7594e8e36929af956f3508517b5fa1f54948d860585d7c0626b49cd356e80ed9a65c9f8a65a096ee9e629599083d94dfd22237eccbeb79ad9ed29fa5332864cd08af5c2523eb6a5e1c564636d514605a934224be98ec2b470ee483d9abef7d4ba856750fcd8c93d2c5f4a0f7393f3062051b404ad691af12e70ae198a540bda1f9fb96e150b703435e8f9ab2fa8a66cf353bec70ba93c25edfe1e25ec0a1e4f55f9e3c43f308ddefeae2a466d365e3960ad9ee0167bbda911253ffb62c00f84340317b54573b358ec64b23d2d1abeb53618e238cd4bd56fdd4acdc66e2d00e6363feb6920caa4db4fa3459d94713e1114df8ca56e332a1693e8d0314e4ac32f2ee32edb44e8dbbc71d506356130b8f1d22b2d6ccdac1e9b9da4a91484cb1c06f7fde13f98ccc5ab2f151680424faef8070974810ab34615c7551b279755af87afa66415b84eb6353253e5e37672405a0cd1ac3054b7c3051960033db3dcd9606a433f2e4301b0440ccabee6f5db7e9f2b73c555748603258b3fd6bbc364bd0601bbfaafd69abbf7047e5c2a077d6bdd9732db6c9116d93acc9ed487e836e16764d6054fb832ed783dda222731a9b8e778f5222a787ed9ff9bdd6b6ee5e5d66cde28c6c43ed0e365c9730b77fdfe02c24e3e0fa3c8dd34a666d0d464aee0f6db20f167bd56ca1015cf23fb84be622ea7caf5db3c6d01518fa71ad1bb17ba1ae7ab3ef5979279f4997fb343550c4a24ec74b57096203463a8c15e3b6cd81c1a98cd49af15fc887ecacc05849b562c20b1d2d1333a1659380030ae1627db865aca60bc0bf0c3a14272995bc84ffbda569ea2301513679db85b9b46b57d5681996ee23605a867b00c5752aa109e7720b5407bfb4c2f3f649152d930111a8a5cd7a1ba11ac601885e656d5b1eddc68d6d1e350bf4afe359b5de7f20aa468a80291617ea44131ed72659d0bf9a3907442e1c9a0afc9350d54ed28d701ac779b5c748bfcaa3719feb9262144f37a061ad89754c49cbe5dfbb593108e1565dbba40b32906b701d5049a6d31713e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
