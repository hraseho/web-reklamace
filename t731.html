<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b567c96b963e808625616ae13bcf2fd18b653c05175e4e5be9d66b016f9b7d5f13bb00dfd959e15b9825fff2e710b76be8a8d21422be0b8ef2568937eb43125ae41b8cb6e76cf0163545f897fbcd510b3c49e605b5563f2f0a37dfbfa3945335f8c805270204a9daa06819306ede0ef9ad326756df1876e0b044175fd1267b8a952d4716eaf0e8d006669defec64df3fde7004ad2f95311eb75c4f05f93c070112345a67128580101b0a179c998407b3ec06587eeee4d5c184f99b2f1327600b40de128f42200c8275200ece6e60277db63531ece567e0d95f2ff7e926afb816a0b28b8426fd1a1c80f765cbe17930448b308fd429713cd1fb43121fed372e07500db06c58e684a8a8efee7dd4f82c38d95de9f885e3706d63bb957fe6f7c1b569651a969e8787d5137e6a921e7e798d3bd177929f746ced428212330465244bf0e4e7eb010f28afb02e88654d58ca05a74b6d368ed787dde245e80427cc0933fdf7efac4cf3218e8d94df68b01f6642737c912372d868f5595b23c0ce9d6a2939014c6a9465bec39e00366b09a56c6bf75bb163ee2fbca8beabd715e68a7fbcd3691c83ff5e4a9d86fcc936091b23d22fa0c89bdccf6488e31172fb44adb580c84e338cb7bbe2331369e690b0688bd66164052920912b8716e88c96b6cb0aec6da4f8866135228606054d4c33e78dded4a88525bf38e8b70bf6e486b1b44c1b56aaee44fa104683d970d4f5fa46bbdbabb2a0d7b27deffffefec50e37b9a1849e87d3f0a4ab4c1876ff255ecb8c63155d206ca150da5e24d680b9fa87c47b40d7e237f833ac765c7eb1a4e8e11f48383904e07b97ab3f15f0121aee39ddced519e604bb34d2ccda9ba6a5a1018d6019c2978de2f4b0246f71b07299e700ce2e47caaf10eec3a080cbbf84dcff564c3538eadfe609fb3b23cfdcb6dcb39fc17aa4c76b8585d23a03cbe6e0f9843dc438aca9f9e00f23299370aa61a9b082aebfa8ac1bfd53159b5b1b3082da409d0353b3d27e8ded831c7b2b15f5aec438c0310a1845aaebc2031880bd3354d0067687836a90a3c40d028bfa24b0cedb4ef2c0e20ff75f765ea2b534a65fcda146b3d146a18f08e5972f14f222166425baca331651826988b5b6486352840333428b4d59f59dbc87891cc915f2cf6e5d9e65035b2c46db54d660224e2ddd719cc9a3b883355133ddf3621b73dbefade3060d22a00ba2f7c08e54c43b2e2f450e441b5a74eae4591dc28fd41c2184afe228ab6a52d2b1ca5365e552a749444676db2371b6a9355b354ec2eb2ba96e261887bc583a953b632626240e8baac03e08acb80dc856a50408f3219674b8d6cc7bcd52b47a509c47b5c206eb6c6eaa7e782fa9de29dab0b50a37feb7e946b0a8b35c82375b18a941bc9a343f811a50e33866dda935470df945018f0fa0a5da3d4cf718a41c2feab645f1f83dd3201741182717b29bfa236cb454caf37e22c0e1df4a56a8a40aba661bbc7bfe9a91f9b97f7a9427ddae0e4b67438a2d34e6b3d8ed37aa3861de318b6d1a4096de4955052656cd416fb5330c7b417eee2bba1558ddb2a1983bb135a2aaf3c4be8c435701e9e74ea192b40c96001279efe42cc171a6854764eea79cd2190aa39f2e4a7a41c58af4bdbfb42b673fe8f89397caa19d3c76d7aed94dc1f54f87c68840aef598419c733c49ea761453594b98471a4d16d9fce515c3a75759f7238638e204c2d30a5e3f2f61efb9fd030b47c6bc1e46d45504f394b07e834f0cfb9d1a474ec7dfd9ec3d0beb33c875a346211c91c03b5d6ae67376bcb84c5503d4025edd8f31e6739cad52e421ab8d44375ab860596fd65986c468ebbe937a02c78a623a16ba44d612ad9236341e78e2d6c507100c0447f87ed9c772019450ba0c093020ade5a060614844dcfb34ea775516677259c01b7ee520d0938c1b7d5a56b17fdbdada3fe8d259c922bd160549c6619305e6e4b72bad769b161f401a041e4bcab5dac28ac24641d89308a0fdd3bfbe76b923509c6880bcc117134321fd5f58ac1aa7495fa78510d8e03740ebee553b6d10a5c708da052051080a334b920cedd680abefa06ee0e984a8d70a329753eb713e1ff5c9354f437ba4f847f7bad6aff08bae85d689abe862abc6d6970108e6491d6cc00b0a4ecfe9d002fdb94c448a56ba4ff0fde3484273d755a5ef9c8249cdb234c0fd90f4e9d5147f0de7f9f331dfd9115ac00f5713e6f0760d57eac9988cf960ce9200e0172beb25b5608834e33bf8d6ec3c0085c4c9afcaaf2bba37e86513322ba735a180404a0702e3f8a735a35fbc3a6138933b35956504657a0a3069bc2967dbf1fe7432560beb3c644900822a528e1d1b190c161bfbfffeaf1aa03baef6ee54177b7d008a4d0432917fa5f411e1b66f0666b31af3d386d8ada18ef862bc1e6d76aaa1326233b153f5e832873f6ffe71fb40e67e3b34439bc631269d795f28bbeb190297e143b5d3133aa88d917d7f5363403d9c7d327715efd7be69e2d60329947ca689de0a6bec872f1111de6219cbcaa66d0d65203ead310e2aaf2de40c887a1f8827b069b8c8765660977282f2cf906c11ba9ffdc471116a2fe3b53c9e6d2e282e49adfc186302b568d112fee206beff47c77104f00a23138087b4a94ff1f2f9cae2e21c85691dac931c3544fe559cea4ce34ee419a083536175d1b24e6368ab93d491e6273292a5729aecb99d8a52d052bc65e8414ea5cd036cde2c4aedbd0177e968ec4dbf6345bdaffcb5521fddf916e3874567de47a48eff0722f5351fd0f538b213166d88f50935fdb2ec553b938772eefaaddeeb0d97270654b317d0e410125990691ff3cab5380d2edf05d2080165c6943beb7d9098fd0e03232a41cb81271e55c4a6a00e3d6d8bd8c22593bbb62dce63d01b7acd495ac723397cc94080c9f21e6cc58caba2013ff028dc3c749f65fc93e91da3e802d17cd3f9e182909ed547259f4c74ecaad4e981cdd8d955f99dc37daafa28c97b2b01b434a8c44f20d2c442fd1db9faa90e51b6e8e9de8a245bb42d3b63ed9c8b4c7769bce5269a201a5ecc9565b98128b65859c42138ba98bb0af0172f9bc54ff0d4d86563efc2a9e0f3a10866da336d34f8da29cdc31cd6903d02cd88f6dcf9eb6eee3511c960908ad1aea8428ae5494e67801ee097e8757dc5c0a109a775f710c998455371c5b07beabca7e3c6f2f1cfb3b53a2995fe01f27956fc02712b33e1d71e719145dc8fb80271f59787c5171a9272153a5cf8f5f0856517e9ebf8f147bcbf0689b025ac4ac4a795f0e05ce43f6f87a400e782870e6a8b9d6280354dbc196ae3abe90ae59f612b80e93853a8270d63d350db72ca9d20417ca1f387037f90e4720db7514a727c06dbdbae132a08246ae6769d6eeae463b6f96b2550d807d713f3898a504030c1954c033ebd2df68baa49ccc14dc5065dc342a08819a8e9a5fc343f5ff552ca61352eba8e39a911e3dab826feacf101b7b2bf218dd8bc2b9cb9f5a5a622a8995719deec55cce7db16c776620a7b4438854d11f8be6646092ceab2e08ff89fb1189440c87833b90da7758d9f4315f104863214f85f5733d513d8a292c56da57cdbaf436c580b09025278d48af8290de109d4baac2f769ecc28362ffa772148c5b21fa75007a56e655029a0f6d28bd0031a7d74438a8f84059cf32f07da074018e324f33f09dc1db19b34a48a575a375e8544d8a93b330a351492d3ea27a3f0fcd8918302358ff455bc5bb08d901991fdb32f3633d16c958748e40ce922429959c26c992be6338906e8dc9871d8d9752d17dc10f2b98ba0c6372d7137fdf5a577d8b7c2b01dcf6a0bb45b1a91b601b117b99625f171315c4325f585e7e1c06d1cef3b81102ae5424d07773cc8332dd4467774b4eba8f666687473fcd6f619a7f91443107c86466a10373f3b1f06d4d91a59207d65ea9e533518429def266c37f50b7746914f035613d2ca2353c87fb11bb1b59dc05c4fe16ea670229583d8d45bbde0d53c632bce75f83c0b04d4d7b1da4a5186228b32b7ebf5ba4e4c45128854465179dcf9a2b7bdb8dee885d9cc7eb55f14dbb451b24553caa22aea3139e5803a1197f03dfcdec214ad04327ede3d2b445a601b1759d3185d1f1d51c188fa9414b8d5d1b0db71f8be34a7227f1317ccd206bbad590e4c25341dcfd919b51a079a5d8b9cb5126c06e4bf75593cdea3d8639923dbb39379138ff9e0e44f768da3bf1e0f94918c92c7e0b76156cd038431de1d2f4999b42d17c6198c4abab28fba89d1b9526afd3df640c03039679b65e7d83fb115c715abf5b7312f96eda3ddc9232a1f55fc5bbee95e0a2d0df88b19178ec7518d0668baf0cd1e057028388dd25c829c9b55635947f9e0896e7d744f0a3409510a9f1d8ea7193402bdbb5d0819b48c0e857a385c1f2167aef6ff215d1c14baac37462e28915496c61090947d1818228824dc903ade1569eb8dc5e09ffe27fc760f1d0e9c0e05dfca51551e8bd689d19a3987132a40c214a54e9deab7c502c4819a0ada80342e8d8f554ee66785e203f9c08b29db847c884e6cbbddf045265d8842ce6ca5fef7a48a54b06a98b6e2677a58d2d860c776d1383e5f2d49934f017b2f97ab43df62a9fa2f2a65536368937add44ee7f1188aeffd37c6618a8dd6f51888d1db9a82d5298ce1916a8fdd78df1046e30ab69128663d058ddfc41b2077e210cda797f14e6263d14d7cd6dcdaa959e364a8f9a0be7ead60724d3dc03ba18b3824853027feac5180b9d569342fd41c4dc575b38669952cec5edefd6c4b0cdaafdb743728047a16c77db01a46333825cc38890d79977bbaf658910ca3300a635196935b55b3ef935558e2300ce063e6fe03071ce78380b4cfd55a69f1dce15ab03fc537f65a78b611d96fa7a29a69d200b99f8f06f0af2583e0c7d681e1f57272661d91dc6552dee35d44da8137232e4011432d548affdf055d081da5af845c2de7088df11985cb79e5319dd5f7ea676adb43fb33feab91dc27f29a86ce5cceeb8b0c05d5b7e96db7db5976024a21bf2be0f9a370b005f7b80deb5f95e1edd7c31bd1c13735ac40e516dd7a77cf48ca28d68474d7df2d5ae13e7dc8e54a690d0f939b504cbfcd0e37dd9def24c0e00172165518084dc46cf6cdfae8727e1e615432a8b2061e166d6586b53b71f49a86d9274d3faeb8776c2d92ffc62636aedb95c117d81b226065c76e8f13bae3c61bd966462fc3affe22dc6f49d120dd40e0b61e98be04808c7688f48b6a857d90a64c6f1cd33e3ed5f8743f6040933727403105d0109c8881ea3c95f64ded5b65d6d1a593972adcbca30164fc9d7d2fc2dc3bca01996b3dfc21caaa2b27c54a074c1a84933e5bda57770c91ae90173ae2db6eff5973bdab759669bb111e8f912a961e92257188430a2947d25b094472ae7005bacbafe904973c4df43e5a93d4c581636abcf322990a7490815ef774ef86bf42ef24e8a5ffbd753a2fb27339a5fc6a26d3032a24a94c11ff79e1f680944ad2f3c0a9169764d07883d6f26f6a6f2f66d2bb74dcf3fd8658a28b6d51a8b450ed00b752ec761e7d5415c26aafed89cc8709882a6421042dcf430481a9eb88cab1f91efae19ee2a070c304675317353c7a237f3877e5efbcf53008dff392a593d1cc8ed2da5be3d58bfcd3e001537d8b036491e40080c238e653bd9570cb6ba658cf2f250751c171e04802dbe2d4f7a80aa23d0a86d65c744c1413d34985b4ad35952548b5cfb47462ccad95711e515e0c91510fcc3b98211136652d78c06bddd83b6b95bde19267310e2f0b551eced91b3ccf9b3c89e3086c3ccb124bb7b304e5a32459afe43afb0a5284a83d8b09bb673d8fbb7349814790e9cc62fa07c7db6e84dc6ca0410dd00049dff6b6bbe43086c0ab3cc6530fb9384e1fb7a8221988476fce08e114b797416bdba0474c878b3ee249293294983b4d27c9d40d141c11754dc68e504fd52882dad0a5c5155c20af325ed054ac3e79e1238f87c538495bd91cb6645d664d5c26d107ed16d03d0758b57cafe65a33e66f379c2b920f80a9388515e2efe64a86eedb9dd95b4ad274abb8f979ba3b80697c6326ce6fed7bbffb4debd580e2592ce219880ae957604bf623a89b69686143fc1c5f89fbfd0f7e67175ce8ff02f56e1b3f6e04612e9695554c4e62ee3e1adc454ac58c1baefe67f8406107f9ad7311106526aa582e8f8d1ab817e3bbb70e0f57db5f3a5179b188834117924733a963000bd1ada5a503eaca630e8fd4b59be05df900a57d09f52e9562b7c7b73a6b20620bc2f20d798ab2e42e4ff453326e78fbd717f3d09b4c4cba8935f188e17de096d75ef3483ded4a5bd7f149181ac8c24a20655125f2fd6289c41c58c63ed27e9e8730d161286800a69be6e7ec9fad58cc13a98c3cf2b7ab2d98e3c168cd973948b2418341bb9ff5b20a7091836821e2b3c8b5abd234fcb4f418c7d9765f94ae51bfac2a2a49483c941c249bd379e4496338ac7250e3c8a278d13e9e4a73a80f056ab839787e04e5efdbea5157d22ed6f0d6c415a27ecd2dc93815244b997233b884f2ae74ef5aeec3cbe32ea7bb9a6aae19187d277664d6a81ea85030cb629faf251ee3aa8ed4a5e0feeb7791f3e046f726267215b867de85231af66c224c490d4cd19c9f544790961454001dc287bda127465f65e8311c4c88207569a9df6e983817eaa83556f3878a0052bc43cfd55174d04ff3dd8a7723d67394ecb639701729bdb7ab39d9d5d2ed782920b860572e3e14406b862b4fdaa46ca9890a1b859aab7987c2e6f454806066d3d06c5c1533e023d26ab815263f7f92512ffe01a2cafae56c0ecffba6f29947aee64d5ea381e20604277ee4488a6dabf39a7adfff4ca9ba414a464410d10b025e5327120b9a0eccdf51ca7636cecac21652e23a29817a3e2d2484a39c479ea8b6d4b0d4479794f683792ee819cfd360897d55d72ac702b8132794694c659cc780e6732023664ab4f747f63f1180f17cbbd15356a75f7c4e49c5e87af420890a1e877feccce1b02e099a4b6a7c915a5289e9d405148c152d2f6d11f2a10cd1bdeea6957720425c781372b080cc749d04dd66957634e5ed93fbe5813b5a8f1d8ac75fed2e65235fdf86e31cadb1cd41362ae6ae8fb0745bf44f7d3a2d9b63ca059bacaa12120468e0f80182297d629ab2bdf6fca92fb73fcdeb8735c53c1fbed3a35c778a2414cc60db96865c45122d320a26f08e08c1050532cbbcc5c923175bf53738c992d1dc9369b64e328d9e93cf763c24fe2b16647c5e9d99eadb5ce4bc2fe7e8f2f14869b593a4b911e60c09fc60c8e3425d9228a960b6bff93b040c737f146e89e83dfed6a2dd9d813374277dbeb60395d419fe33ccfe320d7545b823952ba3bb611f3253eb7f6245abaf8f60df22b64415a476db30d4d7e2be0a39df4dbea5328947d1d013a46ed6a68dc887e8bedfc09fecb4e9d84c4488308f0b6f44289035fb858d13f6e0e97ed29790258502789dfcc5a6e7ec8e688e73de55fcb59e77b525cd351c36b9da871d64d85f141f18ed7dad8eb8cab9613b4e044ddcadd7442cb9cdaed2215a97aa45963495a11aeca4e4b143a02f0ea1db13d9c617faa8073c80249ed481bf4b7a889f91727806151e0b0c76000e4f77ec9466362f833944ece752705959bde1ae64a5c36c89f7b68ef1896ef9e6f6b058902279896b4d349682fd1d9f28154e2c2ebb8345121442cce4bf3fdf5522adf6d32ceeb58f377b70f0a290a930e3bd48cbe1bce4cd034e153be61fe7892492ccd35a31108eaa0cb41c61a7d25f66f780f57795fbfb5ebc14a3032dddbb4b517569b76f9843b1f187742238c65dc5a4ccc14827eb48fedd16343684dabdf510a3c5ccdeb2223f72c2f83b6ffc81904ced8d725d2f91ff8396e26ec7ab73e8462c5dbd18ba91b910b41ee200b3d3e94b7037f101c59ccb8db1ab93be33b5d144ef748b4990e65b773b47d882c69a455f1078c1bb7faffee4b0e821164e9304e4498c8b26f61a5c4a5f3ff2f21ac753ca810f4d6992870fb09effccc10bbe91fd6a409b39c15e452709094da547817852dafa7fc19012c45e1fae36ff9b70896b3fbcc44adf9737ffa1d3c70752c8de45037f4a692d9221194a8bba922fafb41d2d69a9a5901d56b1250f3e6605d96d9be3a43264ae0e3417972567ebd51cd1e42024f32711974cc3a22d8079f2778a7ba70107b5e41a4019381066d9248aed6dd8808d27ea94733d44c7d4e2700c5af8cb467841a06dec529de3115d2176473f5a591751910e5b21c4da20d6c074b5c7c849c30a940883cbd1819d2da87c588748007fd4901c1c14efea15e25e368b2e63abed9bc907f2467b231f58edfb82f77cc1250fb54028b45783509a35e13635f64a04f88aa98bce0f4b775893930fc750ccf9cb97b55141be09f1de3d75d407b79ce2715d1b553e103e5342dfd671a7f2992becdcac33a353b348cc83fd9d9c1a34cdaa6988f301028a33489700a90855b45d7b9f406cfb959a2c922071aff3f88b68e3a544e9fa738b2b79d1fdb4485bc6981196b6118c327a5d7534c5aeb5e5d111ae5f94df200984ff4ec0dde3de71b6ad1acb40febe3983975b940dcc49f3208af8241a1525f309dbf9987ef080b3c4f47cf56e9570f159ceae67e112c5e824ce756c11c22fcc96444032b5de9ffe6164e71c442176895cecfcaac62860a966c18164aa1a2b2202add0ea07bfd655f49daa2206838893c9ebbc8ceb5c829d71ef1efc956e3565022872fa796b850d2409469405b674feef5ea16a2e09c84fc0e1396856d344600fe958ec3d0f65a98cc88181f26820a20a2b7110e0479d6d94f5870e263cb54b2e7b78e4607ed8f455d0266464f021e0e291207d447607a13401d79ee84116fea58530b2fce3ccc7137d83a8f50a464e03a09647487167cfc263ba33d688272213f71dde2741391b1315fbb2328a4bc5367ea15bb916341af1eb7dead12a63636f46422b1b2e33c6c29fda750d3161113af353f7a6e8e325eaf1a331ed9f6cd8b607407a680edac6e06271b9fd116fc8e739cfdf5b020dc89ad171c609f7d6e855a2875f526aaf9ce387159da80b150f1bda4d8f50c199c70d92e21e02c283cd6047a9c219f24f6b5b4d118b12b16cba9423d97a5d2a33e4eca608503349892c3cd3fb91a517bd344d6042ad56e630b6d2a5ea08366ff443db42a02452a57c74c1d6095f684b4a7a5ffcb8e7bef72bcc24a07ded2b99b3783ff82dd6d6adb07e7fc152393297a75f3c0a7c3e5c6d4160a8394603f9b19fbd6069c2425cde309233788b6d3a39c39f0e4920b8ded9fe068822f5e2024c59b62b62494cf34975c3db08b59752d41fe59a7497ac0474c581baafcdecb4937a87da59763aed1c1d6c6fdd4cab9b1da802dd1ecee3a335bb03a8eadeba8202429604cfc9a2738fb3ba2e1c49cadf9b643627888eea755dd2fd74242ef382d228aadb5cb370029d219132214e86e784040ec80b35e3c22a6793bf0a85b663a983efcfcf0f2b539d85513a23be4839fe70857254ec61b2bf259fe409a4695cf087922ade25430c1562bf9cd6155efb3caaa12f4dcabc32a32162dabf45b5aad232080a797882993018198e0a83a44323d25731d2fed037411d23c6bc2cd1b725376daed84cb4df0e7469cca96881f52563deb7a1963b4c2b0cf533f77b44728fa0b5920e2e8271dad9aae5661d78fabcf7481af51e1f4d8a46f1d88e205e97927d332a92819af12bb9bab7d16cd60e97b93280fe61153c67fa31335d7d6ef2d49fb94a1dc0715bf54772abb91380fd22e6d4ec5f08841a12625ed0717b86d07cc0dbfaae3116fb42862ca3cbd73d25c1530bf8378ac52a7ab4f40c4db1448811b843825f792045ff7a070ce5c3e7a550d73307baa7aef48b48c336df51374c1ce37cec545c3d8d760c0640e73697d84e6a4b723d5ab3ef5039912acd7f5576dc119f3a6b029a8954391e43ff78b07ad4f66f810f544840d25d3aa6dfaff13b60774f23923a76fa2198c19c1f01db6b1e0ff33638f763e607fd3238057a120258d1a31572c4b7d828bc98444686d62729cf8adc4c728e3e16dafe6fdab20d716ec0b6af246c23b45f76df9cde4dc36440bc47e944ac59f4b4c3ff8d98be2559d431b06462bf497053e2a68b74694f425d874aba851adf226567b12cd028f12a683c5224cedc4d2da1e5b65308456595575ce0110f6451248923f30c8d56049b22eda5686acdfafb378ad7b72f112f7372c6b72e217a0bab184921f6662cc70516c657ead1c17b407f88ef9b2c69febde1c314d65fc33143af224765c76e4509371fa458b46f8b284b82bf793a609724e5445f875c836ab9c1dbcd98bafda3b76930c09ab2b9b4b187ae9995f8b1c6191a42c4084f4c6ad3242a083c0a9af781961ff568c58c8d90265763c812a9510a2a1da92bc4c4d1a604451839dc3627e8e9e655b168f36b1bd5f7ce7ad47a4b75924760420b76ecb36c07ee2e3af4398d6e2e772f31f644f18e3de7ab2210777e32dd19ca0d004408695dbb063a50bc6f93b39b1b360606f0bca09a5d6e6db8bef3cf2fced35fead473e35cdf2d40307de7068ccd676a8f09f3531751c7fd001dd35942e55d784b2935b736a9c34736dc98136b9df751f5247dcde914e29aa0153121edb540213595e2db0af96809a157a0abe9897998fec8954ace0f55159f1b062b88b727209754b9f7885e0561d149608a8775e5f213c4676fb33718aec28320","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
