<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54aa91b9e8b8c34f0dd5da1c3d6503458962b9dceac3c211d760ce416fb530799ed04653f01db0c4f96a8dce098ad7162f7bd6b0afbdd8d43ca9e01945fb1d92bfd7f29f39e9ebbea0a853dd4d6b5069d59dc7aabed9a30fc494000ef2c46c8d9358243b12e9ea224dd67e608cf2e39d98a496bd1b3c72a87c3fdca5f8a907d1cc3c5a8673ddd5ea1f4e4348ccfeb0622342356794448f6fc1dabdefba9367cf57820707271c9f3be12875e7e24e1c5450cc4d706ed226fc2e667714d17e138cf435834b42bd6eecd1c5ded8ac676cc2730440e01c78a0f5597dec1d10b69617c9e08c3ce733b79c6ef905c9f8b31243fa5d62fc3b1d3f2a330530828eb74301c39c2f0e3a78965fc8fd4ed07b70b0dd3c3faa31857cf6036f479689e2bd014500955c66159fd8df608bb07ae9f301cab1c74cebd33d8b085ebbb016a3a81c6fc7662b888cd2b2f72b7995974562a0ebafe7268487014e7cfb1f9e498448b5a94519e95ff39e2f2e494c5eeeac8ba278e46712fdefa94e716fa5086a313502fbd6a9d0314e5b325d4d0a71ca03fc599d01946e1074dda544ba382d8e7a06c50266314818e71bd09268d379228caef0e6c4902592e60a217ea7c6bd75ea591acd037b22c54b348819ea2941935b589073dbfe6f1cdb205d4e01984b5775383ff40c1b0d5eea1a6d645249cc3ccf7dc54202e36b574127335bd17110392dbaff1b6f26596242927a166fa0afb868ffe7955f5c8b32e74ddc85fb6f74e289f37c547c6fe72aa4b743dbae53e6f633988de721ba20f0bde8278ba599ce6433144d332551bb7c23bd15b7d7d78bc02b81f171fad503fcf230eb32feb868f449d4b520f1bc6ec8877459c1946def8e6dbeb5b51ceb2a2e510b8c406912f6b0b3db33d7d4ed917fa984442ede467335e0916bbeaae5abf178243b3f7f326962dacfd57d9ab51ea853289d8ba3cc05273d7276e22297d76b248366bec9529e41ecfa9847ee20517530399b638a39ee3d7c295c2a9550ccf88ade1ae6e583682972c6b1509a4c9646242d0ffc837404ad832dab2637d5e49cd9805c2fd8a0f370fc785758bab6e1d37e01d9580e5d209f527225c8fb13e7c0d494a2e722c4c83638d645a4f3ae5d662a00894c512a7efb89d3eb5ac6262b4b4ad9ea226bc89dd750353eace27afb8380da439d6748bd1f47b104cc9a88ec9049e21340ae9517570296cf98d96a3300a687751860aedaaa87bf8a08958f93aa37848b2422367911c529b6c673a645edbc630372aaeadb8fd24a31544680ce6f608bdfdf8875f352cb38ca16e4bdb1899fa317c0373096ebeb4bd0b3edaf26a6155ec9d5f1474c7cf5fc7c4ddc002717c797f91c4797c3523b707d234b99bdf658d8133182949f64662534a2ba2da5546bc34080e26985f7882dfbbfa097da44fe9e2085e462a48fc536936ded1820c216b0130a56521e98009cbc18ecb0eb893ac018a95abcbc74d990e6cb43f513f21868519f5d4199ee363e16cb7d5768a7930613aaf3aed736216dff4218ef322705a455350d2041a9bad2dd06fbdcd83653c4a4d48523a0903151db188bc7fd07b7e630617ecc86ee2c993ae5540e9c20d402fca5f101773e4017dd0f3bb87f757ebb791aad6c0f30ad300b78cb0f5a434db9851bf44087a9c32c33b26b2cd0aae84b1c7b6f3fc9aa7a10c42d4eb548d8382b7962ca79d2e930f61c06c98afb67486c2dfa74c77bb6e503e4700b91a233b716a00954d15f516995f4882b7c6b591b568e5a0481de1011dd0e456b04940609263391a4dcff781e249aea93d240b8e96f015fe3e743a1d034709205b02bf2de5d055ae29cced0776a04ccb3d9011dc882ea0820d8ca388e4fa1c40fdd905765362af11ab3cb72f8505e4e4fc37c6d8de477902fcd8b8734bea6f57a25f9bd5bf44f9142410af9c3e84bd50307ae617426bfb92c2acd90f4286c43d3a9806000c79653c9059f0437564668bf5d54788a5081630754e34f52a11c72c5260d23ac1ac86de296163ca0fa5749547b5ba794551613eb5103356a140a3e9350ead045a12ac6c785a0a53fbf75eeff1c53e561bef58bc9a7a60e84ec062b1ff820a647a4009ac59ea83583f357bd663a13b7a3aa00d73aeccdba968b32e5e9ec19e55d5ad93d8ac41e023ae6b45e47540dd3ed5f15fbdc61d687f377be3145cbe8f467f9f0053b5c2c6a7a01c7cbe8808418cd54a4ef126e541db4b11b05c5ab23e5e5bd148d31d14b955d872a0ae50e80fa03e904f69fdac7084c91dfb3641fc2bb981034dda19c5b6001b35f6744ae2b532c968601692fe4ab5ccb73c83566c7d2a3eb31b73aa0373318242576a97272088aa32f7789b6c31c77c515ef1f3ed06eb59e06fc8d1c558311bb006049d1e4589b854ecc3bd40fd850f82f87eb99a96addfb667f9c5da1f565d51a1416cf4bbefc32745fe6bb9b8b818b452b9791fd053e60bff75aecd956f6a01979212f2dc7e0ccf4c3a1af5b2f0ba5b8b8693beda3ea7711a4e214cddf415141a024e01943318af8b032330ae125a8c832386a306f27a6b71e39420cfc32de81d5f51ffadcce6be052642c59a29d9b1d7c88fb4ec4935f14e49d1be56504b76cafaacaeb82987e48f7b4437a8fa2bb4f158ade9f79b6bae66baa9d0e2d6057038dc0ab0fec51ad3708580a381d46b4b3df78839b7365b421805802707570d08df0551dab7836a8c99622c85b7646557cfb2dda086cc6ff54f8a200d37a4527eadf0c2f33db34edba417afa205179e2894c1c00511369f2a5a45c9f4ad64a6e31b2d33e8cfb502923b040ce5d1018cc0d65e1e3d0e24a75c716c8cfdcc7a9bbd2ccafccb5a61f01143b50f4d7fd471eff146b979dffa9b6097038f3d08e45ff5f9d60043a9ec7fb7bd371bc36eff01932b741990adb4c8968909cf054e240495b5c8f96a51d0f0fd182a1bf842f62f8ea3ced9a658995a39a80ea0511b9ac4fdaa15987557dd251463a1b4abaddf965b3fe87b04c0db061f43d5c5d3050c1762f15cbf02c6f3be533b1f138773ca32f5b45d5e93c6983699f7bd8552b9bdf2ea9d91a66416f088139ece1eca30bdec80527d84f1a2237eb4fd5dd77856ffa83c210c0e1aa596fbd77a490490352188f6da783dcb5f26464a18df00fe7c296db45de798a942cc0bc0c887e777668e5de48ddb86b4d4c8f02dd3dc5155bcb766a102492106f64be27c33e1534bde0a6b1a660918e2b39b2082a80600d70f122451ed564c577a7ee3185deee20d26aff2f4dae4b870b78daf78e3cbc0aad337db15d32cfd0edc75110e84a22c17ff2d0a83091acf9d3851e74cc84424ca93dbee068c2ff0adda09ba0db7eaee93c93ad7d9862f7b7f62bd08ad3b704dff375fe9b4af1d0ed371841e32e5fe1dd814eec18f130ba79c6bc029a4a19744fea44e47814c1aa78db881cacf283abc572902eb5e87145580538dfa3263f2ba996a341641f7e581ef9e33c988bc3bc1e6579a3c7c8764c9b45f005860cc2f2f24448ec0997a28de12134393dd39fe4437ef4529fc5655ce43e13f5234cd552d32dcfdce1ca4852f594a4c1457cc6eb2174194fcb9c697389f5d3ebbfffac0f0e8333a0c72e550345976b3391d5f5d1c431816f671ff24a9e2dd82b0584f00cb1563a48b800845473d50f026d5e1b246ee470168b9c304d06ec1456af291ee285869a4740709bd558eb9ee1e14527d6097c66d7b39013f8f992548f65a09d19ce776e0d13ca47509c081c263d76559c50c011db4be82f165712e485beee51d90b176552ecc7eb104d1a07b5afacea3cedbf6d52434206077cdccbf982756555a884895bd70087eb259e0cfc46e7985a08cfa2cd66b8c6516d6b9114681434e7a0d379aed4cf2f6a12af6c33c94e2ab4f69bbf0d59ba2b72b38fd7af944eaac00c66394a2a6c27afa17e3a5628e3d6d355d02177de3c49e9548cb4c33b6c0c0e97d47b164c9077c8836b37c32257859a4e0856ae7a3a739483dfb8bce7cd13618da762eebd88d9d65c37b09b67246ca8a783ab225fed90cf3aade79a33174c43dd57e94d1e9c707715dd1b7a4bd7a2efb0bf784ff38886af07646897b27d1f44007434c02166c3bc29c03b073d5adbabf5a0ae03f55603d7ea29d2b38e8e19ef920479be9971f3613794dd91a5cc11bc5068de76f9cb82fd7942b78182933c7f2a7861c9cdf3e037c531f7d20a6f58f9eb474c022c2359101d93fa06d887926a865a16a081f511c341a1d36df84ba9d31ee9c4e54a0a3309c97abeb021f4cfb08b7696e00166366340fdc9b246ca35a8541179a48976ee288f61ea514a0596fe00578798aa1a8c97cf702d5cbad18f9fffa8c34bf086ce8455befdf3829b0655d94b1aff2a84200ff9983f9c4db9cf4ab639e2e94b811b94b814153fa59fa62d0d6dbb487c443774e4ea39a69ca609ce0c18297ca067787c6d5dc8e3755fc28b68fa0730bd9970bd271abcfa517da9fe1767388708aa760f8c7bbe86e9d70be53a49c62bee0d356624838e6eac05661c079591888f0f3f8da2dfc9db4c8a6990e6e7d3d96cc681754bbb11d9d3d38c9a94f34d97760919379c5f8c93810140de7e55c0a864f6e8523fcf447b9b71e5d925ed2ca27ee2441e993f6384d0b020ff9a0ad1c9a915dfd02752c2ba23d74247488d581fadd742f3ed933695637248eba0ebfd387f6a8977eab1f19c92d9b32c0fbfc12d622882fcd17b8a1d3bc10e8e418ece0b8a51786c392b963b291f7b0e85689ffd28626df353ba2c68681271bcc29d3057675082a887bd2e5fdc92decf97c64b41897aecacb544e1581ecc6a8cbcbd5c9e855aafaf41818eadad126876c6415b8d5dcbfc6e15a2824ce5d0635a0024e672330d875573969f78f63e8ab70d8ed68ca26af4632fc0792f561a3c92c12520629bd25f380df87eda160c14d6ade4d67e54ab8f00ea6037f59e3427df51e4c71acad326739bfa406644cf5ada01f5691219fefb83af69cd4b466e9bd157c07799a95aac18fd2d1e651eb323629fa2f9dfdf3fa9ab9d5c24d2506aa44c415ff05ca72ae85a8dc5fee4e2816b01e52af3fff43c6d984e478b7fcc582515b439756c32e75ed785274c4a951bf0343f053bc395ecc04818ac26baa53e5d17464b27832ed92aeb599160e69f8df01d51d72387162aa5d820ee29c675c3f7de4fa758c95b73d4cbecdf9e40f62cec6902dbdd206cb092b9e7a62cf3fad007bcbc8e904c4a75469b593e99a71d863effe051df3d2ba02671295bb5afbcffce02f19626c0cdecc43912f86bc70ed33e3e6a82da9ebdacee1d85365d914f575148eed742028a4f9a0570f630cdd2db63e0c33f83b670c7b12906fd2faa0e751b26c55434431083be5175f292ee37646965c94c7ed1cdc47593a1e435e3bbcca409cdd3343114a3b4975a893ff20c92e4dd9fc01cee567e1a81916485c1c1015e444d9136773cc71e7f2a288fa6134e2ebab09c69a432cd092ed22cf79b86dd73a5ed16970325885e744d5c48fed7124f90f6520b502c4b0e8b0b376ce173d20ceb3bebea357be5c45c3e3f763ba7551cbd56e318699458b0f56ae2df338975bcc14aed4ac367da29de3623776b40d0888f3a7f9fba8eb371b8dcb30601f1e6959224433d788f5769b89f4b140523fdadc0ad67ae0d6aaf232d031918702ae4656729844d75f8c0c29f0abacefcddb3fa4c4b3f546a68cf4ab8d2eafc00dc39ef68415945582ba4bde104c2e7a48969e2cba8756380d85ae5902cf4141b6103510003befec8ca2700c8af3ef694dc41e4bd75afdb0b0ab657eb8eae484416634f696f1b06e94dfbb8e40612fe65824e545772bf7a225c4b31b7da8bfc6b6c543afac6348908ae1493efe05912717a635bfae544b7d7809c40ccb3e7a4bdd300099f90ffcd57d8cf51e2b8d85d13f794e68753d13372fee80f80a15d16f541e1ebc0617b92e45fabdf2a00e444d4dbe14cdcd0c02939acb151d655a15f3e2a763b4a97fa8c3a235988d3052588a638e31e830d35693c61cca0b5f1a752239598006e0ee0cf9fc74bb8c3333d59505f01b11a484c3367e8db98b47960effc66bdc4fde18b55125f78fc14aed8e1cf08705c85cb4248d9a562fa5d4b3a286d69138823460fffb5f8e27e9e74bb1f4e75ffcfcb05a3ceeac434dceeca44c9fec946765c588ef6cb8d113bfd3469aea3f510b6d8b65fa3d25bdfead8d4c16c44776f2e133544e68a568d4617761e4423cdab4aa63246a32e4800fe6b272eec62d6e85262d8387cc9288fc6c58ee560b9c6dfab235e1d9ac2ea71ebddeae08fd984636053fba57e4e347821302af08d286552319e7c312d69c4d6ef5592ee43fdc530ac032ca9ab3c23273905e673ea76e897037ad3bc1fe7b35bb63de9d64233ddf14b47506b1bb471822e2c2b1c78331a0772a1c2bd079caafe34558837779f7e52f48e27ac4856f0af6a60aaa61ef8e43f242f6b27278db7b0ef0386bbfcc83ba30c7a40e6ae230a927b4dd32f3451e6e0eeacdb86b5585a773a98e9e32bc1089897c3c8fd70a6b46402b6d38585d0ab118a546989e78acc06be2598e2b310ddcb00d39099b1bf99acdae7895ab294d21ec92fafe419e790c9a762fcf8065214a6ed77bfc1d972911347b283df25c763da3b4fdfe7690a1626146e8b34bd3c72154a71480adac533648fcd25825dc005cd3277bd6d30eb66cf7c57f013fa38434f06f6c45503c5b3d8b4c2171ed4b9e55199d7239fd1cae67846a76221aaec28fd7a83d3f1f8d3562cea07f0cf0fac8643286bcb8b6302018d76123781a6092a477401c3ec28c9fb11e07b8a190fd8c4ccdff171d34244c600399d4e5fbacbd471632d75d7c5fab126b13cb5fa9f9f9294ab1bc085edf12c97505174bc28b84594707944577ca85c0d04e4ba6aee9e6af54bd964418e472e7bfde7993cb5bf50c50511ea2297134ec536597eb53444ae12b1e99169843ef52b6ef164303914c47a23eeb2a2e0bcee7dd68237b93b261e033545770d44be23091deacfaa799e7947b767a6c3dd9dcf5cb16e9209f17a82b203b75493d79d091d02cd4527503d919f3bcde77ad9003dd5b597a8d4acd33b2c8107b7a43914105b360803aef35299cc327f8c2fdc85c02a3926c0b93fb2962a9caa41c9bedc275bfdb4180a50a5d52926d3f047a97120312731d10c19aea22f04cd5b9c45333ee0ee29af176f359764f7b1e1fa4a66348c302e95c53f48380db53474da864bc90d15b9b8ce7afbda710a274506927a965815eeb822b4d6f5a4368016da749163546d99547b43ac3740d82a116883dc6924e3704664887eb0026021704e4a9b2fe775d4afb41eee4eae299e8024761e833be11bc2ea47a6889da8544d575fbc1a4358949561f4847d74875b850a946d814276413480f8face0ecb7a1cdd8705e54cc6bee98c7fe3febb18abdfcd641afb870ed45f1662199d26ddbd20948b9267bbfe1f1886415bd6c2f7edcca1ccb84369c49e3dd15d2862dafc88952934c94486acb7ce4f9011de88ccba1496ae17ebd267ba65f5bb6fe0bf04b6a34b3b9e0840e01b369a80ec4ce31ef062ed6195965f493be94640e33631024fc044a5d2ff2433a0a2b5394ee8e11c0bb1c61be7307954bcd0d61abb5a523ca2062be7dc0057aa563ac3123e10cdb981e49dc14598af352ef71f6f46cee59aaffc5fcc82a39faf3d4e8e5e9ca78526038fa654a8fb4d8f3d791acb969f9b1c1b0bf0af0903d76466204cb917d12f64b49f59a48e32d192942f4c81c45c1dc27827092babf91ae530b353cfa9a036a589938f0fbb27188daa0d6567f9dc6baa7b71873fc5e8610cb1026a71cd81e80653ee8bad6be80a3ba8084663b3864607ebdfac263eff2886f04828dca0577efe418a794eb66a708488ea03cb9af684ab281b273803f4c7721f30e7acf0b3d058e9b6e9a282bdd4ebc5dc31f43bb2eb0ce8a6fd7286f242c9d08eeb6a42d69794cfdbb8b6ce4845803e7cd304f153208edd6b43ac9dd1616b951f834a465a5ca4b57666fdedb0cee756fa53e2c312d2aae64daa97d433beea49dc6af5c2fa6693d6a3197392b16e9885e9486190fd9da82a4fb44605ccdb61e332630eefdcd6d9a798da430ce901314dc4dee82c541f7bb7ec3f11330eec78ce78a9330ce43b999d36b11903eb2953ebeb65a23e46203d9a805ce27d3c17fb6e41ab49f3ef8b388084c40d999d376ad673b51afc158bc4a54c04670b5b2a00d08ac71b6139e50bfec3b0e541af610340a96b900121a33eb4eab14f73fc7745bbf9f18165b1da15c8cf689b9b799b03c2d3c2c6934e0c7582d72026709c9c29328216540a6b877227cee3f9cf7dca175fab4d504bdfddc07f2af981cd0f5d07a60ec40d611fabda7e77b90f6f3a246933476ee41f45980b6be43b33753dd96abd730811ede829c21f0e9337d32f85e97bccf702fc2b65fd4dbf12f354fbaa5aaa34a0a2972e325187e2b9a9b5ca509d7b0b30bd6a5c8bbff654087f0ac58067164324ac96cbe37cce61d7c0a88fe434c0ea0962cce1b37f71c611e07f25caf1c8c84cdfeea26473626e217da7d16c2087f0d8867c5b845465957acc6d5aa72523b378e100f8a054bcb17171887274a2456a53553c2cd70e9f6cc68d65d211830f2e4d4c71108e48fbca428ba198c0fab691e66f285f07b55825ac951b7d11afac68433f7942ebc057adce42298fb621db65f3a68cb31842fe0b8217b075837a8ab8da2faa5c561a570b3ee51dcc8bb01bedafe3229b86df3cadbb1430770f40443134f1c6f58f8f558d3447c0987fa30b1ac85914b864797e63a14af65322c4f8d092b6296a1b77e5630e319048bead5d9e27f537f43b148cb5fc4e4e029c9181b9e8b50f70118ddce7b955301536e1d997d410716764e485c27f46fb7092a9f6aff4b1d2a62d0d9d3cd7bacc957b1e3f268f55537e071467c650f7a26d019722899aae1e95c40662a8587b0794998a1ee43e841e8d1daf86eb6f2cbd1854d3ec3c4c6b6367b3f2a07b20a7be2c564e6a96b9cb48d235febbc2eab1f51f967d4c46cc930a23528e7a4505e0402e5b8fce73be54c3201414e10054e2283e63f5d51504d09add09fe2fdb4b54ed8293fbca5e142992ed16e5094c5d1735c6a22341d6a1fae92105f7addc7f780c961883f6b21df1726b1a42a7e078500b961509a21ccf8c84ef0acd22554e4dd63a89e405c0259d8ac39bbc35dea2c65d72dcaefc9229d00afa5a4b54efc2cd28ee6b49368072deacd30400a2667aeef45f8e184dc70e4d89ef0b97c1bbc4ccf766f20062700d11402682cd6287aa019ffca8dfd7649fd7d921a68c04c3b2a2b9c429a930990f3efb5a66a09b570d3f9252347a8bb0f75ebbb0a7d2e6560d70da0da70d00093f89386d41dbb40af804b79ca4358ead88adb025affb3f4612f137628ff1d535a6028b7f3820b83ca5b33a1c865644234fdc1923dc370b1aa2d8aa332c760f00e7f35b0d826bf0fc066d2daef385","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
