<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ff4e4fc55d7e4ef675abf0234d81d318ced7e1db27de79b8dbec2787bcdf699291b8d03f9e1f767dd416928d42f8dc436e95a259ec3dfa14599072e46426e62d5e6072f242eb31df97012b01b910bb8494e276485ae9949fe74c57e1888b2c7217b63488d284625fd06709ec9b6d433f7682da285a7903b2137a7e61e05afa9b8633f7f83aaf810768c96bd75c845906c1d67c3c660d7dbc06e95ac139c54f4c73fe182db5dab33410780c318caadeb0cd40b21edfdf3ee82da7f76f2eb7f64dde8588561ba8e53f7d5b4127874d073c0f4cb32dea008bafb5dffcf955418177be15953a4498e87b9bb7cf666a1d67263b0d75b84179bfef08aab5c019a8120caff6e3b67665e545b95ef74d1b7d9e323fbcecfb8504ce6f1dcaaf2eab7549e4a337afa4bd931f2999c6566775405d34639c7a01a631c77a1d90828a43d96e26abaa0fea594b9672cc021095f81d744175a83cf60f595baa67336ce286cdb88eeb3e12715a24b0c40157f65ca63a6fb0e4d489f2a0552a1bb6f614a7234095ed1dee34c3c4967561b36970af3741d547f6c0500c5f0802846722b39b0c9e24636210a8e42ad926bf8057e7240eb5f845bd418dd056f0e0b5db0c4ac5782bdad209e2b35261159afbfa3256fb1138288bda29989e4b3ea16016bb3c7ab4c3826b96dfba53b97cdbfda4ac3658e7436a88d47fab18be2619bff238035fff5ff9e06359e44e2a60258c91cd37f3aae49b815a59cc8da949981f7c70d8ad6174df966459c309c79f99cc5477ba708807b7e539531e553a1e9c176b67498a347a40098cc598d1f3593589edb8b5cfb2f02cf4e5707553fe5ad39c680a65cffab370d6f7630d33c4fb19992896debd7e753f2a168edfc2cbedfb4da8470b28e94cbde1aa90f4f95e6dc1e8840c44ab608743d8c365ce8a4ad90cc14c75c39e5294cf222ef845c9251359ff1fb0bbf947e8df0733d89985545914e007dd6b12c4fc6935ef3e91092af615215e07b37558349551cca40de246dcb83435cb2832592360a07351919abb7c607c0228ef451ae984541096e1a1c68ea1989def66d156d0526dabf4d0e7c8b64c51c055be0417950ee436604c777d80f0ae4eab2f95a7d7e43235b0c78d65d0bcc908ba6eb334ff3fb657acd75bc18ebf21352256d7677b9157821308bae8658d49f59f60d1b5e06f9ca1966fecd46d76822a8d0f36564e14fb7207bcfcfde24ff79c31779f9399f1f45ec15032c315e435aca8bd24cf3df81479a33103fb8c9e62586e28c163c714e6aa978ce813c1158f6c34f74708dfae4cbf9a59b273009bf38f4b3fbb4a8e3ccf2944083fbca0077a37c4b7f16cdd886d93faef881b3b2425116d92ab46cf3a085230956c76703284a5cb9e47fa3d60eece83fb429f0750ab1b9e7187fb84ec17ae72dc1bbf3571ed52a8723d6f9c9b22479faa7d2b2180f7d2068abae67583e94bc0e302e28db70861aec1d8f41cca03e553d0ed857250d8e58b38cab167c7c25f5e6f2b0eef6eef4a6aab45783406068093acf3d21fb62c855e3a01e908ae53211233dae04c9d4078708b040fbe32b3c50e4f215b1927ce2d91b516377cc6ff8cda2c15b42d9961595eea8ce0d0d5d939cb6b3093c9ca4ab050211ede2bdef6f089edb67866e8873cd769b367db505c43cc9068b6fae81ee64dc1b8233d5db55274b2250b23f1755a26caec8d31e632e40a0e08f5af0db7a8e024a74b386e744f8b9acb65f6237cbddef1ea757da53f493c16c1b0cdaa29b9601196220cd357398aaa1a7e7b9176fe048e1e877e903a657e6e0e0bb166195fbf3a72efa39baba8bfc45dbe02a8ddc480386abf9242f90041ad9567e83e81e017d81d5a09087eaeb723383a77fee9b0835481768566bdaa59c4ec6e0548dfcf34cc9990345ef4a187e488250e43b72c5e522757129ac3dd58d8764e71fed1119b80b714badf05e3ca0bd76c30ec0ca127075872aabdbd89a75c9fb0fd6461d1e4fa7f33fffcd024ff798eef4a9e98c6966a42b4ebb14b1affecf7118f523d132c401afa422bd41de19912a7b40555c962c79d86968c2c48447aa18e483f0d6507a1c1755b14dea00bb835041478fe6aa653ebaf87491cf09a62906cfd909a69b8fa1bf20b4158b561d443f7bec299660fad4b3ad044705fb1278800d74e6e87d8fe0d929b6c5378bd29bc732bb8e5808fc8540868959107e2ce41174ee693c466940120241fc3770048a8167b1036500125f29d213eaf01a10732d8164b6450f17d847405cf6c678b2cd1534ff33584f1139a6b01a803f5e80af9eaeca6b82f20bba493bfd3a2d5c0d038f62df16b050c5841d46aef8bcd3cdac9584c9e73061f9ba72ad06d99c4d32cec6824e7626acad7b3e6fb43f756102559f8f9aaeb44ddfd573da048c28d79ac0162ad283d6fbb77abe100ff61ea19d76d2ae5fbff0fb270635acf43d184f03bbea6585249f1197dc179279626d53afd77134a66817dc5f151d5aa31ee5d296ba31892612b8daae13dccb45e2996f0e13ac7b0a3f9f467e54cfa578a4d8b8a84cd276315b6ed3021ec792fad6b499bf4cf311af97e03a3c5d4f6fdfd9b69b3ebf0bb0a40417ee85bc1ecba72ba78c80a9ef683e4e81ed0f5e63cef6a24a17ee73472ea6cdb67d99182467dcfbf3512a8095c2e78024bd3ad546d62a627e41cd6c9f4b8ef648008277c7b07fd244edf63fd2b166874ef9b52cb5e13f0371f053896cbc5d3e83c3b32664a59a99108c92407844247684bd2058515ef200b80bad730fd56aa543e6c08a3b9e3628205716c188b6788df278f7ff5c20878cb34a9fa5ad6a7d3612835dc51dbd3948e1104d857abdf3431b355dda11e6c7c33bbecf4e45875882b98d80718fa9dc8d451efae58ad75a5af7cdb2927bd14e08d09e83830dbc256a3764e017b485531a5c79048b93453d0411b38333b9a65b31a2fd437a81200ddc5efc6376755b465b2b447d75bd5e1392d147514ca573186643807888fa2e2256a85d0520fc8705cd4cf3479aba2f19ae1cecdef08fd102425f67052865a6ea96334a7baa46f7806092c93de058ecce1369899c464b2cb924faaa47f3d6d8a4460aa4d5f33350d8be075f5ddd6c9da297e9af32ec1f3c4ee644ad231e6e0b060267886be1452325d4665c86f9f83491d547b075b950cd60aa0f370246b480b5cf58814b0e6fec3cb1f70d459774f5e3788f7f696ade8029d1e82296de4a530c8dc9334e77148336fd6e0d667d9819be9b942e20bad76c63a417a8f248985aecef0888e217f1afca4fe04ce0fc3ca888050cca55dec22424d4e897db135d77f6bb4d01f24bf5c645945af897925a122f45d4c7f5b214d69e3e7696eca899427cc437533882ca498ad79ba9d54841bc0581ead728058df54e2d3bd4181d24e5a331d730bfbcec60d321cec1bcdc2bbec1736cc6ba2268350e51f0481f0a78326c8ee9ee2a26a9636b23e876d9d5da66dfbe766ba778a3078815ca1308a314966125e09956ced24b64407ac96687304268f20ac778c5ce5cd722b8484bd759452d7c4e0b0973f602e8d7990b1a3c976c558fe84ca0dabb9e1db453cfceee89544debc3b25a5f5431bffca43f9ebdc1544306c58c5ed1e129e415cad04e9e7394aea9745c13b82ba9c890746b07ca8561cb686f23953521e4218c0f8198487bc25271f2c4688a0eee24838e8193af3d3b6c86277d7cdacda84be5c6eed623a6aa67353b6fdc2cfb768874a9efb4256e4287d0ee07af3d6d238e1d0aaa08c7ac035a48ed6d931810b476306604b9b97ac4b52886c2bafa0e1910bd45eaaa0ae294fbe990f0822b61c632a2723f849e1d64e08382bc84a0a45f29822fca5f39638b67067c9aeda0d206a2cd398ea6d8dc415760f2e4224cc014740259dcb8e1b06018363711708e26e8f1673f4f5ca0640942b0b2a9de12bdf6d00142b0de51a1f6dafb198b639ee875a2333e07141295ec27524fff9cb8f08da546b7a212a81d2621512d263a70254f628cc1e16a56f4b36d67818824c618b9b6ebda05d30f416d0d75f07a07536f2547a903d8fdf371c450b2df2981655ee10b1cc78ea3d77b8185f67e260c1c5edcb5274b1e9908a5260b3ae42db5607199f6a1109ff2bfc64610ada38cb2cd531312eb9a4ca3821ff0f464c55841ac3f30996612eec9da4e82b58811058ac16908619fa9ab63a181d3e5ff55263f7eb13354d3d6112e09b6ca09f517d952f32958513beaeb6b8e35094b5b72345ce44dbe27e6d52704e634c61fc0fd09cc2629f1a77ffc4ab278b0b30f1007e3f35422f6ea53b41554853cce46be2521f54ce566971cc547a61251a6028c9f2c2e613a97fd250b9a08d51719993e9d5040bb584d58e9ffeb3a4ea3eb157d58f60fb0dfb6fb7de32d29a78286d900affbdb2998c5eed52ea3ec65a46715663ea78b8a56f7253cbabfe8c0bc4b5a54b5bd4a1bdcef24cd37d87291c7da650cf0727b84930f5f6053c09f1a3e22f939506686eb5ef2cb95dfb02751d2ae37730c052427512fc7a816e4290d4c9f80ea47d70de28f1a31e63dfbcbf74d7387e8bbed57ee3ba2d2ef28fda06155aae49f1ded78d1bbbb1bffc92b2477b085dc32dd3bd908e8606b0ab66c701a0a747bd9b331397e6b29bb0b2c9b7c9726a3ee5a18e283dcca6db903950cb0cb4636ad544508c841cc56b0c186b3090b40adadfcbf45bc2616798bce5a205dcb7eceae956f8bef58bc3ba4ffbca15c00b6a28ebc841de57f0f63198e1d35491280f30659243ce23807ce4789da80fe7a03afb9c7c90150ee8bc1e0ac3f643f2925af7af74959c6723d67eb7f4cddb573bbffe8a105b6dab6b082506d0cf646c9454358007299ed4dd393f3f7fb76fb17629ffd5be699fae7750f8779ae91d5c55b776600f4b8c671a36064c0ed13c5ecb87e930a019175ba6a7f955eeb418ef185d41e7c0a197df3ea32d446c867240a2413c032db95a839f8902bb5b2a719be60d6c244574c8fb7670fe55752200bc2897441de5c134b7bbacfe515b8d6a6347f29d7daba5174c2f08a27ef97452f37277225c9072b3ef5c90d6c8e94c2c172e04657c78fa965b272624999902f24ac5da12ff6760900cf05b3825ae3557c3f2d70665f2000516c5851289377b427406d962642beaae9a55ada6c01b728c6d62146525c2a24d6abb0940971f952d4869771bc7814e682e358493a8f4930a7a40dfc20350f35e4312c0617bd581a5917a66c1c0a5300348224f502f4b92428be31f4a2ff0c6db8a56dd8926f7d764993c754818fa7532074b0bc6ed021136f10ad2846001c577d056a95930b4196c83eb56d6ab3ddb93f6bae685a6198ea477df0992e3ea73a8f0298e4d2bad0803ad481b4b2fcea64fd6670a03788af41f7b2a164f4b3d8f5ee7dd08685a20ca14fb8a40aa37162962e1478cd0dbb205760c5b4029c39840e18a7fa8148d8ce72f0534953b4ad4f4b07f6098c059558b0c7eecd4624494c7340794c1e923bb6b678cf31f075b49be74b7cd4787d7fec910a975251c1d6730ac268e4c3cd0d5fe420ac73e87ea904458f036b809e8d3131040046ba0bc8e45091846ba691815bde75e26a77c6cf5fb9934fcff8be1d29d2e69219cd31084a9d47f296874158a3b82f9710578ec41d7ec7f46a102e41124bf70cb774c0a1245383defa6dcb10a527db22ed88955c6e48ebfda6d614c95f1bd5550eb387dfdd3371b47d83c84f4338f88c9f260cb686f1f0092b9afcf347d21150da1583b40c28d4e7131e944b4fc552c7247a6ef3f8a1227f40020fd44d210b3f044516b592322e869b87c538837d8cd9cce8a19230cb987e3109bdd79e04d21427009fb43010c0c1d10be41ccf89e511639072cd422294c83731d40ffb6d93e302b2317a647009cc4bbefd473a399e03e28886a36c943fc30c0d575fc2c1958cf0ae01953ee2ed6275fd9a8c23403b033a4b88ae6d8e0bed2fc0b1df8c749b46059c0a5d0719bee6dc6a83403685cbb1813e9f04313a4185515b4b2c974b60244fc132f63e7f7887a4272991127c7d323c8393a5568b3c09a15686376748591f217efdd9492d7c643701dcc8b28d80bf99682006af6d5fb724662acceb04dd101426ed53e32a8f762c5ce8c1cb7ad3454fe337aee2c59686bd09859f24e1506fc846ccc2842488d74da3d9e028fa6bca84ac80062596812d07465cf3a3aee8ab35b2e5d96ee03b4c078ad09229a0f37c20317795816930a7043295c12a8f0a45e88cc0e15d8f5c45f9fd1906e1a104f27953be974efe8c406d0e3d1c2d5a7c6b5c714a2da7723ae9282e397bc58d8d665ca2a73c258dd866323e27fd05dc8468467ebff77c86d02a0ce5db33ce5e9730a06ea8c5118c2291fada638de7bdce6678b951af0066d711ff895aca83f0b9dda8f89c4fec66b884d47f35da325cd3d2e52085c54a229a298ed090ac9c01fd399799f133c1dd79be7980e2c2bba75e976fcaa10faa2d2c2c0622adcf6ec0cd83c2cfe99dc8e4450ad0a9ef7aa65c71715730ec753d4ed27ff093349d4eeab7e1fe4a64e83144a4a4969590b5ffbecdc923e7743867945e3b7766643a8e9fcade0a0367f6a42db1a6ec98efe205db91e6ea730ba047cbdd0ddabcaa41ff7749c0802b303ff6cf4903f53c905c9c00925218f12271f03694bf239c3d8e03902c95b89607138d4a549d162a7a0772f58943fad8c2883c30785d6ea0f9f2c4d20b5dacb19bb7390f7aa391fcc95af8aadec7152deaf3d0c507982a8c696e3a3f0fdffbb05bedd174d932085e9d61f34b23c044134136588408107dcd0defd54704c91742b7796533d26d4347c4178d6bd9517800496c655a06b7d29eca581b2a7233ea35316f6e3631ed55f04fbdb262791dc5d9dbd3c17bbfd488c93b3a17019fb10139ef78414587d297c3db6f29c804a546b3a91a0fe26fe6d0f4258c0402ff10d0bffeb740af20e1dabada69e3ee920d745c88def5ddfd1eef418750d1eb29fd096886c736c2668061917c0342f914ed358c237ef7caba9ff424697d70930440b8f3744c1ddaa7e0929d7271b2278b2f9275212822b42f3fbe2ae32b63829e5be871447658ba4ed66b04ff964ce1d485c434be584b40d52aec13c1f3dbdbc1ea983c34ab8e8b057953914f506e6355fb010bf83463c4d0e4260fb157e4b5b882e66e8ccff4138bf2b8ee9f17914559bf07b0d1444ea82f7a3ad76d2de329e212297bd3753330854f0de4cbca290681c6bec7b24c420fe950b5c9c62b637bd96080960228339b4e2672c6d23a14287ca40d1c6f88724db6087d5882c7e3e6f35488c18584901fae1e62bca606f86b0d9ab4d05e8a142996c508d41774774115f65bf487d3d96283828d68c93f190aa138c425a381eb159427f0e273496ad77949446cef2837956d0f44cc1697ea7122bcd4061d4834b0dd53c0326555f867df9ba4de87138f511cb2882027bbabdf05b822db652d824d7783d95b18280038f98e4b9992e40149c90c1a1088dd7356956d9ea90299343c3d7c0b612b52ac8897b654e2943a13995721fad6ed4fb6289b89b2e390181db4fcf207f715ad90c333dc455e3f773e9bdd934d0d29e806c0eba4a64a01a4f137f686b484e6fca78d2c790c9b6673a5ac1bb9408181fd795161ae4e1acface1728d523416af7d9fa5ff8ccd5f900ac4ee291fb3b40d9750e65f537565900bc110fa804be0f7bd56d6591f79786bb831e8b07f340b800a4c81d50b981984b90988f6afb397869c29b59b1166cf1f303738292bd4863aca2bede8f5530a1cd00fb86fcd0c19b139efa704c07e847ddd130f9d0fdf8e0e082f4190b9e0edd7fc6be2f25985e4b802eef0afa3fda76de603f8c9f4cb95d97333ae94bc8afd5566c077789de453eb89610617eab557d6197a8c594adb69f7f4c688ff7e7123ad5ddc1041deab373758a5ea72d2644ad1fb704315cb368fdb908c150e98d793751cababe273758ec5c81833b335d3eec18d80cf932894865156cc5c5cbd080be0742e581f35f8598597e318ccb6ce1b05cc44bee1757939c803f6b02de12be7184af89f4555dfa295848bde8f335bd8df4c8e21ba7941488211d5f912a30bf7363469c7ddc6dccd157bf88bbd5003b4c89540eb44165b9696998e9190b3a4536783e93f05e665c3dca70599faa75ecaacef323ee7f628434afd35a0a9cc1775a310c1bc202dde1a889cc3a8a6abb9b8462b1ad962901328d99b84b59724af6b07a46b6acc03a9b7e62f746425c22de112d32edf60b244263900d225b665f464916d283554ff6e859acac7d50afef67bbb0d044f9b2bd1b238ce0413bcec1d2e5e14c4b1a37bb8c31c9e940e4f2307eef036fc04e7ecc61277c14e95897184186009116f52721465bd3e48937ee9ed863c49eafdcbfaf6a68e3fb2a84f5e60e10cd5a9f0d59e7d2ed39beda1d3d7ce0c3410b42f3644b72d8ec821f697189ed45eabb07694f5096e13c90ce0de12e4efbcc76b37c823f3f86166ba56749d5dede715c8b1ec5c3790d545e62aaeb50336f16fc38ff8b230840706feaca57d2e5f25c35a576baa79f2e4cce590f9c962ddb59fecdbf1af4acb6adb87b634c6db5017224ec0531b3d455b1dfd00395d342d26711cb3444ba6e0a398dc670b4d26314f728e79769474304214f39d7343171b4e3c6a2a11f1698dc9b6857b5558f019e3d512b07cdccf9552d6a556395e843b638530c8770ced62afa7cef1c61df665355147485d96580d3a80bc331207ca897aa1aa22ef3144c66b6caa562bf60915ed1230d552a170ea09a4f4ea36199734840eb4e87e001d8de4be7982c246d3e8dfdb58cd6078128677dcca22e44b519339ad22fa71c3430e560b20b2733517a9f6065ef16e32f29f9fa6ea82990e365f555935fa72bf3ebe2a826bf34a08cabd5bdb530827a88df3fa23ea656dfce8e2febe6c4626a53ffc8c84e7dcb7c73cd5eabfe0ec67a82f1ac43116d46a10536e769d45cadd6fc0778b330e9924c3f11943194076a6b6e971656f6e213d6d3b68a94acf48dc7efd693b9aeff1f9f1dc6094bf0d5a0e56d20c50b9c705ce1c3caacc126c0a1666e708a8ee56297fd9177757f03aa1dc887101a6fc9364e3eacbcfd82ceaa485c960e2110806b45e608a5cd91cdf438f4beb066cdfdb831edcee00d3dc5172f63da60746aa0b1b2d638caa2283c1125b4f2d9e09f03d200632aadccaf8e66adea2ae36ac08a22c956eaac9d90ebfd5998e36112c2327a05f7d871196ae66e1256066fa7d82ef860eac5ac2b4d81153d0913c83bb8605493f47ff8e76896284231465b8399739fdc4b0907a66221f19da013f797a4b189f7ba645aae6b8a4ac25dde9330213238c2622b7a66c5a4642f1b80ca2cf2daf287a9c45ad67de94b53c43079ca7871ec25332a150aed8811c6d26496bafe1dbbd1b23c5ea10d9816887dfe360c47bab500cdfbe43308b7a585fdd9acea40607a4b45f6db79f72843e8e0ec0ed421aafdc177b15147576dbf793f179af39401af46f8c8fcc8a4cf522d4541abbd27b096b76f872d38886ba58e9cafb1c53e0ecf4caa655fb048035f52bbb45e733ce30705de0ea4fc7ef119e8e2cc3ea984e7e57315e7a16cf51aa2e9d8ab3f4cca5ff9c48dc370a6e17b347e0b0f016f0fa166d74b29140c7ab8f386e78438d257aa4da353fb711f32b631bf01715cb3e65f7bae41580e14546d0268a1c53ac124314f3c31b02cb483c5d30c941878bf003d6c8bf7609d6258575b8ee7ddfd56352fcbe6390c151ebaca2075700e2ef388758dec0f22b223e44d4762dc08bad310f13380f604616a891dd52d06b350d5087bc124d8e379049b749f223895f563e0df9473b1ad798dc71f52f92741d99021d0807872a97befadb29828a6ff3f34b4191a0af16e3f7b08ada6dc6b2cc45931fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
