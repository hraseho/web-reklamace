<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8257515947d8139abd808e10d78ff70b7025d4f66b8eba835127a4e24a52d9770f6d756a94f13cb8eecbfbe0f171a63ea0e452ca611fedd0714145b1ec0331ad35dc16f27cc8d15f368df7a7e0015367ddfab71e4f4b78fa3bee0b79dfb5623e92faf9b16314298321bb3ecfe4ae6ea87fb73579127f31157375b77931527dbe4f5a15815f08159780e079bae8736d01e6211eeeb43459a2ca4c8246b95bd07dbc44ff5f2295f278e2f6ac4a364c2137c740cf14215fa1a1e79c623d1982790cc7e95ad06d04fa7f93ccdf59300e1cf9eacf557aff7d3c1818c90d82a86df4d8b967e409b9629e8e678b9a6a1e5bfbbd6e5dc7d52618a77750eb40da13fed366711a4c526c15baa3efcca6e9c0fd2eb63fe593e5287c53c1dddbb8297d4ddd85f9baf3c534fb279e2b9ba6865c0f40ac9c685744ceec281e21cd8ddfcfc3840043d91387a1b003d8cbaeed5a66329c96dc26f32d12745c26f2133259ab671789aeaae3e530f35ae6bb6769b16b56dc0661a91f048f230dc7e18fb66e57894f0f984ab38b5df2436375362600fc51df2bc0493bc3d8f289dc23b65b4899a40400898fa7a206d135eb9fe73ab3ed2a66833ee19a1717afe467fa5f42aa2300af6b031b4090aa360ba765f6d76bf6131b437609a4c69be7896d850dfed7bdc2a504acc3d926ffbc293184127b32ff0697ca1d4ac8482ef6ee32e6fea5e09daf4fd96edc03f80c80846bffe5b6cc27eb10255fa36a278a0df4dcbfc129c48a65835f5aabacff7e213b9de571422de7418df729496ffe3ea66061e7f5e556de047f7ac1805e312dafe28cfbb94772e614f822f2cbdb114611af7f33b7822775b0e2ee0f4a05a890a180afa3a53b9784784f789dd27ed140cc52922c4ab1dadf606daa1aa75ec2dd46c624172ff0f14ccfaf7822e4c8ea584c90780962e6f6fda9ad664168d194239246c59a36430d54ea57a2ff8c16fcc648abed768fcd044f313957716d3d87840c41a08fd26844c6e5c9aee9a052d3019191bb7a641d6f48f4819cc0222b8d4872157068a832a11bb2bc8cb6a790bca1679d07f9d94e0d47fb8ce5d55aa48d496696df8263f9f151e49361dc8c5454131de6541973a899799fa370d4d2ae2290ac9efb6ddca6e1ac5d51ad23c3a355265ac6ed82a244b5139bbd1b649d4dbbc4d67a571d644328e9230d71d0770ec7925a87941a9ea8f09d5281165b4d5295d034ea7e2fb03b8b7387197e2b34c7907fee37f87bd8939dcb38f9284ea8f5da10a677fefde817b7d96caed9739155fe9b84395234ea3b0b980e5191edaa0afc1fe0eeef93e5cd22394812ce64901bd8b8f8c1e36698848ebcfc9bd0b816074c9a2c1d4890d27b945b7b3c52c41a9c45490033cfda0ce2e3870fd08aafd81c14c752ea3a9332b7de91729c6ed2aab1cadb45e8a69ff7cf42b88feb72922e556b39278b864f1904047fa46f7c2548788cf161f11c3a0e6c7af6345197ae7f799bffb66074bbb9e2c5de038afc9dff7d37d2d472f67e89208e4a33c0c0761da820d96c57b46e8f23e110ae154085eb901db8e9355c195850f99f52bb06fafee1cc76cd1971ede4d96cdaadc880c4ed10cfd4570a2f27b67488bcb60c916274eafc0d6935ae253545762403db3ac0ce09513d12764a9448b49e90edc3a439131047b959e4f8ddce1d42f48ae28c9ea42a3e1be47e23dd9ff863fd9b7b601f03837c02a606adac3fc1ff6005990a46843cc173fa0714eba903268e1829cec87d1260357e73157c203be075001805607df18d68cdb1eccedc8048c49d16ff0b9738e97066e0fb2fef8bbe8e444b8024be70e1fa55eabd8aa2a0b678fdc60058cdd445804627456d139636e2b72501fc69a3daa7e76e533f5f999e9ebdaa936fcc980bede80cfb0c12978c6b7efcd9ff617553b8b464519a3aeb8ae628072cc1cd64158da9176dc465f3c68029a4a0f9339b3dc441e4da0d050576d7a16e9a1356bb363e7ee088ac2e938021108f35b0abbfb449a61826e88d9e48ac36f08456ff520f93cb8bce900dc5a3af8dd22abb85572fa9e47b2ff73b17be431678142f624cdb5444aa4916d5c81d76d8502613dbd14fdfae7a64343de8cf3bb4e003c5146443d76bbbe83c67377f1fae60418f765e4a71ac028cc16305933583ab1d4acdd0a5a174992b8fabe8f02081a575e8222543d70f504c0edfb2d582f94b72c36e50ae9b518466a85503d78fbf33de949121f4788348057dc57f90ba80b50757ec81e9ac0db96ad58d94ce7ab0fd69a53326622996659b632a0bcdd2f31db8b5d58be5f6610d70434fed2bfd93b54e026034215fae8bb3915c8fd837147cb05569d307e0266f6cc9aae7f8a51b24b61ccb89459b73d68fd8be086b785cbb908ab184555bb7bbff808eea6830e7f14da6672a17b8b4c142295432d92942d9ef06e74e67af584c1aa684e132b40cede748c6bbfe0f591db75a3c295cd6b7d1e1a7c77acaa5981c18313b38c534961d288532b3602775be110822b842248a299e2a695d8c3f22ef4e938867ab92ccd11d3cc7ec8dd16fc795ad9c0087e7fa0d48333ec4150a5834023c6f06d2fd8956475205cccaccb28fde21dc2d3106a45d9a1b8076df2a3097e12e784d63f877b4228099939b162bd0e368dc7ea07a8ede1ec82b7c7d1dbc47e36876aedca1f63e3c6345c9a4219e929fdf39b8641ef3db60094c6c39ad59e1a951ad879a57fa583578207c9ebd5b14c106dff50b959c7eb8be59260ab1b429433cfd43739beba6b6b1becd01ed3ba3a5ab7c2c499a1b596fb42b20d903a4cb37bfa71108469294544ce18a876c9bf999e1fc61b84f3474f5111e15c680701ca4e4ed6eeccef110cd43913c88cf53bb11a7835d9d78e449562121e30f6fd331cda8296685834bfaf675aac04a9b1c9c76e8a46e3e6c3b88fc260c2d36f472c38a5806a0317bb69b7fa26d85319cbbc705c9bf6a90d1254301f971e51ac8816e37140aceb697c7395ef251954322e870dc628b7b0f247ac6c864f4a2c94b93caa553a6f1fe6e7cd44851117e1ce600e3d1a5f8fa43f3aaf83148b9310b618f3890ff15b5af605f2075b2d8b7e82b4c0f06d620e3a150c2b2c13def6a04db0d5dedce1af668e93a51fc3473ec445fc790a0dce321b7cf48c24e7935c430702d9b7d414aaa633b9ddbca7a7f8317fc2aad3744178ac47b61c10e2047f0fda16ca59a74557e2948109dc0e1d70bbbb52ad145144be2a94b5e5531e032df4ca3f2a776bc572c66c26525c5bfcb52f20ca55a3cb427aef53d69636dd766a769abea699521607f67ab896c0f0b9152373be7b2f71c4d98a853167f8dde77b97f6769b1bc510d9aeb92b5917b6bef9ec0d1cdc995b63028376db7961595003f59085a202f78db3a885f10480d8efc2a8513c6bdbade7734840f2bd479c726d3a2fe6d69ec8c78d4cf2d9c0c6487c0bf20544c7ba8fab4cb8e2f3b85fae4864e1fe40638ad6d36e48c3aea5ec7fcefd4aed281d5b191f2c06aca652b2964538b81d660e0fb45d7670130c3e7b99da47bcfba3409a0bb079e2bf92948599ac5791a874e6536a08afdfe9aa11eda1738542a2a89254f71505f59262830533561e1e1098c9479ffc686f346033b66a425da5dffebd1b67d594206ebe12d9cb9b6512d29146f0f2c100bb6d46505dfb1076085d17fd407973416a86553e1c99797690c3ba56aea6dfbb287b5de96cd0a4dab90ac9b53f41d006031e63abb8a2771f1d03a5dfaf922af7a75d345a67db69510c2971841c03de6d7749485b57acf03135c6dfa15b3c5b1abe524f99d6eaf8c47adb82134d17b47f716329022e5a6a82fff57e661c651c115e9960eada2ff8036e632751aa0a71e32f0cc9e306450f89a4284c5434add4bbeffd516faa1e513c690b97d07f4737b93f53eaccdf467147a3cc47b0c4d0cb503af946565634758004499b9885951d5872935f0d099c4f09ada2e582ce1abebfabe3116b98b9d5beac18b403bec01bafe4f849bcbf9faa358bdd241f2e5d04fd6f280ae7c1c7ac7b3dc17585d55d0116c2c5fc103a66d1b80aaa8f0da8665ae32d8f598a6d9fdeba53eb5bbdd8097f5ad550263b757e54a1f50cc296d94a68eea955bd66ccf33c245eccca89d34fee231a7db55568a2f306963e27b8ac9c98aae35fe55637e44d5a4c7e20762118e525e9817410faaca2aeabb25691b8ab1ba0d2ea19b2be551c8ec7cea975a58eb80b0d9c178abdc1289fce9d2c94302b5f897ab63f560d2c983e235d29d6dcc5675478729aad36acb08b54cbb4f997ad6f26ef91bf50e3d1d8c89ad3a6d248684f269a7843a858575552650a88057fe628f5e0f9cc7f0c96c013c3386377af8f651d8287af787eca661782fe4de340e9381065ad603f6960ab515b1d63ec56b5f5cac9456bab717e519c2e819429cd596ab19fb43a6c0161d908b7583dc256b158105fe593e1f6667bd1b431b8688c5576b186743de0216c418afc2448361943e4368958e3af12fa344c6994d40970710aa6268fc88ece224a3c6f41f3c35055b0a5b68237d5df97eb35fe5181ce8e700048949619a8a95712d3d5b7f1db424025d9d832a10a5b10b2378f0132040427d3e24becd89036a484d3619f9744afd10220e05378faa56699a061369d5ce9e914a9165d0b831df4c8bfed82b6ebac593c1590c2e03986f2eec0ac40fd7edd2abca649a73c6831b4f2906fd9d9dbd6fe4262dabff52a110e38f85748dd80174bc216e93f4090c56831d1839e5c2b56f5a7cb71646de6fe39ce8eb1d180093084cedfbaebb5f63fd61ef5fdca8abef10689d3107a50d2e6e924b054f2c10ea3283930ac6e0fcc9da02884781ec8308a1fb58143970da058aa8e6ecb43042879cff84929422fd6329b67b12f4fa4080d542be8edd97362a93021109e0b0e2ca98c5f617eb5514e42e425b1b4cccd2a47c145ee0784c3af21e038e475c0cc00b14662c150b57a8c79ecd9d80f2d324114bff2172651e2cf145a92da7d440740ce0e94b6b04e6f11907789637e829c9b3f97183da6036ca430d6660071eb4b048ebb85b453108d8701568c793890c374c87eccd2ec339b72c3a54b97f1318032c033a584e459244fa5ca40458ea763b9ee829df246328422f0d73a1e45effd07ed093284a8b93203667b859d3b2c3e8a9abfdfa27f9cc071ec176e59815936d0cbd7a5ec8c662eef43cc38ce0445efbdf20d370a67475300222a8dc035054842367cef3708c336f18b83641b0f1d5cf18badd6f3de860e2c6c7bfd076bab5f1ea252aad6795f800bf7810861b7c39f7a5384e1f10c56fef31f20f2bc79ec4df432475608fe61c6c460ba2514ee351e0d7cdbd75591e9a7ba93c92733b1a333f4823789096e0302ed6d7c3c830efec674f543a17c304fdbbd234806b5c173238055a4e9f389be1ff2ff8d22b7cd461b06bb222c479c5010fd8f59888fdfcf0aeea93cc1d9bf9f5fa102e1959e3f7ddeedeb11257115130b7d0f06e0cb5ab8c2960ea31b5766ce649bda546a6186a431f79ee458de4a3fcdbecbba341d299dc9a4f407e351d2b0fa002a518eaa5f24d8b8877dac1018b0068faf3521f12a434fc166a2ea5c8ea633fc1a5655199f597105d308de1f2b670fd2ef9ae99bb63ab2461da14dd9509bad4f3d0bd81247e7c52c09c1721ebd478a403feacff3abbcfa18073332b43428b698bd4071c7aacd15db5fe7bb0a949173abfe2d341d8f53fc92af0d5d3f65c25d1ca483ff550f35acf37a4c7ec78f8c35750a6caa0adbc2e20330048fe075e55b8d0076870a24ec8e4ee2751de66932933d46f23d02dcad4d5948a99aa7bee754a9a4bf5c60c34dd2d18c897729b51998250c02e4a3c23ceff526677e3b32faff38739ddbc0cdabe235e717582ce4d8be03a6a698a17bd0bcd01b5429207acb6d6bcd669819ffba30372a2242e1e048d077dc7bd41efad533f8a131170b3ad7598f9196d88441dde826d118bafe0bb761c710d4ebe97f85cd420f913e01ce715bd05575ce968861e476f1ad50fcec0d4fd133c404e3928d28f26fbd5b8369a38d6f0a9cd98b40f46fc6a45c3f237ea21f05f2123d4c31fec252ecb5990af67994d8ef54305756df3f043b2a34200f7abaa960d3c1d8e0c02da06d21175959fa7bdddefdb97150635137647c381a87c830701e97d55c23c8baf7219042fbc1d7a480ae0de0fc37a9038fb83321138b090e9e347513810fb153dd15b80d9c392833148ab2e834fdf87de59ef9f4d0b8350b8d17f41a95c2a0b8e2e88877f4834fc4b5dbe16ef6c1cfa3198a3ebb798db4117b9df1795922c3da694bc4773b10699a566d9ccbd08f8e3f1d3346e61d573fe9dd421b2ec004de5be18360119e6e288ec6510f12f12a6af7366e6960563d9c08265d94bcd106fb5700cc44bf71d514df3a0be001606f16d5a27bc9d13e8172a2e0efe503afdbc8d92d22804cc944a4ed1a734a89251a80b88a30c0880da02bb61cd84f90ab3a4e87b4fe5710916ac3d229dad40d4261836d5ca492c80333608b541a0c711dabe010b94e509670dd1036358510bd9956c43b19325deb3ae3d3ead1855e0add93d471be68883c8664d942f91100525e62a1f46f51e3af4433063cc3ebd261d11beef452f15db074d02cc6fe218ee9ea79aa2a30705355c26520342cbc673bc9bb2a31e360569e9a9f6af067e76bd31c7941f828d4d707623839fdcabbf8b368cbd5d840565ca7984c4984aca4978ea4f8b761e76fe3d697b4172ab7fac1adb8fbc6c86a9f7c75734fa07560103d7d3153ed7f6c4f75e8375c4de2401c2490fbb108d1abd0dbfe6c43a6f8f80fbc2b1f7d094cde73df3b5d9fc61a8eca4b64178315cc53acbe142ed481a3bc8fad3bc709dd229dd6564245435896c6fa6829f89ae26c061614487d4103199e58057259800163f9336247961e015b1d1151c9792d5f3a3c650fb30c430b1e7e2eb2970103676dd33c4b39648bfa900bd9e8ace63770f1a49490c10727f872a174de2ddea77ee2ba5f156b2ce9601ae98235e1823be2bb4e67020335f73967098c1905908bca41de2d200ba1e594df6f14606bc71e50b8ed2d8e13677dc635d113d51af9455d1c57a9921fa7a74263128160b9e2d0550b49b784b7ef73eb5eb9b848b26683c049f452733acff9678cd645244b706c08882e03c3b511d73ce4266f729b59fe16377f987e1f2f69f45cfd65081dd813dd68736410399dfbaea93b9c1aa0c38f621732b17a68a74ef58685f86b40f2c3ce001084f012f247f77847b430c8d39c016de5fbcf8a90328870ba77c22d315a7365e8d3eb00542eeabf3fccafd4bed08bc3c38e6f698cab30de3853c9c114b8f77ed1b9823937a50cae39e88d016f4c5c6bee9f9d378fd5bffb91bded63ba380aafd23667360f927d30fe822ee913470364151de2349d51fcaae2caf5017e41e577cb77f8578d1b2a76ccb6c38a1ff19380e6241a8cd64758b7c023e57cc64b24b8de4083917aaf86f104570396ea5075ba9dd06e77283418f2b1eb8486bb3c88a32ba761e923c02ba2bfe2284448660045b5a07576a07b0bec88d0ca56dd8a4965825332e893c771f62ab951551f86e13a306217e4e696e358156e172728ca5514a846b842bd364b79883fbad8c1a557cbd002a86d04b7efce8d3d498d31b11d562eaef6b71e4cd00fb13c9552e7296bf6662e325c3bac3ffd2b4cfbfe755b6b092d9f3c45b07b40dff3ba795dbce25847b061bcdf993e73c9d1d2ca2261c65771fd573acaf9c501b74473039aca2a910878fd64350d3f75bc8d777f3cc98ee22ff43231c7b8ccedcc32ced3616312b93114f780855a908da826a5c5527116eca20074864dcda2d76348d83e3d63429d1703b50502412de1f4a3d7a898a5f2faf42b94ac28ba1a75a458080e644ca559e64c8760afcc4d6534fa874095135ec09b3f6482ce61508611016147fdd3f3ec6085dee46fd872da633a855d305af870afee989a39ccd6547db1af84ea5c798bcafe96deeb22e866b56c44d2f372829b7f38f8cd777c955e2bfce103d10f0033996bc54ee2de5ad8b7c42de4ed376c97e47d7c750e16812e73b9609cd25fc490f8c94fd6339dc9453bf2f69ce378c4dd82656cc0d4ed6f26304485165b17b15d8e5510c9244414ead03f8189dc8a1ae3145003af15e75e8a6dee09f39e220a47d61a282853b5dd44f175da786b81f297d107540784e021e018608f704b02ed295a92f9462409acfcc304dcfc11cc7c65fd9c708050339e467c0480ec145c201b5f6fa50fceee1289dee0208c8bb3818c0c672cb369c40d02868879b4b4fa28159c7d449292a9ad3fa93f4a8f51db7261bbfb7ffded5b321deb4e4d667530826df3fedb328ce62ff4b4fc3a4463641033a42dd9c751e84e955f43caaea9c5c8bd71bbcecf26b523872ddb4d9379f54be799dfdf04c762aea7deb777f42eb0758f3fb20730e7569ee5e388da413a248776d8c392fe80a6bf4566106fef3570ca13385397a0d31bf5dcb48df67b84f24aa1f7a529682bbdc1b3059db8ddef694c20141ea42427cf7490c2b3ccc5fa28d0ffb7e617daf636f74adcdb33759051de15d5de9849229aef937a2ebc0ceeb63cfa8bffd89a5e5948a31273c932c300d2ee0bde753a13a12617dfeacdcfe5eb2fc9bfa5f9917b7737de94fffa47b47c2a9f0e0c046302b7d724e2c6d04fffe41b938dbc1ce54a0035e7195adc5bb276dff33e0c1318767cf412a194a5a042aec25cff393a3fbf9c3a83ebffe8951fa872d6d93667be7f4cac9cf383f434b7b117077ca891a99e7898db482630c38cb3c85e573f63318caaf74bcf8ba23c77a1d3f04a6e0c98974bb20b386263975eedb95f23ed9fc7f2c42ef8faa35f048cfdd53b889ad43fc958a08877abc546779cbc8a575f0a0ce3267583e31d8747ad384baff43986b207ef36ef66f07521f41650aa0a6978667ef62845a01f4cbe2dcafce76e1e7c3fd09504813de8378a5eddd0694c7ca87afa41e8e32adb881e727267133f0acac80ea55d3fa4d9f98c4bec8391ba22c99f53c023b4ba98f9fbe88dec999147481e43c180e1b7a3b9423b38038f8e6e5282cc1b55820656e5cc72e67c234bcf4ce8f2371a9b8bbbbda20973fc00296f1a86a2113117f0b447a6a69e83566a2f58fc4fee4ecffe4df31abde4b34294f4deeeaf7d3bf5ed89fe7632024cd154144cc1f43975786954cc7c1e761eb2aee853d1bbe7cb59077d0d016774895d85772d99b515a8d927b3bb9f2cba712da4e8cbca48fd59bd4a732c4e2c48248cbb59277565d3ba9a4f6d692392e711641611aa82ac7b6521d4c5def6adec0a975b5b7e65ca1ee3f3bc917e9002a6ee947f9549a988421d48023394fee33f89ac41c446bd3cf43d48c42ddbbf4c29fe7ff5d93db970fae3a9ee8de43ac3b68a5ad4e026550f6e7e76c5cc98e3f0776431c6ae62b7beef50e5d6f7d94ccd13883831f7e7a5dfbe8b547faea013b882634701dbd6764e66e6713a67fb93e121e7a004c9effe29ca7b427bde711b1efcbf26a05b4a00a85cb5d9f4ac38bbcf1fc9a5a979b650e36741f0cbc99bee5e6afebfb7cfb239b7522f2c0a27bf6875f57435f680ba52c3860cf1c0bca69ddce4e81b09b38e05f8b59f851e601af04026d9d2a1e9eafbd3607551e6f483b162a79152daa7868aecd0c8b4db52f1960144e35eb5792b0108eb8c474283b76","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
