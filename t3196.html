<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26672f75fd7f9c41783a1fd4cd27217ffca1d13912c65dba8e635eade061d309a9b7a9179758fd6fe4ece6209d0ae429cb9093b6a3fdcfe5ffe7e69936e756bc16159a7e68110f3244af4893fd0f726d71ce6f55fb0a9c81c11b7b8de8e34f3c19f683c0f193db399e3a5f9315f83cadf3349521deeb2332da522ee34234dae07583dfacfa8f47a377242feeb16a717f6229ce0f547871e4a3228281653a3164d3c6e31bc796c6fb90f83a2c41a940c877eb3c4444fd6bbc0009e2edf7441e5845aee4bb94893abc7864ef70d213dd2b61d2091f765fb1eb2949d78419cae199d9d2310d6aeb58cff08a1eafa1a4dd41d9f02e4ce3ca3e87c4bfdfa9e36c1336b4a7d1d68af02a714f10a24632b6403d3d7775b99db1e5da111bc7994cc1ac6498013a4d0a495f550f313dc676561a9367ba5bd5f5c6fafb98f423dcaab28ffbad751dfed3637624e39f372e83573db1c75d6b85a62945e467aba8163786b8d02c675739a4c861362a141ab338f152b0059664138adc91ec4c16ae7503c046d92c389359757d9863136231f54650b4c603cae1e70532e82a9bb26138bfaca40b92590e156f6405345c3a62b5c450b8743a729fb82ccedd049b41766d076dc3dc2008979689fb54e1ed778cef7dba1065ad07a35bb7528338355d6bb2ea3a970ef03db3d965b03bfaa3e307ec19ae20cbdc7ed9462397a966a67af7bcac361897f161bc44c154084e3abea0f4a3d6d51cea7a782dee9f637adda98ab38e106794f7862c73458a76472af74459365863f2a0f4adc9e95c637ba4ec338e08634f4babdb3df3517581ebd1d18bb6358670d29d31398f6bbc203cc3cdfa0275932051ce038ee080c16faa46f617e7c6f9a88dfcbcae9e3bffe6dc7bf708e521b995b4dff697367500e5cddca935922f939ac36e79babd044f7228e0a9e95b60fdfbca519248cd850709209d4bd950afea1613f38041b1378ffc6d376276cf350097fd6047404986639052bec4e1052cbf4a68c37314dab51589b6f7bdd2c3b749b2a5c64242f3a01f1283cc959689ba64316fa79a65dad306fff1520b555f5454c547f0b93f4b510d4364d2620371b3583be315e6e31b72cf07cf065e57d663a599820e32829ae491bbcd272f500e3d001cb8ec2be5e46c3288043da0da1907301be7a946520b8294b2763547076cc550217090ee333b0eef4088875864f7af4553d0f1a66d1607b94a26d0f59f79ee756af3a7b59c4dcc86b4b119c81dc3a5f9cb5364d3b0f2498c6fac5c09dbc9bebc186b090522d668a62ef766c583d516bd2df7ed4a364a9bc1f1faa5330149d4ea0b18ad62d7f318885998fe38371cbcea3a5957b6bf6cea597b85c0c81023c5aab8c6c2788e700edba4d8515032203aa2f330d5fd6cf6f18cf29f3f58e8aad49c5d180a3d53fbd4e20b4022409ef5a0fdb98d5e841b9e0401e252824d3af3f5759df77475ba02fb8c93da200884280927d75f641d12352fb30407bd67fa927b0982e46c09215f89b8fa5db04993171b3feade5ad8f0a1a7d4288d7a70fe17756784c01c5818ff85ef322c0518009fa2aa51d992e07e6bfb06f3697650fd01845f7cce2f94308128ced7d5f9c687e9a525edc0425155c4ba30f26cab14704df2bafba6508bb6ca5d0f8af2fe16662de4965d62ed640a24989b41fa258a17b8fa0bf138e8164063a3726dfb66ff98c45a82b347e71176e3224cc2c4edbec20cc682e53a35d42619e377df726e93bf96d54a45ada91d3a1ef2f09af39daaf1963ff1027f2b1239b9bc08152f9fb3d39f06782f34f4a922a6be6db4e6949d025a9d1240a51cf8ba22cb372a31427617c9505489e0fec99be3094a115697384c31818ae3126cdfc8629e871311bc56d6b4f7a82e199ec77944453ec66611ab66e01f5478ed8f2c78a6346d90dc6b7b3caa346dc9acdece02d97b3f50c8439de8d4ef6006f31517cea09de924740f46a3d81fb9b7f2e6c24cf1299462642d6c5360111b8d302fe5f87c8f5b8fa9f24b6e0149914bc6481bdbf48089223adb189c91f803d5d9dc05f78fb7b12b976a56dd3f476b14a623726556da9139943e083155169c9ef9e5543592a7be58bbf53e006cfa3e374b891100a743c9ff5443f5fbb2450eacc6116b9d17eba20a6b0928eba8f3417fdc6a91c0f5d880bfd113477f135afd7f4bff8e75237c27f7b165431045aa80dbebdc135d3de28476e11020265730a90219f1dc2c76db2ebab769b3532e9edf633b3211c3c9890c7d9a36a043e2afbd083183b46d7ebff0f618e27eac64cf158ea6377fce6e888f1dd87e73b21be91a14a8a232c3b99d44a620f2cd29bd1fd6d6b80000a9ee8b533bb6cdff6e42ade29570dedb29639174b2b4854048fd830ba8228b90b515e214b0cb82bda213896bd7e0269471e539e52663c28e08468ea01fcefe30d61f4182b00b22785ae50cfe47062cb71ae5f93b47f44ef04fa737c73af240418fa0907010d2df4fcdf17b8c9b01254b9ff01d87b63bcba43270c8e4a56c23908d15515a84de5725740c25406ae1c1a5e11e5d9703498b0357b9bee515a8c8f1613cf16814c36afed8d25e61987aa034af2627da8fd19fbd9ed3d3e8336ca96603882d83ef05d2b99e35a671ae8053486cfdcd9e737e318982f553d0b1e6e28443fdefae8984bde07cdf08b30122e2e207d4e49eba41867be024348e265248e727f8b52e27d003592853efd43a9d18004e7a107d466b55da5203fce97a7de9f8477de0c796fba4b08ddc9273caca10fdd580ba29f219394b12c347d47225f5ddd9b407eb1eb4b9dff3dc3a77803033a8d70251bfd04271cde93a74487c61e9685b0106ce8816fe414da5df5b578b001810f076a05e40ef0e4b1582d7470b9dbdbe027209438ebbe163a90d151753a82f8f8685ad3b5b63564b93c3708f46c57e662752efec493571c6e87d7d648ffe1e9b50c51d5040d0fdfb417a5515ddfcd45810da5362d60fd1173cef5f717422259767e4e36329ca372927ef934056fbda307f4af7b0f52f2717649e1513166ac662b1cb1a4e0a372217b7715f1eaf1b67383c0ea0524f089d28593235b748ce3df4f0be28d8d7b9466f5d55deb564ad7a7510999490ebcb872e44c400e72c15a22520a82b22c99778b9fdcbb604718514ee85e3a422607426e76b14203a8285e76835f911c1ee6846eab5079aa93ca696556c71575b2ecbb0dfe96c7b22211364aa4a2094f738b145dd9272e3ebe3d5a0ba669aaa12bf754eb63f69eeb78d7f5b559473592c4b9a2b01373a937219bf6aea3ee6aca9504fb46122fc8f61af0a5c7a27062b14bacac3d24a3716fdcd46995ea3a03cea21c2016bb054eb298cfc96cf25ba781145cd59f63c9a3dd4750ecb9a28ab3ee76ae2f6f0a6e5a32f5449c7ece0878aed5c8d66f8455a69e67af55950a8e8ee0f49ed0419ef0c6ab1fc5b7a19eae4a8d2931f2617b8b734fb2110738bbf405f5f3cc92cf38bb7b3bf4621f82e1ff58de5c4848d31edb9ca7f4c9ad399eae17ea58fbe0db2537cb7f5cf22373f46ad1a27209e16566a8711f77d07ee206c8bd1995f795eed6c5355224e90d2eda5b26717c77e89078b92535faa5b79cc8be1c477b6e096567f81956fcbbc2459c810244a02abef43e15a813902fbd3e78cd54ae1d15fb690cba4d068e1210d5fb637957ec5e2285116e8cd22d4cf19e3229ff00102d5a5b201157a6a2f3e77e97845ee2cfcdce1071c33fb771b7bd888abc636cba1a6696a6607ec3daf115e182875667b81fda2f8e66d55635f461208e377c019cc5f37af5461af0b4ab3bc6a8d414e714d11902658424ce35de1dc19449f06e00a474de041d67af90c23b1130b9965c7242bd16d990827ea2949ac92132c3196b92e7fb239382ad2e710529ec51054e660ecfb5f5c8ff170172b83cc00bc1dfd2e7b7f1d289d96a85206388ab155407948db5fa5d5fbefbe78d5804f29a4346e56cb96ddb2084956b13a8a4dc805d5bfe3f0f927fedc01a9c9c947c40462d63560016642bbabd3e1a769445d7a3cbf5d72d4d47ab45af21aeb11c8dd2d7230a95554b202dc9343f3a36dd540bbc95670d6683fa5783ef92a53b9cac9513f9291bfd1fb47cf718a86b63a3c7dde3659f8b3182dc648e9bd18aaeafb88fd7a1bd4863d5014915da249fb1f32f4199b47d51121ae11bf0cf8939de57bbf5e7e056ca23782dba36cdbc32049ca41029c4d1d83c04c9e19c3d8b14aa07f4f0b4ba2f081e36c08912111caab161b66d5eafbfc2c4a04986a3e3f2da610129e47a776b8a28fc5cfb734557143457bd2026a6c04f2e6c8d62f2786327060613afaf0e47e5c3e710be28635ad17eb644fc3219eda547c5df679dfd25fd2add79e5c343e3a230d243edfbffbae6c36e61c96e80a108845da6b7bc13eea88211b4dc6c23fcb93e7acc3f77a62665a5366c1b476fadd128b03c7cab5044f071092e1070f5bc329ef246271b984f2e7824c5d801db4950591cc32dfc9d5476c7830df71a690c6858471e741fd4a87bb793797a974fa1b4df97a1f3d18f1892479e213492c2a65b9bc23e8635070db5185802ffbd8e56a8b6fbbbd807ec36e5c204c7431da69f1e1b330e6d6d59f8cd573c9c5733d74e3c1d9df15d081d8f692cd54823d7b0b0f08f610385ea3e919b5c5c32a3541a5e0366827302cc87fc5e47b417e95c2cebeff147d9afe743f84de8161f6bdf56ee076322984112bc5d132f8418d5328028ca0566d4f7dd792fd922b536468014955046466fffd91e6e1023792dfa4ab4dfd86e29d7eaa540603fa62d97afb133a87f993e4dab5b07dd87bd23769f4b86ea92e37b75f9991b3cdacd72fef9179585aba12eda18062bf655087d3880a26ab416b84b9778f01fc2be47cfa7e2494b5ecc814fdfd783ac299b46a2a5fd70ba5a0d176b6cbc9f46a7676bf5330bec035ca7a589904b8e000c2890154e49320e87eb61292cc107617aa554e285f26831c5d26b931bef73c89c8ceed4ba8a179a64db54a9cb905179c48c0bcdcb44e3dfd6d507ab735904d0b0a14e6812d21a36c7a11a3d322ae639c54643423da703548a252d42ac2d5e8b8f01aa535e878c62b84e34c08f5cc60b3f471c8e6edca5c7da8035d2eed62f1957eccac62736547e7d7f3ea196aabd368839607b247bf49bbabec349f119b621b3ca1e3b9015e458733d0d11dcc4e59c2ae8f14db6998e8f1df010c19ed554a408df72973a6f79dc0bf4069e0cc3b7e10e83cbfbb608f2701118f0b3574b1fd2fccf9909e84a2cfcb77f0e5269408616d6de78e8fed9bb483479ad29a0dce66a604cf00695890e6e772c68d47eaafce64e05a9ec6deb81bc57d4e37ddcdaf1a56f900d32eaaed8911d9363417092eba755e4e717240e757a86bed7a95c4d4116b4efcd3ce3296952c770656d487a576daf633edd82ade265dc804bb0f406f62db301ffda67393e2515e51460f139136e33f42d7cfb84a1bb3d0b6e141face2ef87975e4e4d34d6c6c214bf8d7caee578dd73ab1f59b86537e14f4baa34504a902af123829da5da4fdb029ae9a0a6376ec48bbf3394feee30551aa497bca23c73b0f1ff151b1d6ec027f9e5859da36b155f4486c333ace1ac1da0dddc52ce081c21b57551c633ec365ebba8cba9e21f4ae387ebccaa2624fe583166fe28742c310dab3579e477d7420d05aa87b45aa2876747710918d24fc43c5b9d124284d64ab3745bee74b24a8da6b6f6314838a65cbdd21e6ac6c61a5c122b8c4a97612fa1064b9911efdb1a0474c524273231a18668a911a0d70a89646cad69025151a31c3ebda210e748888aadc7826e307b61138e9f6fc7289a9c971cb8955b48aa4b2110a3a6529c92e2d05295094c520d42147dac7f5694037a204b410c5e1adcfcf689b06788606e56ef77c9d8bb8de595951d09f6d808aebbede7d76fe4a1c1ac582e6ce3c4459032ad178916956db8f71d7e6143881f58269af0bf41624df01a85ca5f9031e1ef71ee1267fa9844e10b1b529392725b19dfecdcc8a28ff269c4cf3ad4c33bed0d4fb39ba5e53307b4fdb4b73ff1bdd15761645aed6e1d1c2d793a79881ab2dc822f75127d3a057ec1964d6c9b92caacd11722637a4b405f728a04e05e8a9d1fe8e0eac363735957e194c02b2a6743f4f49770bd1a71d111d20e1786e2a844b3313f6383f7e5b2549f368801fd9687c855d96c0a326809f13abb226b5a0849d3f675987af20b3a9fdb8dc7ce28315fb8dfdb9f2cfa076427d8dccc123f8409cdcd4e9558c033d60a2912c86ee62826d8ea0af703fe8f6d4ef8ca1760a85776015877c548d0dc86baffd9dbeb227018e6f3b1e171f8b1a8292e7c13eced223dba44d4be31a8a8b42f1407dc8cd2cbe186e8b0967f1e4ffb779b0d161b4931d4b46d39d25b96aaa052c3faa76c28f328119f84b2304a3c709b7289d7a047387d7f7db4206e14403c458ddac7399321e774da443b2acdfe7e8bc6996440daf237d7a8323f927122d13b3ea0de11464d9c5c4f25c053c191cceee3a57b4a2f300b9c816ae4bd0050fb449462cf0f1869d89c15d7898bab9a0b4d1683f0775bec37b29f94937352d189fed5aec15f8ce5cd7b1b22d47b9b4dd94c4e20529265525b66c30b35a3e73d67462619cecf114ce652625bbe715fbadabb0e9da383cb79206d5b20eebe6d0f842bc79caf57e6b0984e39fc5a657eaa4b6de46467c8fefeda7ee5c405d62fa373f4cff084df1eaaabff29bb474d824000517fb0b0a1144447756f57d083edda6a55f4da18e8700275d8f78cde4fe76c7b34b6b3345f2c1d02c95423a11bd56871519d64f5361831199246af09b13503501f282a3db521d47ee1599ddd20064f0516afcd8d00aa2da7ae6c6fdc332cf68f84bda44ea4d59f5b0f377c09732a6990a9c82b0fbfee19d5803bba32cb0cd4f4fcde62cc0eb5dc141078f4e2bebf785b3b15e1d0b4dbd866cfb096a9289b18f81d0826a6252d5a82c1299ce9c1ce0b559f18bc9fcfdb36b1a334e4654a70d1e013027ac22e91edae0c82058cd3acf4dda99ae9e3333360188f6fc307747085ef30742a315c9f773cc724d4716ab0694f9bda0e154fd739c242c7e3a849c7a8e4f98cf050175cf3b05f9ba4c8ffca08d44128dbb8cffa50c846a58c78ac43337f115b76f2e0832380ec911276b43ab8f8d71bf9d3d42003c2f5e02699bb3e901e8f044a023c4ff9f7ffab7c09e522ce1b327c7790fba4d275d3e9f13c794ec0bcbb6bc5cb723bd11f1a573a8d5718afc5f73c668e2be67b19db63808381f3aeaa63f79eb2859cf2659cf1947a4dbae0d47b52586b1d02f41ac670690e1ce51456fd3412fe118dd7e5bd380c75047fde48f8c33afdabf6b3a4519a855e7ccfbb8958735bae12f1661a33f269681ff2f0092c664a24358e27fe88452a6a35628a0e63637f1d70a34c7aeb89cc99d0485fcf9f63e5f07ff0ed621ba6e44022c3031c809c869344379a69f1e6f0dff34a297347d663b3025175b7ec0d5fd2324bc3ce9c5dec356c17c29bc17adef4ce3375800d8522da71eee2680bba8d05cbe30f69f051be9e9a4d0ab354850549e40d897850d38dedf3ac9c06c050afdb077d4398dae38f3876a797612e6d66f0f2597fe997b3d14fad9197b6874b65970343940d51f96aaaf9d5feefa2fac6298419c937c97625d9de4c53afd0c58208ac65ec215344862cd7e2202a7819cb03b93fbc833697aafa0b72a21c2e2faa921a1faea6410f744b305d636e1636949db0fb243ace6973a5f30e0ca454c9e14a5515ca8d1543df0339ed930384842cf8fb04bc59223c0f6acdea19a756067ac692705b8d26232f4547bed8355e4ccdda8ef717d8fb0db8d1caae0aa9707adc9581a33eae49b506f9449d794d70e1b9b5eb9e80bbd5189b995cdad01548258f5918fefe0a347151c59422137237e94abf8cc7d34deb98c697023be4cf1909205def7d917c4af3f7e3a398fbb4d0f32aa47d08db4160d988789e2056907caf155bc35a2b574a885a04cc582b635bc625f151f8823c657417c1b9ce36c0fbec2a0ebebd0809d22be6ce2b7ad2e64f5aeff1f738b65690e78a2c1e5ad47427ead82c0cf15e83886475a21ba3993dbdd72b9e10b8396461cb5a06ff5b4aed353b2f33f06ac26e1ea1044a2212e1791a388eb34e61c96ca4a75a320b511500dfe80b32e5bcd9f7475122cfe124030cc8d26aad15b91c29b48919fc94baf8b7cbea71c9806dc2f6a47e1ce2292ac36bdee01c71c1bf846e12be8f7542389f5b6b6b8ad0401d0ace0873327c00fa2d41947665b49f54977146bfd0c3a61093b39366a65fe3c5e0dda410da211af05a20664107204580034a69875a12982c06f8454867f4624d5360967a19ebf4508db7204bfa5b8b46a6364d1d0e47a62cd72485247725a12f7b37167b75c36b0a72e2f49ae6d13a9661819752e21e13044b6b57016a4c5799660734f900a144f7f1187dcf17acdee7b051a9f94f182e7f740ad2acb4d96bc3b122e247826d9633b5a205497946051f06a6eb9f3227ea7de8a8f1ce1d4a9808d157b3db39636f993744a4f75cc9dfff2049c69028a13665a3e1ef6d4f042fc0b7a602f481f3ec3b09aa34c754b96167e9e9175c169b9fd3f2c40664810617c1c1bee63c3890a8a19151b58d745d8d3de8bf8e5b2d3a6f7cd76880d2903956e52c69e0db2b31548a626060fbc5d16c444760eeb08a1403f6289a5cb68b2de8434be57fa5f5d4fe6e3b52cbffe574f8bd47933dce9e37aadd9522fcae449ab89f7598d6e5b189c65bd853b324780fc65b8c919c0dbdb75df8b56d65d38edf0ebe34ca1259d223e17da38956b331c70242744298ef0b42fe43c9d82d9d3a80a6591fde70c7a7319ea5d6c0ef8c30a9426304a7c88491d5cfe0457f56152360a0b490517a1035c7ab22b5c9bbbe2dfe1b533bb1df8daa2290b3ed697bf7c5daa05e94df326d530dcdef24e3ca745e786787decaa34e6d4e5e5df9b8a6c3352643a2c2537ff1c0c073f33bdef349dc429abb3a4dee093fdb2f0a40175c4aa8115eb28abc807be795de128fee725cb96737f5b47462af251f7f8824eeca2cc16a9605319d3e92096c452b0c9debb32b439bf57c3ec74f060f8178d936c2a499469c447e4a29b6738af29dee379175e4a8add6bdbcd4c8483a5495fd8f87d0a19ffe1b524fe19a3f6cdf851a3c5140e8a3cfa47373b0e000ac45f7a7ba8b3a4aa3ee88b36d40199ad7860d01146e82cc54207a1c591ac4db79618bb1d9b2970b60d0a9df493e1d2a0e3a8e9140e1e68a314756020a68508a2d9d4d95a0a5f0776a9f43400b17663cfbe5e6d2a378a3788df3c2305e929370022eee91d67009343f8a016603991065b2642293ae2877bdf2e107cb1c1921df36e3c1a9b1a51f19e7c74c9ed2f34828c0eb1dc47b3bc753239a2efee87787cad698a02a4a3443b67c61e93fa4cae34d36a8fca046f6ebc16db6f2ad9ed7d83a81d6f59ff5cd4c7fc1ae087aa9e1b951ec9954d4034acc06b417fc7c219482eaec2ad5b8c9b3a7e43761c90c9f2d9eed5065f077bee0c9e7ceddc023edeae0b2d94eaa1580c4beda6d9ea9956e2f78f75d3e1a14443f4b5c6508fcb534526a3344f82b76ddffb61e53d9564b99afe7b2ee9950216a22149c965b3559d746c90ce6999263fac0720deb5d6f03cf992b8f7b8bd01a94b2edb3193d48cde744052a6edf734873204ad2811b438ce3b738bbced06ae6b2a37280bc7d886395129423ab86bd1f678a6b8cc5afb83bf1046afaf12a70e1fa5b6ceeea00f8bbc74df19e4806659cf7bd7714d2969acdd69c479541f4bcc821afb6d3555f6b4f7ec71bd3f5095fded2dda32cc736fec2d984ecf3d1e182e2040c4a7c82f985bf8cae90d3b45f4575f4b3713002a4e4bceda42ecf80d5894ad71fa499bb13a30088f08b5b11258fd445835291ea3b8bf4a04156a4e853b761f84a2e67ec94772b10dfc15cb6f73f3db21ffca373fcb609eb5cc68433b460e3f763eb4b76a001f4334b53a51a24606c9aa9c9d96f5d3df2b6365ef177a0d303f61da7479aa6ad450f8e2ef9b66bc525493186bb0a941407d3ccbe626f7216ab4993fc11889eef00448546b83395995e131e77702193b76c968f9ccf91ea56d3b7424f161027c18f67414bc482c0e9c2ecf894690927fedfd1564a17955ef2a5e21c61aabb779259aef01bb476056cc8da0297423fc55cd4c2a69ba9cfc3abf985e76ebf55d17f0e1f37540f042d55690d225b13540b385da1084b5b531a624a4c2db8852b4250e1291519e8117d303f368682016827f11c51a50683f169b0ff9510c2e00146f3e0c567f163d0e2ce2cb38368a2230707fd873b17d877393757ac9fcad59a44f94d4362952780d7f153ee2c7ee51330c5ce5728131f668d99edef4bff408c216b4960900ea01d805f4c00fd42a677d7fc6fcec09d5a2a1fe5a5fcb7a6929f8e278ab75cd2849cba977d82510c574bc8a0b7f5515b7bc53db3757f942e8a7f73d8050df5228a63cc30b8a8b559b613c795843c0cd149d312f6fc4d622038394efa7d9640d7a36c13db54b5db3fcde277617f72d317fb67bfea98e67879d058350871669f743de888b0b7baa4000fd906be3445d61050200c1c5c3a29844ef85268d25e578e38e18096feb88b3e987e61eb6c7d2e676a57dd4caf4b23fbd18c419df0e8de67bf9d49c5fc7e194bcc75dfad6081bf98164b3b2c3e94c386cb5358ddadedf2b35358c73b9ba2aed551e057534dce0f0a3fe05a976dea317a35be713e92e621f5680934a024ed7753263186ffc662cdd74fef930e3aed033538b8795649604d1b75333d58bb6e6b982bb8bc97b806a16db87960cf8dfaa742e81f5143579b28b9e70cc557c47e0635d9b4d9f760ed7b0281301babc6514ec26fcdb092cea27a357437fbc2b27767433f2e793785d17db0fdfeb447f94db2c5a70d7220a9d9bf7266973ced2e2df4854232ea77c530f4c352afada613c2413af773b6c793bed1fe66d7a70e881bab947c236339bbbe94c6e82e82879c2e2963fd0a7c238ee3a6799f96bc877811bdfce782deed9edbb9b60a2024912ada7e2d7d8380e04bcfc197acafcf347160005cf65abf51d558377bb5e59bfb636600c7473e75b57a64214d4b9bf10d079680f9f08fc2835da52bc2c9d189172876c8ee0cac52534f65e8107ec243b424e4718223b2f1d3735449ca38f08bb42ec5487879814c81f9bc0535331e9fe03ad1b242ff9dcc385c8f93aa94060b98803f8d64a0642cd38fed870a9624817885efa6b0d642e9e7544a43c0e08a802d9f73b28e0466a7ded9f6e30c9a97f763d4ce28ce87effc8d62e9ac29510bb3786fdcabe2a759f0f393dc9bfad4239df69bc34c6d5306ce35bdd762624330b06ab7bc77198cc9e4f94a08abd15b999762b74ff494b89b3803f4b39f92e75f834d8abd33a42ac649375f48599790e754d0555d868af9bb067239aedf60247911c7a29b6e889d26f71913f0eb4861a2080644907002138a677d66f4b8b6df94e3867be5b00599b203011e57a52fb68147aa1c590d79de6fede19b18e0a411212d5a1ea474ffad1dfa4de6e6781620a396355b222909921c77e9e17fe31ad342621f0dc97fdf665ff870ec3f9d9bd20fbbeeb52018c8cf9afb2c4867508987b869a7cb87d2a085e23629cc0e6d80335a760cbca8bfacb15a0ca52d7ea22b99d96b1a7c1e9739b9d06346228c8432087469bf844a60aa117815398cc56eb41bd86c7ad95d5c40bf96361c86fff10b6ecd496d9b05ce93b96ba37e272ee4f36560b3464d50dea80bd36f5e342f37283ac11beba0afae2a8681115f4451321d21d21c78b2e4250da05959a6a091fe3b98948628e31ad7b39281b08ee5dbbeafb99c0915a30dc6138c733148542f0e6c9c0082dbf260f4d2e7884f579a8c42afa6c2b1398be156226dfcda5f664ff13e71eb48668","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
