<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3cf5d68dec35f9b1171589a1050080459523e6edac7ddc84a0d54770f95083aee5cb301d5a3c240b663b2f98c7b6d20fb79f59f9df7fe0b293ce627085d8a7c7cb84670e4ef8f39bdbd88622cfd3ecc50d14e8dc68df582bc5398d81c8bcf1287dd2bc2ff3062b394b1428583a1c2819b5dfb81ab6ea3cad96771b32cc54b1c12763e36c4f60b9e51dbd78f4a3b70b41bfc66813c0630668cdce8455426194c0256b02374aa9358f3eba987bf8ba04f2c2d7ed03aed177b826cfd51489c20c27bef48ac987dc0e530efafe316c44e4ce9458c2d7a988b7ac238ccf63896a661243f082ad15c1a9d75e26b68ae1163557c42a7ec902670b0ae9f6168017a35aced206f810bf9e062da0e6603eda07d992431f962ec30014c9e817c169c3cbb856ad68e48839bf928b4f18fbc150d7e18885a0433578986f929d46089e8882ee9e7b14e2e504acef8992cb341b44344d5837aad98a85d3d4d432a7fa84506cf1d6c73e3055003e71a625ae0a7b50962beeedd0fda18185e9bfa4b2db3b426a032897098198aca13c3e8413882236aa4830ed1881160c2247b8820620f2e03fd4dc1771af486cbddad71e41c2928c0d24b2007ff8465763befd5465a3c11da14f3e900e7a5280c52e12857430ba9f89ccc08ca88f203c67cd44179f1bbda5bea178c35ba7a3e14ccb19b1f99354417f26e7c529a3c1e68edfd3f205ab917b4e03c2e4275a86924d6da3a2245ec564d5c73d29126c241149ce2946eb299c78b129ac3b3433f33d148cad004b9b1cd3ce29b860222380856c96e8d5e81bb70d144476bf82ea4f86db97153c27a2a1aa631854caa91d4b2a3abab8441826b082d6f70c6b4de55c32fe9d79baf734575b48cc9f14a78919e1d4522288fdb462a2cb4a2ac90e0928922c579a06563d39a831887f79f8c03e02ec5a0d193e7a598a6fea814dbe2faf52e94397884431bb254f9cb1853fc828f1b726d2627548e1e5a07d9b4a286cb5eca759236dd071aac013c452ebd69641bf884bd27482c06438c53712dec85439cc6b52c2137505c92db6c10948d082fb119261eb86800424e535e5f1736e3204e856015976540d21741209aa180d030c9f8ff061a532b42d951b30bce2f65622f03798ae044378d59302063c393290817f520a9e99fdd88a758578aacbddbadd541e13718d086d0dbdf840ae1bea3f6d906ca3ded996c2a1deb96f6427004fb7355a4e8f5ec33e13a5381f334ef6f8ce2b4b9d1f208cda0bd271cfef6e629687b2bb1a90a8a463613541e143ff1245b8b63552437704aefed90e79d1499c2e35d2570714a0dac1eb00d496c05ea3b0f0ceb91f76852371769308611c0022d959db7d0f22a40ccd449b30362a27092f2d5bc4d7a7c528a1fc72c2d4bdb2a8545745d01970d32ef7dd77c9dfc8ba19bb0c716f3be5bfea95d71c24b0ddb51fa665bfdeb9489c74b8be70e399bdcd73e488b2cbf661272c45a119ef31b54af8db7b179fd057c908de6166320e6df52b7ac992986acfdf69e26bcc05f54de1be73092601c9cadd5b20cfe678a55b4a52dd001094cc8c7a00a8fcd6e6c684ed1859badf5cc36995745d4fc87fa4b9085b59e57366502df7dd18e4de959d1f0441b0ab6fb11d48fc560f738a063eb4a11a885b6f55e36a65931e691a3c14ce203dbacd0dd54a86aba20e06174deac54108c160e9fe3ee5d271a2f30a8b0d360768a1f768031ab03c5851faf3760495f6d55897b032bcda5e8c449dc424a2325e76b7a02f801fb0296c8ca4e730387799338707e349656f849b08e0667ce0aaaacd0f9a7c1d108b79d20ebfebbf92e6f9411e18c363b90b97ecfca6ba43d842f9f10f76fb5131e1f3b19ae1c7a58c23bf1946956d81dbc3f0950889f6069aba8ad693bba7f7178c3cfbf18ff6e315408aa51319a4bd1f87bd562bb6a3493cac1c0449595e3d19798d73f4186ef2dfe7f31f45d91668a921c46b7d54bc1a3513bbf30a45868bc297180491049d8be51e568a9fe6fb765e292f6f016f5f66813d6421dc3dfee3c5f19aee441881bb50ad90bb65e0ac301cbe8cf357151c5ac4b6f2d4c7d98b1806580fb9979d1cc1e5dfbb6caf66bb2a014c72de4ff6a715212fb2f4b2be3d8ebde5fdf818441b5ea782a24aed0930340b4e1d06bf68bc96870c28efdbf167c0dcee91cccccd2ab18acce40bb2dcffa88cadd0318aeacadab9f5afc52212aab2254f985ce0c51b07988305e2ebe03ce95a3a5164796f264425a6c117df4903540b3c7facf70c111d187c15c9038d4cf02c1b78ac2784b9b777e43312f45393f68c0424ce639c25aa8b57ff2fd9f16479172fcffe0e6cbb0bacccbde995b663ca91ef815eef16050275488dcf2ae45166c76a02e9d205cd42a1fd24ab8608df70c565fc4a9794e9f65ec0a5017dfb224d2cedc68f5b6e1dfacbf3c7976cdd2db43d9543308d3689142c5a70babc0aa30c7b3653c32d03e93c86bb1e62c544578650e76792e5ab9de38dfc76f45426519941b41a72619420850bdbbfc6926f1853b154f25f8d2ab1e86f520a9a989b69bb5fe48d203543e6f0744715eafdb265ff9de52aacd22b7db9868b548c6d29f80290062a703e58bd820140bf28e421c0269350d871dcd86f97a69598c28da30f2ed677684f30a2e7e04c1ec591629e709f14cfb5b0c8088f64c7c6c1456c481c50c9b99480f601f512b41fb7422075b31e7141442ddaeb880dd1ab3975c29b7614951d7482abd4c51f211cfad1fa1335625eacee0b182d07b1f80f0fecb28e7fea3d8f3bf6cab0b6423576139a0bc0d1abc9354ad04b31d1c3695e1dc01547ff5b255076c9f2cdeb9837e2be7b83346542f1c084f270c221cd5621a7ffb855d680c6fda665558c7c614979f93f759d0c94c603f09004e5bcb2998cf4523d69480be381f7738bad816916216be0d09461b87693c4e9d0fb8b5927c668cf44c91bc41cc9fc8af050ccf6f0e35792cacbd8bbf9031266f3273b5bee27d62b0a753bc359864f9cfcb340f67fb704415baf383ca2cb862d2f39805941049d8f9b780336f52b95d0fddd12a6fe1319883a5a28ab29cfd5cf7e00b6bea51114d23056073086b7957ea1f6a5de84a34d5bd349fc24ab47d9a3e0c4592cca2105ef04cbf20736bf2f895bad5a2436d60227feea34759065f736512465b704d64c75119cccc9a11b84b6c57481b1b4447ec0989da8b2b1b1b704965ff802db980553b43941c06613519a64702b554f1e868f83588c332d19f31f3aef35451cdaf397ea47c9aa35a972d320a12c5717bf26906ab7781a9c3a2e0297413730b6cc8bbf3885617860cc6137ffb3eebb5bee0fb42b4643f2fc79aa6e5121eb96d02e5c433ec39a26479f2ead4bc81162eafd22c9ea6813edce83f50c514edc9bc56dc5d28b2c38d6f044ba05fe099946bb9b7541e978f44c20009d4697d3229d8d7286318be650516596cc3f5f51a7a7739e0c497af1404d08c71853819ffdd3a5f2aded8a3208c234e6bd62a0865e42baf24412cb13a4f26d3c286cbf0a1e062b5d662bbb67267d20acb79375e6f12fc3bff621cbe931a261eb825434cd6fc594e14e8de73931347011191168bbb1f124bdce8446f43ec22afd6d3d7f1ee1076bb67982b3c894c1eb171214c64c43f22ef81da116235b6afade7539b091cf4897e052de500aa536e4b9b5d4a3de1dd97e4b4544eb81c1605b0233f72fd1df3e5195647c188fe96372d4fbf3fd825a54a4541cd6c84139c726d649b373c4b18f32a139d4b9726ca30df5df17907a050bea8cf8f3802a60ee44fe664cc91d4566a68321d1ea2cce8d29cd755e90f98f0305731faa3f1c31277ffa414f53ec7005c426da80a94cb5b6324264421e480f2185eb9c009035d597ed7eec198554d46af6f177262c1f47916c7309901afb042e514328dbb4615d195347b8940ab33216affe3c3de4dd7c76f80078730eeb0fd6f0dbc59a8a531806cc9290f1d9224beaf4b6d45b2d39f72d4073c1883443cdab75240c1f97b1b0859d4a99c6fc39e2021dd44417dd3275dbdafd7e1d3ca4b6d6639dcbdb0e074aac4233f9164f2de4c028f561b4b1b99f16e3c785959fe754de3e98ebd75cdc42751f86ba8c7e3844908bfcd2465d0be7e8a7bf7d8794c637bfe4d601b24dc0b22d5d21aacad16f403f6733122e8dc85e387662c23ccad673e7a857313baef25ecaa98df44bce69d96d3f596aa217a9e7e0dfc7873bd346beac20401fccd49d43147a961e4463a15aaf92ad0817b5f06cac0cdaaa7a297b57c334d084aa0f41f840c47a3d0d5b5641d6307330b707d105c9a4c9666c014082cfb11d59129bf539b9929dce54cea07800e093df41f9f89836daddf6f0435685bcdd8a7fd5c2763c4306a4a41ccd6b6af24060bda624ba6ce848070a2abd361531ef720e7ca120ab906969cc74ce6798ab331da5a35a2d3410677c5103baddc8ecb5db9b1490e189e3e09fdd7e7744ac174985a430fef42b9e479ac27d5f93c122791e590baa2339143c5779921c735fb3a6bc9758f0c8d191085fc74bb93279b11fc860422edd8dc5b815c941c248fae886063b8d824143c713e00d2355dc569e584d6c9d0846e1b98782426c1b825c53f61f8fb55f06011b659e70af421da099f3b383cd1b300ba8b46153fba4956893792fa947f9702ef79bfe9810539c219b18620ef37d95f2e74f50bede8dd7eb0f2fe7664aa6d8c57f2f9d84d6f049d292fb94ed25bdbd4ab070d4410d762e805767fe1d2b5f9d350feceee7871500da31736ea778d3702a4eb84594cb6784618177341cc55efa66b313962932a0cd603f5e64be6867c003dbea37457de605281dd60211d5c81ef336667301861beb136dacfc49567ed060b8c75112d433944455ee2c673239edcf7f89916ce15c95620d0183a9d48b57713308670b778a9768ee09777309bbd2a236fe23ebd2dccce5f90ff2f4af3b29fa36feba7aae2807d7edfdd6a6ff8a194c87728d787541e1ecaa26299a6937b5f20fbbec9052ee5779ca0e7e39451a2f50bd69975496264fd8bf4312e449f66e060c1126573c52e085e95dc708a4151cc2c5d5c03cbac3f929508f3affe4ef3e29a00fb9306c2e6c7a73f31e679795862eba410c8e7d39d9b7442a4d2b6b381e3bba8e104a5b19b206a5d91b3fbed54a5285cca1b3c328e2591835d3cd2efe66d700962260c8ed0ff2f2086abc6763f5d0bda1f44c95fdb69563d6197702fabfdbc29fd2cd15112f86aef9f653a73bda14cb9a9bc728347022965128fe72ee703b2fd3e4585a971391f530d205fb4d2aac3d4d7bc3e3871f1d677178f14aa1db740a13aa4ada4232f19ce0ff1c559fd7aa0bcee5869285c9e07922bc85b50558a492e9a2d6df4bcb72eef1c6a3150f384548f7538d4e288ed7f6ae9e36bf108f25b044ff753d677add1519b6699cc293f6166ed5e922e7a79fddeebe809186154a7a849198b83ce9086cfd5f600532779c023406b1c0280ed6e879eb3c6b7ca00faab522d8af934e6044e6000277c44a088d1815a287db8bbda928adcffbcc3b31f064a09e01790fedb7fea9a25335113b37583710b40ee3d1e21dedfe77d632a9dfc5e304b01831c137c65f56222640863977867e090b255542e2184b3018f331b72eb7498bd490da3c8d09cdfc76d63e53855c6a91fa0b6ff649589d5c76360ffffd130bea557b995035b91269a0589a6682b77ff05f3c347fd6e6e97a057b5d55099d15fa4a43965584f250a59fe1eb1a450c8b76b71a383a0e5c4fae8d0a0bba44e0128340ee41b8b209b7008b3146bf8bb1b5652ed4f9a3719d0f1e9e4942398edda79f4ccbbecb5507044a9d282b3f04badc031db7af0346368c6a2c22887f49e50366b08f4e84f539946d55dadbf90384fa867dfe0ca2e43a566332c9a761392f7ebbda8867b53ad9654b6b2387ba32cdb45579e10c7e7b6c53ee1f437a8060a124f16aa0484faa22360716cdc8ad74480672aca1de8341c5b9686bb2c764bbaa8896f51d5ff98d6065b465e050aa1961ce31bf384a1acc78afee597223d7a171984aec349afd897fbced1989a24263965c54d9e0b577e2000eb08ceeafb286b70bf6d807b7bce16f9d4d23cd023ea3cabb71d47f0de1bd209dc77677210a2b37f166f9a6195aa486c810c71102436967698722fcfd76bde52afcacfaf763243a2958345bf222a7f695c8f2831d1c5ac869fd4e864bc987c70dd057aac29c23ac59bb59e63c7509f1efc209c850c87415b101c78961cc9e427c52cabf2853765d108a84a40b0525c57fc87b2c84bd35e5098e9d0d548aac454ae1daa5b9424734621248d1e042d3e58b0dba378476eaa213d4fc906e62d689750837f8c6f2e7e0627896ec5f079e5d91fd4f1d60b7b23ee17b824b6ac906e1aa6c2440b22fc9f24fd1a9897a31d68fd183d13954d48477afea0bcad98633ad6bf33bb646aa723961b06fe76b47d0ed6e2e86d6aaa46d2321e15a08c61d9134d6043ef8cab350558f47fde25b6092ee681d7667d5f6aabf053249d492f537bd582b22e3664ed0cbb865cbf6854a36b9ff7ec308e00db7aed7f61b49632301e4bacebaac3a9ad71a29af5c492fc12f975a5bc76f2b90c620deea633c2e620049649a7eaaada28dc161f12d7a60fe47af245f23e77a59a22c5353c0abd12fe77a950597c2a6cfb044efb5d7942eaa753752cabe5287248d349325075c0921f1de01cc1fd34425471fac3a6b56c26ebeaa0b54be2b5f96f7611fdfb7521f6090e63a7e6eaac95e789be9decb12086f40a3719ceaa0488e15be327521a7c36aeb4230db67f140c3fa4c715bc7ad0f7bde03b7172fa530bc30307d70eed55548b9d221cf3091989faa80149accadd41237b41b9be78afe3252d371a4a485556d984cee981ee8bad89556b6ab74c483231ed732e8a135689d8b8425beef8691725b156f071517aa01daffc42e0f0cfcf4f2abffca1457edd84d4a23745d2efcecaebb1235178ad4ecfdd10828e2b0d33189bd1018cc44e16150df6ceabf15e38eb35e5626ff24f8d7b7fb0e5c00300cc433dfdad0c7e913333baef1dca5ce4f354b007fdb91628d35c640315d7a107b6fdc63e4fd8d855f84c510306295661e190d3bb02a1660bcc44139bfc1a123b30c415bc00a7935ae73eaec9f3ad3b9e6a4fcabe4d1ffdc6a222a709c735349c0492c69fa0c897c5a58f750762a26cce572f122e367a932cccb808011591fe2eac222c6f4c4bb63d4d3d5e039fd07188c868748e2d3c9e6cacea5e83308b4a0331420688c0b339821aa779d3422534b93f231f35d7b53d79168c83a2d15c69bb2b272e150c2e63409a7632fdc620320d7991bf8fbc178a67c75f2e6f513bebc2286160c7e5ac69914aee0e0b0eccd636d5e8b0792a5f56e328527f08353369e99a928db176fda777b6d5babed965f3ed79b7a25bfed3160136aee6d29cb3a912d739dcaecd35e428008a1e60a580d01c65b6f66e932090bf8824f8e77056336adf194bcd2f1cca3018aca5e5a5ce20b9e81a795b10bb72f73d19b287d3b7a92b31623af6b9008e2b2892b7357a71131afba95dfd8e67619dc91cfe324ca7aecd5f2f9de0d4ba5976b0478c866c1997e1878b35eaf4e1bd2f63b76c08599b379273f3a023c8aeba699db3aeb4fada03ae5c544f4e10d3e5b9ea2d414340c9903b8cc6703004bdbcbc2aa47183a01a76ffcf15183006f5e72029bbc109f0408cdea3af7127a37bbeca1598cf111593a8e77526908bd8a06446f48256eb256aa225adab8dfd61c99e47d0f3a516011ce045735168a38be0a25f5e9e060087695d0037f8a72e2320b7b197efd9299cd7303dc7aa8bf0398e52c03d7a0e48f78a1a75e74546229b5a32fefdc8ff33789e2c5dceb66a6b682417107a8743d8908e169ed98b5df6a1dc49f58a88331416218becd1246d28306cae94ec32eb43bcea324f317188f01828944f2dadaeef112e79ed163ca9a7cadb7b8c4c8e4bb4c8d0339efd273c6ccb571f96facf501829da6e259693ca4b75e9fc595409dcae4607ea29081d4c724df966d99d40da51830a927b4c8abb1e573b62c3bde8e5d1f2029ee235b1a79bd6ff711f9b94ff6641becb25b57b60cad8bf8c12c157892414e52eb975b6a538e09402a3c617455d1149c8abe764e14cf7fe6a679a9c9851d8d9b44ef958dbea1af9725333673fe316ad35b8a0ba1c887fdef0578f3f152c52416b15ea94a77151ae8c7a4aa464acf5f66a0b671ae5ffa5f74b298cc735f089133a34af364775ca5d02ecb7ae055c0c9eff055ffa7a3887b855f85da12e834ee3cdb79dd645c1b73a3bff4af334554301ce5ad2d5569e3de0a876b9f55d071fd0f9d77fe4ccafd8a0a223a4aa4d0e424a2fff83292a2d10a90cf42c976e7962cde893de648c9aa3995d17f248005780cc31bbdee5b40f8a098585d92c06f753a442ea2ecd3709267961e10e76ae45c107a9ed1ad55c316ff8bade4d23affd5e5d00eaa3878da1c0fd3b47e7f8e208205c44658e335ae883b9ea7a1902e29c7529156c6c78ac4edd22e00c83a1053e300bd7b012e30204378b70dc5967f51935fc3665f8e1a8bbe5efafd8c2c8fb407e0fc40e985b96bc1fe1d730b64ce86e308d2668579cb5f76c08ee7f801df84f78dea42ba4650291c10cc72c6534120f07d67adb9a179b5cdd6bb52322da943968d8a85b3a40d49bb310632812b7b8e43646da7663bd45b2e4e90ad6c79afb4784cf795eadaa9136ca17e81a8d5f6ae136f81e57ea6e5c38a06ee1cb4c891342920f5ad6005c749a5028b0435d8264b687c22d98941bc3a74d329193733d532c470c7625088554210917d13e2d5263e2976f7a27630cf1193e65305d5855260115631044e9fdaadabf292c7830ec3c06c0f57dc7d3acfb399cd4a82df77cd85ef49769e2e305fa5bb2f42a8654fdd99539e26efd63f772a1928d9b839a45b6f10534b27b24168fc50e2412d14177e6a1a205d3eec3de46b4c98c52b69a7c47fbd85bec74e06ae030513d0bb27f983ac423021006338aca47bca54650585193059f7524831cc81d5b35dc292e8dfbc0dd948b1b985d8e1266bf9d1471169b7017363c0a479b56976f0743b44b532891328dbed5dec5082e0b0960b85598f03b5fc8bf9c0ad5ee6e511e503c74fbb30d22830a721466322a9769d3c65f0cacf9e29f722d0fce3a0428d3684b402fcbfc279303a6b15a445cf2cd95026f927b8964bae8a5b9b121fb2a2a4346a63f9ef07c51456537fbf01a1f660c8071ab4e8252da0dc4bbe6ecfba9692c1736d07da6452e9ea4404d3b1b5ede22e785ae205490f9e0f15925fe04d9ddfe18e75f2ce6c4d5f500878c3040ea5a783c96cde6834b98f96cf64132d9e9efc33160629a8a797e040b2d5590fb673c486c7bac7b21b8f12a812b55755a2442d6802cd0d48732f86b62c1edb66a7bee389313b817ef8e8bdcaf4a9ad5cbc212f1f628288ce17389beb7c13bf20f3ac5e67b36a85bbd3d3ee0514c517be2315e8f62d9ca4be15975e2899f4445ba1f7d9ed3930b2089b9ea93644b1d56cc094526cddfd5309cf10506c41c3152ddbcf2c19c92d5a6f38c0e0fc8ec9042186feedc9bbaf1e2dccaa9def2b9a6f3a19a61950c9ac37530a6c0579a7abd75c67452d2bc23caea1d9b379907b9269646f27a7dba1f99f50ede29a930a1dc0b369835f4ba7416dae6d9ce942d6131fdba039e659370ce13599c9ea244b7247a755f6e8a51476749984fb41cf336d1445858d25409994dc794d9407cbf0fe12fb28b714bf60745c6fed9608d0ffc6f3fef73e6e447e80eb5d409f9b2904769950ad218680bb5f648d96b117993888a8bd0cef05d4d5e2c99498e8cb0a052d6f6fa02c0e8240d9372d707af38b180c8b1e990187b2ea5aa9ad8fd780447729204e045a953583cd4e5a459e14fddb44e4eb02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
