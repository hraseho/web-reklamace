<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f5b448fe7f1871920d705956f95d45e461cbf5e33b555dfecd4fa7aba46735cb74446cb5dfe26e9d06bc73b18da84864f851c2195e8f16f3befa73e53e6159bfda4fba7cdcb6c15f60c4fb7a858314a9c37b20d5360d66c689430dd82c149a3e7813f289ea9306fe4441f90e88a837c3a51ba49b0b06d457c813aa61b85d2ec844ab96e831b4c0f454d0fc81999f5cb12e06bfb5f7663dfa55367ed5e35023d9fafb425e9a6564073202ddfbb7dab46ef156eb7386cf52650ba50509f61f391dc81f6c4e4ece283ef4f9affc4c6a2c6dc040c017e276c1647e85a16eb113c2e3c24e08777e74a4730ef7681c227662ec3d8cb266b3ea51fefe287cfc0f29577a516c295704bf6e2bf797ab5de24a2d9a56d67830c4fe7abd913fb014a588e06655c2ad7a4a35188a5b4bd1d3efbb2a13f3708213d67335321359b0237d4daec5febe14e94261e12be7ed96f93e779fdc3729921e49c56479d61c3326fe8fecd743ba421a33a6dc2c9126983de73014ba2b38f926fbfae04c0a32b76b656f7bce37984f5db6622a79b60531ebe026a0e39394e2e8f129768e5caab224b5345edc64fec6da322a3394bd9a689705de3c7d60be7afc1e7573a6b0a4bdd64403ff40eed14a853525997352ad809cad7fbb18472d3f3f66193e6398d4414622468db5f2478ffa2f803b0c79ad456f5e71785900b43a48c03bb389e0d3cd84085c9e65d5f2608e1370f6977cd08d9a53ec76f023570bd8cb59d1881ce2a697ecf426ca1f1ac9a125229f9e7090c121ead53b1cdac4ca0449c94852a2eb56185664485960cc72ef1b44497148a5b9ff36b3d77a8ad4720fb15bbd0314ad7b7c9ca1052ea233f07bdb879b938cb313d1d6b3b59a069beda89ab3d3f9c3512d6c6d024b364b244fa51f8477950d7d3cc81659b48c176a260cf35c020cdce31ad29b29918a43f8a58764214ae62b53ddd07f688563dabd55fa64c8f127b0b72b9fa3b090e026b71ba8bf1d80fc3556d4c89b0cf627551591aa9139a47a6b0b78348dffc95d8a7a1847413dab2c7d078a66ecf355c457262821d51e1b77e40fc1226e3cae1ee01ff0bbde799400a1b9c4a3b4713799da1d75dc4803e3f5b4e732ff826cbeea1ad2776eb1288fa7c14e007091424c0c2b323a77639864050c4ad2e1f770ceda6308426a7bc6a1cbb64f4555eebff4e598c2976239da608d369dfab8778cb2e959e33bcdc1f7625e61dd9536d0edb6019de7924b2d4f64f3ca0a175ced82fb60c78959a8f57f3d4b7b2c5f9113621dfbb277b11311dda7d0aa27bd27f9cf5fad01c5c235f4cf02e6ecadbe17665e9360480c1e20d06ae5a110185a64d3be33dc4551f6a179a7c211fee7e609160f0030c627e4b3ba34461ecf0096026f4413f6aaf5786e3d096f4aebf1b7dae6d8ee452232d821c629be3c398990e10a79fe189215c207efcb70082aac4ea9adad99cb91d478c39f027a2bd3d824db997fdfaf0c8f7a507b57ad28c036f474e85af1a347efc4366e61685773423d61f487163dbc0003c0411c6f834cebc3e9edcc5867ec10f522e4ebcafb78454ad075cc9226b09018d4d51def46751b8cead57f6300e4d713da9c167c29e5083a27356c84d9a2fdc085621cee936086f694a19bec6b734acd8aadf7b3537d4c1daeebab23bfca0e74ce6caed614090d6517321620728b0a3885a794fc91cde153831a9b1cdf1b094eaa8d2238f4e6adb3636f4967964f3d97306fbc33081b32f873dfb602f4a46fc8d6f7060f2efac5de9949b05187f6e9bf70b81ae49bd0d06d179919be3af997667d3ff77e509b914aabe78835de169dad373d832c5d7556cc06d3d4d697d4a6206bb5bbd29dae6ff1ca9dd84096186322955dc138401ae9dfddc5d1a992f9684a8fd84cc7939e99915a36329f69669d40a653d37ac6ee294a79cea325a864fd80df5b5e6ddd602816c2760375eea686f6de3187d989c28f2940137445f4e8b1a1b388514c5611ff65946f033effe10844aa18a09a29a89838e76030fddfe29eb3251fe6076b44f60ab00cb62aadce4d43b3952a72b8f69e9317a334a3f0880b26439b0d2d1b9410321a9fa5f118c2a9476e2f849140510d9edd49bfdfdb36f537fde6f543a8c48eaf90796fbdcd3ce37b4a7a34331f609847ada32f6bf72b1e1cbfc98d55e1894681e915f2700928e9e9d7dee3d83850539323cd09afc116d6ce544e7d4a981d2dbcbb62c153c101c02862f19e3979d83f672e50ebc0b3811b907bd3e223be48670d9b4432e8b4380c191fe50ab9152d0a6cb7b1bcf51a86b9f72419c3699da0781860efe0fa836bac0f94a5a10b48664973cff6503962fd6b361d36e924d369f03391c2ee75f4aeb20e80513a89c9c240c8a76dc7cc9e4e69da37cdd652a8cfc076bf8d78103365ccbfa0bd59de36186b882afd7488670eec05e5c99e58f3971322a790ba7b84b0e5a0a2f1bd23bee9815ca7cf45e357b820c2fdc1fc7a817bb08621d5609d2da77b6e52799ba9e21c371796008937b7a7b542cc8c2de93d0edebd96b24850c20772ca777e1b94e30bfbc89860a3ed18c209577c19a5c3100ed74fe561d63a167d13396bea3415132778f8ad80f55546d70591b17a7c95be986e1df4ff6ae621fcdff4e5da68dd374ac609fa20cb98fb7ab734e82378355b07aa20eb1ccc43659338600a2579394c3c58d2d969ca5fab2e3d219312b453fde5729da46b976743d82f50910b8df5797a58aaa25e400df9354ca0688e090d7e5376ef49277842681ba998172024ef5ddf05fa90dd2b630805cd6fc0d5f44ed67e0cf541c744e4ae79f7899e9666d7560f27df539266974537c519b1e95e3b6bbe6164effc6190792eb469c52765ed283af44756f7b6bd70fe5399e0b2f2926b934e1a6e187408a4b93b70dcec0dbe8294d339923070f3eca8a4e2ba31458e3194a285b8959a309aecb167e2f16c52bcfeeeb70a39eb77416b29d8f20f39f50324e043909a4c3afc33db479b073b91512c9f40aa7709af39a655a1f60a996d4a10a60e603fe3903196c9c4fae70ed83b5a9cbb7ca2fc5fe86badad7b6dbaf5b1952a4e414d435ba3a97d08a47a84cbc15ae8fe3757f17c6879ecf0f2c634f6b452ebe9e36cf7dbf13f7d927c627ddb69a12329d09c6f0995f43a33b07779d21981d60ddc189d2511b8e135e7c76cf1e1f61fab1dcd529c63f2e9c126b25a7a7d12e27229593e665ab127e0c277f03b961e01ca905353eaeea3c1b0d13858422d0b05937caa0745197330715fd7225300eca8ecbe1816b68ed5028e15b6e2e314fe0431112dab5395f25b3929ede52c28d40b46285918ef9cbad39143ff64b55246b9af407b11619e70fea1bf509b0f91440f587c34d7d3748e5b5a51a315c8c846e4a3edd3ad72e90358f3fe88259cee4ddb0feead9636da49b8fb614071a7fa2714fdab78188df3396d28cb7ce2c7b19c8da81d164500667378635d35ec2725954a30165bb838b75600bc251ad3bb6d99916e02da3bf0e5632b69b08c5a770d9be01b58eba8caa3004d00843b3dfbe90faaa8e1c97555605f6b675c06c10b4cda5ea207021bbe29316c5c115b8638a640ebd7acf3d79a57f4eba995178dd6499516c7162f1b5b61e13fedff7709d2dc598382e86a92e5a0a472d0171291906360e0e285734066924a9cd4363f22da56d044db24dabef0fc0a582549e25cc5e87b82f35db370548e2c0697723d88a393cff5c1b70b2e4b6fd94fecf352787600cefc6872584f15dc91d477645396e4c1017c4783decae4e3e23dd74b50446a5e1f9f138c5a18fc60a4c09f3d14edd16aa696325341d6ed96f00a39e713f33bca3e1890dbd857bc17291f97a8b12c7876f5653c6982095c1898124e7a70a8477d8a730336a219faea9c6d5eced3caaa952c647acc74fa34e75bc090a8afe39448b49e01340fcac4c6059345f845a182634ff54472ffac8aebcca00875556f300faf7221a3c12475b327e9a5de03f387f6dda29bc1f3db7e8470b8300d418f8e4cf01a092e8e68c3f8397c71dea186f061aa3c965bbaa0751ec17da846f05048a924d1c8a504186acdd9f899f8132d50e94d1b83e1a26387970301676ecf0e12b42e8bbdab0e26c6ca051013f68d6923095efb0c19f3255b811181cc7fac1efad91d6cb2249b4cdfce005e382de04129813c0f10586ffe91a8e64d2e96933b67ab59542121706505b8fc8f2dc7a008904274555e12c621c15b2a831aef1ed24c9bc10eb137d40f0702d211caeb90eb477238e3e88c2316f88c3f68e849eb241df017ce2a08c82ff6d15d0a0781e2a7c1f9d60fe49622e8b8b97687086daf3651d03be695455154c75c4d7237e6d2148a67e4bc8a8129d18115e74da3299333bcc6bcc035e25c7ac0d73e46df52e9eeb73ec9ffcc6ca9692ecf88c8acf511046d06db667903d117eaee742c3d1a9f23b3011febf03a87f8c8290c09ef182ea1f658d3ea29f6841500a21e3883d6ea2f339c4d96b488ac62b5882f8baee308d0272588bf34e23c2b878ba4da1ec12438535d5bd2e70ddc0e119eeb319082c3c19a28bb48307bcc81f833ea3208c8986ee9ca28edf762387ae07eed055dad89f964ff44991bf608045d2477114d03092ff475e8efdda561ce44970b605169e9f586fd22a24040e0d0768231b2791621459a030df941bb0793a9cf34b093b032253698098776f160c3474c02e6e54fddbff0f7b301cc75c6cf5429c3fc97ba2e3d63ab42cb0c49a75eeb56df596df73dfd6e08a7e33ec769bb5e8d8ba6391eb4ed64c577e59ee5fbc170db89a8febdeb3b5a5895f5bc57460979896750c76e8e2a88370a485e70551d6c4a6f63f3bc89636ecba5db7048de913cd1e618bd400d243b835a61b6d8c24b303fad66fd801b5b4c18465e54979f38bf754557c7f927cb7f8c25560f8e21275b88a5c5917120547aec8d89a4a2f58d0bd9d479b63a1a4ee72dd76c3d660a3f7ae16a5d3dca936bd58ae92843a23afe2440807d0db1833f65895e33f2390779e57eb11d30269ccf32d52af0d8dbac4fae65506129aca6999acb397915d4589d649c5a6c073bec30335437afb218f74f35a1eaee8c07533ed102aefdfd57d8b51037096fa2ce96ca5a337ab52d9d18ba7e8af05b771c901b914d5213a2a72449c2b6c153578da2953d34ce5a46cb0fb2916ebf39f965efb122c85bebe98c9f9f8881fd4a4963da83e6db891abca5d92065fb6fed13f86116277fe4e73f8a822a0a98b7d5d1797c535f628722ff89756a80e8bab9de0a75f86ab928f1feb743fc26f27eb1d0720be482c74518d7d583ebd61f23f2514f6490098dcb8ff9e98126a8323f841c1cd7af00e3ba1655ee1afb03f30fc781449401c8b2e29d4c83f7da65e5427e91432e528d7f01c8e285cbb3684a3139b5f5f64d65502f859629a7f113d1e12cee36a8b6d65471dde8adc05803805e3d9ee7c67b954b506cd1de9f82847c57657c0960f6ff9f32d0f60b3b6ef14b222844e97458349c4bed4be576162364a797fb3778a75e09438b04ca8211c21259da50c30a1f27cd7c0c6f19844e9ad091980d0fc828a4786dc686be44095a062f37dde182ccbdabc0d03f733264868c55ec097e9f0789532bae7606ae21bc4cdd89c75092b375a420445770fddb1c05b3143575d79840dc4e284b3c0a842ef5128c743f6a511f4465bddd6de8f6de3304ae06a7530675274e59f062e0fb1d63e9dc8887c1b9d5d0e6b0934c5d92907d6bee8a4b966cd88593c710e62dae51a5e4a331b436eeec9c0933901a9ef4c7e60472d009d549800fe44115f5afc1d4261d23cfe35b85e3a84df7ba878898c82fd4b4c76fadef5c1876d198f8811262374bef418c0c71781dd6c6f2cc2d71089a76d492b3ae377c70aa562e6ad3c17f88568684cca6052d39e9ac30426d47a82f593664eaac600cd67f73e41fea0242a5f5d9db6ca75a8e4adb1ca74cf78ddb909fff6c87ecd0f12e95b28b7df7de36f047ebaf049e8738ebc1f3f25235e2b2e72f0020a5cb68d11dd83a18b3ad834b98ebf97583211b7da5916edf5e749a4b4f8d3a2f87a6245b67ee1623dd49ff71f2ad52dd1aba798c1adf3f15c6b308b258bfd7434e6015b28399ff78321869a15c0a0c75c691d476e061cef92dc03e8e2fde614854885f94dbe77e0adfae33345322c326c2e1f80ab82b7c08bb7fc956e5606c3578e78367fe526cca0054b0f2b3f29f7bec5635b2c43e637b24469b446dac5879ffeb9bc27d959ac17ffc369fd087b4daacb68a6337bf56dcc5793eb3f80edc0d1f7072321ca2aab123a73987b3d17f466f7518065ce411c9e038d1de0071612e9dec2fb5512f1f874ac82658e754929ac916165598b08ccbdd08e8504bc8ed4ef48bab5a01c4ab53bc4a3104ce53f8a604466af8c58743d9d944093b5ff204995131ab8d104705f2f96f9451e699f2cf582b31b27eab8babb1634567dd61d903cd26a0f64c782eb98d44c40cc2b69750b8657fc518e687fb4f652ea1d76e585e779941ef780158dae6463c310f79a190af31c19a2e675003eb95f9293493165980e46ee603ffbfc9ebade2945cc599e53903093d20d1ea884780858d6f81bd7ba92323377882b4b3e6b76674a4e7ec35e1303fcc899d37b7ff3469d82585613598293d0ee90adc15c6032d7ad65841a4e6f984a665255485d25ab37d038cc61a3f9abd0c7732386d5cf5122dc4dddeb61763a7df44cfb705b8a7b77e528866665ebfb71b724346b454311c03c79350fb39a25955fa8dbb0ea29e03bdd9669f929cceeca21d76ceb65e069fc2da69eff1a90b1c973da9a4c2c5c5086390d27ff6a7a5b0bfc33e62736a8fbe599ba06174376d73d6f79e2c2cb2ee0e2c8e9c33b920aa695ec79bcd630fdbb12a00889b9bae26da3b7183990c9790b0201591a4f6d64fc373d04768ac05b1f4d16ea12e9b5da4a8e44478290a1057d2abb66a8850b580f6c5ee51fd1ffc011fd5b2ef5dc35442a651b31b192cbe0db1272ce6e55d6750e9e2878207092ef5c0d335ed7f2eeb3680f4d6d49084b9017b97e629a5edbd8b1b8789c0bbad08f2b32fc2a9100c13a49ea514ee69585a5ef05698733dabd1c0ce587161a84227eb6b3a7bf8c7ee3f5924402033fa68e50606ef69e8df4901a84d3c81baab884cf7f204ea318ff7fa87e14d275d4b52c9c7745d67fedfe0bcfda1aa3933465b6d202830c479963d778dd9214df586d779a17154757d929a75472a5e10da02c4e1ab8eeb20003a6de81b5a389b17b598c23d2b263659eefb9b1168505318c23c2568fe721f25ecbe3efb2483e17fad8e7f3cf78b42f9ab5e658f6a744b1f626158ba4714f875895e00b2ad0d24461883c0a030ea32053e82220d758df67b1a001ae408f86766d507fbcf5ea7281f5c4808e0f7b31a083b6d830fb576bda49051cac741727f79e973d4c90645bb889fe244c9bbbb92a3c008ae9c921a0cba633af350a558270bd383fdc572d72611af10782114f70968bf14407f248fdbf9f541f0ebb001c27aac8b6bacb5a30472ed20b93def7ef6a17835e8d9e687f7ba6037744789000f63ecdd52fc51122f20a06cdd1a687800eec5c425faf18587f60a69ff66962596f0b213b118424da3dcc3cbdfc01966bfe265a7a4b672902eb69d4f0442d02e7b6ffa47ed1377f94041607741de5c9aae07cd4eaab3a9b1141c800a08281db75a467d0c63a4662dd0cacd6066ac51d410b84b4c5abae7dac51f13a3f9baf40e895f4c5967b0dbc4185e58b21c1b4aa5bf20d2d48d2972155577ccadf2addf08fa97de3c234191b55acc3dca237d69f2bc1f38ad89a1a9ada56c8b5b88aa8f7bd86ccb9557fe4d3b0dee47e9ac1f6517a48a4f9ebc837f2482bf5c6bb737f7a8ca4e0523f121f671f3d46ee4efc3b0e80fd63e6e6602c776ab3f6b7d09c01fb56dcb2830ebf0fedd99dc78478726de41187840b8e3e7ef24f1630207889778e1d4a839f3a315ab41a120e8903fc10b16c09cd17fba2d739b0ab4dece98dfcfc17feb3eeea9faa01269a8843705216b80e6ec6e250eaf7a30fc609046d5a8156debc3ba5ba7392c37385afa33685ce3d3c5a5aab6daeb790748877733fd72f22375d97083e1ac954a7b210d6cfc1aedf5c8058256eb0c2af5c26ed8461f67afb434d1a3697661866b4a586473fb4009abd97ebfd8002a196038df0de4e205108b09d352137e7d1641bbd66336f3a427173cca835ad456ed654791fde7677e215b74510d4cff5c752620478d00db2bc9e159526d09400380fe3aa04ce47329f57262d413121f568d0e79ca6385594f2b1979974bc876d6eeb4d4acc1aa5a093b6e47c4b8f992cd50555b6a6837efda0cfeeac90ac20905801f8e6bea797bb0b4bc9aa6182fb36238814c93926944dc66883a4557c190e91382874a24c48b3ac28f74076e28c921b2c923fc60f24900287613dda9dbc35fa10d30df3d6988f1df734056bb2954dca060ee7464e8285d22cd1c786b7ad6bfbd3bdafc5e33bad3bb9f73aea103e75162d1ed9ed44b8f4a40bf4c293ea75f3dc76b90c6b5b1860975a2d8728ef8509b249515a99377adbf66dd09e8579be292162670dabccdc9fbf5f6dccc5d9efe825cfb4ab74ca8e0ac41a0db5f6803deb609f75cdb918fbf21628841e1f1f0e46d2e33b4a10f0027e171625b267c3170cafa60738d6b24430fabea1cd5a29625163a6feefba0867706f759e8475b47837701292ca47a7ea472a00bc47fd69149b005986f3bc1d4a9193edb6ae41f34c6f33fe36c726b2d739b1b897ee4a4f723cd7819d498192583217638f749c65d313fc6f4dc0d7005dc0d1c0fec7e5268abeb5b9ba53a7472b780f67aa40fa98d9cab500b717b2ea6e81607d231ed92c9ca60353616e16e4c85fd946204cf3fe19c722e3b75f3d58af5bf3d992ba4999957c5121e97a460a93460244f6d091312fdd8c86bbad2b9f8c8cd2144ac92dc2a49aa10a11db0407e27c042e38a5f1abb29d2e82afaaed71370c185b6cdd44e469581deaf15112f995fe1b07791fc8a8bb33d9a64674b4f325b3805beeaf195480530a3c5c485008327b8c2f4a047d47a932cce84e9fa276132fcd6d1bd039a6ff01e9bf5c049066050d3cfa3af8aecc05a32ae7ce0b8fc067fce2f44d50225f1a106e21f5d5f1f7fb5db55dc45b2a88def391455c9cda9e4d6d99640a9da9231e53e31431ee0ce124227849de3da7a2f448f920c1bbc37cc5fa0cbc2049e19fd4a2892fc472459065cea4898697ee1ed77cecea21a8bb2eb2b0cea59d686ba5d1549d5d98788eeaa188003df4695241f8824a8c1e34a01a2ab0a3d73a676a0fc8312dab8bcbf44412d765ec0b73aaee923c70c183339cd0c74bf8f57c961f797e4ac305a9d4421329077ef16b33fd3edf2946ea067212bcd62c726bf12d0e249236c77daf789b4d577ba3e41f1f5d73913ef29c731789c199fcb5d437ac8c628813554679ae827abcead51dd98245e8d32fd1883079c782187fe05ad4216aae584492a1ef312fb2e7f48073102d9034bc28d5ab16670ebd9f43c0f912154d5e98ab8e1cdf37dff9f1a7b5c2d1d5f27fa6033aefbfca3dd2a5d5463d7aa2ff4167bf007f5ab2ac1a47499ae4e89aae4ff9db12a5207916445d2fd73ca034e4318fbab70cc17665aefed08c33ed78d0c29c3d96313398d3ff43b28550716cc6a2b11b46d02d25e917707a049a706f5bfca6f02886f764ba7bbcc349c638476c42a377ce006a4d2800518e4fbf9688b296a6acc4923b7ce3f7bbd09277857145cc7748f0a5b2343602e4df4c54c8211cd22d41b797ad834ac6d7c451034bc4d9a9e30224fdb71e635d5622ff33aedb7e05b6b66c003cf9838313487025c8704e90d71bdf4cf1f6dc0bd831df23cdefb7ee5e03e6f1009a2acddaa58cfeb83d4429d35fbab8f721d14a06c34fa7b1e46d7d2683316e3ad82cb053f70c5d3cf027b196d1f9c8982867091723f7bb47d2f14b70743167f4dce3c8afb9b1b5fc30b3943e5378a164cc62f2ecac87c91d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
