<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a93d5591a2d035ed11592a103af26e5135f55db5e1a348c555d3cafe1350ae255b8f0ed39b2efc2262207085413332ecf084d99e844228f5c98396faf67a53297c9bce1cb10aadb4913157584cb1710249555e4ab91d250744f72b9ccb8fc7638298581b408a09742c5c940b6bb7fff794c6e0309acafc1efcd6f414f0c74d85cea7f897a4930c5a8183e443d6b67a95fa8b0a5f4a385b9a39823505b5983b671952e0b4f471dab93e1a50100d31a4dc86f685206d1c0af25e7352773d58c6bbba41c8103486954d0fa6952c39018bb948705d2ba31f6b131d1ce7110a3ca52b8246c6c70a8ce58c96bad085421de537d09f1cbf9d330ec6a2c72b25148ec3e1828c8b11200a5804aa52291c346b165356c71408887250113f5293db5f104acd79829a2079cb87d1951cc1afb61a79dfd8152253f776d6930de5e7a34b68ce8a52e5ba6a9beb49fa51cb5d5cec3c18ca8bf8b898762c759fa41754ad179c6f733d11e7e74d220f4cf803c5d87917a4bb6b3d0b37c60aa4c7009a59bf2b9eb1d66b022e7c2c0c25a49a7ebcb6c7dfb874553b2fc48b3ee3ebe6be2e2732bf3f3d06f7e4c8d0201fb26790e225807f08bf4f00cd8cbeff5f9c52a0d28a2afec8d6730fe5e308fe57a1ae82a1d94579a371766a909d4479ce888dd2098101b946caa16d2a95148b47cd4ff83dfb5d19c0f7c22b87e0ed4cb9eccd6870f640e3ff450372b5a6ed4b5488487c17cbb64b261200919c8a0c59bbc6fd6811631c88c18e6dea2703f5eec1632b594c3f980ee491b92137a5730a5bc804ed2a5e4750a6c060dc49a6bc960dd9502c937d459ee1bc8d1ece084facf9a8350c4bc90eb6a2a0441fdc00a2fab05296853ad6aa8c1c9b5483b07cff74e6e389c0dc0084e5ffd2b7399ea2a0b2e42e4950667103c551be14e1d5dfcfaed3fdb6fc188c30e7cc2493ad480bb87935b8e0ff73fd00c14762614e57b046f875f2019c02a524db9a4dbf373355716522932788db762628a8130bb0ab9f4250b64870d310649cea6e64bb42774202fe345905a6400e6e7564b5faebd93532ef66bee0b12e3b64fb99573ea9dfe1d472b0113ca3222a969c5fbb3c7d119554a538d3e702d4e196d311778fd84a689fc6850a86a3922bb7eda88b14e375341172e04571d63fee944fb52b047625570890f1dad7b9eb9cf6b4e14bc3d8141dbcd84f1f173cae963235167cba37d107dc7fdc05957c96a40137c5d080210546c4e38cfcd5e3a1b2048aaf1ef4b411a05d1a06d62d65337bc550f8b106576df844650e4864bac59e3ee2f1be53510ef626d3965b5887d497453ce7449d24c45d1fa52059d427dcf589726782ad2687f778ed4cbd12e6921bcdc0fe3a371fc274cda07e669e66a49c2bf9837256fdd904f51ec7ea0ee3514c6b2cf4a203638d8d0c5b92e88ee5e8ffdaf23aa54d6846ddcb31e2302427ea93aba2f9393c2d0f921995e073e333a6ac78c72126b3b57208f6d3a6b80ec4abcab93cd5c7de99eb3ba5a053d2217a4b139b0f2254a88ba02c7dfdd14057a43c1c3389b90038b624aad52eed7beee14f23d63aea880d22215c669d1ff9d69e6a95ed432c925cafed369e9cd49982de6f748079aa157914294d44f70956d3d7667939f8b7ac9d8a29cfa900b78edc794969234832f96bbb7c60fff5281ad0687bce3585ea2fe9efa47752dc8f13f5d4d44d6aa34f6934e3d1467ce559aa47a49af856cddd53c63a00773a5abec30c8a5b8a0764786cc5f4257b2ae6fb84f333bc671ae52e93a9cb25724bc8d278a9cb38bc2682f0a9b1ed212b0fafedf4ba227b58c29383d92a01400643e97060f0938b83abb7a479a37190f3e1c411a1ec24262923071cf16d8bd91d1235c3ce5b2a8771ddb55d89c91f63e0591680221b80390e65749d765679fb4819251eeb3c2c922ed6551636923bbc8c08efc8a4696059dc67e9c1e810dcd8fd374df567b06b050d41499357e0be8098bb6f71d43fcbfb1ea59995390ae4dc62c644cf39a8101c50399b94e5dcc08ffe147b06a1989be110fb18067dbb5aaa29e9730ff198c5989a4863bffc57f852b449da6409ebe7705899f9c3ab2a96d4e2058967e08c1ef9bd931ac5929ab58d14a424dd76ce30be82987e1920aae56d287211ece34dcaba75286cd63e737f28fbbdf3402c6a55c0eec6729dd15b82949556207492fedd23034a1ea03b3f9c1380d026e76ce5596d39426a1177b47584a28178c1e494b54817649dea7dac31d7046082081edf48a829c412c8e8879f92331857f596ca205165008e23357b30827ae244ac6d25f056c854a75ddd46f391c52ebc940a0dd9455203293328b4be76f917e1accf619c898d74623dd3312b78a70346d00fada857f1266ab735b027759d62aa108ed8a92ce089fd13c4b207b8a0d255c08d19489dd303835b80dd4247e5a0ca7b5c6a3453762bf1e4b12d729e504bb823e55e3e6b62931dfb6b447b05180e9123bfb356c9524aebf8d444251b65fbf6d0ac04f39c9f9284a828b39c50da54866f2e3eabcc95ed0aa71b793d9c4e5af5cc6db9ed5e6e4a2245db1c4ebb42c4e844d81c2869f9cf12b6022392b3d3e82dde7e38f446bf2ada02f83e65225180f0c693385ee38b38aae3596f346df230fddb3e14ebc77debd43440c4c7fa9fcf098252c827b70224c264cd733f38b6de7bcbc3382f0331fa194d774cac272d7fe263e39a5602a034e949c6a7a30582ff1aaadc1dab69ed94d6b39ac1cd74b82c9976cc2d07eca4b14f238127339fd05d1829e5c1399239ebd6ad5846884f1fd7cd5909fc46df9965407aa1d69aeda60e049e625a37ed2078cde2fec3b8ecd998fba0678747398b24436b4c5f4965945d0c925e7a1d76efebc9c4348573016b975d7c33ae35f8c50007f1b419fbf02fbbab1dd15988c2df0cce6d0d7c3ca5da8afa0c0d7d54d0e17b765131680a3eb8962a4d93fb86d99046bf1932eed9c68ea36bb0c2bf4b2849f7c7f7e604cedbb157f2004d92b798991acb05fd3b2807bc3159f25a7d2889d8bacd92b88bd4e36723157cdb5ebcbd145d4c110bb632910b7cab1d440e777ee2011ae0da5edfb666471de78a115e81607d2fed66b42f983e4d1a2926b7ae6106078414b2cf5e0dc26b0b1bd244285d7b7343b377cc8b7e025c6e0e905736ecb08c53c629b84567da0b4cfdf5426585d26f60bdfc8cd43b880488158294da9c9985b3e4eb7d71cb527ae3d47587bc283a168e0f9ae4a01b46418522115f2e751a7d784fdd193307f9bb00dc1fbcdd9faee4a2caf940a4de8813d5a7342521b1bda91b0f877122f645926be2702901faaaa2202d87433a74c1931f637d1e5330c81d947f8a9f87c265d1047c26bd8482e3415689dab99a65a22848823410e832216780a1404839c60fdda451ef10c78b08fae3c9def82a514b0da9eef996681f2e9c80203efd47665fdc6e04cb36f3667efab8c6a39dd1f377721cfb136922544ebe15b9cc8fd11771feedbbbf136f3f59c6877ed6406e0e1e3a112e11aaf36c67a1ca9c2a6cf2d87b275677b25a5ffa41d75757992206413bd22b108d9f27865511675332b471ea910dea158b7c19b4aee69e8c5b18d0493e9f1ae7c5ee54045980600e9d1bddfa3df55b0951ff72c0fb1aef76d510e0a3c823c3346f08354ed8c2188669fc43524841fab8c18bdfadec21a2d20649f9943bd0595ad5f1ed9896d234de5cb2adcdc94aee00e53b8c08ba65dc0817409e426bb65753eef55d219b34aec9dc5b1366154b68ea46d2d74448aa6ff0a5293e0c5c6c085a50069f02249ddd8caddc13d34f57b867f984cbccfe1bf7ff713817530057c669f44a0861ab5d338fb40ed5d00515f1c58ae64db4bfabf1486a631bfa0f03e4bef904cbc194e6af9ba99853dd1eec0340c162e4b78cf04b95def7990061b8592fe6a015b51fae8298cce418b29df109f2d9f3146779e956342a649ec33e66c5b37cd520db4a0a4f500d120288d3698b457d0f01603865bf09fb26931c5a30d31f45a6eec8e52d860a95184bf4317d0a6b12255f80739646de751e5745e953e3cec0ff1fa42c20e4a37779af3808e9ca5b1f6af7b43de47d72e3ffddefc7f486628f271e941211b8295fb2cf2c38764b17026b06bb28f8b2eb91182ec7011972d1e9e1b62eea40541630ffe7709b9552c2b063d7aecd28ece2fa593247baf9627af426feb668bd59a83845e772aa216b1aa266e08e5dbc04e1cef8ddae860283494f8837065037a1e0c956fc2bd8ca33a9c5ae62e90ad51c6969a3a89bd222d55713e56d1791dadbbc57581c9e617205bb7f8f3b11d3f9043e976ad4695027c339bb0650b76d8d864891c5fa1b4385483dc517a10d8f8cf5d699e56f89803c72e08d01d5f4fa67908348c419a7fdd1be3822a3854ceaa7e757b4c9a7f03c931774236f7d7c1897127a62b2ac9633ef53da38a1a835ed872d1742fb4cebd84d4a388f94069e51d57f4ec7fb6fa8911342417b5b8109011a3f48b950aa352d14ea0567af3214e8965eb277f2df00497dfc1ee56271e78a2e28bd210146e404c088b112e8015de04e6080cb6a499047abfcfdf06cb8bd67924cc0fd42bb35a396d7548f2caa5edb21216f9da485a4e2596170c37ef88d09ffaa9130c3189db3265f9d0d716bd139fd7f9a9a2cc942fe7b9a3b961ff804bc14f5d98e00559ea1ad88c4c441c77bbe18d8c78ab21c696f6dfaf353a0a4d4163efc69c39769b045bea6d032329def72a8769dd5db86795279ca3f50779609fb391b9ccd285411f060599e0d03596cf9065198da086445cb062d3a148f61b2b1077ece40985e726b7d3640df3a09a5fbd9205a2484f1186a5a6d0eaccf163451baf5dd8a23700b60484951e3f3cde37c15f69cbe92b5c5b0a2c092f846745253ad7676779f0616c0518fbf553099c0aaf8bedc0a7a879d5908db647a961e3898510fd2747169921f375350b86eeb68bd5083c1db98d96c88a228cc69d172b31e628db4ddaee47cd78a2d4a89e600f6b5b17a8603bf320b08c773ba80a55121331ab959079f2e22562e92c27cd5790c4119421f8b021801b0678e7789d9895550b5fe5ab7208849d50ee230a8d2304e8da7853353a9bb8bde8355372524e021d7e0606588c8e50abb83faf5b279d0bf5c44dd7ff662c6a265c99707870f522956be7fd3407631656c3ad88b2a0d0689759da76b95b633bac5a11f6881823fdaa1362875cc0b31573d083e49f491096f2f225018702490365391179d42abec0c6260180ec4f04af65a271dee46732b4ebd23893f31f051f2d78ee0d97c0627ca60de44b4c007c160f7eef96c88046b2c521829004fbf3380d64df308b963737c9db3479f5c973e82e7d5a274dbc13319f4d7bc57b11e170aad7826c478974d604806f09b247166a5b704b7ef29be79702408c3472697456a96da1e59ef08700c18f046d38afb01c2d77fcd55e35cd259de6ca5fe34df405903a79609377a165a5f780660f864fa2820905000b2c495bfe996959d8d9e2170adc734be0a92556931a220381ab3d28dc8d141efb8c9c5ba4ff4ef3c53651688d1aab80c5eb4cf3a270b516498725f2db532f9903c98b0bf10f0b10d0bda52fde1f2fee86124b077b38e8fe29b4d362f020a778faefd4eb0e6199cc20f270937e809a118ad3f867d0b0e0bc3694ddddf1b6c5fa4c151833cdcde17dcbfc1d00ad491a9df760f7098655c08fce170c17999cf93362c26ad60f6af578cf8e9b57b5b3c150d072e2c79a63671db56c1b9255c95a740fccf3cac039ff29e65660b7dd72fcf2ddd3e399d28f39c317f0e96649e6869dd3b26da309297083714846d69061d9766ba74b77787acfc09b08908d4deed5c04cd28bb179ed9b43887ca0ae0faabc76e5988c6bf8259f8aae6b60b71cebe228c0b6d294ceafe0b16ac29c57e4912cc2d7bfb9248c90764ee91fde0a04b1ef4bcbf8e878be5383c882f8d4ddefc05802771e612b27fc133279f3a7311729b44171bb7b3f4b9562dcaade0772445a6599a3a7a0c55efd3e065b025e15267db594299816cd854f1d16d613b9052ac9203da586e88d272eb3c0d956374fbd95f1f493e26c0c47df7a9bb576ec6718cf3d36ee518476f42785ca29e0e79c7d1e048107731f8bd9ddcf5bf69a1a2a767aff91948da5fc33f56802abafbacdf80546acc46420937d962c0508d61ff91a3606032125efe26cc18738863a9a8d64c6421a2e9131428966ac1ac912ae55afcef10582ea0a7fdc6ff670c7f49aad84a9b6f89a1411b12aa2c011305af2f32b7de292e7aa5209cca964be7e9abc477742a01d374261216ea563ceede6dafaec8872244032ec9a17b7d19cba7b6aaa0b8468f67e50f511883776a5580c0b14a27ab270a0cb631978ac59d24dd1d417f78fa528888caf68615606a294d197b24fcdc31a36345cd1271f2dfe7a1b61b2cc55ca63ac722f6b72718d4965f42b165e83d2435ca9f5b6eb00f679f8f4b644fa6c310a85d3def01d9f908c585fe209f423bc4483c5651e73e422d0a49923769639a15fd7b4363f0d58b795800e813d3c52205fa956e30226dfbb2d041f8e3b6214cffb13f1438126304dfae6cfe87a6a332c91404d2296e10cc27b492fe53cf763a6cd8d382d7c7e75f7974568c1811ed2f1668df0f8b9a2ca23c7fd23ff6bc165f1808734babef0de2f1982b964c34f4ececf8a3dcd5ec9159310aeb0a2a38e1785e8e9d083d9a9a20259dea23b60ff19a3b25581fba337fa3e788eb2d7176ad55b0cc1d9212992ca54e81b49b1a38b1867822764f5df827ada7d3fad219415d4bde058fb448a9669f1144723e3695c97d2adc5450c1416edb93e986e5428c5dd23dd31b3e1dd284b1bafd801e845bc7f742565d3d2fbbd5317e2375935c10c942bf818dcbf9e2e09702dc7a9d34ab16a1eef980fdcb2f8cf8946d6b2547c38e27dd2e41e906197a19af1a73ee1d262163972370970bd2f1164e42022cb5b03fa95213790737ee807be975296ff384adeb6149c7fd134370fab8ef477a37189fe24bac3024237b37c60e1627a2db132b7fd27e8088b91168cb7ea70e57df3240852bd42d44c26c11f30c553f9e3d03369d687f01484cba3c5ff52490f942271e22eb5a0b7ccc4de0bef6a486a22ea21935a753f86a1bbaba53d3d392d26f61ce8692518267bd9202dec03eb68b89d422e086f252dcda048e50e508ed0c22209c1f6f6122ee5a00a5b57602b47ba6a98c0b30ac12a3c7493dba12043b415a2ba99da2ff293d1497fccb653edef7d3ce2db1fa288649d7881be088b89b5a1296f224b5af307adf5a023db739dcb2225f6dc082e6f2f3e3c2ba2fa3bfceccd6d2f6753cf977a65baf896e56824c271383fa04d2b07694e158320ccbbcbfe25061b2630dce7dfff82e41e6af2eb228d100e16b181daa5fa8bf0dc5a1978e2326f71a42f16790b12b89e8c560cbe026da85db5711493d9718172028bb97793054f0947a88847d132a37d36fe6faf68600bfc32fc3c2ee439f303602ae236bbd82102f2377719ae146e2a5d435fd67dac2107d8b0f02585c9ad8347ebe548843856f7f939df8055b7d841b646861acbef94701382394b9284aedb125933c3de538954bbbba0c1642c29db889c03be22475a7564acbf202c9e9e66102907923e1d50a3b48b8106e13229141a6bf0435628335faea67865829416ae32e3c2a160e2b648497c31e94bbc201502cd5fdcd3ef8ecb6d1da91a3d0ba32b77309210dbe264fd55ad5cd8a39e6bc5ddc35b3b62ed9354e9c668294e695d3da588834bee8d99bedb339853e538bcfa354aa037a139339ccc70f6a921e8c93402e0fc7d17f20a02199c16f6fc51c0cf01c76dac3d45a8a276e021b57b1fb47a8e2ec47bd497cafe93e94a5134ca7a10cd0e16c4495efca7038bbae8ad05d288cc336e2160d2074d5ebc4f06a71e79657b08bf4802b0e8a4839e49a378fe2d73ca8bfda67055e62eff10fb649b9b516f65b77b82a63c325575cd73350c22ec4a2a25f6e5f5d0eb7d10876b8801fa4b56a07de18d3be9905407c3114a5411b4d46c24527665f202c51d68594dcf83b7e5aa813ab99feb9acd53e31e1df43b6dff61cd1bbcdbf0354ffe27c5d2e62cdc4bd033f35b87fab9aa743372fb4c64f773e5c3f349e903c5d0347e975ca115606ccd296301be5a29947d1c2afadd6b26c21e938f8338185f8821c675667995994e85258c7963d2150da3a8907fa0fdc562dbf5e9e35a8485330eaf3e72c235377e3764af24126b24fbf4f5adf04633b198f5faa107f4364f16a03dcc02adec12b5ebf8dea76b0d60b725914720e8f0db4bf690bbcb74b68884630c17e6f648f7b52cc4b6208b83cbf9d229515ede05f7b90d0a443fe1ccfeff190135a82bc35e0243c170a8e03956a105df98b464ebef3bf3d75fc2c3d0e3292cc1d0f7e87392c04062882bab9488fda241d0451e484221dc9d49c4e03a5ff146a1b16c66cfe21afeedae0748fcffd7f21d1d9bbb890af8539578141655cf98c6b7f56f6f86c94412c06f84e2105da15c255c578a69b128045f6bd48c2f0ab42cdc3289daf9d22b217f8ce7ee28a0d7b42d910c0e4db4a7bbdd11f16d26dc507b6aa169acb13a544334e430a94ccb95e9dec3f8ea6bd0213e9ad2df27537a7cca9019adc68dcba08305c54a39fb5d6d85e8a5bd86740b46eb7103a91b7a1e258bc30b8f6724bdbd6c82a7f47c1743d6ae81fd555f2da58d03c0ef85d097c0b5b1333f4d04c7ba82bb01214b95fc9441f57edf68fdc8417e9927ab8ff1ea9bed68ecbe284cb525489809e98900f8d7fe3e3310b98e7bae9a750e279db1c0f886616511b75b684d0f3055f8f86c5f80fca0f5b66dfdf9c1791f5458bb2bc2d7b09c600ef2781c60792641aaa0a96c48dd373510152cd0c3041b1dcc3339e3f4149b8e663dfc2d30eb69965c230c5884bbf398bbbb5091ee7cc772bfdcd56247da7262dfd841f0da0b7c358e338f96a33284b48858d46bd340e541712ab4e72075b58abc1404ec13e3019f3643ae5d56af74a5ff493144cb04c69f9cf91496ec69a91802a0a3701607e18a6ff439263d430333312f3ca250096bdf8a9357bbda0075cb46768c278693e49713c34ea613a995442f58b8a44331a232e9654bda6a3892cde7d8c93ea160ec88eb4232771f9906dfa13b32804bee6f24057dc6060a886d52971f5e9f5e8fd8712189dc6cd4a8ef12b0cf2d028b831f8572b9c5d8a1224f9bef4e883d0c55d47c8d2a2e21dc93dc0c0c1eef4d269f512912f09ba5575d4685d8e0243bcdbcd9beee7aaff802e15871fb0b014b05c230a594746f9bf8ba6745625c497e05a783fbfd7302c747f16af9fc83feba6bc4ce9958d37cefa67ec2b89dc204c67d53838d90c5a61c8a964dd86bab51e0838bc18a07679e526a73a049d23e1a2852aa81696a8c9efa51c5ad5d977eebc9ef5ddf33f57574b68acb5aff7d1b8428e6bd410fb713f443f7f5fc745e307415ca303c8c2727517ad063dfabe38c61434989fa5867d5353fc4a0b7f85385fe4d8ec4743ca97433177998335229626fb75fe7852fc80db9b6ad5f33baa93a740d1665c7362a7af969ce9013772b58e62459b686f7d9775a23b32529291e06a9f44bf96ca3d50ffbee56777f09539f5fa7df463c47032cb33d786f2c39686771dd24c54a24293621cc7898e2a41c5fca92eb0c19aafba01ff6eb1db31b06722883a31627e9bf2208f653088bc10de69dc78d27150fb570469f181d04c76d59f6f8d78d9926b55b285d528aac4a6f19dbb4a31ef19b1aad0d077e7938fd125fd932b764125f5b4dae8adf07820125eae2e2a6f1ba05a7b1fcd0f9f2a51deff48ab669f2807d162d858640ab2d937bc12304da2a49648392541bbb4026072da811adf54b87776cda9955f7767d7c36799952d3bf7dcea4a67ad056716a14e94b1faa47c79643a558d0ecf31f3c033d79eb68dc93f0a0b6373","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
