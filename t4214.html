<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91810b7c4c793b845fece797f9f353d3147960a98dacaf977716d5d5b8417931992f4e87b0a0a876b0ecd610cb43c7a0b6419921f67f6c06f680270b13d2056673cebe614a88f445d8f359fd3d33cbfcc665215a48536f18c77757c1c7000bfdb28bd422e86f255630a59c4015525edc82147b18b3530c2ccba3d96b07ccced3375f8f5691747e90000a8fc8071a2b1083d6c041f23e8dee300826ac131e32f5a65039948e92087cb3a4b0713bfd40c833aacfb250040382681688ea56adf5fb01085835dcc7511a8e4700765743cb4b8165b52e0506125f7392f60d1b0351cedd3fa755082a8435adb9981abcafbe3cc6b4e2c90d02666cf1504dec187d7a1e39b90ecab8d2867ee4db2025799704e807e3d85ac85115f2a4c97f0821fa731083cb1dc525d0734c9d8ece5a8084fee3da045ecd6be9ee6d9c27ac09d3bcd80ea20690757fc50896a25f631b075410a0c776cd74d572ece40ca11c9a67680811e436aec16e481e63c41d5a2af39a26b6eba49949dfa865a16479bebe9b7755ead19a2b485ae9d9eb3192b56fc691e2eace02df8362bd8585e917b3995be8408a42f64e41cd6e4c3820becaa4374f62c43a6df5af9d1de1e1eea24e577123af34dd493e8a7afcb75280667f36fab6d8cac9949f8573887dfb47a4ff206099f0761f1c71682a956c554287f70597fc4cc0125ee322eb960c6b06dbf3de559bddb3b6222718f213afae982590f5e4085bb96dcb84a359ebefb7f4010606fe758b13e587a5e9e7927f93a014a3b8544d37d25f4ab936b83299949b54a00b8e7861e7434f7181153f8946df532e4c279b4a07211cc87ac1bc0f189ac4d6e66e55b7101207ad53495fed714c34c39a81d08502101be356725813c4bb48d90c3f3a0496ee7bd6c4cd496ae976b534889be041fb6fcb5d6112113893163dca90c4463d4054afcb0959741a214a8ba9150b69451903689aa14ddb57b65d4cb2f9f45e04eefa47aa8859e9c4627259be2b58aa959d14c43deb4ebb20bc5895d8d6e97a3d2ad2738da7a3dd0e379f1993e764723d87191a7bde74342a6ccf85a65f1222c051523101c47dd08a9649753f8e1d6fb969eec08a3ca63f677bc609821919121b80baa8d60d7c8d850bfa8e5dc13a25b6fda9dad5e937024a69ec22f829f00586770b50249b58e00ea4ba7b4b567d0c407e9b9e76705e3da69f93a926f32305ceb4c71217885eb0b6a1ae9f7a3f2da4eb07b17e875efc51b1c229e2bdc4c87ef787f796a91e4061fc28bde93bb457f7a032ec79aacaf4765c1ff43d8a96c78d476017649dbef2c1f6b3c1c2b45a81445107c3debe9b2de5ab3dc42a2bcb0af0896e2042bed095b70734024192c498fc8cc03fe696a9113fb75a3ce12011097f5e08aa8dd234634ddc76ec04a57d0700fe98d9044f5dc34f74190fe9b6506022891de0254e910facb16a5a3f1f3466707cce425f39879c976ad285fd809b64dec19939d28908d1840f2725d7ed8800240bedef9ad28b2c36e69e0c4ef7c881811586cca82d7922971d22d0a4db8216f8c8a55707806b0b529655a8e158bd4e3677ec6d787704103705090774faf13d6c5dba5380364ca135a7545850b2de621f0da6149db5af18f2f478a4e6648c1783a2df5676bf0780eff5d3885a35890e9e062ee486fb86c6f3e9edf9c0d37b910f60a6385dbcc09af2c4d55d131bd79376c344b938c77333326bea0b005b5437298dcd92fe5fcc142a70d1a129924f4e9d29d9d99f9a70125639df7ceb2c3e6eafc64a64e02f1d1d53b262b38269cb48f1966f13de890ad45b84f2088405351c24eb2ce56272e9040034f5f3515d83acbe1e9e07d9932c15731de17bc5ee852539accb5c3f7ba4a51d6bb59eb1e2572bc9450751ab48696188b3fd70aebe41ea43828f7c7752ba31505c7634789c691b4f597b64c8f5fe69640003d64cbc879c7c2d8051ba5aa9c2bc9230836b1a590fff10bc87225863d8ead91ae42965f975ea087e39a3372dd7afe4756723b5ed03cb906b46e691b110cf0531f5ce6f835b5545921e08fdb07cf0688feab3dd48da3a6c27964bfcc3494b25f54407cd2eadf7fbb18851222de6d64d8c75c37bfaa6ffb18cec4e00f5b1a4833861b36e537e4b72a3ca7cf100a16e6815376288f9880b94faad7c329a83c4774271bfc299aa075842c4b97f019a048b4d204c017116fda6192b8b900fd174680a1490a155a0680c8710c0f8add0a487faa75f099c3989361de0ac8dafd49e8268d1f2d027bafd0760d695c68b82a0783a7b585541ee581cdd87c6be7c11115dbec1983f4f195a17478a1375e54ce5c7f73e74e228485ffbfb6b741bb6c9f810b0765614174056a2972a836ec54d232f1e8358b9fb36cc98de3d71aea3ab593e02e4951ba8167746ef74d42976575b192f186e3fbed7ab6569cbcc51ec34370fc195d0781cfba9921fcb945fbbba4b4dfdd9bcac2239622c52568444918cbceab53e36e0a91f39ae984694de11eb95f70f37cdebaf27a59b2ccb5102bbe5cb0cb8a9ebb504a35bbcc1d5a15f579d60473fb2e49b408656c7c9459bc83040045977a83ea3bc2e8a9c1dd88a0befc31c4820cf04102161cb37886a4982023c33a14c437532a114c4d22eacbe88d090eb5db74c1cefe37b29e57e353b8365c4843bdf362431c1236a33c4eee05de8126b78e3e1425f3ffae7313b4efc4c61d16e4a2422bf8610884ac2dc8f1ebb43bd41c6020cc7dc179c39112c0dd4b8806d01ce10e1d3689d1111aee73bfc38239b9a2da0f13e25597634d02d214dbc48f75ae448bd25a892dcf3bc3adc1fdc92f966ef77fc5e8cac9b4fe4cbd19845c42e0c0148cb90dd97e8f08c582fa7767b2177b0dd9feb242433f159240067808b28226586e9291d04c39ff6a79da57471e6043ce10a8b12165be1a92bd47c521d56603f63bc55422dcb8d8a76aafb68d54edee7e800866a77b17c79ae7a78439f116df4e82caabee2f27d3010a7fe1c1595ce42c3117b10a2cafe8d3db03bc5500258b22eb782594c64bc36e148ddb50e3e6e13b7e4ba3443f21d1374e1ec31b1e0fbbf65c5614f62d8be869b398e0b3cdbf4434cc19cb38edb9a7c3c0c01cc5f45397d81126c4c1fa70c34e87a42c1d9a73e6db801a291f65c1d5bf88419a3807660b0558d1237307d61c2ddae25e2069652559ccb0f18d73b689530cfaa8ca0eeac89dfd4ab07ad9eb95fb8868af66376e7e65bf747fffb3457fd6171fa2f8e5a6d9cf6abbf93b4d4e440ecda159a57b4647c28819ad825018f56e94dbaae248d8278b94b8e8927d129563bf1f2c889e215463d236e6d8933651da773548ff62f0868307cae7f048f5f8b96fd1b6a03cddf9d93d13cdf69b7f702450f380561e92dbb2ee8d564c46c1ac6bd104cb972c5a41a951be307369b6aa90167c66c6264b541eb9c37639207f2341d1cc0f890d889ad9ca482e53c5d3779d7ce50b834e580063bb06503b5977543345515b0d714373d805fe9c4298b64b8e73f6d1c05c1e750ae9c1b1d1ef523f61c3db2c106879e3912340aeb38e65420191d1c119658a8ac3d8519d7152f5fb12fb22db9ea4d813f98bd2768dcf19b92b08df64e7a72ef25cabc9956d73e4c2fb508d61a4566f24fd48691ffdee95ed9868d6a4ceb4733b3dcea3817962cce20252c543f92c2f2a4d13fea93e930b0608eec44bf3072ee12e1a96f893ae2f08f51ec54ce835b24f3fdae242187380a509d53f2c8ca72f2f7d3a282987e1454a99223581ea850415f71c7f3c1bbe89e108ef4cda7012feca5130fdb0cc2a36aea2519afd1e9cfb2a85b2364518833120133db9afd6413170257979e950bf8cf5afa3caf38e6db389d6a09340f76fd2bf9ee576a6aa2ac52182822bfd33e5c874b2ce4816692f6bf53ef357582fe01d316ba242712f69d4666cc662f52a2e125e1b7ad9ccf654bac1a6c8e4d78b540f0d3100b30df96beaf90f08ef24f00a92ae600bc20c1a83aa1020f53208d2f42b2f9f7c3d7cd025aaf3ae4142c55346af5e4603493b3b0209f0d313a3b65d99827328fa238b9548b5a11e4605e3cb2516a01eb0e9ff3de93ab8310fff77381597a772f98306a898fc0197533aab51efd2e4c56dff64314dfc6f6897a21504bb762ab442284c52ad7b02e7f2ff48936d953f66cf4b1a8a49763057ecef990c414dc9844af6f5d5fcfec94e9df772440a6366835b7fc95fcf58ce8320cc0dec7f6d6d18f2971a0d21e5edf2b6f0897e29978484b3546141cd7981807f41bfeae3152253647f31c7f06db8123bbd2c2188806e72586dfb42f02a23aa8a1887136ea78baf65b784ffee73b45d1727e76ad09e8f579a1a1c2b24ae446e26714b1eb3d853fe0ebf6c206dad37e3c95058d8d69dee9a107eaa0b102f57117b95c05eb85db5d49737287541551d021fb59771f2db1dd6f1ed12735c94081b4ea73205f8cea18b6052e1ecae22f466f3b19440ea3417a20bf8d0169caeabf0cbcbf1e0e01ca1a0e08ad41b073c4b454bd43b6dfc9e5b058ae65eb269c78f05ed72d24f2715ee8fbc5f4baafb42ec0f312a82eae51c4d8112177bd4514045bebe3cf90f6111db8f07bd3587bf3745679bd87412108e5930d0f6e2dab2cdb2168358ea5eb55f4e00178a9b934ff495c567e178f10ad2bcf94d093337a977d1a06e7bead9f8559f6ad6b4273dece7d0d009a29624e1606b21078069e3d68c1b48d2d474b6eb6a3461c0dd66ee0458fe4424fe642c6422803334b7e9a0eb48dfd6ef5f511a200d7ac6f5364906fcb1bd014f8955430d2931115e0a0f2c9fb1dc312d87704a597fa91217d2e76d727cdee7510c7f4c842ee6b0d4748f1278d21e484361652329c8e17a2304182ba1614faaeeb9ac85a22903e2315dc2c485fe26bb235ae2a737e7b24f781cdd860ef96e54d3322e862ff7a60280d0cf46bf2f7e6a8fb528ba6cf6455fb0ee42b06b81cc89022b74a2b98791a6988bfb92945e0a7b95620a62091de1d8fa87577350d218ed364851e35fba5ba9be5ae72b356f566154e2c4d4841a8a0859f57cdf335c084aebd8002abb6e279abc7101d319657f35160aa1870455447e47d5218115590a34e0d18f9f4f2d1dfb9e01ccafa79f678320b6a29e70370508bbe1c9d0173790b5cfe9341fea44a8c3408f1bb2f533ba451e674ccf8a53a5d0b5530e972696790e4edf668d4410ca12ee288a7364a08b004be452455934ae15a97825b91ce0cf341cb4c89e1e4700ddfe993d66a71e77a07ecb89a58e507cd16148d3220159c652d7c14e3906d1766e9c363f66355d5a77cbf661efd8147d784c99988296a6aa059fdadcb569e1c765f075917e7ea7e4e63d26d7529fa3aa2919948eafdba2a47c6b953eaf4dac666debfd96a87b995d4730cddc842125795ef8a7db9ce621792cad40fa47857c7fc0e5c8505c4a8d206911c7df9e79dba632e4f00d3944d5af956e30a958a4d3d4182465f26625a1885412acc003457ead0f3601a022608a4f4db16cc175f2c1a4ebb5d840b2c92e760a3c86882d7674f35b9b6a74f32e1705ac07cafc73992262a9f6f9f9a8c8119e38e3380f6b1403e71573e6c6e78e75680c9c18bbd22c1d65258ed19de74c12b25e955ecf6ceff796eefb59391aee338d1fbab0836d4bb03b870db721dae1f21d2580ddb586b0d88e31d038e3b9bd7ce4f13e3050cc2329ff677b0ccbe93417b50ac7c64b9b48289b85a3ab969b424518cc511d3cea8698a41f9f72fc15d3a488592e38c4daceabe3bf03112d77996deba2f0eaab0f4694eca12a326dc0fff52658a62b0ac586012b1fd6365443ce0f91171a9d65d58c544b4b8d002665f9725b8bc6163760e368b83fe2d1b736e7cf2a6f217e4dfabb19783fe9d6696b28237f4a540d2885ce75c9d7db60d1f30bd947ec18a3ca657d0cdc268ea3da484cecbee533f4ce9b95050ce1204b58e5a7579d49bb6ccb8f2cc8f54eebf30a1ce0db2b1a4ef115e136e9e6fb43b6ba671011434da140f7a681607873e967e7142202185abe91dec555c12e1fa1480222e143d2f3f8f7eef2dd44d77ce2e368c9b8e485b301632b68c18d3627b8337b4b335f9c8bf55fb9efd0e67172ca643a5ceb253fa5ba2df4b68f86443be7235a993a6bf17a8d2714c8f75577251ce6904edf5853a9882e0a862c962eacd3ab7a015af03c31d216e48bc259668f2b4c6fc8016da70e4e01036302bcde687003771aa99f489b72c88218ff3d8baaf044dac619ffddc4676f5c429a267b8f411622c5db1137bc9cf0f65b95673333e02462cdf784b04f371cad892630548bdda26931763bacd4afe8428e499ebcb2891c2b71519265f0e68ffb223936c411eae888a2bf3c7358457f999d7448e01f027ab0c1a41537569c7d1abe7297ce32ea52b299a3cab2e17d8c729e763f7384cf3b9804956c3fb05058036942ae7ec23a7fdbab37a2282825a9a24e219435516f1f52ac2adb1f005226cb13e245983d6de3fc87aa8510aad6ae1c672d1b6bc4fe3269334e23111430d40c6d89a6af07e7e9be611daba00f1062e0450bbd3d54a3b8df8f60f13adcc993fe8160f844ad06944e5ea52bcbb0a55227238b58960c5abe166244c1bd94ac5d6f4c589fa715283e8de132fc30c8857840534607e6bd01d6ed1f1e023d198f92da502f3b7fddf58c537eac8d9a09c6a2868220022a5556ad7a7052a0a322151d97a6887c0ae5de5ce1ced411e7811a30a7b1de096388c3b6fc39a1c6eccfdb20e8c8a65a4a6d8fe77b0be777327824f97a9dbc3c42266cb2d9d4b6fda59b3c94097c204d3c6f02f95f36e11a537fdc17a1e46d8a33e17b949c09cf65804e22a16226432d6bfc599a23e5e8ed154832537f4e2071aa6662e57792a874e094529faae8b121b2f0fe2b3968a711d883287cddc0a602020585773737baaec3b3a876c0d4e72df25aea96b82f001004c97f7935bb2095557c8b87e6d0605cc293606400b6213eaf386779fd9cf7adf65376732bbaf4941623917f4157cca896c21a21beb027a31fd3122c9a2dd23c430bbf262c642cf260cebdb9a8e99f25298b8c497f14ac20b416c9989c31fb581f413e707be5c2325a38fe79dfeab0d5dd1d1a98d828043df4dd62c0c687ab401dfc7cdbac6a91c7f1537cc6fd889f3b253fb7d7db654c601e391f65278ada15ccd92cc2ea975d9772b7ea87f5f8370fc1d5345f94d451aea506845bd01ad84d65b2d432ffc0b7c50131d83bfb7ce310a295d11718bd9bac4eb3d0e175c680a81f88b6eee528b4894efdc01ac00d6f33549c6bbb68660892db4f7bf22d056959e01fad86624d889d64a64a45395c4deb22fa52da00149fe94f30154f30fce1f696b1064184a7420587fa303151649cf9cee72efd53bee6411fd3c39c2dcd41ede06b7881f9a5a507c8f9416c5ec16cbbf14e2130fa74fa4fadcac946db46a6d813e72bd14ee6d3a144068b50774ee006af67d66d597538a582b2045f6c4ea6db0a99aa656129b5ed5640aa85cac42695c61266289723e35e00606c55bec50dbba3290695570d9e9e36218f54a3b6c43ef71ea5a47f21cfb34e067467ea8b93902669bcc17062d92eb847a33335abed424205f7499a84138544676a81723ec03b201fd1fce34fe3d4514a728dafe84a48396d5cb51d4ae1fffa754d221e05170dc25415074e2b718ec2d55e8c48b90691aa42180855775c10bd502952fa4814302635e009d20e8827c62e624c8b321304366a12084b762e2c6777ae95d3bf90b90b81876db9e00ce266abee032e4b8c68531dd3d95e1b84efbba62ff0ebe4adb69d9f64d08375f264aa9624ebc7d6f31c8b7809246a79b1e067a344ff9a37ab2596cc3cc0c8bddbab5a5ede4a344a453cbf3f09ff2c29b7af8db798f9aaf2728b2b7aab84998e646cc7493e0d628d2f22f6e27e3937ed1058596dee869ce05134aae4cd6cbdab362cf83514c1b5654603a3594678182022755c07e1fbe375f3407df2691de360f4aa3c413a4590ee3b0777a236abbddf185ed8431ddaf5242fe9e038d831bb746ff670ea799a05acab1e2ec0bd020bc25b5dd833c9c308527bac1fffb6a245d29f293ffd6899886d5499e294e9fbf08a986bacd3d0174f312953f3de6fc34e398687c68d92c214c09d04bd246ff98d08032468a2ac0f2b70b03f7f9b4b0751576f48cc077357ac927279118bd32a9c2c1b14f37c32f8337410b0719cd69cfa19d4d1862f6c79d5154ba7f10e4185157b9dfc29bb09e802e4926e63527a96507f43f6bb3f90056bfae3c7fd049233c54eded11abb2075b25799533d6327cc43b3e8863188d2664173ba01aef62b282eba6d9c5140384885813f40f58a05c36652a0e83e280547f83ebcabf0289d512cb2dee37878846bdef86b69ed90124cdf261563204c75868df137535722099f43cc8a5ab28200b80c39ec62f05f77e8b1b962bbd25c88d710cf90e766e9d2edafeff5940292ace0c8de78238c6217e607cac68255b3fe2109e919f6100a31d7eac2dc0b03b34d829c5e7fed409d45fcafcdcf3f79419aab0daac695ed692b330edc3ed71b7dd1132129f18e857330cbeb11ee12f51ad55d0854eeb06847f58df6e72bc078c60fb2ab1a88888da13927c10b1ea94e9e98d7c1998d740a2ac82befe224440b183f103ab0c892e7feedb4ccadfd71f46eb01dd83f559bf820b2cf52d639f0e7e40fbafcfa31d6d999dc3c915caa286d71aa561e5c6c221db6e9b1b1c32fc73c57b07241829328369673db7eab2004eb23252d78539ecf3ddb01e884c47ef800be8cb7649e2a7d4833af83159c6548e8375370e8d282431183df12fec316efa1d3472b36c9f7f83f97baca7e8436261fd5acf491018855203a94f029deeed524194b5d36832536adb96e6dcd166721790de5dfa36c6c53354f62421c71dcddb2659169e0f451c9beed1b9a2e8e5b5ab61ce9f54fd415354057893c11dc2e3e395971ab5bdb29b2a007a7d7a9edc2c8226150396f25830014d770ba0f7a1773d1a8aa5383ea4c9aabc650064fa82adf4103d8b9f53abeb8f0a4b337887be5a6c0ca4016dafd77f4c0585d1853077c0479de1d74ee447704efa20046373316bc6d4873dcfb2336c25da2328b2795264b1946933373adcee6bb6660f962c4bdf4a1a544380681a43b215d07f8331f63fbf9c0f6426054b5956dcb4b8d8d33a8c90b913e90cd4e748ce66155ec768e05c98766c909653435f3d1bbeb532c57b8ad49ed9bf300daef841ee042a9f6d952cb02f3a3e01ee9f255e60033ce7e57a20a56f87f434be8ad6ad5214f202c0a4e290d9cf628752c89d721ea407162ed8ce4697a6792d3cbed03b92c6053f48e4ac715e3ed0c3f16ee9ea68b5a82819102bf520c5e2f2bb84acbc77a0074da54fd8c879022078f27a0a425d890840695820a40331f563c9a4fe675a57d037345c2fe897c6b3203ffcc706254e2ffb6731b97a0718d43e50055575727b6239563957e5c645ccaa03fb29e1710e5d96ef820d29db88101363cc416a8a0629da4c922f00597d7d75f00f8e9fc05ec240bb4621190dea268349b5f2adca1059722f67635647342866e7994ba0fb6949b7e8933732aacc22902c7c14ff3749b1dfed3220910090461cdbec04c8491d616057340f37d80443a04113d050f8c5fd6c74975057863f77275b38a003a3eed909c479a6cd4d8a95e8d6076c43574ab298fe11bac1cd161c6fadadb3549391e531b9be4158eab24de5d6465464bcfa77b3c7c747ebfdd4eb7dd994f12b7c59b2e84fa33bd825e9f882822c0f58ba66cccd02c457268914a480aed3f24adfd9668ce1c15521c42fb19e65f1089175347ff484670bfae11ff2a16169bd1fb1868edd2a9b23136f68871f5be1d8ce3093a38495c0c25183ad86dbb34d19002644b17c2a06c035353054ae506baf75aa27238c12c1a7ca19050b97fad39fb470c5b65dc4841f921b5b42b28959bc4509676f0ff67f70b5d5c6618b3193750031654cdec2f571003a2a80bb0dcc1dd0fa19bcd7fe51112ad574d5e35a1b7096044b38b1f701f8082f422a1707df307f425d369ad09077b0bb5965b08e1375d7c1b436b547ea9ff82f303b144ebb27cab54f4242222780c04678d634c468367ab0a7fdd5e4cc6166106cdc2fdeeb9cced7f0b4f584bb8b445c976bb3f4f2d5b6fe783867489bf58d47f6122330902f5ac82544e3f9fdce8c90164f6425dd7a00f3a95ea2ebe4f687ea471b6e6ae88763d00c22dcff6a0e5759864b9ff4a7f124833a12321046fcfde2ecb1de8c0705c5b3ea72c1c3158b041c56b24ec0079d7b619cb5196ec8152c77b83be6bf33e636d60e845c7548dd057de385716b886e2932c4be181557681ca3f31f4927910a9260ad0265b4307f14ce901743138ef995e3a9d3a375b6c8e805a2b8dd097c7d0f23cd11eddcb01ee0f99fa8f7eeb0ad4251af454a485fd1d22f771f4101970b0da39d48db260d1e679c32b7f41ca98f24aea1268cd2f030e9c4eb2a76cdc85b36228c17d1958f9af3ada6b02e8972c6a131cf3bf385b957f444a52a3efe351b1a42484bc408afde1b81127b34a13cc2c31994b27609e7fd682bf23b0879fd8b5e3be80ee3910de4fbe8227df7234a81e97faec786e4f33813f6f5619c44e219e9f6c9c96024c16c0e7752e01b9d76ffe480cb464b37270a6693a5cf45edca39f9f47bcc6e8ba9db00744d03926dda92a72b61f7a74ed49cd001494d8c6cb021164295e44a115f0ce4f8ce4e46ad3756f8d6a416f0980462350a4739945bff9e24998947b83b853d331b606f0d2acf6fd64532cad82145bc1db884ea465b2e9fe69f46b810d9210fe56f766d9f2f0486cb1a016570a3957731494b9dd971fda30123f3c7e0479aad2df26f3cbcf6959ef3cbf983b2b541e6b809ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
