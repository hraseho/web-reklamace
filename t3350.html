<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6e78e7147c892a43e9a4b9b92fcc10558387ee370fb93e04047a51574ae4c54d87f68b590c2261f22831af30d062624b6ab37ac20a6d18d3b44e0a4290fe4f425b61049a816f05724548abf392bbc2abbb58f9ee149ee53605c4dc328798bfe9f24c68d833bf0df618337d1a878a7c27c4c18c45b2f55bde03ad1a0f41fa7468fdd8b81f5647a5c66e6933377d0ba37f3ce25cfed6bb7a13dd65fa0987c3d86bb35cbca5f8e220284c4d3fce7a09fa249c124ed058fa7408da42467d742109027b51e970af71c1f2f5df843d9af1b909dfb6f84ce2b28b8090bcaafabf3d5ab7b049f86252bdf88cd5598e0f1793bbf8bb448bbde4c988b890dd4b0631ae050ccfc07e364d1b7d8882b6d15c95bc59a69fa9a974ce3bcf0e7399cbe1d4da39b5bec10892822e10a90b7fb9a819c0fb0b5c6e78fccf7d6a9ed93c8eaf6b0d59372e929f785e7d264c0fa8d5fec6f69717f997894f6b7be84f732cda479f43e47c22ce1e7ff2281a60598d596eab18617a62deef25f3135feabb85ae23bf3189000e0fc3cac4327a01c317971f09daa713068949e0e9dd1e6e4790938af6a6d996db59a109917d31fc31869a83cbd7c1f64dabe037b9772fc9993be37683f8614a225c55f8251c2413767c4fecac99ee9b2be6e32124d7c79a4eff4ce6963d1b17b3e243fe84f71cfe81b9d65d3df41e1072bb9ac9f177f8b1569de46c2ff9142ec9896dd4342ed8f0bab9066f6188899700caf97663000bee002e9df5c4998d16656832ba761e017d668993a1936209f48a2995e84dcc6c8b716aea6cfbd8c6564eef1bc0c9c4a9082fe3f7c585d1a6f3ace063d9102814eec44b1c6a857433a84ab3a6070516e9c0281eb91248ab4298cf5b9217bb0c467c09dd57ee0cb0413eac9a4699ba58e47f8df3ee58673546e905ec00801dd64ab7b01977998c01062baacc657c3338b8b1430d799424d12dc9df0a76a287c7e70fe9cec081e9206b19bb00bfc28410a70a7a0d6c4b1b3c77d534dae7f56880d22c74d0873e020b5d5c782744b2cfbfd59427acf57eaf230fa8ee5c97b38f22aec6151e99639681cdc0315fe1d6df96301539d9148a005a00286021f1642822b160b6e6b2d4e6418fc8cc9b914aa0f1c870682514e3cfb7d0f9ea9ab91facbb8fe908946b03892854af634f2b63ceac3f6e90361a1d7e81e81536bd923fa61a5e1df134908772c4825d017c73e1d53e3452cb17afc01f20024ec787280db09ca162350881937141fc33fd80931d9b8f4accc7d1d40240ba2c54438c0e4415050202929bdb05d8ba585333039b7a35c8421a22f6c78d09985c75c4f8fa1270fd47048f1191c8b03ff390f681f91eb9a83439f45e41c1aab011b8560dc27c5d148787f3340852363e45867e34bebc2506347a8efd7028f20a80f516fd58d659860e2afa14722d012cb313a9013542eb3def27e8e7c8863f110659d87f113a8fb3f73c9a68e168023f2c6debb5c91876d575a79499502c710f87a94d2565a5f141923abc0935dbb013c4acf1e91dd757574a4071c3dcb61896803cbe4c82716e9b45008e5031e52adb5b09a4d5319a6ddd4db5e785aa9069d7de7ef714a24dbb1802039c6690ee92b2cd6a59e231201f5f0eca6f920a132745d6fb50083beb579ab0eda6ea9dec157087bebc3bb449e7f56c03fcf192addbde3b39d75474cd21c5da77b9bd421ea4d54ce1892369fbf04ab1ac0f45092ae3893cae299c3305e5a18b53babd1de7ea5b08d962ef6259b8f14260a103523b7dd154c614540d06ae4aebb7018192fda8553aba2d7cb219e232d839e2cafdd3003c060181ce1ad7d513066f570547e6576946eed5aec995229dfb2410fae1d0bd670354fd814a5f22bd0a232a08f51582db4ea74b536278c49d6de17fedfbd69b0f142a9e99a5c3546fc522a906d2737a565a1ac800a002408470d70bddece4222e9b647e757eb953c1f70179aa861f3924217b576ee9302dfbb0c922dbf077f35551414937b9fd222c935c3aea99a259ce28e75a4975e256bbfc30b20191bbf69db7d00df54c52bdde53d6c89e5682ea79109787d8e1498b234a843572c3debee08e0ae3f7737f6b8b824f504d8bef1bcdd35879182d241515e527b9c5e6185a0b3d6c633f043b1b7359223b214cf6379c008a78d3a3eb9cf7db9da666361161d7a3ca34da7fd9212fc96d7042bcc5e9b1def518fbbb82bcd840cb1052b49667e4f377662fa328652ac75ffc247ad0c6b626d69b94130fae88fd8525a8e457b77a97b9eb79a8273109e4f5b7f05a92ea6b5ff426b930c4ee1b15d966a2a6ed306f1f248ded14edcfb91a31a0e033db53bc7d6ee70fe7ebf96616d5e60b8b8d2f4d126e0cc8dc2f99957fc906c030002429781719e537b382877c6ebbcaf6160540b09dbc15f668401fb995ef6cf17095dde9b1febfff6a34bab91366f2d8bc21d294a1b42d371c5a8cbf472df77d716beb38b0cfe70ddb83da0e31ca885e88d47e49a29caed1d2088310efc60720f6a2057ef094e4f37123e91f3ecaac0866120a85a98b61920b339b149240bf7b06671655d180fdc5984f07740b4b9e30b5ebfcf48c1de86986912c3165e70be9850e1d98eb466e93bc3e1cadad34dd78e9ae083fe10d125687499ba890de958d4788d181ea6cb8f23ae32e2a7a3dfeb0e63af8652ca930ddf3f6bda0b9930d438d6cb074ca977f2c05ba2dcbf548028225145a1e0a760d9929290065cdce58eef0dcee350972bcbbdedd204f9abe322bca5143e2545cc1ec2cb57f736fe2cc1e11e553599078cc1705bd370c174f72bece325d0b3431f061856abe4affa4b0becb67fb4d6525d9dfa7c572318f44782c90f8a66fe6cb31f9f1cb1e14f4514c5712846ea2db2a34ca24ee654a39c9db15d7cfe79442ed74bdd54969648bbf0896beda53a892265e04fffb8bfe0693d33a3708fd90ad4823c58a2958768bdd84ee644a99c1a3a94a41ae006606259b3da50e4d387e06b505de9eedd350c8a3660182d9cd2112330b9786165f62a6e6fd63e0f8d78919b8fc639575e31a413794411b7dea033d7e6aab4df5756fa9f125a1060071b93b00ae7860b68093dbd27042206cf5b0f3d7c4e2df30424b33d89c334f21ec85fe2735036104fbf0cb3d5e394a0cf13ac310f72aea2b7abb27c1b490456143e8babedc29b5a0f231b37b675d5b80c59b64840a6378819182a9660dcac9d4f3414c745904fb579d8067606d014f1bff89568ab606d21b38e7432919acca15224217308d96ef99e29a1d8feb32ccf8f527ad803e0595548fcc91ae6222b7558463932f07297d7867fc0c88a5e0139048e3872967330f4514527fcfdf80ff8a9641ffff76db652e77cdd446696cec0bbfc2727e455dc8a4dd143c01ef0bdb417736b7874ce78ff7c0df06596e1b643074396c0916eec7497edbfe32ed1d33598ce365c6293f897c97494bffb4f2de67392e4e38a1e3c67d868ece1fc496936bb20a3b96c01f9354fe47f65752c5ca69e3f1397d6182f4883082d4f94f0121ca1bd9e24eec7e996a331fe23bb947422077a26c73ea4bb106bb8b3e757af64a1bb647bdcb3c5b1075bd8f69df2b4422118663f2c770c4a480ccf5935fac95d6bf20b5a89da9f76008380e56fe7c0d6f5ab3276b568257db574c147d73ef128328478346ce8e50f740d525f930cbb0378f8f773f326fdbcad76723300d653e46f0f6ebfb591623a658b9c787115f2b83973b0518e85c81e72e1d11dc6882e662415f8f367d65e314eecf2c1dc75d6e04ec2d686fd38c1eaa56d226bf8c416e60509ebeb9044b62884d5cd7e750bc495699c7cb5b3eaaef049df559bcdee43c271996398853d8333817ab3a293d00f0b900ee21190e8afa9db189a99dc9cae8c3eac05f85011593287fbaeced65e756d8b6c5736f4be24caa192c55d15856bdc0431f5bd048b6e59cf5276ad1076c8b1cb132f57223249864d31881893330224a895f5649fd093c9af5c98317fae93ce173daafe14baf18f577bf176c8b6bfc23c4c9c0b3fba1b9016e71461998318dfb9aa8f42413e8c9ac7333780dc5db97c780476f429c36ad6b72650a2cb3124ed5787605e06aabfcfdecc858ef8e0ad362f8c9ce2abbb83f6f21ae8091dc4220ad0e10c7724975bfcf4475b87eb333ce6da7c6262554034c94277f09570813fb9d3ee39e1ff945d86e243fa734df0023773d3125e933ef4fe1b7ec72918ea9c64eb4a943dc61d0acd5b6e699aeaa2d0f3d25999538892a079ef0ee991051bc1e1380b148fd4af137a4b54e7e0e2ae24393268ee4c710e3dc90f696282bc0bfc396e0a2a23587a9c19e158262c96d118e19608378cf04811c1f255b6b05e79749b925953e344a67129c6df9a2b533c3f6f87019cc1b2e54141fb5344d05b9d29208b60663cb17df30f71d13c62d0d2492e8cec23c3f6039211f10abf951e968260a2f8d5b6feff7d14da9ea10fd30637e1e0945532cf09881f0665fd661919ed03d49e6fc860e2c719d69c2313dd48aa8d1b2e93e6318096b179c4ae2f06169f1474c5963da2b4c7b551f92bc110efa3c0270ee2f740c17a4367ed4837dbdae4165c75928ac195a426ed315f1789c1d54cb1165216e97b5a9b4b0c4f4f524e221733c6c40db956e8c27ee87a04ebd0fe0099161c21448d98a18a5cd196f010077fb55a21128d724db33ea9777f9daad9c88be13b945fe3eceb8c0ea8fee7404e1d3d0639ea5822dbae0e8f572906eb84cf5eeceb9b37707c1d04db492bce109e21c023ef6166b9697f6debf304f742071c89720d9f4924116eda68bac24b19531386745f4ac9a12ace7899ae45124b839a3247952dd8e3f0e6e04fe134ae0d99d0133ec8c26e502430cbd9980d8ac49aebdaacd45c8214d784ea016a4009c298ced2790b3ed9097af19c112965de317c54f3efc57fcefb49c7592518b75622e0856caddd22c4150f7e2acbc15c4b5b015e3e9cbec15680d525f250483ea512fd5bf8c87c466226624678d48ce77b53627af6fd45869692a8e6525f0064aef76acb119c178f9ce622b2f7e45dbe471c15f39de70de1e86d13a9c54417568d805bc35ede9afbf351139faf3dc1199ff6b7af205d78df357109bcf2e54b1e9fc3d0cb756ba1e50ac30f353adcf810663d76e55712425c605ca147dccd710c7d589939040c928a1db648ef44ad3df098dfbfd3470a3c944f8878033d6e84cb5fc075c4afadf55a1af36bf31dc98fe51439c33334ec7c6048472859f75ce67e63a729576e7885ce4b902c95280424de3c5c3880f387a26051853f15f02f1c70421b37857ffa9c01abd113886b7ee02afc4aa2a1c35f3456e54509d9b352d484c4e094fbadff20b423f91353a06d811ed9ec71f33227dab48c13b3434832b85c22d028ca3559705bf9d6e87873c42d1f9ce76c3ac10ff1ffa687495061a21b4dd04df15c6f406eacb07192aa806c4fa1ee4edff6cd12bd353136644cf21fa0e3d3fee53361b8dbc813f488fcaedbb469914581dc86583e7219953673a9bc14b71d2f400ddfa9db380d8dfa375264442ff02e0c904be7d2e5af3314db0f44c951697e3d1c01f9d632c690a25f5ccb20470e4cb0375300f2ce8f57ac794c6506aad4558be77a0430e48bda4a9cb17cefcf45f54a2272bc33187d339596b8f5dadc268f528de1604cbd31cf83c83aede2e427b41ce836bfd910b1b9d8653c3d8c35f3e04e1cb3f646fb8fa571de2059bf565985870c614b1cab5936e812b7b48701be77f9582d734e79400e90ac06784a58dbcfdf9c7e3038bd617d6edc0144014937d9216dc97ab0e95d8a6cc01211161bcf16bc112340fa87eded8b4a0115382cffd49d873e0848ad6f1a880682baef008bde9464d7d4030162bfa784b16b4522719e02a73bd5c6d04d47d5598a42061b939e9e7f041e90846e21f59a86e5069e6684ec3dbc14cd54dd2b78e77ea5a41c896226d59f3bb94cd0a6b237fb690aa766d939c03b0ed74008d69f28668c9ecb7211357ca90623058afec46ec31e1843dc58ae6b37abaa1d9ef38ba716c0269e8596d7dff12fe1f2a6bb232f76369a9108cef1423382e7c199db1c5140002e337676049f92af96b28fbc3f5ca0b22f60c7943dbc72836de5936beaf4c031dd2519516d6e430870b4fd9b7d75d37e3acdde5b5091c49304a28cf4c59f9ee778c59ad12686458209e8e46b147a99bda0a51d46d5fdaf991ef28429ff92af82d37b4501a0f24a7a2463cae8355e1474e7ebbdb37332de21a4391720c85b944505d572f87369de0d11491047c2abd6465b3892add81214e6552de17fc00c53eae597900b9dcbd0e07c241c7a5556301458dad79aeb9a40473662bea0d47e95a52aae2b88dca3bab3f0f3db578f3a9ec8e168cccf92a8475a0e58c7c2a55d5778b670a2aed403c230e73d676e3074c5b7693f4352683d45a45b8cd911ac546c42a40734c6fa96b44d07b138d14a5a317872cc2e7be8e9c60bb43c9d514a7c134b21bba72b09827fc70cdfc12fbf095cee6ed4a18b63f28924052bf0f735c17994c1b491d6d31da093b2dd6bf59cb544f0fc060e4df6ed6519b4a24752047f20d826d180549f3b5c1a07d850c233163d4f11758b49cfed50b31e860facc470ddf885081e038e313cf68f6e417ddab9cb1702fc2dee0620e1d4bcfecbc4c341f6cddd6a5d67d248e307b58d6b3af40707879f17b334aeee78b23956260add2ea7d7ae6ea3f60665e7b336ef079888e196eddac92be5ae6b29914635c3edc021dd0d8f9aee8e256c5bbff98c280a829a5448feafc6d40a9f8c49e9099fa08491f01c99a31ed3070034e5bca9a4fba689ddca4cd4da861626b40cc47ccd5fda34d5773cbac86b6a3f6066c69be687d2e9aaa20a42d73b3c9d7774c3206b20a670d052c7cf64596bc1760f232d2876599698506223924b4a6988a5a367b9f6c2a11fb414c538a1c67d03d2b1fdf6dfc52e0f226f13134b260c9f38ad001de76c2a48702f6bbb915c0f74cc4788869d33a0f0e2a15e66fd75d61b82470a8f228deff54ea9ca58dc79be75be36d1275e4ca9f1d08f05caa4461648d4c493ffea9153a9b1d226d148270afc0ed24530b967d8ddc10357dc903a5223aed5c94c0dd7ab1c894524bf4bd35788471133ea28defec76a4d2a80367ddb31aaffd004a45281fb77281f48e58ad7f658188c3389fe70ff8756d85ed1cf325c9cca96de8b6710191321672fcb5ee8297d90ead5f4501895c74ec10f5ca19052133d9c245d510ea0f75624eb5bb4bba61a2855f3a4319ae95041616a5dd0c8a794e6649a7efc4b207045a6909aef093601be47367143b3fc1d41121a457696158d4ee32fef2cc6685cc6ae56508181c1108f2b0cccfc43f0e06214892091faf0731c794348e292d82ed68ad0fbd27a6e8b6f528d9f26a6ad387c59e90afeb2c06e190f8f93fcb8dead6ad8f759f325858df1a9a7df5fc42329b8449471994f5e756e3f7b9d6ee9ad7d0fe43dc2dbe10961bbda9be3afb055c004d0d31d31b278068ca4578356da60c0e738ce4dc9667e4ee16296610b77004b9ee04de5ebdf7296023ab6da32895f8c44f0ffaeac18998fb586da1180a1d13fd8318fbd2847a39dc96ac21d015440ab2d645d303ec6cd064d4c5b5a59154751b5d6053e9825e5b85277eb063a77b0a439198692ca5599ce0f4213f55c7190792831cde373f82d3cff209605d33ed6770fea8496dc2d4e1d8b73527d60e37e8cbbe5a6bf299f6d9ffeeb4632af909c26d5da8aa9e63befa55f04096c0f6b8542da8e1521ca95b8c3df380a7c42a2ca792f4e90d18096a6a79ba47ca10532df77be8dc7809637e23ca3a738ffd0d6a0d7f876c840725014d5df35caa49c51f68c0d40234a14a3bdb36ec36a054cdf3aca8536c0a5a8540d44376a482ed454a7931000ad8d5ccd676193ef65977bb9ea7eab91ed469cc49759cfbe68f2b4a5460aa4f0c5ec4d2f02f268801d080441a2bed6839f1c64b54e3d0767bc560712b69aba0cb35a13043f25fb2aabf4917b7fdf9896a17872cbdaf99e3261d63d410c95013e3938981711f2fd4be95e997a076e998920ce7af9b73524819d71abae420853834906735243bad07be86758c6dbe1909001648d78f5d45896d72d84c49c0d1e54c77b7ca204fbc2251abe0094f6f87d33ec9432046dde2f2ae33aa7c24697cc8cc1d48a1ceb7ca2f750b7767fdd0e4eb9263ed60739c464507256b0eef87e28f4db0e4397f5eaafb2d3c9282c6b907fe5e3108b7b0d5ac8f8f55e4b5f7126639204f2020716ebbe156787724b5e8530e4012c5542180867a054d5e422db3abf5d7ff6a04df3c9457857c46c8d2db5e55e4797029b8b28c6e5491a18d416bed508de9763576cff0e31eb86a7e3981add2a5daa4717c2ae23fb0a41d32c4263d10518dba9a4572c2457b7bbb11305baa19ed496c3b5fb9fc0cbb8c6f0c0b784e71cf4243091fbaec5ff87793b2e3a38e7d3388dab20dac123dfac44e2086bc84793e62626fc927d58d6929bbf51ee4f5b9b380721d72e4cd0eb1d787140176419f474795a049e0decc94942c2c9720d459793167d7b299b557b394a6c0e9c35aae712fc240d4b9809589d5a50df025f5e15a9ef8062d2f5001f2c5e3aea49eb7c194ac31239b2ab29172c7f27b21018e7939a889e0dda1a7a553fe3c6ae97a16db938e08cfa37c3ca2888169b9492ee28daa6d7d4b7de8d9f599d18ee1ccda86c8aa17e1513c1056247d58d3e7c85df6803eb71c8aea82399843591cf46f7c24760509b9f96e73333c15330223e9f804de50dba90d44df5b43040977b135e25db159588208739ee9403e29219f1167cc896d5e019469696c01e1c568a41bbb5dcc81c4a62379aeeff8f41bd0c07728da887e7029631cf67fb9c46d02be54517b2b31c2e355d74803e873079d53607436408e7a8370021879e0f0203df65626f26d1990c15b8bc0be947e31ca2c06684bbfe271cbaac939ba24680b92d9205016b9d542653954de1bc34a6c3083f6d81884bce7f19f026b816138cf61c4c1c5f78f20db9930343c4b51e0d6e090f4cc885986556a109fd2ecef63b59054cbff0650456ff1f25948f484fd172a7ee5d5c9b97cbb8414a5712d3db8348dbeb1816aca7d3e781352df9487046464c21e029582a191216b62ff7456035303f851f7b1edb8601a705e54b123757794d28b76764758ca867708f5bae38a59a491f10b01bbd4eebbc36103a86989dd4111f042109f043df520edd6b8f5959572e4c66e63cf2c71f0ccccb1e9e653db3cd1de251b1b1156bf0973ebbb8d89a9668e8f32fe6d502c240765c65a20ea640b53155ecbebf96291c1b5e59513eb4016c367a396f7ebbdb88ced8c45397fa9e6abb85240930563bc0b8c5f89c3570fcd9e4a4e4cc8d34b03dd31bee7a99439495f97a3cb532e07cdee30057d7f0555e9d80d5396db5bc6ac48dacc6510904c6c253da47be1750639e4f401666fba1ebbaf9d34652689770516d8a05e87c8af6ba87445ceb1c18ba33979d5a4849f530b3343e1e399c6d84e8e84e6a90b15dae0bde37503807e5d3a87fa6326db42bab3d411454da421c4a22817e478b6459c580eedcadeaed0741317038acf7b1582063a3492484d7d867e26e430784e170dcb8b1a1316662d49e791f49ab4e0e190c318d04e0cb3618f7e9037a982537a85bf4687377093cccc3827f4b70d7b65ccad6e47468eb4cfdcdce55735b57cb60118f82554ce949dc85e2d6fe7674cc2b5fada4d508f187e71bded68a5c88f6853e25f51b8c3584d28b33161966d10acddbb4afd7a07932986a7f8caddcc0afbdba3a9670b80284b77aaa38b0b060abe3d67bc58c4ad19ae7ebc1ca50fa47d927ccb5d4695f6120e8a0996ce9701143aea4cc764fd10e23df30b94115815182e1e99d231547a004a9d8426ba0b6da31f292041a6ee532d88cab0e397941dbe5e4c8634f2282db50a1f6084f2b23518757b926a8b2c76f39b945fe7357362ee0e6b7884c4d0b1ee92bb96eab20dc41c403d0148fe651f491e4b4991d81da3f7616f31715463563c7650a096e520bb06b44c2c1a34253d19c46437c02a4f7e128152a6337fcc3e78be15b9f507b5e7ec7e167fa3a8eb499338edba5f4e80ce0a1416eb08661179757a785251ae6efa750d67fcb8ff665f6a5128f4b34135bbd2fcf13f53d283b2564782ce061cc993a64e25a46d777a7e0a5bb05bcf0479303d3f75206349c539e62803b30c1af025d65d82ce915a4517781a0d86f8a61b6cf1d0f594792218f2d66ef799d5f19dbbf40b25f6df1ece2b7d54aa1fa7fac61ff594ff25eac6b56df2292a70753db4bd918db378b8c4037e7e60205f9cde950f875128603f38e44b37dde6f54caa9d944421755fbb371d04ac828bb47ff90b8dbd073f48160e199e30b6318164e96fa665619f32684eed5e6b0fedb38eb12b3f7bae2edc3c07cc94e0a0b2f60f2626178d5887663456e862c3df660299080f25b12785cc6d74616d4071f0c990dcac3a31f32d7cba937688befdbae6786139c4f03029bd4d123ea2ec4a8eeaf43d8dc73ca9491ce8e40b958bd89fc53560bc89dd9c61b2b688657389084449440a34b8f891fcbec0c1a87d324e79cb36d3e9959cbd9e5b123a6d561331fafb79ecd0f14fab654ad80d18d8f868af5b7d7ce4eabd402d555ab31a536a79c1ff715806193866ac943d0ca88c7ca6ace44ab88f4d98a7e666f22a0ec9b09cf8de395070aa625fe6c9fccee34a1b601834186c2058f307dbac7cc4c1b21dc7224d41f5029a96de8ba95990ee020e7ee695df3b63988ab3d44114a013bdc800dfa0a070df1c297423939a481413469f612acf13147ec8d90f1fe791a4e4835d7540dde97c0c2bfb45c0c3fa5dab26f5371adc32c5d7138131687087f33e4303beb0825a3bbc94dd98219977507728c4671f42b7c4d8a9ad6165355584fcc018797685c6af78dc9abae88a5d55a7cc63979c05dd64f84daef6cd078dc58d96d77b25521a827476146ac921b4db9e272a391f3dccb0985e80b505b989fc20a42d4b19f0be39f4237817c1c2ed1dcf2ae38201d570ceaae9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
