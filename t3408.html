<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9040ba826252bc938f60f5b509f1dd24955826ad53c69dc9e35dea456ef8cad1f134e3ec14cf8344e99385762126886a8dfed36d1135aed1b4fb19be656e607bafb4ab6ca5f65e5aca8b3db54e739fb26370279e9fef91d886b20eeaaff5fa041e931cbfece386e519bc35d38789314f4e802cfd254fdf68babe6388457819e863effa55e2572e37e7b903143905bdc64dfa9d587df60ac2caca2d19440fa8899343d32ca30d9a401ed68f45ebc16fd7d2cc1b248203f22ab4fed57563603ff8cc8f35956b8ba755ac7bcf3a4cb5a3f3470198d9101388881b08f604c02b367948448f95b2c18dd20dbf91e6d5dd214931cd0122e977cfafe7bc3894176a2438eb5eaeba7739fe08e5ed24c6a9b000f96b69c61767a2fa5a51a6279a11fc338118be174f4703344743cbbcbfb64bcea3c8cb0b1345e497e39ebc9d9346de04c62cb89d4969fd5dc430b0629cb711cba11bc0fbd9ff168ea1f570173456e0360c1c66297b0c5d282013a7ff072044e1d93c087e8ac7b277c93f00e76b888ae9371264bf813e8b914de5e383cf4a7be5b2506478e21c2c091bd89810aae485a1a4506951c90bd7aaac91364300c74ed169d16ce6766f041736e1a3be748d6d3b2b8212bfad3740ad2df214518e9a29ca1d8a9faf7e77d4c8b50923ce8459e166d1bcedfd37501af4fcfb2c9dfbd0d21bc57b2feb5ca22fe9ac9df4f164f860e5764adae8541ee2c584f6e68bfb58bb40a70716ad0ec4ea4953b53950cc19a20e67a1a0b60dbd35d75c3aac372894590156fd59e7692e699554d0a744d3509fe5096bd3045072bd6f30eedb3db3103bedec1197bee22f358c77135ad56c8642bad28cf3c26789fc5dc0e4bf5ad9d1e86cfa6df33640ec3d1af4afb8a75e4b92af25a5bce845367cc8d0e149dee81e99c64c4090383c03e85a54ff4187030596215a3698280a20587df9b7bd950e53564397cbe48de44eb9d229142c70b9c6caa11eaaa0632e9990b06d48bc71bc8a9f9ebe15af6a3bcac6628a09b887e02d64b94642a07f492317b717e5c2d0550da071df02a11044a571637e0323a18dcaddb103cb4bd55b9975bf787320b62d2c713c61c1725fe709de2c21fb0855ba7f0ed8af626ad7c3951bfbd634e0797f4fd94bf42e6f37f2997f9124acb98030a7dc20ad7773b74e178ae6ee1589032224e97c8295669166caab7a3d4e24e366affe0334c427fbea4b346654880927790557a8ecec8df05ef3b92ee19693804d82fa7cdc5f987f8180dfef332f79d433fad7082914f7eb3f06a7eee24d0cc325e41bfb09c6396929eb1f4c274225128a9d1e3f2bffae79fcd0207c4a11fe21c02fe5da744f04eb969e72377961fa9d460747259f667f625d2b51e058966a40c5607658b444a73b1462a1aece919fbfbc06e337806afe701794d03a8d1f213c463851945bb029b509262ec16719d4842bfec7b4c42d85ac70c01e08cb49cfd9b11908acc4d636e2d77177ec6732499108063aa2e6c0deb01727dea1ca3552155c5423488835e6af65050ef84103c5d04dacee6638028c48f32b2c2deb1d5352af930f0479d0b04cb1e02e7de13e927f6b517174077a1bf16da33ff70cf477876550fa2678bd6bccca0fe1f96c5cdba9e15bab5d336fc43d95b3594dee3aaebafc75a84904642be5c62b82aad2d8509a6e0896fe1109b5610d36738eeca80c3bee2850e305a83a10fd059cf87739b8015ac6b35c77883f30334ffe4d49b56feb7b72c3c698bfadfb015c2abf619b163928246d08a6a49a197944de26d97acdde897d42636127ed0585314deb298e3c70954d6cd721472ff64e7a77d0930ffbe0ea821d7d08ed7a5d1eb7b8afd4954e9cc04297651884472a6415454adca9db26f7325191af0096778d186b61d0eca74ae2141f0b9be75f707170ebe1f2dcdf7a90ec1da1a238a4773ca5019701276ce8de06d9acf90dd9ab6aaaedc7c6e7dd33dda66cb701c674943c0b7e4c76b21b1be3d334f9d0480367a35866aa5797221e4fdb96277b5e16c0e2f99ead33239dd9101ff72d299d249fe5b35f3c550a27b76d79b387caaa52a5054cef9d1bf0cbeda81bc1ecbcbbdba27cce310d6892f0669207d90400539b820f65fe1aca15a0089d824006df99ff222c74981e7018772b77c07f31cc8bc2039a1ff357b208e7919531b9aed0b2e11247ceec4a08c44501d89433679540e7e684cc07c5fc76161c887ba7fc330c75544d300e2b34daeba5ba3aef4c8c78eeaa04593f077bb7eb358d4e819f7fa72bc1ebd55a59fdae4d4160a8d9d862332829667d3e6c20cb671dc451ea3dcb40afdadecf16f5d1825a72ab9d445acc0f679d4fe210a33c2821d57eb8cfb583862357d1a7c9afa12521913d9e390e98941466015d76fef390bc6abb09c265baa4f254ffa392b63da57ce70a9c134aaa5313b35662ec79017cd44575a18a8b4941da218cc1a651e35b01cbbb621d8ba0df140cf163d377c265504ab9d5f92f67ec154de19c2074b7f88188372f772b356c57f5181f1b1697e6004116a9d571380e55831b9e483f8fcf7a432ba9e258bebc89217bdb2cebe9fa432b6c32424947234045a1f35dc2fe6010aa762cc35d8184c86fcb71ebb5c97fad174170ff533ff03922e7b2a3b0d2e004fbd3498fe28c1a9bb7978eaf65ecbe2987029f2d0af13fbbb4e88f99c9ab67a591189da83288e119c864337df0805e98a7125a84a9b2e4a33c484ccc96125733c2d8aa404fc2befdb30492b79a21a7af94ef8b36d6fa277c59a1f1b39b482a565e7f4885ab5a8b7620e2fa93fd8e1879306e6fd20c6054d11e63d54cc8d2e165c0c07f81d52fa553e599d04a0632ef4aed3e50f0d9cc3a0e72c0ac970c6265249aab27469ab7d0eb1fde9aa22dfd5ffa84f4cac5df65a387f29cfcb256a7b676f3d77dccc53c09c5388ab9e30c5c471386bca2cce0382a1ffeaa52d9e9868bb7f1da93432ae0899512ab3c334ecd8a29e854404f7d37abfd1aaf22fd65caaeeadabe64e3097848054295f1cf358ba25be9cd2743ff0205c5e11317ec901db1df7002227ac013ee12acaa19e8088ab413c0ac2129ac0c5feeab63f05a6380f4eee1d43da4a706eaac276d779318bd7871f1fe55239ece0b89c5df12a660f47a7ca0828cf896de5deaec7230241e78c2187dd8dab812955d51d431a97484fc82978972b3cce7c2dc91a3741daca202c90b9a0878b63680c46a969b2e9c6e55abbc31e8ce0f8470490e621be9a417317ba57903a1eaa8b0b9c8ec7a7b14c036765b1836fc8825883515d6f6a136aaa31b78803003f83485ba3234fa86b13c6ed78acc57db2d003c7330a60c002a6f5c00819775eba323d078f894d2eecde6840bb33b1f8669c752c24f1793db94e96996552654ac5c03e28175ca18cb15208c2b1d2296a796d4fdd568714b053fe1f72b027510c0db54937a5016398cc468eb703e59025bc193dc42f55941f512b0f919c20d8992acaa954f1b05818cb55bd0ea50cc0a80d962f650dd9557024e2b00b70a8787ef4e4243910179cce7cbd7cf0f32f059a9b958e9a8745c5fb020bea9d2646b160317a9e59e9bad40019872233604832f056387ce381058207ea3ff81bba28c729f8fc4a3e8ba18eb87d57f0fe381d5727df00cb3d53556095cce7e9b5949ac83b99950e6a89b170bbf4b6095daf270e2ac9a6ec39949248f49a6bae597b19859610949bf74bf804f60a627be9f3cd45b6dd33d64e79fd2eeb5250930e32dadb1efbd55786a78b69971a0224b6c562782b0eaa01092f1c326028b2c39852e95e17da769a215270ff8b5256d2cb8ea9c5dd34dbf8d66fe165ee44c14f90c781b95d8e3e19ffdbb9346d6c6c140190e264eb697168b3368b484d81ad3b2d853d69ee32ffe73911e1ce781a8016a24a3d37b8314bb43f2946e704040e79aa00033aa2c459af06c86a67f3e398d9a15437d5d23d1b50ad30cee79d15b4e0fbb331387d3128b580b60932d08e300389715256ebc45b9920da03fb5afb15a9a8502d14ebe912bd3bb083ab99657ecb1d2caadb839303821ece173bfd6388cccdea87603aed16bc0d3f822ba33f9ca17f60af0a41952a6e497ed7f8801d59d0d463376f7a3d940bd4a9bc082bd3f8f5b2dfe4e84ae72a039e6006903c097597aabf090970089f1126c595f8980e8ca6dd2462d9420caed0f59e85d12636a7a8696a9e551d5a44575feaa7261f19dc0e57b70ee2f96c815746544c9a59741b2fba343a9d8627f3d5adc873a58c05cd71934e3c67aed4d4801aa52826277e0945931e2749d5ebea519fbed6c08e2492ca0cecec94661cd7b8c6354f9cdc7613acf649b44326318b498a830d8143527ea065eea3f3bb052c85151b931f665d867f5f7050e48c0e79321f78689dc80cc4747856c5b2655e73a3f6caa089b518d872b3c21a9198abe1f941f92d173c02961638960658122b74ab9cf2d79776856df5fa1a5d885d46b54e921a77a69e71b571f12025c667c01f27a5759ffb959a2773879afb21fa2730109563b43ee1363ce3b1fcd16a178393c064de4f28a4cc21b554c93f0c6d266bb4ed4056872d53e942e98d762bcc28522bf32f00dc45c4eee24c007ae8d4638dcc8effd4da860053b93af18a6e15a2f0a3697809cc53325b82a08f24ea6e3706d3233781e212e40b3e00b33c2c282bb5ae78df7e82020342956405c8fb14e556af28b27fb689bc613d287db2f57586e2f41b604a13752e2c09326cc5c50b7270488e35df8ba8b769ea2d9a06429fbe9e8e7dda5a2d16cf0b26a70771cf747ae041f709ac3d075e3c27f53be0bedb6079fbdbe8d6bf45901e1d909f77fd53018835d28f6aab59cac91fa0713ab7e0643f704e467b054e2efd50831cb7dd70223cb5607a116f0c434c38bec7f6b237809178b5cf57faa9a4d4993549d1e33f92278f31e7dd2b083126dfc7665c09df50a59bc03034b5beda0c539dda60cab65d4a1a130f47f4d52d636c2672b74061ff01787b67198b2185796dc6f10107e5eb0f8fd0eeeed354b3eaac9983f1b06a64525da746d27a3f51592d71a256759dfbc545dc35fca7356acfe2c1ead8b9792e90b321a6b773c5f299abe339fbb9470a9de99ab0727916826493098cbc7e65fa132f77979e5ba480c5e12f2fd035f655775d5876e221d3adbca7c38fac9961a27b0dfb25e941e9c600a3d24aa6368a059ecd312d38818aba1cd40eaa687cb0b3d3f2abbfd412f9282e541da83c376c2cc96a549c7a101275ff0f4c0dd8604e8bb5beffcf7e10681fb39e461d66c699cba24e779ff825317795e3d4181acfba65cead072ebf0bb4c8eda33e0cf5b9da421a7dc1b3c9969c29a98992ee2f48aaadc613f96fc9196f3a6e96bad07f58ffe24af7d7318e7a73b396e60c1250e45f5ab647548ae66aa5b5d597ae11e35d99fdda4bfe0552662bcab6bd645b88cc5878edae321dc5a8562bab949d0367ee01293bea972775567aba09749e8e9eba80b712910e387f82f37b173bd689be31d90a26b57ad6251a796f1df7c3555ba715558a077ef328ed573539c5a8d0cd2d1e904195099c01dc19fb061a4ae57a9ece9eef99fc8f19c9d3d7204f482005620aa5c76500e186fd247240dd2a48b1cc38b63f6b51b1612c65e616e54160898c8bc4922dd125e26107e771f0ac937180572d26230c7e3efa66901db64bc05a610e58510d86ea1d3ab3379f4d31d823576dd9d61e19b5d9058ba61c9183e65bd776cd50ccebded3ab617de4d00cd74a965ccfb00ac93d2d7c6b3d65efa82bf7ccd82f9ab42e8f8b982e680ceb2196afd2995377088a83d34a337012c87c10567ad44a6e498db286f7c318651ade118a3536061e55c582a55a7cf7658e570b68f779515f4e7dd60c67fcce94c30fb70a103fc9add6f4a0254219736f4bdfc8ed1a73388fe3302d8b5dbc068519baa7f61637705202ef23d7faa8fbcc57e54fc3ba3c01ea7787522fdfe0769c062055873834e3b4afdd39a4890c5d8d4ec63acf1b4a2e4a158923f7df1586a7c159ef3c93152d57fd2be75ceb03b6d03a2af09a73af808ee54b796e5142a6648b7152f909aa9c76cc392d4754053ed7152597df765bd1e6260b5a5dc970053fbb16ee41b1c47bd1d3f0efa8cc2bbfedbb9911c5358de883173e8eb0f3c6d1d103b70c8db2c730cce0b6f26e713a1ae88802f3a3a1cd9205ef67c0440b619fe6a96d8d01b5c4868f223d0c3b8f2e39c2e69bf8f26ea7a49eac2ff9387526760739750d8ecf91bc1350941f93e592c829f7434e078f73771f7ec181e90abfee695947f2a884d9ba1b69ef3cbe7e64feedcd8d6e58eb4474cf25f6fd2d9112293b7021e54c4af782ee0abd8f2a205a9749f925850fabd1f2e8d2dc08febf3ec155e9b3878ffd5d83f91c6625dab7f6509f330f4bc7aace924483fec73e43a8579d76491eb476af23c054981c30db2d7d863614eb15a9638af030f2a95d4f48f1adbdea9bc591ff79869d6046a580ef6575c71aabe4092ee81e2731776dfbac761fa9bc8b6aee0a74b8b797a3a2b5304885684703b3a68f5dd72207a145edb1a93e83e02dd563093c1b6ae5106459898aa8f09ec8fb09896d262ab1c0306ee480278732549b914d191d9f8f70e48b1021e1584661e0068a4f37731343186dd83bfade5d67dab12c746d184b8918aef570ec35ec820eb12e779eefd0bfce74ed43413581f49afd66e2d5d58afed93a15c37465af2b113d778428e2affc8014581ed5adbfc11d6531a52879c1da16dc8a1e475271c46e68ce44db9283c6547577608738f681782dbd343450cee674b8d3b0260906ccb134ba9d4a3424d0e8105e420572d48aa4894c5806f50d858399321e91993030eb03f1afb5ce4e48b26dfa4daf75e731c41a1232e3880bb7b3fbfd2dd5b6cecf623ce8d6fcdc9e245497166ba14295423754b46ec071c8fa6d176de16ed98e537b553068531a10593658fe2129c2342052a5e15a12bb007f5a2ac78b97a3cd73fcb127580fb19013353ca657181703e149e16506a05768d456ce34432e2a51a08cf521cda246f135414888d4e2c183a42ae6aa0ec811c9d84b70db4633b0afcebca4683ebc0f546e7732bb6ddc28bb438a482722772d1dbe90657e58ca5c696db97b0fcbe715af4eb37064ec2f578d81bfba0017ca731f2f42832926476b432c04c2955fcbde3ac140eec32b3cfd9302f9073be6b211496d020fc55254f7a2cb1e3c0df111c2f908d8412d352eded8bea4d94ae3815e6d170d01732d69e3ccb5d53c49fa47994ffe3c02dd7abd26c72a9e9efdbf5b73cf39355d424ebdcbb04725a5bc709ce7559bcedb26b7d09c55fabfcdc88e4aa581e9f1c89a7362106586f135bc529e0271481fdca79832c1f1a3aff1d012e6c785bc148cbf54ae838a53ab8ca41d6075fea6b1603f9afc2de51213fc45d3bb51f8e2337fc0c77629504c4f32484cbf1702180405738f22263d1aff812d2bcf7708c4197716f436505b6606f1f6e868859b72cbe77a80bf9b6b55d7bf0ab0729579ccc8c6a202c7ba41cd5760590ed3d2ab03a54f80b64299322cd4dc6be4e55801409f8554b53f4c8e21c72703e1cce2d99465ca2b69678d8f57e9a8bb131dde3f2046955cd1f566fa05d5e9c4429d7233a77a3275f2cf1582e462ca5f189deeafa6038af6dafdf82def9284b1db0066e8082de87538c052b0db23c484ddce8492e28ee660ea5fbeb644f0e731d4a81e5d8ce4d0206afb0a9ba2b6f158f6c608066744e7ddb3de1973a150f39bf79121ffa9bf8693f5c26b616c4da9cef35f0565f1f92da5f64475fda73c0ffcdf5c4cd66655eead345248bcffc8e45ad47f20aaa4986e64a1ba0826f0920eb7f2ef7bfb5a3e7f20d5ac490694016ab27fdebd50a3902635b24d63796a23dce9f1918133c40647195f31aef7be0339893ed4797b25927bdef3e3c7a233df1b1d6b538ed491f3513050c2d382d00aee9e12f6eab82afd16d57f4b93c2d4711cc63732427f639aa94760c5b06a4abc9c4f90f8e096bcdcbc9ea6e13abc3f24500bc405cbf8884dd8c4f2cac4b7db662593966a883bf3e77da61e6af26f6777ae20f14f59ecc51dd3b5fa8ce963d0060f159aa0a2b01c10246ee17128b3ac74b8e3e61c4eb2224dbaf8a629c14fdba10157422f81a7a59715446ab85b14e5b0cdc574e93d350eb3368ca3e4b8c6a51b34c94f9f2efdea81de0d42aa02e11acbd56b72355fe42082b2539f1b7f81a155e649cf629ed807566d9ca714f9934dd0d64afa41a1d43994e489b22a6279896d2cb710ad5b9981d072076fa516ab9da07e11dc3c906ac78d9029eeb43e243f440bc5e11a07577e6decf773dfad9327971db1101b8d9cb1bceb272714e7fe17a642a81fab58edff9de96dc9a06b817de1b370bdaedcfef77d97f8431df5bd4d325d32237326f3cb23f3c5f42cf22103930f1cdd843990dc966ff66941ff21a090b4aaf2844ac0013ea3143ba8f03389620c8f67bc40d5b2f118acbabf7bce0cb07d643f5b6240dab55ec53d30ed148633cf1e40330163e1913691abec1b30026a198fa8b31ef93ba54fb322dc41865e68e563f076c82fe0da0149d35d254ac30b1ce662cd7abb90fe1aa0904b5bca344df27d4a3dd87019270f3477fa4556132ecbb7cecaf5c61989b58008cba557beae43f6e71a210656c9670ec37021c8aa2b63314d2f5e84c06c03013baf31ed6cdc7527f5aa1a160651fbcb48701db9d2efa274b675527f6121ca04b9c9db57c5915f378e17b60632f715a4bdf96469c6e585c2e10a3c577b03aa1e0b436592483170bc13139f826aef25dcbbe0527f1623b5d929c68785d3c71645d325767e34b3f53d13c3379060f15dedf3caa0b71e1f45e78206e0c33e0c0beb2623ce3be87041da5f75c6d5647243405d3612e29d381be6452ec496c18146062a39ce070701d513c9f7d356de63419f6d57df2c7a337f917aa0770ad49c1a5ab006a3f48b780e0064b807ce1f1681621d897a7acc27f2714c5d20f9cb0e4d2068cec3743beafde1bf04d3b2ce12ad6c20d4abcf2de39513d7b0b182c44960b9ea54dd03cd2ec7ca9fe683c4fde9eee313a4861d496c891850b113a9802d94aa807f2893417014eb02785edcb6b72b2d9e15b02866c851f70e23cd41d192da683571e6916e9320f6c56da9ee45acf8580d51ff05fc9dce799f84a8038fbb451991b2772a74f57857fe1fda5dae35c86a67aef8a5c4468c2936e0a1233b80d18bdfeeedbfd86c6a138e556fbac33a4d39d9e29d58f9bd1c5b3824977dc0f2c261107c1d6bac194e9b80775acb8f440bac2a701cf106e69dad077062573127c1743441737e404b4166120e6f54330a82f09bce6007613372c4ade34bf2d6fe5a4eea71da7eb3cd0fc5a00c617cf1c55092e16f075e44b12e8106e69b4e7bbebf7698c7eab4634d5e295278156b793dae78fa03e05dab8cf10f420a86348468e6520e73566aa8c99fc5561ac4ea29ab85a4a12a81525efcb3043ffe90d1350f66e94dfc8167f38206d2afb1cbb98d9c0bb367812d6b069ae37ba78f7ef0d4099b4e8c0f78460599c70b1d34da25f02307093177604e91af2759f6728a8b740c3f9206f07c0a3210625c41335ce085fa6d3af9d237a63ad63e5cdc08a3eed487f504e84c1892d5327a759c28f91701b26e0eb3fbe4f866cbb03d3bb8dfb99740814badf9b925a32e3ae0324f7ea7a1a176389a2a8d54af02249a1a1fbccd27eee2e03b089fe721082c85e8c19ce794d50ad76f56c245231475421728f12d8a331464b20e7ac802321ffad1e0cec5385b73a673c0d8bf57bb99c4fccf56569c5a38152c4da17fd62b0382e0b9a07642e3bf1c9b7a57a65a39e3b0be38f39adfa80170780eb669f32c0b5eb810a09caace448643566ee91f129ee255c0f9110170ecc1cd1387eb0a251800f7af1e76383d1c6f3aa911b3be24193cf43d333b34e43c49254402588d5bd983bc7297bc9fa44271fdc0330c0349c7a09797554dd2961d8b359df2477bfc3838470f502c496c66b9bd3f6d2199bd96be64ee928fa7f918642a26f267ae6520829968cca5ca7283a59da895edc4a6fff3d1438e2a995a65f53c32afc5b761048d07cb3084cbe673d0c33474e3d40c92485e0ca9abb57d10c330ab107b1417ba12ff93d97159074fd61bd9356ae0515ef5afb91d99a80982ada83a5a2923fec033aeb92dc4954e6867757b9bbb995fb470f6ec10c02a86f40371820970d9cae373c90c6c637cf8d06884e56d3a3943045bdc706e399e72e84222dc9056ab52f4eddd10a2eefa88b1180a7689979fbeac7a0ca2d5e5fefd6918e8b69801ae932724fb3ff5d7e4b9db1637d71e1827f64a571c00132b9ae5f995b1bc8048231591ee3f551c2bd9e1ad5bd21311309b940da9547e4853747928f85f60de29ceacc4188ab4368b4137c71732af6c3e25d4bbacdc0e99b432d156fd8986fcb132eb65d604d1407946b6a7191053a828fc970bf1cbf4a770420f6f891190c1cabd6d3ccef251f2d11290f0055909d4689aae8de0410ff3af97170e159118125144734bb2bf611b122bdbb65c95dcb563edbab84f644ef2dc70ba25b8227584118af46c7edd2987fb6a8afd7eb135c1d2bdc37061e6c75f87418c0ad0c67b38c5cb42048e7fe82522d4f290e19505bf0826142aa3718eac6a824d4e8c3f2fe016361577b96c794fa9945801ffe84cae6aa746b519a660ac3d97734958acf1ba51fd5583d26c3587821558e4bd764a693dd47a0a04ab7617a8750f998cc452c3fca25c32bd715fad33f45cf35eb13113118eafc9683d3273a89deb82c98682d60ded4aebfb305305f4e33cf38c2b7071ab69da5b36ea8e91679d5c91d0d35fb74d8a1ba150752ad0fa5b9873d322061d63b8326858a67298ebac74d4b0880e25dfd73d98e6a38c8e9576d702e67389471411f3c82ba1b9433cb48c62980eaa44ca24eec6fbf5aedc0ab2af4f613b50183d9541fcf03a543a0ac263d978f6704e6722f085eb3d980d0e3dbb3fcbf88d0ec0e16599f9aa14df6d8f9389342f7713116050e9c2815d6515fd41022452e624de5e025f162bc40dba992eb224cb1eb36fadde2747c8ceb1d40972c3fa0c4259a4f671de6e61eebe15c83468be87ab7fc824d053191cafa4881246822ca4110de0d9dc03cb5c59a551235da5bb6e8edeb9dcebe98f05b747ff417be2f28925068226def3654f91b3dbb08043b1fff6fdec22e090c30439654bef06eb83098811cfe7f80154a9e57d5f55d3d3b245e5dff902201207d2bf6a95c35229bba46912fcfc13a21dcf29fc1452699806bc38a30aa89454823a57b1b081f5382424cc12426a92270dda23087fc5108bae013728c9431a1a15fc07ceecc0c2ba3f431dd0383ae5acbb3907c33d7e1a100e74d1cd794293ffc6e9cb5adcc6a118d75df2f4549e051700ad534906120ac01b27c08a33d78695fd4770f75cbbdd8e2477bd0f08c1d7d88e0236fbef906b8149ec16dcc1df259eb9ba0b502f402fb63d1a708a206b226196687c1db58a76703059e4bfce85007668a0a38389f940b50cfed5dfc10c9d36b2da5f506d47fdd46a46029364264c665b19639c71d5faebedbf334a485d34595d444ec3783345020128cb7b8c60481d9ef0e95a24b5b2d3a686f8c393da19cf1239f596854546b0e7140be0cfd7a39acbcc2c669639f3d5cc556de8e0f877e224fe1e4ba8010d3fb5fe75b9ec22ad7e38b17ff6ecd2fb1bacd06ce9437d3677491f44159b0bb931f1bcecc3d163a09ec69cb199b60b3809c3719c2c07771c3216e4592aac634af6a55dc9661c05a1340c3cd55eb71fc5713fadd990e76ff9bab3c1c32b45515fb6f867c73ea313dbbf3d1e3c0e9c4fe85da933ada438efcaa2665949a02cf91adb9227689ad304b3fec86311d5b0dde7c3573c6419d559c4e01c1cf9b5e74f16b0f4292a9d07d14574474610f44e0522d71a475d72d33a13cc8378fdcccda40b3cf89c0ce62bf29d28e66a5dd844824530bb93187cd7cab54a6647b823ee5297fc5f80e0226f1ff7a749d2da0663027d611fbf264acb20e916e17f51cec33118bcd5a783daf8e7e7db782ead3980881923d59d67088c656e887d7807ba8beac112b6c9eb4714d7edebd0e833dfaf08538a8ac713d32420a706869e6baeb679a8341b98814e643abc53b91cd0f096ea316c342d4d829ce8a4f8d46a0a263db858a89cd2277b1c6b0da1a53048dc18a1e2333d400660c3e037bded9e7fd2d546c37bebc9ed102a34ff3c5682c5832893ff46ad9b603686aafdae2da191106e3a95c53d790414cc0f11bd0b62d3ecd1e1166482e429c6a1a0fb77988ffda1a9e4c021604967f37af0f053a8b562114fdd385d1966bbc62b14b77aab7cc7711bc964c1a9e31e2693c8f21df075d1cb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
