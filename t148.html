<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18df97a25984fcc678ede4ec3f74801afc2d79a1b57b5c7a6e539b55658e2dfc9e60cba2da70f0d4cb0a253e20cb237619cefc72bdc101885ccd07162bf9065f9b7388d031859ee93ae388efa5a04d07a36dc13b514c95103247d6734e5332cfc33748aa3ef13c44f5ab673ac6c8d99abb64f2d92290aebf28841ebcfa39db1615fe069d0079f15188fc41eb25bd4a34fcad9f566f71dcf476e9b6220854df66ea0ced930b8226b2cd2e5756899398ac8261ed37566d40deafa55842eef33c58953b411b792b4e761544320d7476bdc02abcfbe1d43a606b89446352ef5238d3e726fe3b021dee48c9c06b815f9bb59d8c6e60290b3eb7a4267f408674f7944200251b06a838a191c588583fc5c5b401806f4ee9f4fb4e9fdcb95cc10d6f921a5728f58efa1136185c734b7e0a0f03eda1c8047bd22ef7ef69c486c8e16b9b0e191b30379de9211ce3eba8e0d8981dd93a76b1c1638b917292f76ef25ded8bac051356f2ce722c8e931d821496c47100d1038a1556e9c0ae8882ea1001137a44172eff9e80ae777a686d2ab6b1583b2115984abe8cdc6b19f3dc8da674a88908cc9d711af628a32c60789b5a325b726174477310fdb2a5ef7b006d2a2f529962dd45b649132793a0ecb957a8811aa40f0239da05105add8ec88e6b2ccc2c400709e51c2a9dd063ffd7192de8376b76f9e73e04154700dc96d0b59b46c76b7af5fba1a82083ab1cf81c7b38ccd14df04ad1736ac851aa2262750d14a061b7a0605adc73c0d6997233fc3ec417e4351e95c1419bd0948de8c3463a0c566bfdefb8817082d9eeabd0b1dafa373180f926fc802b4e64cbce49d2a031773804ee1a4f96d70ba3d567ac0aa828079e50f281861ca0b7dabba868add6e6ce1352dabccec083ec7ee464c7cef5508d6fc4c8c00cc5537e60c3cb15dde1cc3b47254349b22de18b59473fd610d96f3f3f02cb85b6a31233e929e78e869fbf66b52ae3ca1f52f63bfc11caf68ceebe388994cdc7d3c243106c8d54a711f9fb97acc3a0d83b44a10c450e242acaaca8181cf03fd3422ab3f31a3987a21dec4efd8bdca94d6cba8437f7f647a5ffd456280b23ea38b5de6ac1ae0c06c2d033a64bf715fc1f3f1ee6e3fe8d12b8700ad6aef727d8ae00e43c8ecdff041955671e2dc598475a466180a52eadd11328cf94de904fc48ff276dcada8e98018d5ec0cf55bdd5841773deb0a259814efdf1b14685ba54e393e341e41906d9fe1ef6e1c37ed8a9c8dfb0b2afb6c53533150840c1ecbf76bb39435e58bedebd24f434a6c41885facfe9073684ae40d2861029aac519924a82f69d3818448f27aa5ce1192d2d5049157b7ced11bc7fc8a2bef3256ed44f8a628558f018855bc7bf703331159f4e229211b91babb8cbe37d33007af016b57d5ae6acb0cede1525da904243fd0d446830e42cb7cef684064992a2028b2c69b1f42ba74f650f0643aba3147f8c7ce56607fe1b4c1ecfe743490e136db7da9ef3a04ac479037a0651dea5f90a673f84a17caa75f0e926611bead209f567e08e377d583444f5e78492e06056da4005b6f23c8705a288ae20fd12875de281e9137392bfa5f6e147988f3ace0ab483ca2e51f2265153725c3269beab29432183f93887230c835b290c65df316a13f7fd3a5f9d2c0f04b31a6c15621e7c1813c9eb1292130834deefd674b28830998643a9ea9e4d95bcde837062a1c230d5d4dbc64e2c32c0d50c20246904e149ad785c49dfbf17b18fd1c9d1bfcac7bc770acb549c81fbd03a2141c7e756e79cb28b965a5d334a9d779aebb45a40f0676ba42e3ca2c7d2a17b008c6d08a14a04c377d951bf8df36e9a9c7a8e24378a7d14debc6a87a59bd75cf94058364997550090059e134c404b60a059a9e9bc3797a8a59cfdb0fc98aa8810e912a6462b68e164416be67b8b2fc6e17a4f1062098d1719ac763a89bb5b8b86c23bb208fc0a054678624e493555a33b3b6d62a19995e9b457d3f6889a1ce1848ed0b92784ff3a674bc8d8c2450f02a026fb1674ffa937a0e475132634e4d6e4d2ea0ccebaed2a4213f03ca303f1ef66acaaa4055578d17da95599ea222bf7455a6f239fd21b8c73002b55f2bce47a78919da80e0a17db098a2e371fc630455d965038de2ef155b368d11bfe79b34d837b0f6a53fdfd54eb8923707ccbd77815fa8d298dcd2daec34559dfcf054aa34a1b036d41f380be386ed3a4f1769f11883404f7d8052baf0c494e65b66b5313b495b996cef95e097d61e8ca11c75116688c7de2dc781c04d719a2ba4ca5b616f2d611514effd83d73e9951c8d3922257b5f08f5b3126a3e8f92a48300feb09722c8ae5669268a27a34b9e40d4e0b9182070ec0c8709415a3255d1cc202099c300a491f74cf62efd9365d099d6ce74e97859c0427b5ebd51134b0ac9c0667ad2bf7d12d5695555478a82038487e8ec069a277b6f9c8547a4afc903a74e7dca97fcf3811b2feb49375ba287d63bbf83405b83065928daef96eeb087bf6ba1f0ed91357fa7efe5fb3d395c2383c1a02157b0056dd694df05b3e2f5d1b63f97ff196dfbff29fb91bd0db87cd779b81aea745a9ee961520e148a6f765cdb29977719675a75dd9d5345ee876f0604289415ed2469a006b3c0688256341f6647d8cfd89dc55b9f2e69968765dfe4ba3a868805ec8205a6aa2bbbfe1d2dc370df22f0e972ecbdae1c2910e3843d23f8fddb9b5aedf0d6252e196392e5a8e93fad1f797748838566271b0064ddacd3ac753a8f9b3a2472431b9d236b55751f2a2ede1ce6e0437e8718d16b3e9d0eefe24475794403ba6576abb3209f007813e9a186d5644c6eef7f2c2eae62d3ffa8b286114c7d3ffdf05cd3bfedb838a7f25f7f33f7ec18d422c30713b8a1437fcda2169024158db319cdd9a27fef402a6b0d48d5077423fe57e90ed37255d4440942cda9fa8e976b35afa4f109c6ed2e1642fb2844a67283c4c90f09339c96ca735b18c3a4134840c81902f2fbfaaeab90087c7a56e7f5083db7f379016d2285ed757340493b6276c96e51f716f1037fff208d3251acc938ab4ea38a46740fd2fe20e0e4246aa4583b561de74a91a8c93906c4c782c4b00b14e88a1be1f6917b037f5ccdc9da81a9796536045cf0c972dc78e0ea0a3e91519bbc9c54df3c7a26e9686f3923d19470881a919746d9872250dcf8fc0eb4d977c5360657eba6da7033896927dab6a0ff9c991c6027df39a137ae383b84ff97acfb7a4883003e04667b80d0fe530d7ff18edaa0532103a6a43f066216b5950a66ce7a574c2278aea0c0f975c837c6ec0809a964ff23da008a569db756b19616e4a09e7f54367a0f98d35d365c1043575a18667f86d6af1fbc220ffa372cf6c754f65d3a1b5bf612425e59ae9f14842b0555459e10a5cc11341926690cbdff6d7ec3b53a917c12c615aa855d8a549b17af897aa9b21b764b3bdc4abd3a4ce5a6ba79c75c742f80a352362ed9295998e20ec79f10c80dd221f1d4f4625583fae895e3e88b27ed53caff1790ed89c8adeb15f5bd50f9ed375b0a4000867b26c8e0b38fe87984ec29edc58ef85e45360263f09470306ccac955f1bfc5254f278f99f746fb41b49ec5343f326639ae4079bbdc66288014b3ca1e4619872e20b93908a7ff19c04fcadf86e53bb80fd0c31c808af8a23eef7d17540377282822b89a01011371d3eec1cc8cb6cf7bffe52ca0cfe50f5c5c0079950b3b24581c6fc577f65e328bbd01ddec76ec2e647d5f251e1d43369c2a331d6761a49ba416fbc07841c67ca9a79373a914279ad099c9d017b29e54b353847225beeb8281c8b281482322e6ca6327a3ca53933d89cd4b739054ad24116e12c7cdcac373f51f6baf3de5a2f81103f35a8875b3ea57d41852ba1ed5e274ac0cd77f8f71bbfdd92d38ef9551bddc02caef3a0334c36ae791157198da3fbe1a0625ea5eb750c72468f30e860b2539803d46b616d6c94f80a4ce4c1ab3850692b97e50a55f55f26384d50200e25cb0ef6443fa1b7313c95a77028251b77dd12e629cdfeb9455389c2287dab84707f55526432a62036000b367e0706288fd0ca1af67e09ef2e15ab9c4866d005c37435c781c46e27b97c789bb9089f5e6bcc2fc27f87fa2428f8f2bbbf7045dfb315f10f67fb91fbf0930837591faa61cc1eeccf8aa55170e498cd91d0d5c8e002d1fd42c797fc70fe550ac25cc933a1a8726b9bdc4c07a711f93aa2c40f130ae049b5821fe2aefcdf3cd086dcf8b8bccdb8919fd0fa74f26610ccc50de0a677061ebc2e84b95420fd50626e6a09460b0e2fc1f41ac82dc8920b3b16ba8ddcb267813433859ad210f7c0df7a9fe1c193dab6c66f1cf3e518e1af7f9196881442b4ceed2949feb3a7867d9b2a56858595572d164d6529b28b49ba2a7445e21e7742a236f35f1d3b32d7ed5371b374566192105f6ed7f74405626a46cf26471df7b094b435dabf03e83105f791e7bcbc44198a43c144e67b70a9d89074fae1afe6cdfba9d028a6157024e8b5064d6ea73feffc979e5fabe66bd0f00bcdc93b1f0d132faf5f6a85be8e1bd01ed5116135c72845b7fe33d8187653d9ce8ba63dc3757fd26bbe8395465730de75475eaced6d914890119066e68cc3a74cb5e5387f517e060eacbc7b2cc621eaa1f6b931b6c2ccef361e50188f5014af8e314b709a842183faa02fce3434e0bec160c8b9ba46e21146ec95e905244b9520004ceffdf4ae7fe5e28968274705a060da950e6bd50970aeca7df4e32468022ec632efed0805447fc0dfdf659c75ee60fca9a0ae13edfe31094eadebd26ac6ebc977c5d3ec0ecc18c0e6ec66807e015f785d3f0dfb38d6bba5d3147fc27acc566778b54072619b893e94c14229692d45407a95e08eb476d0cfa99da5725d301d26e801119e5ea76bc96197946bb49fe125bc083a0c4b47fdad0747ee155ecb487109ca67d98e52e817285031ce7db0c61d1806bd1fc75307ea1bab0139be648fa1e60b853e7a072f1f0a8327472aafb73be48ab52db2e995bb83d1236d2246faaf33ec9d8947a97f4b0ac35c300ead0554d1b91ef1daf0ac439b62cd5c0788e0c33205440b27eb2ad6eb2bbf8567866f0878e16c5cc8afe39bb7e1ce23826d2c33d3dc53a535a73d48625f0e52889f2d11b330c047e6f99e8257c5d25b50c55255d515dd0dcba62adae75d92516a2ca367905e43d41bfd450076a20f0497f16cb0ffcef904be30d2e5dce27f7201ff1956d1bce3bd3202026274ccb87709f8d4a7f151f0f5fabbb2ca87a9f2939a3c5ce88ad97244682feb72cc506468d68fcb678b980be939523b1aa5bda733379faeb73e9bb92a42b9dcd948921f211afb30715713ad584adf8e4bc5b0c78cb7fae08cc32a1ad691f66d19be56c37b6c3b17c93e5a70e98a3fb3a457c8d1b7e91a5739743577273e1290ff4f2190ed21760187aa33f66f4c25b2b0ddf5cc55e2b0491fc4ac6961a57296ad3ab9ca5b2d3d81c6a361cb9678161347b92b6c2d8a7836c61afb99850b2ecee38f1bb09de318251a6990dee6fae41d290a482db917f9cf6a375e3e5233b892adb50547a512c5bc103acbc104770a88fc4af17fea60c50da72629994a4ab5fb6fb0c6138c832bc14ef79850d4de1591805cae8538ca22aa906b7a5361437da9959942bab1f73b7d78f8c6360d35ab3019ffc62cd9b803dbcbdd7b22fd59f34dd40f8fd7aa4b292c416769492f5b07fe373c2232436d5045327a8fe1c1252ff98e354fd502d915fde48f130fe43c99bd9910f7ce34d6c96e5f7b06014005f05e957d041ceab703c7c5c74a34f4c91bc7a782b5a0083c77afced97864022485d1616a20d901a9141ead6dafd5102b803aaf15245dc2368434bdaa6e0f931e4aca52ff5b8b02616a4fad7eae5e2be2d4f668d8b6f3ca88db999a3cf5d5f71ee14686014afa21ca9c298bf72fafd43e69bb52068c31cce8082d594ce1ed6d54483bc0ae63f0a15d1468113f058e9f9fb96e0534a07dfea987aa4ccb31f66e609d8ec10bd3b5313d0c613ddd2e5f9dbfe58f0657ee1459766c77aacef8924e02aee7f6280151e28f8acfc550cd864d7c0c7fad6908ff3988be2ea4836f3728a0c8e6328cd1b632c22f2afd102c6b39abe218adc10fbfe501c79a2ecdf63fc63a2b149d7f6a244e1e84577eec73c3e690ef8fb7fed8d85752f419c494565b670c8e697526e3362fd97e64b7502a740a1d64fddda2b1a45d763a2ded9bcb602aeb5b8e86b98e67670be7971b3a2dadd16771db9bdfef4dc13d7995a663a90c158948b8970021e59197a327192a1ece510a581b1a49f649021c7f3e4f17afaaf961fd8d34d7f976bbe922c2a279fe552c15ed430b624e0da0bb2f9b6250ac1f5b7d4223edb1e61fd30f78bdd76d57f15d851e0002d22d7c350425dce883dbe947b849f07aa68d91a2b4df29711a7f59b2033de271b92c6b46ad25398b0a471144755fb8f2587206f25d33e53a07067c49d79af6129c56accb3aa4fcf1d7d82458860f3cd4aa7a937b59794dea524e5496b6515a88a113bcb27b3e3ae68865703f26fd488173e429efc58cfb44dddf9bef73ce7c75e60d5e6db90b027a2fc3b9d429532225d86ed2b89d1ed89219f8fbad79689ffc186e1fb505576ec1790545872ad62ffb8497fd5ee2c488c3ae4f9aca0d7b4f398feebd75bbebf5457337880e6fea6ad8cff837694e586600d2a5ad5f943cf30c64a18c68c78324165d317e5b05a7f60ff63d76c260072731d01dd7138a5e2ac558f9ce14ec373b1f0ad8036b0c396ecbc5729d9d762406fb562532e9a6fd2fd086142f877cc044f5a9ad12c66c6392273521a4275cd2f585c18e22e33c192181af5d3fb21d2ce965be7306140e338bf875a9f18defbe6e6837ec62ca6186d179e5fd99e79735c0aab4278167830055b7776b48b30b0b0fff82fae86f8c684a43d9879d80a0ff433a45e37547feecc33a9e225f733e6827356784e25282206e9a3810123490191f613f3e719f1bda12bf5a2771a3307ee7ec89194e546102e4fcb35c80cd03eb758e4532652c5b017901e627b4fdd52efc3b2bb61dbaf261aff66573b66e11b8ea209c4157773920a73850b6b8e6765c59fb0a1f84dea4965d5f6acc129c4c9f5787843ceec355f8f2ec90a91c1bbb90bfd71d50c4a62f3a361e2a45103aca7b4cdc491d2df4fc14931b31c5fccb41cd396d031a36500438fb221b1fc15621a3b46923054084d7b38e44b00ce6ba76ed8c392be77fac60b18c530c92f904e68bccefb0a872a02b59df532f5dfadf8f3b8a794c3d70df08bb1f1a9f0a5bec545b6b74eff9eefe45bfdf6168b1b67226cf88b9bbff5c8982878a618f19f58bda5ccf842f28243592754c6318cd53d4bb587fafd895e24d3a401e1a7a890f4af283a387f1a9844e4aca2a42d9c68733548dc2eb7b6498628dd330b00930df79c392cb4f984fe1ee311673e6ea1ba9e8345e731469c826980fa52a1af577fa18892b54d1fb187824aa0c61f7601ed02805315c44bbe05d699edd485f0bc26dcfd91161e475cf288b2b4da72e0229d14711fc0680c3226d4dd720ae42eef73f5a62a2ee8b5ad7f192d638b3c516744304c605de33104dcd1dfac718bbceac5faa258fa819c8997199e8e73d30e4b74b3284eb5f10a94b5a19ab1c95b14a452a2925b10100f172ecfb71377250034269bb01c7b2af11f16c8867b121a8cda193298b48767b6703ba7be5a23cd52208f5ab3fc672b9c7ccf6ff63890fd3540e9747536b9e901d4e5bbe52a1bf78d3814d4fc752232bf6ee3f4b318145c6f2bda2d65ce9a06ef3feba3c6c1aed9a3fa70fe10d1281c08b891d118a21d8909ea67af5014b634250a6df8a35c59acb89fed6e558d3ada8879f20789560d2f3fc52b674a0a03ac1b3d947cd5b857f47ed76dd67835a6387900fa9a03e86e1002ebcbab2629e655ab26b30bab6a28a7fe8f68ef307569b29f29f644da50900867b252c4666c7a4722ad1c132f1b2e1a6a7724259ff3c86f32e3fd994c5ead1ceda06eb61cd189fc5a45bcf8f90dedf27db16bec18cb6a84a13dcec8ae478d59d069ac2f0b5d74c1e03b3e88a4eeabce3da0e75a21d1225552a138dcf721e5beebdc55a74dbb48c89253d945cb28d93946083f41001c1db8c6305ee52803cc71db19719d1f5b30335cd0c90100f784631e167b40958e8ea7c82b05dbdd35a95b4009322ca4606f903d026f54c28ed45fbb0f5f1ae3f72bd2eece759b3fd2170380edd88fe389497ef73d6a3dab7b61b3daefb947129a3d1f7355c456f5f334d07b01c80838b88c06350bc7855eb3efc6d02e0287ece7d07f5951a3781ef23fc6126b3a538c4e9afc39d252802dd5bebf6ae8f7ae1a716380aa78b23b4b25cb845f12411575f646f4efa7f3ecec00aeee39ce2b157777dca4e564b9dad0bbf104231cf9675665a3706fa60175a3355d15750c811145ceb9bc12c0b1424bc9cb7924478cc8c264bc9c928fd7dadb0fecb1bdad075a126a2c7ec4653011fa30457683927ba9baca4df5cecc84c5e97a391e3dd738f9e662d345ae06cf79f6c3f6d240810235275e168332a97b93a0e8c0a64cfb9a75aceaa95323f2bf5400a7beee3b2d25bb680de747a366c5b7a617f1f51ceb5f60405e7c4b9eae0c1af28439997ad88a1647de5c784c3e2e14d716213bdf8e532984fa27347ea0fba5f7dc5592fcab5823115657e36dc6b319a9d6ab04f9a458f2f1c70224ab107b83eba43dadf7d7b183debd3f8052dcd249c8ce0b84d820eda6860ac00744b0969ced0e96c295ec1b3a214ab049aac6a2e447be2da31a4919a8aac58ee298f0315c2732d946b8484a3cee4dbc2e1154178a27560ef4ab6037ca1a7aa5852c72e8cd9e4dd2a58ae4e566fc1f230f7e745bc19f582e00d17f60d2ea0f3f377805790e8262dfb8a39d7f0012b0df804cb72fb93dca5d96575a0ada56ca4c9ff594a4bc1ab31a29738ebdd349d2bea2f40231b48deea6e188f553193e87ace8532221c307043f3ef909cb4009355a5783685cb605c2b7825396a6e14ec630e5dcbbaea1c7b10757c369275922eba08ed23eb947de4ea907f28633d2acee017315b13ea1baec0bc2be24d024b09490b8719c093ad7867427f4127cd3ddbb5cb50d2980d5ba89d6e5a9ef078af85b4d58399b285d1b1b462bd4c0f59180e6856678c2eae2a1f5018a4c455b0b5754d40bed5b6da9d64bd7b8460b4168e0d47a6e3ab69c2d9da7dd572d45d15fb9f9fe58e89da5c84d3c59428be45474e984710974fe2bef2397ab263ae1306f9b32a621665f5a8e438e28d7edfe2b1c8e6493363bbdd2af7e909fd47de4c00885c6370198a23173b95b8cb389f46737b3d1840eca5921a2e17ae7c47fa17a8c69c7c1fe40d1ce92b33a597087a5623f203458732e8746cddb58bbbc7149911d497cb028a9e79785fd52112d3d4f512542b58fa6fcd372967ee60cd479655d5c8005e6df831dde50c6fdae6b3c244b26993fee6c2ce492362112413d83ded294bfe65e8b3ed8eff982b266fdf00b801a403ffc11684dfacaf5d546f8167f595e8b646b2c4eb5ec1813b82ab181c752ddb212bb93511f6b8c2057aada0ccc5fec9b0794c6dcd4d86a554a281808cc472cc18aef0fd1d599a8298fd70b04aaedcc93709529c375d2d8e3a9d1a5e1387003d3304cf448bb00b38558071d0a774690c8d069e2293e48b06f9039289cc03a927117830a9886491665c390853bcd4899faae68af861fce45759c96bbcf30d97142876ad22e7bfbb38c0210449d3a142ec46e5c01c7434abcb99c1bc68bac39cd203d1e4cbebbbeec17a1d1d320619160a2c48ace3ebd1b276874ca284f92f2c1a1d1738f0b8977a19177529653baa19624b3f4c6b9e44033a24c7b0052e21c5ee1a074ea0e6606b918ff868c5bfc6d845fee9d84568d341196c6af97fb58f8e5c4ebbb2c7b26396d3aa338020dfc4abcc5f07fe4ac396dcc58d95af438febf26cd08cde41685d8d014f1fa6380e1ddd5db6ce7e7949e77c09bd013b679d2edd566c6560bcb176155b209eb1412fcc971abef5a9153c8e3e9f9f5e0f1f55c2e866f0ff20b5adfceae8847916f5055efeafb794a65a2072ef4397b56c09b926ea6e27c7a476cd5a21049d093367fe5bb292fe1c3fb746cc8102c618fa8bc76a880b36f1c7b6104950964a3a0c12ad6d441a74bbc52320e354ede2c09e2cfd53a1cf1df9d13be0a708b4abb1b4c17e2988d56802c37fd1afd8830f637c6b36392e229fbc201561e2e245854a003d72ef5260904fc19a35a8dfd912df6bb332ac988d7f33da269e5a6053d25f0671fceef9f2c4658f53a3e17ffafeb27d827664d5d12a4c5303811b02dd3d09628bcf8e7ab6de97b1f192ed76bad25c21a408e049ddb6288c71a5ee4d6e59ef90151e28dcf22be0d4d864c7e3f8d92062e64de82ecdcf1b6259838c5e44ab6c3ce366c9934f7eacbae3a4e459bc1962f5137c9a7d0bbb200deb7d7329cc8dc736d1c81bea0eef30e8e57b9bf4d9226ccdf088de79efefe4855ffbb9581d27519027265ba3e7e5058746c8ed71438440277ea0d241658f0aa7e61cae9fbb5c7145de516ec845a6ff8d78fedb43836040681c91c4328266a93062ec76cf28ebaf970f57033570d9c432f24a38d2491825f5c84fec6a232214d34dfd34063d824ffca76987ba3bc41d12f41cd45c3fc35df767ff4f5c7763c2891c2fad2fd83c259d0dbf30a3da87771cf4a71407f3a708c988ea6ebbe4490c129705d8c55401580bc8ebfd90bfa4a7a4848435aa45e653c09b396fb58b6fc17920cedaf069e483e185f4beda630752a60834e0d8ee4dc9105ce1c2bed11e0297cf699c525d10150811aef802cf517f761dc54887166bd9012b5f95c86c1d813183b451b263ce40f6dd1b5cad5844953766ef0b0d2cdbf2bd4122ba3a2fb207bc6d9feca52ca9bbed89492fd9bb581f905608a7685a10c4d39accf8e2b147bbcb960ebb2470109eb90b2c238224755a7ac3f8d033d57479fe3e4dbc884d6fe379d5b064ad286472de583f793f1709c9310131225d52838660c7dcff3aca510c0e445ab6ced134fdc9a9c9555fd7947cca96e9a3c0fe00c246312fdc28b3e8f1af56dc9ce68109059df71e622bb7458e40e666b7d2321694014695f7352d40035f6beb312572679b38680468120d8e7572ed5c483ee1ee070c5d13e0d8fc7c3cbcd8ae7ac5b372fdcf0a268812b4bbc56aca3da58232a61f514b5cee190d702b8d498aad735bc5cdfa66dbc55f41b1a3094bbb6f39ae554fde9653afecfa653844ebff7d7cc12e0f76628c6bacd351c6f3e9b1ee4b4e49249111828fba804f8fc4c289237b1299f9e80e53ffb887a4c97e6ddce097239d2f3319b1465c9dec448ac1b8960fb8684f3adf08435e3dfff47ceb3755a2a8d4f92c7a3b35b63826eaf2ed99e49bf374ef9e0893de6af62e03c18b6d2c5a3ab5368029c65504f26796489b2dcae18427612045987f4bab23992526cea5f70d5e124faf0528edd6722e77d33a4472f8c0bb8ebf154aab5e8bf25e27479b3a95ba65531da9c24009319d96293e37deef920739ede27fbcc58ad95befee5b76dcf66bae3acea1d253e10b1834e391f53ce62abdc8987abcdb45287d01547c63ffd69f2cd6e866bdbadec88f2a1d56baf308cc8b9f78d83c5916642f610c7f99f799e8f1b2edea59cf67fea932a9bb035ec14910634fce4253530225b1d982b648130f68624de3908f22c4e4264b75b334d626f142d7964313435b818b7f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
