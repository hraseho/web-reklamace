<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33d9cdd384e6345a03e08a5eef3a9dba75c5ef90dcf63dc4f6800666c0b60d976da6664a045fc6b26c574273709046a20531a9b10741e6661525582636561137071284ebc6b8ec00ea3dae51cf3a6f68071220a8f0a03e9cb0cf4d7cb4688353dce9868226422cd45d0de18c7acebe16f68dcfc557d2e26c267c458d6e212c7bd70b0c80167f60bf8dd0e78a848e497f22a5a2d74173074d9f214acbd114a4bce12b563496d3be4285a015549de292101c32c256a1347484430cf03f732d6744a0ab06211d796b9b2a0f5f5250fde11f0d0e63cad05bfd79cbe1d53d9ef6048e85b07f9ad103de52922f9c9e1e272f4827c8c8327074cf8bdd895f055f87051e8e9294694fd45edbc30896bb64df95748619d0552f5312bd6c78ad99aebe51c66d66d4e020540d600a56dd39d0de06c489699438fb7dd27baab97c2c26ffa1de06af47bac4d7a12e61591e190a7fe9174e96f665377ced935f26b73e089493e667d7e8cd26d0bdefaa40ab0a65522c63585266eb95906d083e2e1ef762e5853090f863746ba71f37d4266a32a60232f869c2eae1e81eca99c4b83597a187de2f0daeaf59066e684860cf39c9ee74eca05d3796b23c72063d1f86411db1eb2395b67968f51ae8a96ad0e5bfa1ed586d8b2bde3815a4a902da8f7129eae228d0b67ad2014f0d76b34e468056cfd7d7673a1cb26e04caf19dfbc6ab90bd1346cea4bc40cad97299044c828956525406b7cde9afee47fe71ff63af356540dac5bd42c8b127a99718dcf74136818088eedeff42ae23d0aa4529d4e00cfe30658046a53ca3f647f758f5c41dccfbe2c979415697cb40ab4e8025b456c21621cbb7dbdad5c8b24891c499d947516e6ea9bcfbc0367445625203abdd58552e5ab4c8bff6acc0d686764c75c7ccf6a1f5835210d1570b37f05f66772ebe7f1e4a7af81a9be1e7fef81fe280a7e5d35fa7b736dea84eb07bd3b2d3f4fcf45425dda0b766bdbbe504aefedc08fe1c586d8c33e4fc0facc2e839d9dbd6b6e7d367b3a59eddc1a8f3f38717a5fdf793eb51945fa31643123b314e125483f8923b2fc27362559a388f219ea8bfe18f011457810e822b77820b419963836707d9b90fb031a7041235225215132649ec86bb91c16ba4ec40f1800a336a7b35fb867f52d3317af744744aece4185134f901988cda6c81577cc31fae7821dce7bf113828111b01d9c44f079b7e1d19e8941dc2fe256ced71ef314b43678f3a5626be86b3d271fe1647c1572e2086b8beccd917a2a1422ffb21b6865ae649ba0cae6d255080b0f8f73ba17b69ee5577033e0e75cc8539269508d28c6bdf1b200b6448ce7f7a325c8da015a0246617b072833625ab7a69223ba2c28e6a1bc5ab155f090cbbbacabd5f7f1162450791f45208cfc4352a5a545ae0db3e5843f66089856307824124d17fa8bd5c643665b0e214d8a83c471fa80cf2a6021b1315768d531439d7f71eed89852747a4e9e33c896927f3952d68e5770361b98136105a317eb867d9d05b1000b31b8926b520baacf82c7a8747c4affdc7b5e5f504458ecc12a418db73680c09e9233bfc133133b546d83c1d96e8086319e560eb11bf8bfb3b1cb61658034c191ff57cc82476d74882a012910f45eb6b446379fe18311b3caf79a10760c6dcb9f9d59d02706c9a3ed0a6f3b804049420d3012fd7dc587e2a8922d760c497acd3e356fab4a9113cb921fd712da3c936dc6a64a4f05cc3191318b7fc9f05288b9f279e438cf6ad646c0ee165d7919d2744e0348d07232a6db4fb3d71bc450ee9dff54c228e7cd7d8e9c40b20d656bab1c7e964d7c208bb6552f182014a48e43455440014a8449ff00c8c173b87891ede0f655d82f5d2b6e72266f61fefee2b2fc2cae12754ee0c7beb251e96091a462ea0f7d0f390addca698519e35adb4c3c2dfb9b667d4bac7adede92666c8a77c6a222c95c8560ac35db8ebc43653721f9998c0fde796edf9d2b513e6657ab95036c9c38e8809bd040cc116d8f5d78bdad50e6ccfe80e86446e4119f0ada463dbcd3592b4297d242e1198328e624bca4ba77358cb8bfdc6514939234322b6b0d86112ed1305cca4267a1dad9136b90ef05a3ad2432046c838a38ac8376c2fd94be2a1fffb9d1c66d95a9dd80c17cc5d95dee6e6feb74709f88fb0b8639cd68397c5d42e3dbfe0263ad451e57c943a69f05764b384a8a2dc95821b20238a25df9e092893df9e10b22fd6b905bcc1490ace2971c0b1ddcc640d1d34c29d0895194bd2e6889582095505502d3f850bc41ea9ad9491ceca19f5e5154d2b6062bc779070aa70b4f187122d027e80a01d4d29cbf0ecf0411a1c239ba8a666b26dce816f063164aba88c6c472e8fbd89cc20065b0f8def4e68914c47c5938518aa788425650bcf1f6228bb9aa9335cccef243fda4bc7f0b2c49e89519485e20881f201415b654dadc349e15a67efac152bd8c5799965b8eaab731c7fa666b7c147afc27c8b416e33c28d3579edb64e02c8afdab29f222faa6168831035d03b6993c1973713868df7cfa5b3cbb408ef5418a647a896198d1e2d15675c22e97dbf148e98035df489134892b206116dbe8e2372d35376e385a8474058bfd423f4a71ae32c4d7d07d59530f4e131d285464b89daf02e71b447c968624abbe450689dd89cd1dd85c5928bd0016973896c1304d1fce670a4b79ce9cf7d86934492e43eaddc1d6766b11cda88984cd8f0775a115641e5ca82fe9209296b46e8d1b097aa0351c9340e7ced7de51d95a9d29ea1ff080f0b1ec19cec89890fbefcdf80469619f6fdc34e59f71f2da80f1a2ca42f2de78833cb29b4a94ec9d1c48f557192dca70812ac1243574e726c7a89d7509295066e453749e6120b88ab2fda54359498a7a451ce84a15a0690c67f9ea2f3c31aff94fca8c1c91e529fbecba9ed7df6e0125ea1be98a0e7590b59d50700c75b432681f222ea619cc1a9d65cef7be5a7048813a4c182d715d97256097f9260bc20f4568d0197f566594859d149211c44f9c8c4ce209606bce33c173cd85b841f15628dcbf36b4687fd0aa5028307fe0478f30b07903fbdcf12ffe181e308e148461b08911d6484ba1850aab32119d15425053058d26934308cd1bbb35c006dae729322110265fede5bc07652a834584b849d3fec45a6e395ab4665227dbbad82cb26f41fedaa43e76035fa6b11819b1f7e1170cad3692c3705d132019a181e0ea1d5f034aff154b106cfa3ed54e6cb24f6ce4a5dc5781188bddf16445e32902d3e33a1bef3b8b3cc2558e7f9bc8e1e74362b23ec40c55cf58c9d605ad9e49fcacd61aefd2153e6d541c5b5910b6a3c45860b2922cf1ed8265e262f78567377c39de7afe8845e8fff7402ce7676fbe6d7df12d9e8ba550ddbc65cd823842a205bc5db3c80875b67d0ea28b714e412314daf86c4cec2c7623d1d5e5d24a2b625af67f66897d40bc61803574b83b3d1ec2baf3cfc0cc0bd416f6fab7287543563ac472620a968f4a023ebfbf18d8e0f1e3db7e8aea008d64e711de2a56ff35ea8b1f8638e6da8ab543c13ec3117957e0b548242194aec8a14d50a19af8355aa750dad6fcc8ce39899126fef119625661f213cf8cd256cf7c30fd31e66029577d5e4917c6e612af1be58b5a324e65981b2c43701cf118183655d75f66151651351d10302cd6beb0ff217ce244a46d0683c87c12ae02b26fdcc997de63a0d171d4fe62323e8ddfcc615e1816bbd8237d4ad4728f54dd065103e5ddc25d034319248790758d90b9e9b4fd8b69029a7c49edde78f9426667f832db030ef010986af577cc53487bd3c40ca01a8dc66ec7e47698071ad40855218d103f075277945c4419054bfd45083d6aa5e7f38b4109e0f07c07ead5aa697b8f5405a992b11aed942d76387d819a1c61778e0ef0b752c413460d596ca9ba848d265a9d2aa98692338dc69ec539664773a3bbcceb29fe4817eb72914ce6bac3ef40a6e84dfe8b8a05cbbdb56ec4afcd9c9e612ab9f7dbe6abd3f6914ba1cb1d3f4469f9bfe4966025cbb1c6148905882f672f392325f9d3cd8712e592786d3a9a52ac839538760c77fd61d14a47b68735691b921f7894e96b9dbec2a40805d8685d1af9c4e39fe380d7b2d53a0aa388e577da1502483860bfdb97923d7e5946903706795c65eb790cfdbe29eeb6c81a8ac7a1f5844523600bb64b1ef28e10d120fbaf6017bf42684cd17b1b807854b8129b9a7581085824022df2e9bb974e72817ece4d7f863ec9cb5074a2da6dbce8867a4813ab4944bd6affbd901ec345973c24e90a07696ab78594a3387496d58423ce0ade20f451c968e639f8ebf6da6b08b494d5adf2677864b1f43d3d17ba701adbb57938b3e6832306279100c5f22646b4525750d9fb13d74a78b35dbc923af6332eb2cc30bb80f714ce502e2cc93ec206e6125e151069b964db831e6503b6f40655b94178fdd50cc90771bfd300b3a3469085240bdd72946ef7711f98f9c8eced17fbc784db776a1ac790a7cb927b28da79a08fc6d6fa24e6889349123e979c0e5db2083c695fd8e63b99b6d8146de50741b98778977604e5b150e1b1aa3ab8a2b8e13b6e190481c48084401e793044d45f2bbe28cb017e57c7912e22f4895ae639c593fa78bd83b80b1f158261bb48a1416933d88ee201565d0ad250f98fb2733d1f22939253bba334a6543235d3240d69828dbfb35948c44b831cb36d452cb21a5540a58d50581069c557954b836194abf3e29928845f311593c901a1ed9eee73ec5f8fcb79580788e3e4ba252e78d3acecb583c1ca542aabee6dae2fb026fa612cf2eb0abae12147c7bf32d9c3eba978c864932560ccf06d95dc8dcb1b776f1abaf7b279db24041dd1b2f1b579fa761ed62533c00997a92da402764602a3cd57e625666b1a92088168d62d0300c42b7615bfa6ca131018d2103e288c026169f63d04c1ff810074c467a6418b05a4a3e2c52865d1bf2d8d68b097f9690a174e20a69081e0bc17a52a8f7637cc55f946064818b64ea22f1cbbb1bd7ef453e95ac1f73c3e7fe1cfb8c8cc865cc9f113bea66462159ea09962412b073f6509947201a0cd30e0f06bec1cca9961713a0dfe86f8d655a663b4b4a03f6913074fc6cf0bdb7da3c806cac03a1e77b829fc0317cb3e6a9b4e6232d334b52efbfb9d040de23792c3112b0bfe8fbc357af3e9bb4cfad3f5a659726ac9a35bf6582afe7336821766e59d53f8776fc2ced16664b54436fa03695aaf2b39fbb6ba2b1961cdca068aeddce06df527048ebddd6da7a04ea6126b072281997f343ed7fda71e918e1eab74861abf5baf77ae502cf75ac48f33e22beb81ba51ca0d7d28b4efee2610d4c44a6a2add09705e60175e49bfab15f75d88963ee0c213e403d9aa48d3611d36e46fae4d85e6c732cf647d6a5aee5fa56e30891ea1170b38906b825d66ac438d3a603195e7d0c461db02ca09c61a13a98fe9150b34eada1bb89c1a1ab4e8f06ba4857cc837980d63f0e7f5cd280fc2fc70dd45a10fa9640cfd623e6c59e6f1c77f5754cd33de2b1df8ef278052539916b4c3c6687a75c53172929cf737d6a56c0e81e8050d5c48c1f4f1738d17d34ddcd8171a595dac1f77dc6879b791e5c7139398843cd5f7d70b63f750079f34e6aa5586b1f10f07232d92b43d0efb790d753a29b04a4346ce117ebacc403809545cbb56106d9bd793a78f725759dd888d9d9233494ea787aaca779e6deeae6d4f97297a41314a3bbd3d034209a875dfccc73cbafb4231507a0fa6272509162f2f34ede54bdd31a08432c173da5b6f73e023632ce80e16a8b821f58428fa6125aea14403eeb7078b4c533e2ed937a92589853870a435dbf36f83a741db6d786cf014ef9e097ad566121f718423bac12a9062b9e87c9bc7a180ad8b5a7b6e41e128510d87211705ad102d16b186958b96b51364e885c3cc8cd6c861742f20a9be54cc4c775eafeec000b15622ac890972c74c613bd3efcc5b0d65f57b3380f07cb777b27f6bd66b4a4dae5140bdebb05b804fc9e6f7a5b6854803337510a29f3c4080bc94a7695b4150195ea11e55291fe5d1f2494bfd68d05003a0c1258be855f08ae703d78d9294d8f3baee318a0312b72472fc3eba66dcc3420801cd01ba333a124004901babf7db33b20f0b4a4064786c63b5278502f5764dc9d983914bfae9bb9f0eec08cb61cf72c3218328b570a969ddaee8ef43ae098014ccc3fb61f5e55de0f4758a766c64df81d50d6e7c92ced3c69316d40e0e4af9abb8d2fc15342375c2e3a46435034bb48326e26d8a859ba757f476ce00f287b7d59add1511c405b6382b50545e20a81363b516fd92bf6c0ca4f463821eb5f24fee3792228202f89566a31ce8089c24b8ecddd8ae8d79c72e517f150d1b2d1d8c30f4f1f14661a872220c8ed89d15d018fd0cd0051d840f323bad4a5df88885ab9fd7e01e8881c88f10be7787c9efedad3315c19c2afe93c0903ce8ea275e6d3bf2b30dd191211f8c5d86956482c80e38fe00c25252bce50421fadf85b25e28fd9e309e18d5fa3bd69a60bfd67c365aad08b018a7685c4995295060c247338d94c3b9d3fdcb17e981c867279a18c356015865a738a5be898d6e1c14f937af3321270eead6d88553887a1f72c6f2afe443a5c7fc0e7b2e56b27b618082edd559d3cc781c38e4d91ba91b6466e1197a32f529398fcacfbdd4cf5a7360b4f987d9fcafa565b48e4aa6b3ad05fd661e72e47c765d85be814dca85497388926417faf8ccaa3936fb31e4b73944d3dae69659865b59afeeebb54c43c764bb3b6b858032539ef8006619ef0fb6d106a6e5a7df107288ef7e463cebcb9f7a3df295cd7ead348bbd149e7ff7d204c856e6f3da8b9beb01e0371019650f21acc506563fca6bbb67edc6d7977978d4025e61d0ab9291a7f4c7e0081a64f72ca3ee505cbbc181411f77997d042fe15ff89ffc25b41500c7a2639217d3f0513e78de442ecea1158cfd8c80245d11929ddcc8890dc7dcfd9043fe155ec8599306968f8ead1b2144321c73165417929b1fd9cf5b1092613629bfa193610b304a463c184b812116c8314039280bc22933eb63d016375793b80022f7b213b615d5a1cd5267c449eb337c7416396e0f9b4fd024fa80403e9c5e7b66247b308a40cd651da57636d0a829d54a5b0f7d491d98391e4a675c87857878c8f23cfeaf2c4825bc042938a6adb93c0592506c96352539b453cd97904ef851d070f42ab2b98a6da2adbc4387b52328bd6d0b3f78981e489ff9adc76ba6c59f2ce679043cfd726085838a8fc247ba754895bd1c20ae862332e07b0ee4479bbdc11de2c45987f0ecddba905e9f1899ce92632452eba5cd7acc8524fcbc2cde80bd575a092098104654638061d2c198acc0889c63e75cfa730dc2a79442f0e64e38d65bd816223169ea556aeef91e3449eac3f36bae4d6ce893ae1441edca732a7689a35528d0404bbb7af9584f18184ea96143f8a6cfb100814b415184a096009fa08510b7c233a2e43fb264849717884ea2e3fe377f67a15d07398d587868c14e2aece390f81bc2250bffc8b2496354835f2dc4a8e1c528d7b50de2a310d9c68b8814559bab64ceaa41b9c9bf7cedccc62601b9f1fa883a088981312fa74fd4ecd207c3ed1bc7c5ba019318d0ce5fbe51e9ecc74da05639ed425bef20975f36edd175a8727be6e93e18a41bd6044023cd4cf1d769697defeb2aed7de3dca5520c4128e5e9213435828e78eb7cfa0dc0e30585f1d866dcf308e94a88c13ca169c8ee2032df2b7a34db0915a16a9455a190ab5d994d6b7da0a1f1d4a08146523b1d060ced5bffe14e1ba514061e769e0f7bc01ec971977c017fdc446d76bde25aa69819e32142f192826d18ba367a69408d516d9e135ce2482d52cf2014e45e8a56f76a6af1faa9f3a9654d5c6b4dd86a6dc1460f9ce95f4ca3dfd881fbdd5adafb8971a33deb22d2f1aa84e3abb2ffe6683ff02ef03f50c672c248c90022b43c6f053054a873c9b4b7bf26f116cafb7a8c56c4e2241fb67c28c099a31433427e215d2337979edfc9b76c64034e06200abe35b3b45f826ab92195f1f47aad960e500b5673b77ae560fe1f8b710a637c2088c2c8f5423f3afb6c0446ba0bc2026fcb48286f1025510f345f5b5021f09fc6c85131622b22d7ae19ce2272992db8a0063be5ecd1f022540ffc92339ba181fb82b5baa124711298984e6af91c91b141d8d8c12263153906e923ea0b1bfcd7051b620533fb465d65cc79335930a9e8a6ed53f2bee537c6d239f9b09e43b6fdc901adfceaa35334dc92af7c98fc492598d9356d26591c5eec0516f5469510eef975568dc26461f8c6533d555e9470e2338b06e21abdec4cd9ded48df30c987398331257d6b67f02b538eff0322d9d8498f922a5215b3131d540456bff54cf0b3cba43584e9956fd290e0a8fd6508239ff092d2b2b31a9516d3a53b567d48d47b09dbec71e03d39cf22d9acf31b7fd3662a213c5c1f88af9d7c98f89155392d1bbd41b335b6b701ffb96f5d85ec9a8470012784765f2e28dc2c3d34cb1fe18ed6009a3afdf5d986104b69071caa24c6acea0f461eb34b2fac7ce9c6a58e60aba33f1b0b6fc3225d8e5b215de9c73cebd823155167aabb27f839a03f26cfb3ab62ef46058c1ffc8297dabbbbbcd0fd2625e66a9b6696fb263577f042f5e0060f5c0daaf98031d72a3f9c77bf1daf27c1cbee6a4f713fd137d4e3b567569e03576e325b783d028ddd01519588d8890255dbfba346d8de45d00416dfd0132dceb7fc941abd3e087bd08ad2a5c4b01e5d117f122294a3026cdf94c58ab7dc8dc4b03ef1218b6602a73477b32b266f5137ab6a5e5926969089fa4c68beafbd95f7c8033c03f4e0866c50a2d79ff67edb5861019dfa8dd09e1491a9b4d2520a9c2f2bf9760bb067a17325aada5086b7573adc26c1ff52b7e4d5590a4df17de920d9e9efabdf1d9b487aa21265c23823b1c60135e3261c5ed31b55900ba8d01aabc737fa80ce3357cc066ea8f86468f5013401b58c38776be2ffe27b6ec9846ca78628446b8fdeb6011d5e6d0eaf5d43930597e02bb82747e77d0847f907f1074dc0e7b338c966514eb5977de0cbd26633ff76ef9a5ca071287524004e0e754f314fd627752d7133522e7cd7f5644fe223f56547788a91267fe9a35ec2812c0e7d42a6ff0d6d36529084943157d2dca078e567917ad701065ad02f1c6054598a2302a4940c98f081da42120b5aa1757bc6bfae991465575844ec6036df0626a54c820005c6bc0a789ca1705b488b9a169979f50034292f9b7b13d485742961400cd4e61cb7cdf989f7b3a44390a04320d8fec58c9b12370feedc8a4b70adbc681814a952d940ae15f532909d9dacc0fb653501def2ea092b1b733ab3e7761dd9fe699cab284ce8c3c807c07934c1e4c33383a7dccd73c0e887099009746809dcb865ac114f69e8c1a24ec493a4b4fe1829e359a7e47bc4c89a824ea452b9dca521ae2c977ed244f0f82444b1c8ccd29660fa32e6a1a122531397548a1207dff6a465c4e9610d667b4e5c91fb00c05b19be75db2c1d1a30fad145649eeb27a24b7c28dc54840aa6cfc2f7fe76974dce8b9ac477b17f83b44824d8ad5ae29f3111d29abcd82ed25b5569a4a93f5ed11e8b41d780f52e7c0c6b2434776501c9f59df7d135421ffd8d6d2f4451a08a9294de2c672d13cc7c21647b1b4a39db79b63f201154cb409c34c8f53a281e4562ac0f234bdfe8c46c2c61fba2f60c5efecd397d5c01e8b87c9787f74c11e11ad28ab65bb0f86ae9f66f686ad8547435ca0d9cf0a0e19649caf779f89bffeb9ad174ed4974269df476412f3086e752408a7d6e31245b8ef996c0471a744f4ebf356499984aa3552dfb8948ce7bc234f9701910f9efaf30cffac99fc4db7b605a49dccb56932237db9c7c17823b944cdf6e5895da1e761fb4f4682f6ee3550e3af095661727b8769a77f6c42353b7308d8e832f66bff0eb41391d63ec546ef0545386e958ce1bdd4e272a059048b22986586009cb1eb06bc48b007cbf3f4bfcf54c416bb0222ffd1a9fc165ccb42f019fbae9473295ad91abdeeb9f804ef427896d2991c7a6b97bcc55e39ace171f441c345549c0856bd25e1582378f2f15121e9d156c935d155874b8f22653f0c934758f7778cbc4d326112b23de83c4326c18fbf256ac737ae526179703f7fa7ea4a9c6257b3ca1220baadb3c27dacbbab1bdff4be9d8da6f84b8c67ca620233c42a0f430294aacb343c24eb1e8f66440c7a3d95a1969e9a133a5d78c42d6ac19dba1e507d1c65a8c38fef9d768b73979efebfd50ae3b0e7f4e87d00b5e90419acfcadc1b999c9bcadc0bfd9d982cfef1c8d23ff32951a225c5d42a2fda35b2d7e8f09f7989872a673dc6af898a234ff1e7ad7275b0401dde403f4f4d5882b105f4ad0109c8e3a93cd3745ab59ea1f7c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
