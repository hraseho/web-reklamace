<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38be546f01b0a47f6637a19a1729d86045b6e8307e03cf0356bea6b2ff26f93640b21a299970736a2bc24313378db3cff3fb0cfbc6b285506eda485686b37c4d22ad937f6e46048c38e95e3ce08ed34ab260cd8142b7d7e3050b6fc5c0ba63387a98e1b5ff20e81a6fdbe9a48777a50cd396519c0dc00070c5b801936597f6a4d4ecdddf3587740cf1568f1fd92d21a98b5faa9b2a900a450cc8faa9404b9ce8d7e257392798a7f68550b39a303de12e4e58bd7741cd0f979534692fea9543c50fecedfeabb450a5aca95f796e4f1571899cd238cb331c9701b540046e894b684458d21c294e2482ffb409c95628599daf66b3d3d880446077b84fd428f43c490c05397606f56dc686175955e2526103f1fc8f5a451c3f9434e2d5d126eeacb0beef1f6de0a19eaeba0263cb1dd29dc911a211c8182792d9a9d887ec6789892af9aca0baf9f418da1d48202022478812acaba14cd75252b70c0045cf5af4cda6b02b0facc369fd0c01506921692bd69ba96ded4dd4f92b979037f24917ac98eeb0a81a52ea549787d5d8e75ffbb29f8154d21cb884a8e03ae8fdebb1aa7229bd073907ae82b54f43f104cfbb2ef10a36604f35931b8a09cd91ce41e377bcb46148837575753d52b31c2175d0a88dc19c4b99fa695bc7b78772103bf75fac7afefb0154e1c53bb634c7502ecebb80498a441a7a6524d2f24c53847a1891cf823312f9da7e51c8f7eb094f97e281718994ef1b90aa7a01655cd1b3ccf44046107b2ae445894ce78fdb34930d322fa4b17de2006d74373da2e79df5726f00b6e97bb637804464b4959f8c58b884beb91387a6deead119586ad1c7f84bdd2a5ea01cd76c6c9fe9744f9e1fc178e1c67e3c994b5d722da66e0558b463f3c836d640a04fe72b5d415e44a72e5118cc23b5beecb52f4d7c6721775043b8c5e2501a07f86e86f3a8bef92782804fea7dc478107d5552524afe44cd34d7a88bfc46d2985a90024b6b430a19fe9098b8f00086d9d4814ef932cc0122f6a23df54e6c5e95adef658919bf2faf99258a3638b21f688fb95f814db483d95b2f96ab599e24070f5739d5e6b450f0a366c8d1da7698603fed2e4dd323bc092b2f18c478fbd3050e47410b58ab5f26a25241832d3efd819bae05888f33d349336603794a785296b06cc1134c8512f26ea45256b04c7bbde470f5292e134ddff87a2baad854ef5dfecadcce5a659b34219f710b33a61d7f34541a0af2ed89074ded3abf99e3bbd5513d312593c3179e62bed6a3d76f5f19a4ba34c8734f3170633643b2006b3e1fd0a61c4189a70f5f36bcbea1804122bc0730dc466584a6c3db55f052487ab6851b9ce3dd73013a6f3498a814904844fbfd321c467bcdea5c0d65f9c6d9deb890cb1b0ac57e4164c46b5e102efe329d8986a5dbc18a7a01496d62bba4637f471ad70864e223cf8108bb07c37eb42133173c08a8935191d1745c55ecdf46a00ae25b01dfeacc30731dae89aabc61e9814ab0f3f2315c38cbcf468ddc69b619336504aef027f8f2a07b6ac8b60f04b6a86e0123f78a522e265c460884521b73b0383e67fd4cd3a14bcb7e8a66715b3a2f39c6e7c8dd37031d3eed54e4e96f6753e41e1fa38a7dac4be3a939c8d72204763e8e52a86fffe65a16e1cfe2a5464315ea81ae8ff2635dfe202da68f71f5fcdec791bd630f88110c1068bc81168899af6dd3a79ed44b78312b12a3dc61a6c92a5640a5f14d3cf524cf1cc9a770894a3e515fbfd374d1cf99bcca23367c6fa58358bc983bf425aa54fbb3489d89ff08a61fe2c7ab8470068ca0b42a06d231fe7b3bedd38336a0bdf8baaf058b92ce8e6a5193df26af78bb0cd86e553233f4cc33061ffb4804325f423ab687839f8a09e0a9ff496e095ba8d2874082c15afa4d1302c8ab144a055284c71c7391ebebf272943b5322fa97d66f8158e72e5b4b2feca5d7fee6d06ac90f14586068ddd909f4f11a1a592e8cb28f236f998671275f1ce209b92ff03b2ec908e35b4f8628f780b4aa3f26b4de5eaffe021c153a78de5b54b412ed70a9503e642dd64ce2e983e7f5383ad32c17a3a4fcafe40bf41f10106ad6b7a1c1e2e2d38d6fbfcea984473d438bcd1cfa3194366fc1f9c28dcf7fa4fe10169c2c4bef5bd5743d4cf9c2a6a56d306c7c230706fa199a9ea4217359a62c5b5eeed72e7b8bdbc2228b6b644c7a75cad5d7497211cc7f65b0bc55c34f7163d84b7d0ededde19229a6070c536d5ae45a51cf2d4347a09726d63153ae9bf5b9fd518fcb0789d73bfa1e129c974fb611586abdaeb8900334ef94073db6587d4bf7c1d384b74bd4de53a6a19cfcfcbe5eddf9fe4123a7aa8bf89a0f3988b45c63dc19fecaf63df510a032155ac736f13e6dbb38fe2edea92f8b8f6e659bf95403e50039dc2929dbb4f6fc6c3c5e23a55d07cb274cc5ba19c59dff86138bbdc8df05cdb8fe4898589ca5a3da53098ffe3c5fc8993c103b20ff3deb9d47415ad31b22ec47190988291a904da29a8a5c94a7f6ac8a4f2eee6e8606fe4d9ea7254379d0a67ba8135aafc6e41d735ba05a347ef686dffccba32b287258d329c7a8b85e9bb6b6f66d03cfd9244715a2d2ed9646daf3ea0662cc64be804539bf4c70cc361392507527cfd511c6c80e6a830f56f100635f642a97c3179010bf3f797655da07f108cdee637bfde3d3f6cb128908468e0aa79d01345f29c7bbd9769581f2db7a73532c9df7ce0aa3d0d2b3500a3dafbc91ca6e398e35c39d2a1eef1875a25be73ea0b2f7bd92a64b74b3615830c480ce32b8e62e5ab901b77eff0d0d5d1a6e3956616bfc0f8dff73a72d9d6a650e932430360e46942925199a735737f43de97a07bc8eb454454bb44113f7d90a90206faf9d13bc2925ca9ff4d56c3cb88d2722cb8a80f2f9ce1c3f6685a6b47518cd933f6135834c14615ee5974d91de77da22b8b9967d6cbed1a3a86e263a77c652dc92f06b9c647bed684bd11f0d20b097c6e11043c04f176fafa89d763c9e06b5f7ece4d97e60b6759de82f8a612497a06e28cb31b8ccf8e31e27cf4f00bc77f1066dfd4b3813d71193692e7d3fd416d4ee58d879226d2f6f43c483ca787bb952cc7fe4895299c6624f6c3605616c14c73b59e47c7bf5dc8c7aa614e2a22a64ee98c67a1a2579156e0001d47de9a34ae19f1fba1c5115bf9916f67bb92add454308b0b76a6a40d970841c50e3f52188d9aa953112410dc91918f16cd9d6e14917ea701864feb8d573ff752aa4cba21917e6999c9b4c15b35a27c0940b34c765095f08c77fcef1c823aee79293eed5446a6e3c9eb60461e3eaded6fe9875385d65026844d281d0f389f50ed3ba9dcadff229f0be2ee8bf4275586c2d2a5d5f3eae2a2aaddb8c1078dd5d2f045c7373e295ae6f7f3908c9686841c96a6879d19a74f001e8de54e85de8ec26e7b3ef61209a6ca1a23563dafcccd468be9a9acc73a76520e3728057fa73e87383e31074995bb2a7d452df65bc9a91caead0d43ca1c02db249b7c9ae10a854413c208ff20d77b7016f3c57ab5aeb6bfef1d587206526f069855a9e93a40d57b5accb72dafaec16b0ada8bac97db6c049ef18623390a774bddaa3efdbddd9d28be6b3d002761ce33bef20d7aa88699a15e0e31ee2e22e61cddd01df889de1ed203538773121fff4c07d185c18e49b5771091e3a81fe170066f84069aaa90a19490a0549f68d8c271a1761a46d10394142858644c11e52e2cb4dc10eeb74929a870d62d5fa4342dc8b67a45af3adf6af1701cf199e4c1420fe4b8f897909e317ef3ca2d77d4b73a642190f4f8768a242ed23427aebef9b6b0917910a86207d70c73ebf721ec49b133f639d7cafc41f17f6266be356a72bf02cc8f376c48a44b0422ffbafac18236b0a08040c01b793b4c6ecc0a43d0a4f2969c0d184955856e89e033b4aac3ed5e70965d585078cfb53e691ec350d882bb4a583f7b375fa7ab292e24cb62d5b0bb122ab5b30acc07ab8caa621e54af3230c288cad43078dca019fa7730c13872f131d38680f837998bbff5c1231247979046fe210af87b9ac27cc488b3228e114db7b7032322af159ba5c8ed2edf60b8a4094971a82d048b35e4e15b1715aa250689bb9b6cf6602ba7c0a58bd6633f50ea37a6e5acf3218f998c2cc41c18ed3bc96b3685ff5d8a83ff2f62c8c6defc1d731b9c4b19231b4fda44f8a2296da7758d89689f61360824dd3bfd9678ec83fc8aa555c58ce754f329a2a503e893153ae9d04c4b11421d09fad839a745c0d11bb97cf1c64cdac988049b85a942b02d6ced1e60346d63b023760cc4c405c65c742656939772daba71ce556e4774a5e285b81221c9d573bce60c97b07bd83890f91e79d9c2efc5352d8098b42288d14978527b1ef50928d8dd511e23643a106264f23a2e9ee76c975730a06048fe9e814ab54df247ad0f88a65fa86ab55c0f88e2b3a4eed3eaf1354882615aed4cad7b3e77ce46ede1f7b615609d1019ffd07c42a9888c8f3c46225e394cacbfff32840630553ad3749e758e159e41c99caf0235b55b7399750953bd047da8238bb8dd24fc82d052410c3742f01d46949a2042807e0f9a8a06407198e3df35abe08c68251c5006045bf31f6dfe576f1087f90043f59b8546ff1f5d5ba3114b4a907c22f64dcd0af23a323b69b8f0bb7fd6f5936f9b848dcdabf6b6c151c04b813c40acba028239295d99496f7750efaf4da85be2d66da6299b2c21a17154e8d2ba240e215b0266f0d164a0ebbc3605fad433ccff3d96c804704b930a354bcbc9ec9026a0a86147f7c3b52cfd75237d0e4af28e9dbf45cecec2691815560a9af7d3cad017aac35107715e2bafc56d579669943e4208e5f38352a0871a739c44d88ed88821379b780ebdc694664ac9c339bec3ccf0cb26f249a1c5ac96803e0959e619185f26436ccf1245affdc486855fdab76fb4ab1288aa125f4165a4aec5becdb329d3f9c566cf78da091cd242df826363d56bd5f2dcb3fa40c82eac3270e4f48609b7fc601c5dcaf64c2673c0e33c844df47daaf0a4611fafd7c20719187979f95d8869d32f856126772888e05aaa0a1b4dac01c707234c720e8bcb1983c54fa757219a70ecfb661a16aa19d3c7e76d6f9eba9d913a69cff6c0338c5ad9e575191907261c7935acca70a29fe95dde86a72b97b9ac23f5b972281ad3252dd38bdadd183a6ec9382e15d4dcfb34e0f48e8ce1fda935245277e6b1925472fb175076055ced105872ec178db5341a96667ab25ff38482801b9f785e560643909888628a80af4fa0008e3cd3d587cab36309c6f7470bdab39c52bbd9ab804d16c007e5f82b99ee0844feba7902ad88772272e2b83599662d6d67b03f8543b93abdaef2fe1e69dd6c06f55d45d6261aff11a1b468ee1f823ce82944565efe9e377367e6855b51011d44863b10b34ca6c0be0ad879b72e77cde9ed4954085ce0bbf49fbff9296a66bca280415cfcf6a600d2dcb15ea5a70f1d0f4d79a0c1d4ac786d6bc1728dff76b7ee0271ea3c6128ea2cd89cd9abdfadd85d80fdc9ac31928a4c6f2658c0fc26947f20c2e60acb4b646b2e83edecf7c3e927d910608dc746c17fe99b84965758f158adc90b9d3b2ee276d6970921a9f1320f050d4ec1c331d41606555ecde781022aa92699cb0414f0eca21589550df111862d963f64d4c1408fd05dea85ac4d48ae075a715fade9119bba6ca719fba198d0122828d502302db857679ee1428804e68c48de81073a22f37818fa3cf7e831397ab959e2c38dbd09c00a251515c66698e9cf429cd5367532a04beebdd45e563cc88517fb7bb387a6d0fff44f75bbea9429556dd9ed4255cfe9c3461ab36eb7b4dae51fe47e53ce1f483545d2cd2c39a4fa73a4b3301cfe1ebc2d3b850c359b02ee073807a8cd9e51c13ad0a8ef23c87c39c44c80dd66b1beac29d97d9a303734c2480ca2eabad468630dcd3c134f06831346caa87fc341cd709f71329603d0d4b30db1cc3ac15373654713a89a365e832479331d7a95712c9c9f3781797fb5f233cef5de35c2a7072b26f682a6de95a89e3a10113fa8a38278c63d247c43dd6a7005b213bee40eb9f761feb690ece0bb4254eacc851f1b9fa2e149948f7b01e2a225709bafc05c68526c449a16c610815d28bda8829efcc0e32e011264054ab18ba3293ac1bf014cfef53b17d91abdf1528b6096a91dadc3f6139f943dbc64fe9fad1106cf7e84c1593725158314493e5a8b72347d92bab68f114e3b423e5492ec2c9ffd9a553561032a7da20ff12ebbf22d9195fc9ba907e0a6faec40dd5e0d032e5b9321b3b22490178acb1a0cf6e2e138242c2a089e8be165fb06c1f8509069d05402d91faf439a1b7f5b08880bce1aced754a231d7539dee61289e872a38f3dadef631cfc89013407c86a7fc832fd0bc47f901dc71e3dd3b08393bde40a0ba9afbc7505a206b115d714b2800ebc4f6df5f59f1bf57ba9590e620c7d9a4e0468703d3f176a301e457f7646f11680fded44251d58663c0b7648a7ec663e452718ec85a83bea18d0660c07765cbd11f007258004f757bc94b405a17bcec951d687a2c05d2e6d1de6f0d0a325ecafc8b623bcd8151c0c314ad9da319018d2e39abb524556218cfcd13caf1f245945fb51b50f19e4fbf683e17d4ee84bd87954852aa8e3df0016d2e448ccb74fc4dc20f5b7a92d5e63f31c7fbdbedffbbbbfbfc92cbb69e3cc815bee176220716a377cfa2ed03ff64a628ff336b6a07b64403346e15934eeb2466ee01ba2dc4b85566c4d57f730de40bdb7c56b605bf937bbf2238535f55af093a1ee0c2363d7cb4ec07675989cc61beb7423c1d507587a85431bd9b6182cf2f74a4572297011b92f82698f7176f8fc83836d689d4954634ecbb5065f963c92fdc0913234f707ecd8bf6ab7b597d0ae752ea64eed93819bbd5b025f44322af4e65f3198f393db4d8d4275afc3244042fb9af63a83b87c8b74271db007c01063023e6d471d02785fbc6147252f8d30fdd289ed173a3da669d31bceb7b446d79cdf1ef6ce292a57d8a2cd6519d8c1551a7fb9fcdb233b1c35d74f3fe23898b3735b6508989b53768a100c086bc903538e77b76396a9e8f1475b1beab50a3be9e89876930f76ec46196723a0071b4216aa10dbd0e96713e31d615a041f418e9c12f5b96252be620d0e944b4e9fd6fd671d39268abbe02e30e80cee3a523de1fc0a5bb03e0e1ba8c3d3e0b81ed8947d6518042a46b053451ac70240bdc8cf9d3a80a5db8847ab5e25f7cd210c05aa90cc33551207dc4da1abf430653029bb2347408ad074141eea3df48bea858b308a037f5270238c7c53e4cd922fbdf19b096a726ab0602cdd8727b7d78b10ea565d5466159dce931aca5bc8912160d6644ae10c3904a866f98755e90b806239c9a643e157d4fa6e8e067c0ab4710f52991b20d7893ae3fbf678dc830d553d6a033d7244fe3a0ffdb709d017ac70fc78d20335ff5414a79ef5ea7deb917ea1243dabf18a0a44044946388cf24b97dc9d604e43ef364001bc7ab5cb76ed659c45c55d1d7634da83f9739c4de8cef45a77ff1fbc5c607256c18b226c2df644be64bf38e7129fd122d44748bcffb0bd7813fb6c559a412584e0b39aec1c4537f9dbfc64f42bbd54378e96495981d9dda2aa0b6133a1608c6931ca47c4245ad4125fd86a4ed5ec37db5b657d861c09c7306e72437b45fdb1d46ee253db0519b2135ed76b7baf5f20890c7ab2ed065ea6396e8037995edb3a51ffb7f78e08f707abb0f2379ae5312f5384ab5d6d8d3cb499ee21d2086b7d5ed6245d793f7083d23ecb4a1327859c9d2dd0fd5b8f4eff720da6dd6d051dae284f63db7c7fc5401a7b34ba382b3edd64e70ddd17929267874792300aeb3c95ea59237c3ffc5c4a238e1246b7395c9e67213053a4c18e8bd6d2ded822640f85cb26612bcdae9fe29eae187b1eeec4be83978b04cd0dc54e0b9e63f75c21e4f5c39aaee32f90fbe6423a83f0d2c663b0875549ae5cec64ca484a0890ba34db555ac9ea45265a535547c3ab496bbfb986f00bcaf0a58c844d30488941255999e35a9f10e78c90a9567ae9acadb21ec3b555f4dbea7eafc7122e511d6a014d11539db126715e7ba09c354e0b8753d77db5bc2432dece317169cc28f90bf7ccc828d10e948d10c4486f6bcad6b9b3ff7739be22ca9436b187db336f3aa141ea32956afdc9b73cc91a109a2167ae45d2cc9e8591fc56d40f1c85fb75ecd993ea4e1076626e160f1871612623000fecb27907c4cc6ef943b7efabce27417a4a8181bc30434dd71b9344aad56ad73edd2b23b1230f9dba5627f26b2e487472306480521dd62d9bb2a567b3bd3e760789bdee34d85bfdcc82d33a016777d1089ff86d7b4335bea68bc2bd57d188a37de6d2bcd35adccf6088d9747a4f91262b628dfd61ecaa6fbd67f2ae8dfd359595e0f1ba4fb1db8877de53c3dea554b0573a86eadb10cb4935a91bf47d939ec5033d7bf2259787fe09362de2d6d1052204c6c0a7a6d376a523317aac497583f7642029cbfa42b31ace7867f1afce60f77b761543dbf3e82414a9aaad4c9b8892d8fbfd584fd21908084b57f8a886724d191ae09c6b394786e21e9981286a1201ef600ab68bf19092ad22a58f471829045c8bba88fa28c65e3f35d9fb9706b8f6e94e72c877dfaded0d74ad077e8c330dd48c2224450ea5dbee364db16fe37c3f184dd38151cfeb2ae3241ed425f8708c1a2dc49391fa09189cdd14621df6206a5997a2e6a1d6f82e6cdf8dc0d1ccd40e56734f35cbcb64b23961ff63b34c2e6c42109210687a8da4161ab4806673d7baf4c4dd0411cdb03255ecafd5461c39ab5c6b3a8d797cedcead6656a9fbda12d70a68b51abcec207574e6e03a28a60b6275a3d03074bfb2e9caab5c5224075abb53908a3b270ee705f6010ebf7fece15c8665b2f1c3871b726d6cf1d7cb6644f2630852b6b9f2fe33e4dcb4d2153d6e63596ce345abb7279418b232d51fb7a54eaa54529aa3aec8aca05b39b6053376982148117f70e2598491ea6ceb84dffdb238529a46bfd9ee67d4adb27d63ef2015df0ea5413ee7ac81749c7833b473b6dc35cef4d38f4209a512eed193a6d3026591a5381662bcd3aa52d95be70239fedeac63c1182f04f3bfb527a421cf77aa6ab955e99d851343da3b45bafdba81525f9032ecf967ad1fb1188134502642aa26c168808c53645e6c6fe28f38ce85759c3a6c2e31f8436885539d041e24ae39f7a9aa5fd3beb333bafe0a5837b100f432a70b93b9715475e7413db601a4f2a4f01c6edb040be9535ab174529e5d071164e6dce3d68c5e7efcc7419efcad700426b0fce618bba76daa6b2acc6a0e8ddefb6d561dd4c1baa7b35021b974bfbcf961f690a043da9484a3d9becf713cc6431610cebe839af6aa83ec0e819402476a5101ad9b741bcc40073686c54c9e1f646eb8e7e04931966a17dc0e02543a3e18a38998d21e0d1e2512fdf2c760fc99f68fc725ac1b27d5ab243372e7b65de836efec295cd7bfe0a074d5f00e3d7768da29d6e2eac524919c26c7e4783c2ef524e9106472354c147bc40f8b9f4e98c9f9283ac67e7e2d0c9d5203865edfde9ffa8fbed54cc1687c30dd8d63071f6be492899fd2646d8fe7ff13c47f2859016a51d1e9467d7c837f50d29a0bfbfd33cae8f95647dde26752e401059df0118136bde7eab9362e80dca68f971cc6ffafb9a034aa64e4a675e48dcd8d38b981b786cdcf875aa207fab377afe3c0cba03fb0f53cf736d6fdba90ab4121a873fe2d9dead6ffca1dfea6a02514cfdfb9b37c3bd6f5e686c94efb1682b273e21cf68499b91ed44d4bca1c4106ea9ad183556bdcc85db9af13327c27927b360d1553f095296438ffbd6f94fae4dae941415ec762a2f8bf064c3dba9ede80b8d49d029e78eb913b085af5a7c3eb94399aa045b25e473b960388aed6dc4c430d21cccab154919f3c432cb666a9d429b787aba2a6625bc3e80e165d097fb928979e7a3201dba9da9352b607dae02f11a48b32b3003987baadb65b1b6548e141c0eaf8e85eb8ef4d1c40e2e2bd2ff2c4d2f527958657321588cc4db0dfaa3ac08793f4099b23a47e34965e1e01779381395e18a941f00e0aa9349e49524b11eab8749f77c08f39ed7c13e84d55ef71b0b9df9c4d904e66dc25994a6694d3732752eea2108f062ae741aaeb0e68afa1103803b591524832691842ea270bca37a1f8dc25abd503d0e7085e4526c2079a0f716c5af0a669b4f4162740346ba579bb21a9011ef96743ee709d722477c3b18f69465a135f4cd7dcd79be3add4689c33df71279433ee40363c9495226d79f5e5f656966a37b4138e2845aa9382af2003b23f2949bc09def7410a8a4d3e17583904f618aa8f731c98d7093c5f6b98ea9bb1e6eb7e6c7febbe0a3558de6c8eb3d24b115c6e7a5e25f56b2a5dd1757ab09078b2a11ce00bece1174865e139c947fe24a3f9be1482dc82dc8d56f6b737c484b303f62087e34bf15d6c17e61152015184a6809b2dbeea416d9dddf51416fa1946fd64ad952ef0fc3833182c42a134898400b6539ade193ea946b81bf8bd5749fdbff20b289254bc52c45b1b0fa9d454de3c9da7dcb13793ddde032a75ac5ad5df851ad444922f19742cf65788ca20140e212554ce560801d7b6c5318834a886b8adac00e6b61be23fb30d3e8124d963b51d518dddf121fb5cdd94bf544ac2b773e04444e3d01580e553b2352b269fe33c0b8fc3165a0e147698c71cea003c937f24a57d6749b73ab69bcb78a1b909133c55004781c2af3ff3f4a42cd59043ec5b9dc3d667f250384e5b4cf251f7768a6e01ff83f0af59eaf8074704e576decac32633a1bad0eba20b6a27bd470fadd4e5ce4818fa4b5dde112eb2f3778b7c4f848860fd83044badde9fe5213b14d3500e4e4dfc1561b5d6c704e9906f4a3eed0a2360f68823c41d878fbc046f95c789e348449135baa3170123d753d0d1590e97571fd52a28171262a6bdddcc56c7d45c39e12b1f409fa05ead2839c8a11ff612c4a0e512299c82f7d24fff6256e5889f9d6a4f4c50bc47ab3c4b45ecbc1093e20e7952747f61993af28d2d1078047dc6961ec021906e752495ba601c9782434ad277aeb8a760c9570236b62c29a92112e110aa1ed3f4163a9dacd8c01608a08e5a24d7aceb737a346a2679d7b2766e15bff5417a03c532d3490dd855fbc00c2f3a39c49bdecfaf4573073eafded67e9ff2ead952cdd58f3b6a688b7aa8d3dfbfe97831e1580fd0fa001958d70b2eefb8077651d3d84abb649e8b0ed72854f1d876a23a1ef5e8d4592c59cb24a75b2d0c03779dfe3d43b3e8f9b78807fcb0206f3faf1c3cb38ab25e51c66fee3b8ba8fba88b627969eb2992d83124871d7cbb96dae3231b2636307c36f1c201677d6a1ce4d5ade4c8470681a6bd65bf0ead58b10f40fd1a855000a600ea20061f3a961d3d8920a92b9af6a07b052914a2681c8ef25ae55184825b8a78ba259b8e666d7c487ef7550e6d22dbcca9e061263012d9b464efe5ee4ea9cae3299c7aac12e86efdc04d4d537f5458ce05f92d288969d2863dbcd802ed6fa715ba3cd63d4ac3bbb8be8a16233260f1a6e5d2d4c9b162ebcd4bc41ded785bda30465fc720498d1a207e2fbb65a7fa39e4d86a1b3cc8006aed7e8712e3ba4e7a09a5fb9fbf9eaff2c14a8ee073dbc531003ecd3d584ef1c13ccbff8fa3a1a52ea47f5ae5b02f5e43ad5649842f49c52a9f89cedc25b055b4218afc091b4aebba77ed766965fa10faedcd2422a0a45b557bac43b3fb4622e942ae148448d9352ef87f5ddab83493743e4d2dcb2b3f9b954b03fff3c89f7eb61863ecd2b9f29f75d563f6df235ae4a35d8e4478093621eb1412b8ce2ef255a7e6afc8417eb78b83f4eb0bf19a93bae40b94b1bf01ca76545d25226a2a31ecc88297cd271bcce6e522b7459457edb904a426ad5fb39970c846532acfefb9f39c782085f81107f2bd8dd6fd436934e6c5f3828c61ade0119567230b2c666adfee98d5d9910e6f8853fd1dd53f9d412f8ae4df71291d9dfa433c448c44e60e52475acf7c3eae55055c08a50f2e1c9beea088769ad68793a4e380402d5e08c49d0aa26c7e8d6595e061b209548963283c40258770","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
