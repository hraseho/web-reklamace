<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bee1e8f15c77aeb5395514eedb6dc2f5267f48c6bf28d3acaa5570a4bfefef61b75bc4540cb670db10b82c0b7f56b82367b05392a85e954309031ea07019be42684068f987c5a02bc3616e5252c69d4ba39bd53c8e8d6bd5254fde19d71af94553576ffd561d1666865cbe828d1c6a2d5c560a67848572056522bf351d362d265badafa6d15ad1d64d04a39381bf87d97e186d66ed3848a30f589142d36f556f2abfdd6085ff928e6c33bac18ba7625e35d7976a1d591178f08f8d7a7a6fcb76822b343e73e42cf431c3e7fcf810e8bf3b77bf87f970d9e428f16ff3ebabff46baa473cdfc4dca671d613f9c3de57763246592491d13d486210a44c71b32ea299da9fc99dd9a65d859b3fc5ce9c8e1f59fed55a93c8dc7116684c4b9657bc49232c083a10ce1bc4ecda7744e73a3083836156433a80026be688006173dc5a89e22b43e4774a1e479fbfd1f8dac3780a81c6bc4247957697ac32afaf7641726ecf57eb11a42658e685fbae4bd316781823d5fcdf189bfdcfc7cb48a7d8ddb2e104be495009f203f267b550905425972157fcb4e696cc0ec796ca82c436e7ab9d8cd3124c315b09be736983d8e3168fd986160e1b4318de66a025276669fb6b9f3b3d37842eb46d31571741286e2c61b13af00bf38a635d31cff4d045e22d43efffeb96722bb65c8388188c8f1a242d66a09f0f369ba5cd7fb1af098516c71dc7c5d09ffe100575573a90bf1179740c37d5ae32ccd25dd1d4a536abf4fdeaaad0ec0e04ec8e423adf4432e65114fa31f53f8c85bf49d4b9a447c5133e34ee0a76c921c9e62fcc807a61d7cb79802ac036d1e8f4418bc3167bab5a16aa312bc8dd7b19681a8b8ef9fe635d2db79a8d495c904b25195bfc67be4dbe1bfbe58dd9c04b67be4328c20b1dee831f48f21420ddbed33a26c99e80f67ce0dfc2c59d6ea18ab740f3bb4b350777cf660894c0715c097d0910a0c682331a5d002c489dee363e2991cbabda08b4026a92f2f0aec4ca8f9f77a610e71b8f085907752f516f1f92f368483a77fcd345cff5e3c9581fbee940bdca2bc5a8cfec4a277f37477988fe5869a9dfcb4d54e2104cd5ddec3c7d4cbd5a2fc4cb8f574998ddab1eeffbe4ce7ffd2633d617f7fa2bc057d8851ab238efe4b0dfa3af086f6ebfae2712ee3f39d820dc000bcdddf3ee2e99004a8690448e0375fc27748e75b6d3d9f485ee97c9d1000a8be89716d8a7340ded2a2dd543ffb306d1c84c8b577781b3f299deac866bfd33b630b6053f41511d5d6d6e3aeadc274c021ed9f00e7e3d3456161ce253772e6b37fdbf8c3b5b98f35c6be21b26016cebded12d315a3c503c1861b6a85b76d3255e1fea0b75a746ad4bdb2b992210c6cdfc113bf12d2c36a1d600a007aeab67ca9f790b17489dadd31b1478019afa15d54374b1b9b76d5892ba23b77b7cb4e475293ad0b99d7f51b5cccf0b805c556f0a98a904476cad12ae1cbb337d78ee9e48d776b94a23c4f987ec9fceeff3be4c4b70ef7ea4e79409d54cd60a8ed77f7daec42fbbe2be3887d0f540cf24e2d636f45c36fac52a9260e71fa517661f87c3f5e37f617d7a4905a7cb30fe71da896a4c91733005315ccce4a6175759bd29c7165c84c1554797cb597381e6eaa5c9601c1ee15174c9dda11f5aadc8d9f9a613d0fd8d545163f45683ab39211fb76d79447e7e7c4d7fc56ca534e5e84eb97044637e9237b36c04936731abdb65be1d39dc2f850c3432392d1a0c5053cb61e9a7ff4b2461b98cdaaf8a381d74424924c8f195e9b34ed90d887a77b9a16c7bf1ea278ca32a366a567cbebd147942374e21940262ae3bed2c2b4ad4dd6fd53fadf3d88ae04dd9fcbde167eea99f0c513d16f895031a6c626f7bfa9472580de488a46081895352147cc14a6f0e58cf369d1d9ecf8e0b49725ea7998e751e32d6a2ea23640d59634dc688cd8c5d4fee93b7de9ddfd2ba8ccb1cde96368d37849dac56012823e979bd2afecf5215b66cd9c7b1452404e0f03ee44e79aa8e7c5873989ff339555fe1702071e4790080fb03dfeea81dd54e5c18bbec4a7189d087ee0bf6a5923d64294e1311db44f26b6b4b8b3f7af4a96c1e76aeec9c74b0c3258483fac7183237f42256acda552cddd8d9cf7e1a503bdcccf587fe16ecfecafcd1a86743754458dee89f7e63b81d157f892744b8d3d3fe06e91c9c8418db175bf6e2a574dc45ffa9f8be02558b8a12577a2dc47a391fe5828d7929bd1bf556c6f1469dbdfb8e9152be707280687e07addfcba405b36ba4836c89c9e79b396f9ba32283cdc4fc4b1d2197eeface2205d2dc67a7388992fc51b3e433beee2703fcb645419a41fd610471a6dabd9e6fa75963b3280341f77e562d971ce3a814a863ee28953011011b50881eae4c3a40707b7f1f0926f9bee1074144917beeb4c63e547a659a984df98e2938b8bd3d6c7e5c6fd327587187da5679ae5625f2f53a3bf00fd29d73ed4e0ebdeccccbe1ca0d1a66cc17f9944bd5a0ab1c3130823d3a2838dcc8f576011045f78aad1bb5af2aa5f04b9606f7a42b2651288178c8f12ff668eb71f253211472183b48dbecca846da087e1cf3848c8d184e5a1c58a22b0a66e71a7b4279a6e874a5047b80d037385a9ef91641cce96c7e9e57aad6e9dce107674630a7243da1ec3e645dc15681e45f922c8a4cc7a237703fc36446117d315e685e44d0dc2c3162a39cbcc6f5a5152ef3718ccb94bcda1a6d3349ebe59aff730396e91a27d9d37467700d78f75b7bc9faf48813e2a65b7a55e180bbde5f6e526b619a95853cefcc00695a5163de8e2c03858da44d040500dee7f3387ad6af1cc38f6a9d96306db854b278dab6bd5eea9eed308e5b9ded39dbe1ed93b5f254edcab11fc6dc8eaaada67a54351091dfe39cb40366d3baa60e6cd5e78aa1b8140524e8b6eb6ca292e171f43abbb3f9bef0249123a04a8cb8a4651cbd6f583b779b0d34e6074ed302f38825b75f246ef65a8d7c084e0bb2bed07e4b9aaceab61a8a68c3cdff16234d5b60fb84575f0c2ac3a4bb97478c752506bfba6bbf5c80bcc4ea5aa9012b4b92823e2b9d97177fcb3a8756eab2d0f7aaa3cfbd3adceb29a3261c53427fce332ed3fe97936f0f2334809108ccacd9673aab2446ab87078e38d0ae72a21d2bd29b2e357ba115860ccfb2c066869e673420928f949fe39113e9985849120d9c6bb7a138f040c0be3cc47c4a430ecc23cd1dceb775f1b64b4543792a70c3aad6d9b1da3d89193513fe94164be9bfab8343d74fdc26a6801a8890372b1c12dfa7f6e6d11a4fa1f30a06d53d5f500950c2ad19f3b1f6e701dff1d9491c75a8a8fb217c2feb76e9a3c51ae50bdb57e2189d1987419971feae8d5336d4e5bfc7d6e07d6d6a96fb29a26976efc1035fb5925940a5fc96174ef4770e7187cc7621ac5d4dd3e523cfe0a4514c7ae4b5c995d93900ed725971e4ffb364f15af7a79f8e9b720271329fdf6ab6805535a1892427443780936f7d3356d9cc7b997dcafe6402d9aa521e9019a308df4290c69162452125ad5c08ce83b1991ef31d8d949ccd38624468cff590ba9587122521e0fe09a76e73a511d85c4420290f645ba864995d7a74e4b37d00dfa8e7af4894c65ddac925983b26e696fbc38d04ae3095d6eb50b1dbf4db6786535be7a3c60aac49fac0e2fe6b276ff2709a1840df210c5281889cc21d2a6a05748ab16eec8e8c91e5540412fc54de968a80e140e4e840fe9076d6f13f192710bfaa76ccfcb8cbb8326259fdac015c46bf8d84d5c2d36de3278319b88d496624733ce1f6e7c4ef4a569e219fc02f031285d294f8248bb40011752c3807056fca56d6ca8a0940f81e90853bcb6eeb9db21250323e99161c3a67f827804013df9a13f68fd06cdda91e0015e5b39865864c38cbf018616570f224398085dc06da3cdc8eaf17260957c7113e07e2731d47f3816d245a7155d22ae7d0240593e2a7f10fefec518c5e3020f8ac7a80409cc64a774276f8eb2ed2742d4170d6512f1ada8604a7055fd0275865d81b7d05db872522a16fdff5a609d43fe73b595fbad50fad1c3676478a665e6487ac4588a253845ac453c8d9fec09f99ca0ba807df8870ef6cb3b51d5a295e240b54bb261607c689e14888825cb0a4816d4e58fd41b16118cc5a8e2fca56e5868a8a7a3a6e5bc6679c92d8879e6358e834c3b2bdf6b3e28039e0a83e1374ae327ffa66942de7bba8e12116e96dae03d44bc9eb774a75cd5fe0b99066f8d7d83b472b93a0c3c6ecbf8772d4d6138a6b19b0726cd1248d5c01e984f64d6e311850b2031cf5922d9d3dd29fae2a8d3e8299f7688b714046792fb7aab52bd1448d32ac821a7f668a8dcde28797be1e468d5d49495e4b8677ae310bfb1e8aea70bfcf5d8f09070ed6cbc2ac54ea1cb40e49548fb21b4a8dce85e1a7d0d0c8e01dcf87de5d40bbafdc307cdd6dcf6e3b11558aac21fd1e26d13adb1d31a80930845f4876467f5325882ab741d6480a65894e10d9be3dc953bb16139e1857fd44cf56dc44d38fa5681c9b099f413d50966ba404f1d8c956027a90bfce74d1cb0c07b83977f86e7224f1fe00049568972edf4f5ad596039d1969585c8d3840ad29b5e929a4c8472edae1148b12173b4dd80465737011b3ee61ee3e8ac1edc33a1dfbf4e9bb3008e87c5f9dee2d6597401bfd153cc8b7b3ab31955466e64db6c8e3d44fcfbdacc262e97b5006d23c34cdf7274eeb46c5f2400e39258be4488452036de477286b9633774e96ca8d84c05d5b744ddfd4029f404d88b416fe83ead45d8e3c8d7bae505079e6c9edbc242bd886cb31a7dddef34243a8839a7878f34b931de161f527c40868efdbcd8b0022d17a4ced636732ab71517005aa8b979b635bb4aef31e419643a0efcce43bb306ca1853116367e0b08d75b93526b38af5d0355490cb3673a49f7fc12d4c898821eaf3ac056d442a56062132eeb1b44e7ecf841b55f44ab71bb5fc814310d3d7b7052511fea13f9f2bb353980e71471e6c7e197131ab0aba546f6461e1af8b84a349a6109b355c5c63e1a704a5a5daa3758df361ca201e0595ac449174b10c4d9b080bf5bfd287d2913dda1fdfb96c5375515992556c6b9e6a836ad7999912aaaa4459982bf6f543e1c6852553c8069f31906f3291d2b4f10811365844b3c63e8d5912ee27173579182382fd91d7cbf8be28e9d342e44265e9296d472d419c70f3dc1eeae7a50f896b1121de085888f7c6f0e1df8556035ff8cdbee7fe6f65eb8a7223f43aec188f6489964286e99fdd62b0296c7de7c44616fcd42dd930e407e9a16a9e5e01e215a16bc5195d57254105a02a00e020485fbcddb295175eb30267a46383f447fc38aad2a33c94478fb35457c09cc41961b3ff9e0440baa8c303227352ae302432b5a726c3968a1ef0ce4a6265675c7aaf2f1121aa036d584965de3e3ac6a3adca077392d0fd3a0836f1470e8d2b89e4b724c93d61c917ca575c6274eecc97c34842c64e1bd5d7ff50a49c7f36d1392891a4b521580cefffbad346e5e9bcc2dc97fb070e7f63f0dfef70563ff75cf9ae346c4b3785ebd854ae0b8bc9d3086d472fedb876ec14f76e37c884b3f87e1dc1a8ad605083086d3620259b9b8aeebab71d6ee384cc2a9f50d487487700684c7e5c2f2f8ee5e4a76a321ae3ae7ec8ae50fae3b4d3c9a2eb44e95b81c9263c0daaba5f3bb54f76c6f8ac7f81a6e1789797ffba7d614a5dec454ef43655926ab5d953c89ccc455290aedeae4316639fe6b8c97d3ab05177dde8f189808a290df31b1210fd0ef3c27a893a40db7d65629b30605c0b7963f7c28e711a894a954bd5f338c93a2682c3f60b1506e8adcd1fa85209312055bf89369aa176564a64325931258291fe580570dd4d5875cc2a157b8637ba65261d2e08d2d438aa1e6340e4fca58f30c6fc5d6e0ac987d0373c9095efd99f5d26f2178df101dd72002daaac16e90469630bea2f8a01a343705a22e5a5598c9c6062d214a31b74978c9207085f71cac7d08ab4f9ab31f209369a2ae59915cf2043fa0dc9ebfbefc81037bdefff266c0025a6554dbe1118074c1229a16e24cb7d0bfaf04284393d9796743fcc1598b7f530cb566da746c55c90b25594e044e7a2d06085b9dc5f57ff1655391ae53adcec23d481ded43366a0bd606f1a6bd91c1d1cab5e026d5b245336371a7f96e68d11c1bf5afd99fd650ffb2fe0bba76248009d1425ff3b88c5a833a4bdf0873a6828716b5b475e0ead668cddc7c4d6cf36b0158a2f57ef99198e51e3febfc4b84c7caf0a32806e4b431da3bfcd903ee91aced2b445ffb20fd1b64838da826bdad10be0ccf018496cb4159bc589938762938c25bd8664e9f8792332ed690b39ff2d32e57fb8ccd03f0cc4848a7372c6b0b345bdd627b36de53524dcdb323045d83b279bd4878d67103bd855777162d792bd7a8f58603036daca6fbd1f604ee621d3ed2cc0e3befeb97deed06e3e84f15769fc48010c75c982149c3f2a5e4579f0f272228d79870258925c5cdcd8649ed76879935dd6da49a571b7bb6c97e492f07d670db7f43559902a069eb4a5ecc5f6c14086d9bc9c73778e6e7a6822fc3bd121482ae9eb3f4aac8cbbc18df466fd7a09f756428396e9d1bc068b1c6d98eb5ab4091ce89644d9ae09a237c56ecd2f2b00aa898b668dc2c0754ed73096958d64c42bc1fbafe6524b0a14e1d4ac08f8b9c5cbff8ec133d554896e723ab697917e562f187882842ced50e195ce8a4f197151aa77cba497a0c1eaa6f51b88165d30404263f30c211b0a10887179af1c0f1802445c107b9e4eec82f0010f11925cbfab637b0c2cd14a171781049816f8d02228941287ac62c873994ac4c7244ae78f554fec68e146f3cf0d474ccec39f0fbd1cc71c380ec06920a527ad3bfa22bd52cf2b210d9ca4c7faa633a3f113e14ce0513eb6931cc64a7d212ddae8b92afba1ffe463bf8e3b2aa20205c91951de8c5d02075638fbfae95f1cc1451d871a4d056f28629f8d6aca0a2cf16cb23ef31ae1990c948c7e93f141945af70ae54c5d485a3bb7231eff18ef52a17708948d3af2ad3da0396a05b2e1e4d4092ded82866c43d6cda86da8e0baf4249ca5cfdca5ee9f8f39f7a700ca4612dc4803279fb30d767fcfecc2b2df31b15649981dc0fa408ccf3832a2a2e30b907b1a93d861dff182322b49f2e5743fbbb396184bf0e9c3063e6dc1e2941afd57cd5bb2d951c90ee6b21a1da689857aad703a4a9883f35c4ed442b2e21b310f325f7bfe747d59ee034902d499d34fe72f2d4b6f223afde076885c1ac2d7d10d8f9e112d863c14a207df46eb3dd82f2c1a90c92395c102346178c7076b4b27b3872d2caddeace59253eea695c49fd6b2ee091ac0f97f6f927b3a09bb984377032b147646aa78e96976430a5e0896cba09c957919cf5b65037584c548ec0c98cf20cd5137ddf7e362bcce3e048acb5d591aa16c206317d4b48ce2a4be0b9fd9075040ad92dc5cb22f2d84f3db7fa2b0cfb4f3a41896f567fbee15bdc32f2dedc71d05fd6f0bc94f6efc81f51bf0628ff16c2767a4c87b79035fe30ca0e11f64aa58bfb36997ed1155945ef117a9c999cf4a7a3b66475833c6a26b79b031aa6dd625be35beb16908fcc12aefb88d40f9a4b264ac200065e56d8eda67df2ef6ad85dc0b48a933f4bfa0e4a7cbca24f5f0920d0cf55a42be1e7459b6f48a40683eff4fa952df866a094bd4b943ec6e2a345f09ba7f17a71d01aad33c2b1f34781ee6d21ba06fb7eb8a6fa868ed30a84ee8ee9a973ed062e29f9ffe9e7c6c3360606c91bbc92c46ba31a6a39758597a9dc8d549febfbc54e64f6a67d8c21fad1da26f7848b7d2f5c3d52264d61cc845a57cc673febfdb807d15155854a51768a3748c9c834dacc36b71a05f3185fbb627c50ebd83b74898dc929636ce9215123e11f31d1603ed16b24d6ab364b91467cb4ce3720f370dfea700725cfaecc81836dd75b905ee504c7fcdb3f1327594f1291920c283c8e65535ea0ac51259fa9e5c27f2a7dd92c7cb1b118add549a18a941df83c0bea28b568435edd4f1e565306cc969584a8e5b6781088ffc4a7eb7dfeeca59f20a390e7c31d012f52a5f78c0599723fd6770e5f20464984926a645a4f3f24aaf2cac1ebf78e36891ffbe19c97e2e298a604682731aaea5a95b8a3be3c9a2b02bae4b76bf636e2fe1a462dbdce283a87d917312dd0c83d03677631aeb39cd915cccd0f5addfab9a4da50cc8e09012127800d21d4ada362e21f28c03ec2553d4f88350adda7c2f5268696f91411ace6a92635ab3b52b598bf855a0e67a77b2fd8fd49c7ff1c4c7f67644b395d7bf4de010e246e30ab5ba3c50d4a4fe445a7edd0240a6955ce348ac9397a957129e6e2b2b626ce4198ecddfd5411b2b907e14f3a4b286d6bb245f67b56f060149a84a91f64d60c16e4a33c7019ad94fe14ad464246f7fd52c52dc68e66e2429e2b764f986cfa87570cad95e42ef17b565973c2670df65370c0a0ece6fa5a19cfccb7a4ef7b8f4df2f1d9db5fa94b4b2b52020d4c17f0f55bfe8cb4d09937fe8ee849c0c1a2ef158d4f06338880c5d8ef8ac9e9d1e90e8c5782fe61428a91b7c0824bc0083e096ac258c5db35d55438af613820e0b1b2f74932cdc6fe11bbb1f2cd12867f9bb743b4e16ed64a6b234fada3a6d096d1b2dd6b74ae9593e3ec92f3970403a7c2e0c91ed70768eee73f848ed23db957f43fa6986fa6801f65dd5666f4bc8c543008c31fef30d4975bad65ab77d05cadafac9f4cd7dbac9b98732675993075e39bb51ea08bf6c11597e08178840297db36c291336a4ce9dbda4d1c147c2a1a839c1220c743c6c9d47f84f39aefd908f487b74ffc83ac131f4c8af046303171c78bb09db3eac1bc8f759ec522b8e088481b84bf04648762216f392a44011620353671a74a532ad432cf0c78905bfaece9f24dadfe80d015bd642d89bbe37a800decdc653afa871872fc89655ed5256af9c09529483de6387214f7f52331acb824390cff8cee07be6c307cf18978ac58ee3bffa1a7c5ac17ce734c9c6322849f71ab072b57deeb85fff13aa2844315f03c0095c09ee8be0fb15ba88291cb6f2d6f2ea64aaf27c0b36d636a5a3c1e00b3d90192589d506f2ca1098c555b2bcb01223d0a714e1647bbefaf1bc37ec6db2a57c6ffdcfddf0466d2b194f82fb8d035b27fda8e011721ecc1abacc7e801bc40ae1878f5b0df0a56425393b68d3cabe0543d5c293be9ae41202738703ce99f0e14c8b0f4de331137c11b35e38997440d9da73713d6d7c4d348013278c101094fdaadfe334d0b1440d0c4b7b525fbf6a129093b027da9d93d31dac8f9cbf7d4a688f221610e17c8fc21f91a07883093f6b35d7fe1e4799100339d61e3e5ff4edcba896ef4c57d82ba194cdaa121f9b1dd080190667e7c3ca5472f29defa1cd8546b6c45b140a89aff748f934fd8d1e6606ede3984881e64926b347e281a19bc9a1e5156051fc361713943b404888fdbb8a251e03016fb4f140125e50de6e3bccc71fe9f96aaa55e498715e9deb53d28178cc39d062c3d1e47d172f1145c053041648b83a1f71e2fba1c90eea1fb3783722f8fd24b8d0155814d22ee49ab77ef98300169d6ffde5ac41908f38f1d09b3d953f2535706ab45342a83cbb129156ce73fabac01002817211a7e267fab02d75cfa5eef6e1a87cc4e29c99e173b42c37a7a00a5c3f8cc4bc796c8d43ec76dda5bd9aa891e1caca145d9b8922da20644102726cc50dbc5da138c1402d922a3df13726d8f73775975cd3ca76d4c6ca4e6047d3e64a770b10db3e4dbb94391ff828c6b0fd6a708d3e7640163dd1450f81f87298a87cd4d3f64fbf852fa02da0b12f632af2a3adc0deffd1ea1dfb7e36e29f8455160fcdb1256ec1f19b2a6995f7090f435adfb6f2ee662e9ebccaa8efcbe6c173117639f2487d0f416cb17f87e4a98072d34d86bde51200ffc2146a385a66a719528510a4713f9798862aca60eaf157f0478bacea658581ef8fdf8dd9c37587e088eef937e6d84480f2ce5a55c4569e989a6b508fbe491872da5c2f7dbca6e875871ca47ed7edc092d187fdf06b1c59c00d0fb3b85bdfaf5643400764b1af684bd7bcf7f65721f475c7a956e503419a58eedbb8cceec42166d3fb1f54452d42cb1558739e9cbc4dc1323c379c9d6e4ec2bb07850ca4d4e955798dd66aa54e33272ba14832e057274e10f547e7516943aa41b10d8afd5dbd6e4138fd0f30babdbdefd9eed9c11c2c011e9c97103ef6ff3fbd0e0e338f53b2e239e3cea22a24e106fd9eb52f4d35d76a4d1c9b17dbedddb9ac6b3a9843b25fd60b3df3568d11b6441ac24157a733ca49ddb4913dcb0515d9b37007bd4b659af6c811f5eeaf73922fadf6165bf85a70014aa49d38496206cd98e91513df03528f9d3ce1745d50b0e6a68d710582a6510caa63ea2bd7d383e0fdecc852d301458119c2ce8a5f85527bed1f07b5ff427eb9d051e396ae9cb3708b2ceceb907b6715790f577e76a52364b8a578ed7f085fc891be9351fd46643d82f33311f8a6a5488e35d9d735f16bc97cbb75d93347db413f382a91604df8c99aacea5cbdb6a31dc00b17bfed24cf7e3b525baf7734be72c9c8d9b77cec5707d46516a09078e40830637b660304bb7a5f178fbec45ebb69bcc142f2857ea2b5ee7de8d89747569c19944e22f342e222ae4ee513d6875ea161f312fe1d25942940db772985f82ee0ad70d7bfb7469ffeb567c20a22441e117c42926df3149c53896febfab634eea9ccae95d071bac7e85c90630136697823d34345f9a51070d48ee2982825bc84c77edc77072b761d7dfeb1e62d51e7f5fd35639c0d2b65479637c272f288996e696761d30881696a2f39e726f498369c543cdef7be3f3f81ae1b1bdfe567a88291a5f439dc3f42d1d39ced8eeaf46f606109d4e871fa8843c1164f11eee70cad6ef1bf8a43d14bcf5b21f89ec54785c1019e3efbe730eeb0c32c28efcd4066865bf81a488c658fdbfa70af90e9242eb798c2f2e90f72b5cf49b26dcfda1cc355af26eaec9c88cfc6a6990f11ce8d3a60ad900817cdc5f85ce7ae6227a46b9353c758cd0875464b7dbeb28614b6d5130051e518f917c7db42032780bca54695bf1dd7e612f49eaceb02a56bc0970d70024be8de8660c4e7fa174e1cb13a7b01e5d8e138b9e28ab053c009cd25fd7aa10550556b259c74fd3c17fab81a11d5096b909cc58d6789e16077f9b01e4b76d4fd8eeeb502335a7886257af6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
