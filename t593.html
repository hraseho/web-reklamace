<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9195a2b6a2ceab45f2e073029a59958c9927a3d815a10f1456a9f0dd0f49d7f3b5f267f17d3dc5ed284d6efaac32052cfd0fb228de09a53b3e3df315a1957cbe8d1a45f79e157022432f7af8c969c3067fd7e5c1e82a547a855588bc48154c1666ccd40dbb2e6787a34e7b7a4169a5d09e6164d8423a4cdcfd5356fddcfb5155410458ed3f67a46db20dc7c31b306245a31e23617c9d29c63414e6b629c7991c8218a0fe2473719a594d362c478abd4d4ce4a847d2da5762e328314db9748d3a4064ba98b661c345af5b02ae069aa95367c968378d37386e9de748879b32aa891a1725ed6d9b04a3ff936f8d14114aeaa0d1a6d50ccb969b252d5f3751f5d3b1c8cb6ac3e702c29e81aec5a2a232325372ff14297ab8e1571cce5293774ec1dcd33410b2831909268fc8b594d7c73e866088d5a43822386e41a7c43558058281ada32b902c9cd09b03dbf9cf6753d71257063500eb644b23ca7eed5d0c7dbcb9f5fa02639b4f3e90ce072201f452b7a5912af05b5eafd10116e74350f56b4831026770e5abc44f21ddf3438edb5c973a8a474be41adf8c6e9a07b939918bf89a41b03ba27740759a4382e4487774f0472dbfc15005a84fb5a5e223568053cf2fa68acb67e1ec3d0edd95e224e28dfcfc6f428d491b926b49631ab82aa5f7bf746ae792ebbae6644b82d98675567e4a11d8fc0100a8fc0f082a15f74d4263f0b70248dee3604756512d9d8adaedfd59eb3391c0f202e3aa335a3e711decab8143351e4962bcabd405fe8e9c6b5eddb4cc278b825283a88a77bdcde189c03a9c67c5a3539010422288c2eb422b2c5f10970bd7ddafb20b5eaf2ac62f64b5c2dfd66f23ca196ce023f1d51ab50cfeb366bd30561f77add49a38d0468ffeedb6ed2210afcfda64ea20997594354b1e5fe8d476e1ec3ab0c45c45ee5dbf079d20072da99d7e40149fb5d318e27cc889408dfb1e272aaa71982587721b3383687211c6ada75fe41b5b5465abe8ba446d12b421110dca773a2c485ae2e54f97ecb6e0f87a61aa91807055d46f66e9c388d2cd55fc0e5632e6f00d2d0ecc2aa830db824f9ad30711f6a904b5b2c03cf49d8d8041e5436dcb2fe0d0ba3ad83e94d9962dfbedef26649827edc45c0be3dce5d31475174e02d07d6dda8fdbd7a62ac7839752a7fea7112998f3d30fb1394ab07451483e5e8b769e348534d59b2491c7790705baa58b243b674313d0ab725a3891b88e786b5e95dc1a1e112499fa2aabddbbe3a5f80b866a87c0869ec572cecf788eae735d56f9a8a28f069d716db8ac461e8297275f15ff031ae488b8f6eb7021fd6f41d6845fcdfe2beee694ef65ad369326fd1096a0cc33fdb73ee69a26ce05425cc91f77b42daa94e1165479f0d25f8eaea3de0ca799a13c12f4faf4e4c953a3723e6f7977d65d4594a0591b4e69c6a883d09c3e7a9a528f0944f21266c22c1e0be55d67c6bc0c8d24891d9d16916bf61c6dcba5d3e93dab269754b96e8c2d6198108a7c7f5bf0657d93473ea28630dc9b609b78942c6f3182860f42aad3ffb497d42321329873850bf964e44eb4ae6e0c4f138118a2c5d2f69bbaa7f059e74a3699da0f44c3c4dc76e92d7f6498e0cb518ddcc9db2b1b09250858c5cb182af270348d28720a9159a55f915e6f017a321135f4c2f4e7142c5026142e9d23d65a250f8892557a0874768381d678357d19c7d2bde376cc324cb04e044df0b5dc959d507e8bca645d33f32c70724428a7cfe5a4278d07cdf07b8250107470f42c0cc02de2a64e7a8a66e77505208691668ef3a70daed8a12af7bb3e0e838de9ff61b62e6b9f286d325e4903807dcd6b56bf65880d3928ee201f6b723ca0446d1897c53faa3382c3f66f9915fe84da964b51e9e07de1b7380befd803bedc23550275501756ab300a8728b7cb41976151d641d77fa3acecafdd590bc10c1928356c147a8db46dace8a7f93e31a1761e89543c9006711a42c3f620e07b2fe9790dcfbbf4aecd617ec5b77f9893d5c7c592e1ae85492c4b7cab74eaa425df1f45363fc2cb0597a93ff77aa8444c511e4eea35567f8482e0281896d71cccab9d06475323b83f197c918d7d40587eb7dca0166e3d38f733e451554d64c2ee7fe16e7cafa64c4f322e02404b4fa378b78a869ec5597430235116079ba315bd2f8995f8b017ac3883a37ca9b1bdf6db30d865b1da7ac9e112f46c56a311d2a29141b24ee6b98505415abd9bc7de82f556338686794e4ca8fba1d8836eb2285b71e1a9874a9344a2d10f728533f8e7f82d8bedeb8a3a8a64cdcfaf1f5bfd007f06a808a7391c4d2eb92945a45fec7688d9e134aef951b5c1a6f3ac6d41d946ab68738d7695da42bd1acb8156303ca428da1d109b849f0648c23a0a2eb7c6c2139da3c9c11c62985bd8bb4a1021c3f95c3ac1014c0b8c58ef32c5365bd0f4fd21467417ccd18839a5686a68d33f2dcc258f68de326a6b0a07100f866576a657f77b3cc22367477904d7e75f0ea027576352da66fca5e3d152d2deb3d9a484c252ea720ad14775bdfbe91400e87b352784bb72d5913ddb3f693af6f6a35aa57b3b4c36a5a742d4817a418cc88aed24086edc96abcd63239e1f366adb520b1a6bdd9ec383d3ef9fec086df1e42b800540152c742a16f945ad3def34c27e88d9d714ccddbaf111ec26c3e12196d5ab899a24213d5acc1e3bef3f7d78b519dcb734e924fafe7dcc667e0b9d8aa6e30063fba903c1b3a8a7dbd26b7c169a316493f4db7e33d6debebb32f925c41fd76fb67c4fc21526a74f6934d478046c905da027c97b8630c8e14a7f3e079b4fe81a7786d9d26eb3581346d1c8cd42c6aa6dd6c5cea6ad0dd1824ca42cdcff2b9c0c54ba5a1ee46855e70f70c22d9dae02a3c737774ea06bc0057b6ca6b14a6ae2de76b20b9940b942eac40078d5e6a626309e293525e6e0920e35e586ceb5a1384338139fbf75a75932a2b70bea6b447bc2f9c67e4718690798039acd790bed42ea4a1750e6c47ef2510c160e5bbc1413fe966e4766eb5002e8c79aed8acc2dd34f3b31f73be2c260f048082b8d6e7e80f64c1bb110e8ea7b00c8dbc46dffb10b9b94ffa51e9510e29e9208aba4a4bcb35807328ed9139caff965529e86f9516f385048ae75b7d8d02bcb6f0efcfa65af02ce4465b1f94cf2b5e3d9d12afc798815854a5822ef41b9c15c6d6be0d22f8b6500a8f594450b65d6db7ed30eb9653d7e0eb25c22613e382c717ef4ee8279cd05a1a7238a8e6426c432ae0941bd0f72940582a3efaa1de0247c7994dd7bb59bd123874b841206275087106a2fa19e03e81325fefa06e4acd2df6745e62a32df3495cf87e33c6e1087821595b3bbf7680adcf5dd9fe1f8c6b3b44c50f8d686940696f23a2956bb045a8f6d0911d6ba6f19d4d5d0eec6c50d013e70bb487078cf18e3460d74fdee596c3d367d6c90a61d4127b1083a3c9e91cad190546193d573f3e80dfff73bd3cdeed7c720cd021e83dc8dd35b36ce347591e9836ddef7b4e58ca5764df2cda0228dcb32f4f825ea1c40a8d9741c5709d84b6ec006792c5c50b7febee79fd2309d5368b20de3adef54e9f6b870cf3190b3b737525655f7efef1ca6fca3f1d1df096b8c85fe2665af6e23acbe7144edbe5bee348eb2b87cedab603e2b4e8d218e7c208bbf68ae4146c726064ee2fe9fbfb23c8ed17c95d33b6fae4f8a0b783f64df36bbe2a43be86237cb22e33a3d3e449e41569de99a0b72bf92fb2784b46e18ab009e3871d2608eed92c0f476bbdbfc77e47942e8ce33e4fae77253ad206894a2fb011add1d27f8ce0874e45e2313ecbc7756bb905a41d302716ca90477d8ce4e93a4dcea277596c0d1668210d2f1c28b0c8d34ee859839f144eb939a64292ad8f4f3d9376dcf65104e81defe81c513915ec1ccbbd7cb1c3388e3e3f21019a9de8109c5b7389a86c27182eef7cc87bea132230af77f02f1d2fed965060a2a201266c783f08e68129591633af99f07845a7366c1082b8080e88774f8dc476d9731f1cf094bc617ea6d131a44cea324594a2a3132df5fa98d3f199ecb6617b1524bd06d5b5a66ae7a059f73e7e49fe797121a0fb1cef66461416a4ce80935aa293c2b4ba6a7ae601e8f3df5a91f49970f91022b3872eeddade5241ff0298e4e7b53f1135685a17f9e14a4c57b21db46b4653ee9a67081e0e223553a80e7bae55845a11d3bf218da22c3baee8502aab3c1e8cd3291258fd31d75159fce1bc9a977aa945527e35dea152fb7ed30e5a59302257852bdb4477a8b39ed7c3772b6e950b65fbb6dc9dc1b53ed99cacbf912699d8f9040fa2317df5874d5666c31feedd4db4956550f6b35d3ede1f283d6f980eea3b511981b8808f4f3ec804021c53ee52858cb939a9a891f5f3f7c5a887f268b4d9c32db2dec07ff3995ca85644f5e9d6127d4a690ffb5bd5059c48be96904db5fa2eaed34cf689b09847aff77ed6f6b28cd4fd0ae54483b251df9e8e42101da551ea93c57a235bc53f29a5f7c12433284cb5a642776c471b8c607af459b0028ef26f98091881a0ba90633e8fb8254a7c073ee87fa3504cbf963d76f37be2425f55e66b86265c6ccb49dcc9e69095b017abecd65279eaa0f287ae49ead2b78231f7d85b0d7a4514ceacc71591b3a98bf7ce9555a386bcb01d836e253b340594a188053df9c875ea98a8ef5c733b0e1d3f0193b295676f2b9bb666721bc1fa8c89f91a7d92d8fd3bd81b699ff758a3d0c231b5c2968b7117d05ff5eaf23447c5b4ef3b21f549c968f6d02bb7da548d7094545982be9d61b2aa8f06382bcfa95213aa7f461bcacc4a7ab5b2b2e6fb2b655fb4d087bd7755cd2214c1dc5f5effea82035e3633e4f481d599b9c4bcdf57a28a5085c335da4d75119d54286ad2afaa0a62d2d4f63c930aa0f46bab83a70c58327f7a6e570696dc230a802934546b145df84f212073f8ff43eaa0212c67db1c80ece256c18f6e107430717f63899ed75b325af6a07b4e9f6e04e8d64973947e245dbbbf164a19ee8ec1b2e0bdd49a012c99ac163583a43492493dec0798879634ab7a3fc969be494eb2bcda44cfdbf3119cb079ebd511a448726884e73643e4d7e6059efbdd3a2a5af025aa77d586a2d5ca1cd125b180cc4df7f7da1cea9d36916e8874a2770a304259c887d2e95784b93a7204cede9c6894fc355826b2820e95e575527e59a5949445cd01d64c0fcb87e6acd097d94e1484fecb887e3348daf9f803893811594eeadcbfea62bdaf32d563d158c46c9f40860baf888a6ba2c1ed225e6464c44fa1e0f18de84e2ef63fedf581bfd71f716fc7ab3f04976dd2ecca8acb5482bdb823dc209ba1622e15387f912fe37984ad1642056e1da33d9edbe5a74ad2d9d27893b81a75d6ea793e6422e3f302146cb5fda8b37aac77f0a4635ae386778ffee82761c8aa375f83bda11412f6f5b82115d0c02cad2260046370a4638f8c905312abb01c21bd59e37302be76da74df110a71564ea198f35fedea2c66847175d655cfd38f591825ccc09580a82f448d5037efb81dccf8fb47ce4ae0a34bb762addcd0164a92aeaa5fa34b0b149de1020a6a7ae6fe2b44fba42fbd3df093ca1679f79ee3eb235294f7147fcdaf49c89112a70772aae5b86fe9f5ebb90aeb6de2ca4aacacc767a603c6a808c7e0f0ce6d8e8eb69d9fe0275d4e34e812bf0c3a6eb738720af6db19cf28e61912709d9a4c21998725876426a4490a5a887b2346904c1f753b3b7ff9102a4633d1f620f6011dfb03c68c4648cf3f252ee22d3f8d9691e0b9d4eebd3ee2e54dfadd71874552123a5db82865f373d467e8daedc2c919ccab80e7d74811e2b7fc7790d2e653058c2b99066f87d65c25b5b59c2555c42471fabf5d8bbeeaa44f1bf460599680da87bfa1466d1637f7520021b0cc0f7d7b4229c4f8f0c8a2d33e98612c80555ade898c5a78f8ace60c12632ecbba58dada617fe58dd37d6b4c011d39050d8024c5e3d075abbe945dd5101847982e8a7495c778bcc0ef75cc5e23353977bf60ebcb6115a8df0b39dd6eb5a1923bf3e40f4071b31d1c7bfcc34abab01e1be7d272b88f611c87589432c0088ebd003025ad89a9e099ac1fc4facf46dfce8e6a344e43459b3c804d533955a4d2197c2d47fe7a459c2b2cedb989571b4754c542272038c77186427e1bcdb1c14be99b8a72803c4d65929fb0459d61dbec7794165ca4b054a2fce031f9c0e03361887a294f4286ec3d3cebae13bde32e9656d66fab0f41bc3d922285c9a3aec8081e9b1b3882429149155d56135f24271eb1e5d87b63b793d1478332a4b5ef4e9189d6316ff6138244ae676facefd23f236af320e7dc8a11112ce24d5c98e3c85634871b95e13edb3b5389ba682aec8a9db11ae7700d335c027a96ffbf8febb8c41ed2c4b1fc63222696d2d9860e81cdcfb17ae5bcc9ca5a07e31e18cb6c46a63b0fe276d0bf76c0ec1ad237de20afcf549d4d4a6d4a52014399333161a5c0485ff62401578e016b080d3532f7579bd05b69354d9f95d4e7b72637bc955bfa00c3ce59fdbb428a956c6e5adfe6f946b4f74e86900abe0cc7730d66b91d7da094b04a169cfa1fba94c530fb0062174db48c5c252f5e2d11cfe0d0640b1077f2b243cc440f9ab3469a4902c6da1a884621b210bcca0d1de32733260cd9a3dad4ae4adb5aa525534225117516642fd9af020b8beef6a197e1593adf0a6b3954c70d7419e27f3d1f98f1edea5fa425871ffa13108bd6dab78d0893b4315ae61c262b5f27d6b6f69fb643c93b93fe7682c5ebf6e911693bc4f263ee6d88c488afdc549b1b585198c03323536ef3b3c984a17faac77cfb44e757ea21c388d34cd240e3e48c5d55dceb207c877058f6e117c377df8a74ba361b411dfaba3312d7fdcfa88402d523db69d39b53fb70b28b755800f4ec7ea9e248e02513bcb8596037be7f4d36ca7d9ced94ab3247ce8aed123d9f1703997a62fa083af49032ae2df4e538ee37c6092bf4952d6259733e9bda8f7052b16e05a037c6a18bfa47327d587b530c4c759f832be9e30c0c0ae19739de5f9118f5321f4ce09a14036162a902c51a30dad4c8d5cccad96b16cfce86e8edf138c665121aab02f6d477d2ba0307841db5d97e6dc9d75e1ac68f5aa0a7bfe742972f97a95d9f6821487fec9e92c7522658e3636c95fbeda47eeb7263f4526f8c82567cc798498e4383bf9af39df3bf3f053bfaa2e87e3799435da711be997aaf2b6579a93e67b2f58608f87e245710650d9c4826f554c89c4f3241b5acccd72818907484f0b21238af79886995bd6103be4a0d8d8606ff692fcf6b0b2c08d6da072e33302539d05a285ec054a586e0925bf639e03b4415b3288486d73c3bc5c68812d75b394ee1dc44d02192518f12d8e3c9a27c0959a57a0135248ce6d69034f9468463880bf859d731c4b5efc9f6ac5cb60a8fa1e865c1a634e817be48748a20efed5289498e0a940e2a13cbea5885ac28af687517f6df0f6468eaaa74f4cbb37c6111b0a1a435fbdd25918d22d65e3f23524341ff1386d519263981f9b9f7f9d59c2d1a95732ee8c4d7b0f8d6f3629e7b064d15119c18d28b8e458037327a26c3e540c96cac4ce1621ad1420e4ff894b003f1d16abdd6e17b6e6c81c989ed008435b8de29a8614f6ca49649ff7627d9c66c901ff647c7b70601cdea6e156d710448112ea35c8de9ae3782381e4190d9bad511b8aea143fa551a556eb9dc275a944fceb93974cd571f40a7c674b6b1ff4396402c20b86a9acf0495b722c5ff4be62af94156cbca6801bb60f94771ded39c7bd38d3f977d0dd3d47f9500737abe1aa5f1f53ffd9b1b4528e5a8fbf40fa7f9d8aeb47b7bc1c7fbe15794e8bb04fb5b2aabf9578187043e765e7b69c5b915d249dc81fbefa1949c65dfeba1717bb9e248a6a527486e93c0b2a98f603dad5f1fb2c15543708ac46b5768335b6ffd6f19844d08a18fbc521dc4c0a08eb2a829d558fa7abc48152fb6180d59464392b6f570e58cf8f4f49e30dc59b73db5b28df011a60b8e1c5be31cc11b2b0b2b737629e5f30395873e4a2e5492a1e7123bdfab2211bf2661284eae6cf06067e8e7f732e7767066495b7f69642c9a92608c5a7d0a81d8e58fedfe1a4716fdddf73c0aed8ce043d8a36b00ece8d52da3ea654ccb59216dd4c02f0125c7ede7ebadc2f18c00671002c93ac5d1e4cb804f856a3119181a615e65f72692bfbe12900ab2e09d3af76ada79568a72d65b81bca72ef4e5109c770c39341fb01f84a02001da1ff59287ce8bb1eb743b545dd0d8eedba6b7291c94080c7e03b667a38bce13fc1dd1305d83d01c3b8a9451729644ca8f8c03506d445560e928aa42be89a31353a24443499ac34fd5794373e3445a0863edf086d048c031311b4b71d6c1f2bc9d270a359e583c836b7f8ba47cca85c7a638b4c1f33087fd4ab0bed85266543d8a11da127dfb86c5603066fdccb31f1200cc499c52ae27214af32199a099fa473001a610f2dc092d48b0e1544a4ad161ff0d672b5ee86d6d681a184ed41a994a0468530209bf989ee1a917ca2168b8e4aa09604c0be5ba906d8646b2d74bc01a736ed58665d21e374d2133497ca032946b821da18b7f551bbc8e16f7b9ef95fe832b097638b8150b3c75bf57db9baa68d22678974ac5b7ae7bed0f0e4f905865cf45a6cee4874a4eaa21a19250364115e22c357a27f17cc5e62ff93301d06fe75f6c1a3c3c78b8cb465c20bd4397de47a2b3d2864678ec4cb1bd7aad9325b62682d50e4b43d4293133a83634f0447526381d6e346a907512e1b7a114f937b43f8d547e7ee16b75ab569425a8365dbd3d0d8e747e272087a7d5b2846313e0988eee0726833721823134e417aaa6752a2baac8907e97ba2e79d0cb2641c4298583754f716c215e0edab1e8fe84a854bdaa85d6cc5d95565c6646141e5f97e56551ad967a2b94d248ca43dfd4874de33ebb4f36ecac031dc7fa11fc443c1371f0282a60627ddbe0f219c4dc90efb47dd6bfd3598cf2a69bc6d3a0c32554cc7d207912f2b1bd7dfcc911c0483d3c49ab7397764ad9292b06d732c4cf0d6534f2e8de2554bca935e0ea089f395d6b0be0f216ee2bf0a64374758f8c94cf13556a12d23005fefc8dd67bda3411c7856c1d4c5a1db64970e9b9335417c2f7a8aa046645c0f8785b26e6262e4bc936df7bb7e018a1753c24e681935367d85b8fc0d6cef9eab9337b23f5bf99db38074d2771d93d5e2bb87b38377b176a78ab7c39952e1482fd6b693b150e1f29c0954dae29e11ee1f95751ea090148fa3dbb058222b91aac9f60152bdcc17caf481cc41eed8d0af1e7cdac75d1c5768a43504f63082c3ca9316c239e4e7cf5ce8b6196a89fc20afabb2a2d9bdf8f006f2a3957042d3914349f29299db000b8dc70b03fcac5a50cf3a3bdb5aea6523108959fd423b1bf48ee6b6940e7109e64973ca84a4a2914efc10356835af1ca8e2bc7a4ad2401ffa67b0a8c39889c71510197a873fcedc0fe112de109b00b0f720720cc67d175f210a2fb076a022c730707009e7857410882f624dc1209be178c91c32435104e0e88b82a60ffad15cc92b2ba3aaad47dc2941029616922857a5d100f06f76e4b7f8c93d7739a5a49514883165bd1a3afa3dc91d90ce32c697d8b3d39ce6bd4e69cb3ad4f1a33307ed686bf5bc9ed77bdb7718813e05201c38eba32bbc25954537677c0ea048f402431b0af76169aab4b92862a09a17f9d29803ad6fef8d1634c0bf896cd75d22bf60879ef4beacedd3e48731c2ff6dd039afd99a1e6ba0c0f109c40a61531f69264eb7785df9e903a159571f29865f518a4b391901023f954eb844c61641f0d8686324d4f11912aa13d67327b4c240078c7c90d93109520aca26ede645ec0cdc0eca928c6064f90224638f2944182b2cb8e83f33341d400295525f05234dabde64abafeafe4a592179bafcdbbedb2471c6dcf98bb469e09f834e97bcc4a534c7b0ff1c5c14c9fa874849f9b91e1469512a3bb201b885ce5a768f56aab326156c39ae123756b14b34411094e49ffb00aee33be6264f6bcade0228944e2b41e248b6d27460eecb98f7c0e177edd293acfd4c0001ddac3a37d3307795ac8945462eab6d6b2a19b162c128cdee0df5300c685a0336e1cd3054eaedc0232e69598d2f61e5220361eba60aae34de778fa7e7d0ab64bb9176db9e6bf9946bea8ff78d009678ba8e4a2b1cd908a3e4996bda709d209676","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
