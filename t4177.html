<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c07bc021e365b1e61f321944143c1b5bea1e8dd4af7ab48624c2e0c78028dd620941be42ae1c84d9976e166c3bef449de2fe4c46ea25c069f8c2e816f6dceafa8842aa74851ef9bb0a892f24fae06b95b6ae374ed23d2fc23ba5ee6e500370edce9c7bc2da2e5df68eec41492034c4a058f07c9e61e78445a1587d9ca565f94bc7c724fc4f180be37fe160707f8ad034f982e3f7c7155df9d9b7e35cd4d7d1e28ae3e05fd3bc23bd26a7a90e60c890ddd6da68812e8c91273bc15bce1e84ee81fb5c7ceba149a574e0433bb402722286a556ed751e479c6323cdcd659f680087ed0ba6c2da927859a18ecf029168acda655a6d47fce21734f4d96d7fedcb423fdcd069f15316247856c99c4774b34ae555b4287b1f2e9cec1e4e2ed375e79b0f4e59d52b90cee3dd5c55a3c0ec4f43ae41a5697b76696201440c091a06510b15c06e150f30d7be153e57a28f5c9203e3fbbe2abb22e708c18654b9d719b52dc2614b666b3969b6f02c5202dafe2763f7773316784b0431dd2abeae2ba61d35c34d4eace9b4776754caaf6e83e2d611ba85832ef3cb9add9c1da36b2af701c709e6f9c37930ef7e2b5a4c69f7246e11ae99bf014c96e79f15939783d70630ed284eee0ce4aa805ab7faccc8bd982456e6137a85a82b60a89f102c85c7e68c65a42bec206adccbb256b56c8094e9ca06b344d4e0f1f558406613f327451d7d5447f768d426d880c9769c217f6b82f69caabc3fa370b9944ab112b5c68d9c3e020d83305a70151006385fb863616bf49951769e2ce5f0724473d167fd28341ee9bcbe28473a5f5b530e07dbcd6f5d84bc29652eb17a9ebd08399a7654f8c200485d76f48996e836de14f327bf2f43d00260ea80f0116f2d6a57f99d47b93b3fc91d74e598a32396531a99523685ae25416cde8f3db606063f7b2dfecf4996be2db97157c55dfe41193f9dffc0fb5c1de4a374c1d028ad952617f316cd1a2d893c7673a70ca0743ac27043fb3ecbcca1363d6993782ec315987f230e851d718ea7e4420e74a9d05520860b8dd75290ba25361f7f61e823fa7803dab803dc5101180db99c4fa4b9495141e11df1f00fa06e459095e63189ed3beb4cd93a76d5e252535417e5de2eae026e95913c0e909a6473b4209bf77c0ba445568cd37c9366b0fce4f27192758677660637e8ca43a6241b55724ad32d4e9817ec297591f32f7ac2ee886cc25a70d5c8ccf8c23c84369251cd07ff1b24e10e27ee10b60db8d3f5f2b0a4b1335cf2857418a173db3c467786b749f9a932890efb50a7d1fff650029e9f9899d4fb63499587a32eb262763de3ff6e14b7d0cacbd13426970cb9cc59364b1f16f73518b9191e91e76ad21c4906e8eef726b7b57331c8e571959d939626b10e8e2f499062844cd9cfdbc6d5e17ec9ebef3c71d655e24fedad4936781123030ac82410e725d4abb649cfefb0b2458cd5c418adee6576a2191ed9aeaad355ea28a85395dcb26d33e221492e2499eb82832d718e1af6e49c3972360a6414541eeaf19ce6445487093cdcbf9b62d909bbd4baef484738036cdbe2f80867c80bb81b42cbf10e70164792a1a25123c78a400caf973ed51d40a5c952540bc01fe92707e8db121d01cc9b0975f75245fa70ddfdb37b826b399d79bdb97453603b2f70c77e9beb021960d9d3723c67fbe61e5dee61d5bfb854c5a54036b2ed9ac312729732d3a84b2e703ce133e3e4e078cdd685f8eae2a9f0310f6855d7e7b9ed83eb4569204392bc582cb9ce9dda48bd5c57d66c97eb5427637e57659d988886a0c47f36af988ae4a6988def8e7ad199e59ef120fdf8c155014bb94d8fec02ebf4d9b13a1aa11e52728ce4467c3194024bd3098da01269780292a0b6f0bee83f0ad139925f838364e24235165f8ef1609f1252eea2b56592888fe25951fb49029dbc6b82f777d76dc4f7827877fdf8b22c93b3cb22a1c46a7032753316e3070c5d373671cf42d80884fe4cc3f6abf87b7150a218351d0946144f3fff60d9eab12fd6e7af36043eb7df9eab321af005f4d4f29d4decffc4612aed7b3b94b8dbe94be25d148d286b52ba688909da7a202a35c3a1cc572734fd0843f7e7f523caecb422d3d3ccdb90136eec4fe239cd92fa0ad68bc5385b395e9c8f243736fc8df504548cda49eac1bc166db374ce55fdb9387f8d618153d678063e92fa56793599a51a4ada60ddfb922aa850ddfea1e09d573d6772fcf78550f6cd538bf160146d1bdebd739cca597fa5ac75bc25d780e5669e8a2c87f1cf787282d6a3b193947b1216001d78891c6d670e71c1ef4b1b5d3f497ca220a673dc2e9281b0f12d1aa1aa3fe272cc84a52fdcd433424aaa0f7cd3d32255f85b21ecb348fd495839b6c4ced0e2e4f8505da63ecbe187ec8d20d60615dab7660bef37ab73bd2b1ab22e555de4ca140658420c3e620236281119b2ad09959f9c36b425eca12663486e5b78272f428a1af66120f74b3da626bc5b9c4f9b632a5d5ae3bf1c57e87373c3da6f0185d39f4d569b1fe6e7e8cf81cb82cac964ed0579c0f3362d67364cc5a2e3e8d93153543a3177addcbe73da4ebd3b63f99b9079a0cece449299c6c635aac61b82e4fb52ef9d8d6d429d0a094436efe5f3d8b023adc3e1f4a65d7daa65dbbe2a84e0da992670a8ab3f41fd98916337e6d65eb3b8168dc18f2eb8b9866d07f375e20057fc8124a15756500ef4c30972e3a1bbd5b1d412d2a8e5f96d8ca402ae3fa704390894f9eb99e3b79c3c5054f66bbb451e41ebf7b52991b0c28e3b84541df8d35ab7c59f9c213deee463ce283858bb4927de9d64bfb76ff6a929a031a0c381ba370883b3d208cc67129cfbf22ce100fda654ae961de42ccf0febaaa83cf7d8d635e4d4a5bd9c3b0dd293a040ba5d70d57f0d44610fd3e70816f6974066f835732532ba9c525b94842ddefc4ad492e1b462d0883b3ca16ac3762efad79cfe4741925faffe9f1ed687778175a521ae22f4aadba922964d735787f0a8710b2cc48f686de42e4f4d5d9e9d1a97ca9ed46e0fcc0aec4828c23567e6c8b5b224470602db2c4b861980429df98606f3e7731529da9e71461a479968269c7ea7e67f43f62b25893dd96e9dce09f18bd13ec6473824a915892c53c794e97cc7dac9b1830b373a2d372cf99db4ee6410971b5bc0404157b56275423d5110afb55d48a3c3180769f6b485132f0b11c4112e74169254b6927a305d837e5d033c07d12cdd42d03b9e8fd0fc74d2eb55001a788d473ba77f83bc9db10e0045dafe253aa53ff934e3e800abdb515a8ce4fabe52982e892d072f76c041eb288274cf1f630085ac03efdbd6d57987dd32ea27865274c150001718d36cdd589e93924242765c578001a9354e010c1746e4a6582d450ab4efa3b50406ce98e46757e1128af606abce8d2179d9fe55a95693f4babbd3c11d17424a9a8947d90a0deedb7cde5a0d03a3042afd1bd4454b6eeb7659f2c4e50849254e0aa1172c8038fee537e0e5901744815f842cf4c84d3e6ed4bcda5204931f5f1f93b37edc95b9da5068aefb7d39f9f8a63ad41fb1d46f49d7e58a0b39117f76bb1f923a370f3232e0053202740c7d14fed419ad9c8980203aad7eb854fa87360a7ca4d04538ed0a1f324c67efe82eecd32704ce9122efc57021359d950eb928ea84ce9294b82e728a7b2f8c78f9431e8db6076d03616b633cf16ddc66c651d63c7bff5269975a24ed8bfb768aec8a6aed32a8fba1cb57b78b22729b0be58175834296b32fccd5f941311b5d9656daf415d0d3a4bfd4c4348292f04162967c9929eb53cec8fb7f69fd056eb0d6f66d37c2889c96486dd60c0ecd369ee992954ca8e25a2a803984637c20454a5a212faeca76416e9c0aa4af328d6705c76ef913253f9b0f0c7a63814c5646c7449c0b1b0d6c0a9886616f8b1d5d36d869ea21a56580825aeb2c1d19e4ad314cbabd6ad4b76f7dc7e5a7dbcd36b295abcfca403d1e159ff9efcbd42a06d742ae523bc438f0396088826032fe9664d926ecbc79807b6c1b4c019358a5ca3e1aa2984f81e68eb9e2cc54fc86e717eb4708bf3edfdc3d0851bc1428a722f70d5a8bdf00f22706f2acb099cef54b0629945d0a602c807d08277b5321e89fd3e2235ddd281ae109ab4de95eca16aa25f537415390622bb90d66b30a0ebc2638e3be800e2b37f90630a20bdeca005de4ccffab3ef29a5a71d670fd369b801b64ab917f6390b5f658a3ef91b9a835ebb14d8208214076278f676fa311819b3e353cbe6cd9b8734f30f3c486ecb5cb3c2f5147688f3de291ffe788e92b4902bc11ec75d51de512e3bd4711eb84c5b2b096693b6dbaffb080fa8921952abc2e97e7599c248f9333f9212fbc83a1eaa88961734c39fa81fd6661149cecd73fdad42caa0bd45608c36293aff7556769b583e34c7d5a5c59c67735b11aa79e35488735cc2d1aa4fbac908d72d6ecb3ff2cb5456704bc3a2cbebccd132b41882e34ec6f663aa312b499d99c6f6f3e19b5bc0820a4da83e8cb1fe3c302a5cff3649ffdbd7622f6eccba1752268a57b078cf5b48fb3c2d6d469af845a21dc727e3c0b60891beff86b410bea1c84e2d89b97853dde115bd1c9ce7aea0ebfa2bfc822b2cf37cf1a7c1f2f3f188442b9208b11cd813b1b4e55ffaaee41e5026dbb2d1f6260ed059689b1ebfbfd90cb1779acd79d65cbda81e2985f73b2afb0f4f07f7788403b6299414faf6f2cc13156068a8e1eca5347487506185231b55501131bf6ba503be6323872527d9a255610f61565e462357980028ab18a1810b146da81e6bda2e52fcb41322f42e0f0d7e45ff2aef6b4e59790106fc28a9b1fc22043e862b8fde70d6dcbedb2b572e779dbe280db5dea3ea482b769d9377db52dc3b760519dfa28ecf461b063031fc7178a6e46a5c94e16db813ccae8293a6a3d2584a1520d28f4f642cf7e79f60c63bc5b35992950892a83ab54de49897b3f2ad3146458f280e58078ed9c2b2dcc0b56b62571375f1225ba0193be479d2d588cda8ce5841a712707c8ee97dfe0486c88d9e865a2791953122ecea5c8ac36fa7356067fabf81391332b83d949a833c3a3aaa7dde6271d090945bf11c2ea12ff91d812f127833803f76efc156102879c7b15a3bd40b60b7a85527f524ce13b95c5b1d45d8089ab8b9e424d3dfc37e504d1e6c9b6cbbb3072a9664d076f76b2f499fc11000eae0723336e2bfa828f26a770b02bd7df19cbf439868030ee0e2a5d6feca31c43eda9b1d1c0d1a075bcd8b51448dc4afc113c6e5bb72997b974735b671d46d51b28c634bea981f924d23f6d806ff7a76c2f7c7f8a4c14738dc2ca8e69667387fc1d213adf050e881b752df24bf603faec8b70b1bd1e4919fce8d345bd5278665996d5dd64ee1dc1f15d0a5c212dd0a4ab4d0e19200bad3caacf34befa48877084f55ec395ffe4ff8ecf2e6560af1644ee61ff6bc2c31f222944c4930bf62ddcbb6f6fd245a75cc6bd870f1b1f5e16ecd8e50db62c707a06f43952da62d090096ba8a2c34fbe39bda6ce32d2a47badbccb848889d2f65ab5050b9f468fce373ab6998d90e45dc3a1dcfd1ee0a33c3b8aa012cd2a72f37f3b27ef4197e81e70c6e8b84444d71ca65579e7c15e010786aee0111af1b3fa575f8f35fd5792f9c5febcbfc98ee99abc8bf9b724c2e1bc535676e24e0bd060f2a6643fe3464d3b41064b83b90a2953cb626325b11eb155507cfcbabb7a372cb8e5cc3ddd0fc393d8131142d0818086773eab8b56a3e0d96f63f44a181f288db9c2765e4a93113b99b89ca3c7851f1f916dcb0a1802ad26c56fe8cca8bf8b51a73c38cd2e5596719f1d845a458e49684393a8f9c93b492c1707af4766d37f0a3fcb7a681c40f255506da650b1211c2ab4b47027515c295b7b6d3ab26ebc8a95ce637f75c5b281cd050c329409fd29a47194499b1858b0a720055ac634243fd09d8d61d889ce6f28be78a61a7798031481f79156c2dbda39900dbe22af8f6eb727f57539cd6e06786c5020e9702f70b632e60579b3b76349f6a61d630d24bfc90d880bc3d4065391a2b3cf3cc3259ec63ba42db5158bd58b3805f5069ca4e40b98be78360cf42c28e2a9428fd15e8fb4bc819ab0e7d2c181d91dbd0710a7dcc8d77ccae62ce0a104072fb76c58b1ad3e0a61bd013ffa9c9b746506781b600a69373a11df1c4a0ae00306b1d5e90a2b9f3b1ecf5e5d82138f1763700935c8be29c870c2cc0bb88d10171383b8342c12ab76ceb5ae347b35730be759b288d9204f737bcb85edac78cf7ba7e408697f9353e6afac6f45acda582af4bd6f9a877387d3a5c29a70032ff1922e0ca120ce39ad7d5cd35e399fa45254de2645b5922a391dc8d5d473b4c74ab72c17685364f4e579a0c27c0b8407548be365cc52bffe5b688de47912b5bc85aec0aefb4e32bc36cb3e9e425e8d3598d22a675d5c28ecf48044a77f59f46992c26a24af2f1fa2d9bd454cd5d20d8accbe3c8823160d0d7fb812f6538b81a1ffc51ee0c0418cc8a820d33bf53355a08c7146f287c971ef36b3cc099f2556f33346af18e6dc31bbae4f2e320820be6258a72599a804e1fb27ef371845435e71937f395e44b32fc1d35f380e8e83f7fa03356b8fb3cc8c4cbc5a0cd830fc4a894bb3eda41f60423bc6292641f7f783300a7b688d63a3375a45e7fb15ab78c3e176e6716fbbdc57a1bff20dd7413022ce442ae1c690146da0cbc179d402e5cac613a37ead392ca02515970daf12a89ad15588a482816d4bea0865213ce571f18acd0575a0d0b0f14457b788d4a97821f81e42e819ea98f3e52c1e30bf47eeca2a433971780445a3bfc7455f23796d63ef16de4021263ce875f693c3a9bf3fbdeb32e0e7501ee8ae44f3de61047337a9599f6bfd934826e0938fb4e7af8a2ca733eb8f0222978eec8121dbf8b2405236ecbe362507c056a0ac59f41b80c2aff0f5745440c9f9bcf7fd5a2861eef6b18fc4270490655cd6bf7d7e818a48077d00253a6cef8434f80137f11e066d7f8d9762f545d22bc5db8e6f3a9369854dffb9824428fe1a2c9d4b1010bd7fb05c212545602dea3af184ff3ac1689db1d585f50c4b5ea9ff7837dd4f2b5c1cc92a86c20e9b8e17430f055592c0d8dff9db8b2e659517aed9fa4f5519c82fcca99af1033bc15b93eeab5e3d943b51703947ba463e1fb838f3305906ccc5d6ced20871f049a1e5e78e19f4ce70a40eb72f988bb3be020999a1e3a0727a40358a3f56cf09b9d3bb07493fcb3f93fd7453623e80553556a4664b0f33a1292dfe902664bee7feffbf983fbd40e0a5cd27c5e219ac741d84d9a6a9516e5a2ee757e16429f37cb52362b24ffe618a61d2bb2d0e51942be882022bc0d62082d05cdf8703130c4e7bb655d33e07784df8b2a6194cb90000c1f6c4024986e9268abc4ffb03efaf0af95126e295bf359d519fe29c015f011da7cb3bd44ef58b4e9e55bc94da708281ab0b68386eeaead62a603d62a2ee2b7e5e791f2cdea6e4ff315c96320b65ee1814454f93505b957ccf6401d7204bbdb086974b0efcc1f19bee6d402cfd858b567fba1f2d5feb956ba9514752b6e863d1cc44adee505864b9354e3006cdc44a2d95185f286ad6d201f2209c76c49d98471538b94f0c839123c8550a0df46c85aa6c3fc1765c72f8414d8a159b26885c412e7d3ccf5cb2664e2aa9ed2fa9b691bc2931bd076a55653ac9afedfefc3623841b20fa7a710cd819e55d7ff498677e4d7b696a875a3bec2356abad6ea3ffebc06fcb0d5fea4d3069c90c3807000d4b9bd0991331307f4213afb8da89a9388c0f14f2b60a30ddc3775e3ea9bf4c00f81a6c85b0ff994e26becdce4a324aefd5df9230065cb4117d3a157a0d685239015de007231efa56a43b45a51b5813074534d090464205bcbec108cf41d610ed06d2c51b6a5507ecb1cc05a36db2049186213cb9dc1b12c98e1712e066e301d9b9a89ed1181e27ab136427a2f838ab427fb1ac3e3d0cb9f566bf15b060f11a61b0f5dc995d53cc2dc16d4a8591d425bb83d447d4efb8a7c1fca5fc0d81786228c5a0cebe387fe6b5b03cf41abdc84fb64781875d328a2a9731d8c304bea84af6596773e583e59074375549132d0d8c47ca4d80d245f4ad5cbeea1b298ab6a053fbbb98b59d36256aaa04e75680f8759d4c23bd71c8de1b2e8f4a51d6619e677cfd7d9e842ed17ef3edd83691e572a86a94c8c78c26e9873db700b42bf101ed5565ab15b6c8f2535dde0ccfef422299552744d36a06a3a4baad5445438c79fe9fececaf19601563e832c778985fca556c0470ce431f40f012025112f8cb3fab2ed787a27d469f67bb07c3bcb3b2d3da8f6cb794ea369666a938b4e0c0d792f62804348a0a0cc02b13e9c02a3868459f14be1e2651ae532f19b9e28bf28da1770272a262ccab3c141e0538673f9111495cf57a43706ff3d4e69fcbe15e0d892493837089bc4267c11c9b5e0b1e6e8299d75fe3d53413e1d706f725ad77b145d07d7e895e503282c8b7acd549e71a8da0b6752a462751021d0f9e487429133142d480816005b37d912cecece37d3626d316b9a318af6e3862459d0461558f309e43366a4f7ce7b4115ddc3d65d91b6fecd9d6ae61d9aa4a5824d729750f29f909be72d88408ef31bcb6664d785db22bdce931f098108993eed5b386b224d49654d6edc78455b8e3dc0c226da543c37c74fc88d3970e307b854b93d4467e5d6e36cd6545337a01b0ccb6fd9c4ec6ed6f117ccb93796d9b408c0411362f345a0ea0e03b5e32c4b2a8a627f3a99710f42c2a5579f7f68cd6350bba1046e81eb8e09f61cd392d4f777723a19132b1e3f642ac9d2fe9b6c0baebbcd281b7a0f4c1f4764cc58b4f62284df1248329be4de907456a371f362ec485ba7539ab0983423cb956901a48a78a30a1b4acffd9d3d3df1eb5569f450e18155c1e195a15291510a1f6d83278be17e89c5479758e1ac66db491e8d40846088ae3e5b51fb46220b5d111e73b574a53fa915eec42dd365da2172ba221ac383791ce7112b10048990d291a2492f5f6b3686969b90a71d352bc2430845a6f48a3bc0bc07993120105159a10a753226b8fa31bd2158f319a1466b37f74e2f5628fba36f3a92229bc4011f5fa11831fb24483ac5ab9dc67973ff3e7d7a48d36a34e0f062fa8239385166d241298139bc9cea1a8db6fb248b344232f605ca634a4c81f8bd20b7a41f51a1d4c5a5380932d377c1fc78f83adc558b1beb43ee4aab95381c5d041d97a27afb6bc31ee3f0570d8f3edee48f8aa0ca99d276c17d36ab31d203ebfc0bc8edc74c5fcb1176248080069667f911bcdf2ad99b2dc66df951be8cba03387fc57ea6ae69ea2fccee520cd802e308ecc34f014839760f4a91b90d0f5529741ababccad50e2c7c980292f5cb047bdbce58e44573f3e07a4b73dc5effb94f62d8915bd8e1f6f1cf1197c4f62f8533aba5785704c758457074e8bf43e18d48face16fb8650f45cc7e29d21225aa35a8f039bbb62db31fcd3617b66afa4e6439610c9a5ce8837286febcd44a2b284ac916cd0d4faee6d95c75563ea8d23bbe78e02cef91be5e6a7726384ef07559bb611dd9b1a3d5888426741d561e9cbeadfb9e5722fe711f236385b864ea66e4a1da967fcfc038daf8a4f7f4a5de9c4f18ffb45ad0fdc5451f6a490ee4939d85efb6f1bff2455467397a37e4ca2693161ab82d30c8dfd7d8c02fc687b7d632ace2009ef6659bfccfbc80384181de61e7792bb656bd1fcca5d44e3ef8404536ba52aa9878abf2452ecc9624e442e9dabcd180057b73c7274e753c1a8f8de59755849d4e95a74dc27b411bb009c6aa4c65dbd39ad9a2c85759d0638f03c9da7bfd18f666ae790090e98dde774fa6a6495a968f03f5cc1db8149c10255a64ed1e33f268248ce57233617e3569f8d34a0ffbfa7036791c13c62e88a6a64029917389653fbd38358ac57524b4689cf507975fc5bb7002c88e1b5da8b591d52ef554e40d8bab714216dd2a00d68775f3985e92cf5f97eaddad95c8ad82342be3a0e2a04bbacbdeaf60afecb8413daf1a625d9a73efdecfe8ac92bc0505784494e59bfefe25f7a60e12ae069ffe18da8ab4d59a9a5cecd2512452a6a5effd8a9e0013efe46116cbced57e451023c94ca02ecccc3e0db86a052b3057721f74a704005afc04a12ae8dcdac54e0a760cca3aefb59b83e81a55835167bfaccb4224df4e7f5a1f3acd64af6fab56615fc303e7ddd86702f22e0ac05f382f88eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
