<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9da8b87894fe79d8df93fe2306cf1761b194384129642ba1b8a703f0c535898b4e024dc0cf8d358d66e0f8cd972d433be227cb3939c7ff08d183aa6c11b5675ca947ea5b0fe2e670b855fec9d6b636f0afbfa3fdca1a2848b4a88b6549ced64127282d067b2f5bca3752668589b8fb246b5cefe17ee87eed9d52f605c2ca1d3f3ed0c5fa3528ce4f892e5a708e0e33444cd5caf991bda4f62a8c8e44ae86f46f1e201a03720981c710a50d137ac00784172e470ec1ccaf6be6a33c06b64da72fd79821559456023dac4c19385f8ceebc024ddac119d878fed96a6d23f4f8b170090eed06cee1548eaf139d0aa4c2937ac7cb8170b9aad6982977ba3d580019baf45f137b8782a3196b745d6e6a3f6a4002f7339c108598cb13db1d0fcfa15205b371e828ec608e16607fb5ab3bb915abb6c24143373c240970d0a43d9f86dcd0b3bf5e125d96678c8c179150226f1c2689bea6a59407e1079ef73cfcf41d8ec40ebe9dc38425a9a2aeeb128e5d6945ba0d6da5593482b5ce4dbe08285b5d476aad0c1e889bd2d952d6b3b0c7cb4bf8e8048fc9a7ccad237168825af8832552bb07e00a8150960753e906e70dd143616d730c33b5134ed14698f1e88dc618a374427f5a64905a34a457c6d3db9b3dfeb2359a5a47a0dc80de61261e2dd9e6620b1f2df7bdf0b7dcebe8f808a8001b48f08615926d63370a15f6923d66e86e503f941a143cdb20d395a613037c371d1671cf827d681c6a515724f33d381fb26e267ca5562ffe7f166570caa7aa19f87a3acad2687884929fdc04e32a7949c024cefcabd824385fd5bc4f782d9a6a4df3508d59c0d1ca60acf28fccf02b7fd59b0785b37f4a5f599f5aefa71318db52009c2d35fd22ab656033a373ec66b021c973dd04bd92d30d49219d6a407d2dffe9331932bd4508953c4f568643ee894502677383e07d7009dec1178ad0f12a8b011b4c3b2eeb7bd37625f6d08b81ed8d231c7fd716a4188a32fd1cc4888e64c8cb26b4f09e6e6eb4a716eac880de60e3bdf78241646b2072250a1d1cfa5ad9a4499051c1ecdc1bebb676616b625e40f586b881d1d76f92f64cb4feb0f6ab44fca0f1283377bd56226d70157f10c371f9cbe949786b2bfdc004d30dcbadfb85e787d32262081656f3cb52e49353193072480d76a2f2f1f10453e5174f086e60c07b940bdcbdf620b3abb5f2ebdfc6ebf704dc48b88be3e2082ca9d10fa9a1bc96c4751653c4f57246cb16fb05fbd28ca91a44dcdf86ac39ed616df6f7bf3eb44533a7ea808d5f08caf5bf14b3c527a8ad397e1e4525910b98fc757f8d5f59ef39a437b60f5e9c8f8546f8a3c0e0bf94c63c9aebc42e6ce7a9b979d0aaf8211ffde7a4236857ab7498ac156992c57a0586c680ade974079ab7f5b0eec1508a79aceb8b2f0ebda4d58c2c7aefbfe096a923baab58706586dc8cb5a46cc9a6c801ee4b924467cedebb29430a275f2c2c2ea7e64a0750c59062f6e8dbb9a67d9be3f7668fc83c7fdecbe1f7500a30698dfd8e486a3fa7c0a119ab3631b45f9039d2111c429ca7fe04619cdbc1ddfb84794bba4341c48fdd24417f22b691b911c8eab2fd3abce272347f6859e2869cb9775b55f9b44aa353b368a25e946cd895a6c09bf92f3b87f8dc6e12e28cba1d01565ca3d3588f384dae3303170ffbc419346c319f938f9ce06df00eb1f36f4bcc7ae52552ab61682a008931810e7a7ae0643ec330ce591d1f64f993730db049f6f12ec4edc43f7c4fd25feb11daa4fe5d7f34ccca5e01c3cec68776e0ab73686ef36b49d0cd853a2a330aa4f5473a5f22ba0a15edebf50be3eb52b38a3e5a1a3fd4ad1d6d3412065ed1deef5b59499f7452c1420c8c19d734a4b4c676b159aa761a0c4316b4940c353bed212837a555f012350e06337900b2896db14cf369e83d11c99f2e7456dba340a9a073625a1358b228bc161eef79b7fb776778841e7c32759744e46fc7c2cbb46e80e3c4965d9e53b621110ef1be604a7888f81beacf69f34fc9b439d3ecc07816ebf97e37f3c43c709aee3b6186ff3b371478a7bf8912c1962259800803280101c54e832c197b3ee8ff459d43525e6d61bccfd2f7db62f4101e76beb9c4013b8d9a24097436c4cd8c2f08a27f5b417064723f188d0d5097debe293c2346440afaa7508d1f46e4399be8789b154a7fc028ad0d6d8cd323eaee2d9ee809e59e97777c1ff365c88464065ace23e9732d89ef8e6761c4bf2e3cf4999f11e3d4136f1b8c24267484a35a31fd9017f3bf64699195e945c22113ce2add3fcb032331319c990a5c0ed4f88f38f7321eafb085f1e6c195e22fc8f6a865ef736607f93ea6465b720bb91783b5af9a1b03fe156dfab6f1788e7c6cd1c06e61cb557b0f7b73e27c4125688c83034b5095e8dcf941ee66537c056d7d31b35909c5ad03fed1f8bd89dc8288d8bb470be15df9a95dbf27f6216b55e3483c2d62da1e685a03462fef38292d3d2a3b658450a9736ad6a940ef52d3be8e321f9069cba5a458ad48b142b37cd9d99e5e2961e62c466436cf4db7e2ca22436f33d86e4a36b879671d3f61b90c64a1b5fd77942e5441ff8fbda0fbd0381eaecbc8e799bb28ace174c0ab9ed05172c41efb24ed67f3145ba63eb1ebf058e6275e20c051a828f45e2480c289630a9f01a1785947c3a9c77ff4721bb68a3b9834a43697bec5ba1a2a0872096e41074e2603e5a982c2b49ba3c1d5869c1e456c4adb82f0b9c6c95b05064664a56bac88de692a0721a5e05d797e722e67c80fb6c775bdc56dcdcc8e8c3b8529988c8f35933271377fb7600474e4eef79af24890eee374b6e5fbed4086b0335ac8e9fe6d913c0bda97972c94e750f176aa0aebcebb82c12528eb432be40c3c751995b36c2b3ed6cc880125fcd18d9abd09fb70c117b8973913805dd6e0d2ffa73f75baef78effed20ce4105eef033f48c6313953f7331646010312601c67229509278fa38d7e33a335d1486953e2d630cf47bd650b4cc206a1c9d5c5e50d2218f4a5b238f5ef9a420b4370f52ca5aa4228a3fb44f3c5b215d4043dbef7d94cb3d17e1f2a5a942a6a53e7832bae0416371ddf6218dc179fd43615e5d318d3b9c447ce0b10c70ea3fb84537e57df8ed86fd73e29fcdd51141b6032efe1f04024f97f752ab5fa95feb3e010861a300a63f4fa4489d0bd2806bc4f536fd3154d53a6abf9626a59028b95406748f9bcbea4beda1286c508c8185f300420edbe0bd35f63a33f37553263aaec0967a9d7cda81807d9f7980021f6abc815158ca1ac79167f7aaa6d8f209d72b5a337207c72ee07f1124046fd89596f632f3f74741ac43b2df5ac738aa8ea261368ebb08750ec7223f7d3c35b5225add44c69d0e2bdba1a0ec976bc13ac95edcf211a3c68d05ac4e83f84aa6abe45637baddf1ad28f2f7d60a27e715fb6412334450814bde0896741ef27171bf92b85ba74f4257e20346c7123674de183977cf0706e26aa27937fb963d39e0aa73229ab6e72efe3536eccf8118ff6e14f75cbef9c10b08f2dce151046486408561d49c781239fff6b8790d5912c8023c2a4f5f2346ed6d7c6bddb57bd9aef662545c7602e01aa9ae6fabbfb260101ebe1c3fe5d19e722fde3f46fd8a6ba9e6da474a02bac103448592df12064f1a99bfeb2a4326b9485ca34397d5ec054967b83ff4bdf78eab163b23935fb8bcc7785e0001780e46b0ba7f0f9beb4e62e6355ae53bda2870bfe83daafe68062029fb90f59fafef978aa5173d2726c718092d153cd346d7e2109bbd125e0b9f9d00576aa16f4b81abf1a8efacb07d0e3eece9ee99d45d26010c56b28b8501b62a3e1f4222184078a1d5db56e17acf3d134b8c9fa578d2c5c4cc0abe3828835e2e4285b4f9c35e7f8aad9e3d1d4adf698d4560a95b3fbe52fbc872a0e08d6d234ebaad06b0ff13a5fe9d6cfde106d887c38e586c8bf4f78f43be74c593ce276d993a5e2559a110f08d13abe31d9d1913979bda549532a177f142392966f7edb3a87779eebb4c519a76b6008d0f1d32b9089169eddca66cbd683a9df75493d51e25b694b7dd3431ef99b293b5f8e32d90ee2116b65694fcbe16e1daa7fd9f67e018248ede128630e5a1f0bcdfe650879a00f21f92e05bea859b3bf3976815b082d3d876ca6b1b4abc88c27ed3795305b3e342a1b8988cd9d397ab14afb5197f9ae1805781585d0f4a0e964b3c50fdfc20a414b740aa6ad0f851d0c6adfc441e71e396b5397fd47ff3941798d03fc3d5277e3a945859dad2ebef140fd0c8e6eb32bcfc2758785ec260f29890e9a9a8be84d4cb95bbafb3d6c590604e4f7375bbd4f77e2bab9231dbeaece6ac1b55ac06ea5bb17938230055339882c814660f75c0ccb1bb4c78695e3db0d06610ceae2422c3b64acb83d9a513c3d8f0da7cfb1ef29a3675870480b16f619c7b31abe33ae22ad755850a797eae2bd9be4546c7a9f8f70c495444e6c89972772f57cd74ef80ccd75b5cfd67549e986be4593c01c0617b064f31a4d2646903b4891599dc1230c0749c749182990a89e90042fb8e7a8d67008d6474051c2309064aea14634eef36828e09dac5c3fda2b8929f743a159cfd58928e0b6a9c6156a4f962ada190fdf3b622d23ac44de8b4fc15b01c61112c62331a35fdcdaf02904d358b28287f16fab98024182b0664b92baf364bd1442703b45158f2dbc69a523339615b9844899eec5586f43eec483437c742bc9813ac6edec2ab1ce40a9d242a9226178db34a27f021d106d59440241b7e018e018ebe8013d86cf1ff2f2c24df75a46ffcc6b411b4e4f96bc111fc35c27ff974f9a355b043aa072b09e671028102b6f2d134080436a514873e6b6351568fdb2270a1fcab69abbff38e40e690c71aaba4023d71ed7482f63eb696fa98ba805cd0a9a360279ec4b511730f1a91277bf1868ccc1da32a6b566ffb597194a1af13f68f69fa56a04c84316b42e8d7faf641e2dc3ad47d641a2d1b4c56af4f2e01b6a2e8b270da28d5628450d3ada8170d7bddd0f175665888e29fc3964b5d015b022ca14e0cff11da566673f78a382a9ea78f89a67582e0ba9b803f20ac8a00b90f5eccefeff32f9bf34ba8325ec5e7d767a5afc66508afa7e07e6240db42ba4265bd910fd13c36a66c7c90ef5655edec314e7feda64fb2c77918a169dec1873e17e555a92529b5f0d463e4917d2ea64869c1781156181a8c34c2041b2478e72be87a71e2ca80a625aa1434724e8001a5122168dc95e3d7911c547cf72757fafddd6a7ab97de9d19b203af72c46349598394d01f2896fc991d1cf77d5cdb7ff78583e37fe29735563b999abe39e904af4cc8945bb952ba6c1b166a45641d416dde7572c0fbc3b1ea7c693be8ccac50198718c003d8c0d4603edc1f8262cecde63587375a3beee1f1e43bf47211a08e61d77aa6953d0f18bfe0a72b8edf2a28921b0948eb3489a4795ad2c804edebf9e8f1da017388d7bc9b12cd972d8920e228187ae62cb2b70b610f2031f3458da6cd69e00b4d16d5ac88429f0f6abfc03b91e38167d6eb2570911fdfa6f72c29a32b4ef37ed77bbac12aa77a544e29e01147cc644dd30d11faa6cc8e660a611adcf0972d2752c56f80f6423ea09ec52fb5e4ea2dd85df61c6fb75abf2a8b0fc24f02f1df9bf679e94df1dd807ccab3e704494b0ead52c163d509098267a12b6db60975eab4bdf7656bb4ad938d8412c690ab52cef3e66cb242d45153995d200cb30cc5b83d065fad1ae0db41e130939888b62619ce744fd233106f83b8968101631ceadad0b787da79d3e4c415a30a6a9dd7bcb3bec74641acd864adea879b6830779e8d9c9e6768b3cbbeda19dea20ea222a7d8ccf122ba12b30f8c0c0ad9e0b718ff1ecc7e1d4ead6b5522f234409257ea8563b0d8e7a9501b8a08585f97a9f8809ef162579d99e61adb3160f773408571ad5b11e6ca189bfedc96b4dcd0eec30e851d3a6cc3c5d351892e23ab106331d11683ab833449a7f67c6ce8686df8e92dce9b05f1861285cf7b23aca5cad1be21da5d08326323949c7503a7dad61b73a74f80e588440d431e09bf4a2c9de7cecd633532fe96e32d53800bd07dcce0aee0b75ec1e065d42ba4a17a8ce0aa31274a72ecee9d40af85f380e65f8ee3f005d774b1606882ad5370957a49e15821a427c7480c6e166597b74cd6a1b3e057306d8f2a4f6cb5934e2603d871a757a665c9db71fadcc4366a8ee76442437870afed831583c0d8cf8ff8f9acb01ebca804828acb5c6f5b26090634970945e12ad5de53aa2ef652b4c562512c9095abf690aad4d0638d65efa5712b6b0e0837dbab9d4a4bcc7aa546e8efa063ca88288093e1d0a4a16d8b8e174c457b83e454a5f2aeb330b365f3ed53880134e582c9c41da62ee50c8a538c17ca7d330c139a6d98d4855cd7b765c589ae4d4bc297d0ccaac4e51f702f6f0a7adbefcb24b1f31dfe9b3948d68e8c97ecea4cda46d8ff9bf15ef5a32aac66dc7a3948c7b445c2adddd88da669fb57c6ba1ef6dcbee739d1d16a1886b01a0db76d5a4599889cbb7b04d2c6c8a063794d4ae2c8560a142d570e1bcf5c9f69e411d4d918131057f45977e12e0c95403b4d00a46ea1ee9ca2dd11d34e7e4872d970d7fef20d1fc24f633ab8cb45db66ed47bdef8146e8e530facdf3a17be34528c49ed68993a9477bc3b55199eb4a72a6ca5fbe1d82db8116450b09978eda48b3f9f01bcd7f251b296334461f7453629d61c613bb03ebdeac3ae8651bb0f94a32efa7db3d8772f2b95ec0ccb0c28322d5af0c5d18b7c1f19261fdcafb6e5c2858647bb7574e9d9b34ee59f2bae05875e1ab7ffbdc56fbf4d6623dfb26bc564779b7e76ed6d9d3a5ebdf669b211eb7785a9dd331d05f4e322e24d39b0203f9ffccb77b4318b4dda4fadb706e41f97c502642afc80976b24714a025e8b02357aa054aff8af3a5a09c69b559e8748eceb15027e854599d411711f130d9efdd19386b1fad7d0c53125ec2336f60e8695b760b8b7a1014ace192a26afd5a9c8b69d41b3482e2acc50adce3ff9e83e5600726fbc82ade854bbfee244a8b259806f713f5b9a0e3362ed302e633c999f031136b23afe3aeba8bba1f62db11b5b8af06095c259725b7444027b16d2ac6881bb81f52b5ce5498b5a08e388cd6b123181c182af3a4ac45a9a62e2d3578f692737ba64825d18be22ab0f6aa5746fe30cdfafea637cb20a2efcccc7e1e02de051c9f4a13da8efd18e168c01fa2d4d956537c7726ab4bd89d68869bd5af271aa791a060432db661283b76e0bf8b01056f5d18fc74e6d490cfc3dcdcfcba60f717e09741ce7a7c86b592db1ebd3a758c9432ae64133575d00e2f6b4af023bae2100c6e8acddb8db3a8be5e638cdd861901357fcadd1f022b3adfebf3696d0a4ec4adae2ac876ad029565f005719550825daacc95fa5c289127dba715bb311c94ec3be74e75d632e6f2d6c1ad105d8be1d7af237b044ed4035fb4cb3872d4eaaf9a3d6bb5d9b71eb3135f53affe6b5dfc0e8e487053365e3611740d80924e345bf3ec84cd81df4f10f24fe08a4fdf7b3ae980547e9759b269d3bd73df24e64654e71e4c14b436f6420ae36a5e7ced129ac9dc98ef766ef56092de70cebcfa83e17641262ebc34802a3edbd6b92843ca794ac29a39b35f1211404e757f288592230902f90ff15949f47ccb4fdbae81bf614ab9370160bd1565789ef31fb7f12360c3eecbd3ca00dd0a9f4542352a41aedf70a82331d41a240146f498e49b2f2789a03b3f8fb37a9fedb714ff8a4afaa6b4e450daf881ae170562a4ec067d6dc1cac50d04a00d5da9fce93401ddf187b14a284b431b70f4e4b5fe37cf872a6cc0a3f99c29f2ae334641782d26dcb85b89aa55b1e76434886c19eaeb705b8898c765105c2f537f4ade6b2484a4dd48bde3974ca3ccbc00750ba15e32f2ca847be5ffc1ddb19ef0f2af9d442fcfc08d06e3ddcde655cd165df64459183c4d9823f05f7a0dd18bf65f868ea58bacf60faaeb4573568eb060dc805885d4faa68700857c8b7774317ba0e9d729a5ab561bf1c3c7b89cc070e867c4aea38e0fc03304d34cdc087f9707ab554da4290cbbdacd980cb3b631564928082456a431d7f25f7df6ba89faed27d12fc197213d99f42909df5f40b5400a39191776a6c1251ff597075d7f0dad3e4e2a8551245b4176e2780ac7132b41d377ce2855c97ccbfc47b8ffbabe4419a460c666d96c1972dadc359918f653a10ce4b3f65cf7b30948ebb8a0ed7d92350ad9b82360d6befbc9ce58fe0c3159a1087f0d8a3c68fe520e2322c3dc53ae85d35ede498f3534d8516fb2157b180ebd492169b0ae26ba4a4028db04deb7f31ce5d1ad66c6be51b1452f38559506290d2044aecc44d8b11b72f7736dbd3526a3d01b6e2a27007b05560dbcb17834c8b27308c72f9861ee0973e43e6794b8cb1fea2c11aaebd9efe5247cb39fdc7a8a65918724d747ccbf5859af0c598389afde620c33de7122b603b6f63671337b479aa02ef392a8c3015957374ed1b52f6662de8298e79227bee0307b588167a3ef57e9cef5cb5d4926bbca127e4f469d3479048c4dd7554b9755a8dce17452d539722860529f6e6417fafe270e7e44e01b97d333c8001e8516f54d11d59eac2063beaba2f6d33e487ee58f96e3eb93bc02c16176d59046ccf706371586165159129089102876f670200b28322d20b4d95f5ed126f6b1e183730129906e38356e12a735e351c96bfa4c9e51fa9562d342b4b286a3f29bfc1925f022dd746f50c92f6979b2d608ebaa2aaab41ab1ec735b1c4888d3643a6f54b48f219c2c1e608e53ebce101d639c0f7a74b52f559f77ea1804e9a673fa35b16b0f0f03ac4f7944eb6df4a8ade5f9fdb3f85893caeefa1e329643f061a4df4bf803419a0f85bede35e21b3fa4f883d1d8c71d5286183e13e99d16021845b899992ce8a3d469ff93851f01af78a3f53fca8807fc5bd1c1c49d0223ddecdc81a689765cb710891cb312c22f18dac7a34453cfe50fa586b48f8e4feb049e2e3d2509e7c4f969a54aed94a94f3616875b31c6fc47d4d8b8318b0d3a1f1849798cc27ec1926c2f759d63d816f50e3d24865b4266f8bd79738cb5607a7480d3897b454e3907aed76515399b70fe08a78a3072b67614fd2dcb67e3922f2e66011e13a3c44365468501b08173d0570feba39e34859d1b87a3dee7746b186eee3fdbd89f087ddfe5db277f1ebd153dede11d448969a8b7a4664815443356041489cff7688dfdf267b6ebc8737ca172675d2414896a425b34a90055fae33a3336ad7ca3f8bc94a4fb51cdd956c680b870bb128fde7981b00c0f131088264cbae5590f71d50017af1ad9ec2a2792f0428d13a4bb8b6eb95ff6ad74bb5b3fc8b160e283d8da5bc37387092f7fe76fc2065d6a7d62016806aff80970b4a8c9019710a54f582bc815721f455a7473470e547c07e85ffcb9e25927a764aa2dbb3b1e7eb621d6a24c1c32053b131c4e87bfa8c2c837f22c3d2f498bd25c6cef2349cd7c6822a11e6c2319e6da80d6faffdda818dceb060b9f4b03222269cf7bc0f0ad4f22c2dae6c493d3c798e91cf3410e4ca1bb6ba88c0a9463aa248a01cec29eb35b67905f1148e85834ba0bcdc0069a498f7907295f47486d8f63d599a83d57e960a6a6a9e94080c4a3662660d1d668ac9f2b04a7ebd1183feff0e12224b691568f2876a0ff55e5f68e8f34563852f0a419c9722de5147e816a8606ebec990ed4b88755f3a124cb2fe6a8a4de1c0ba080b788374992d89ddf68dc2d9dd07d14ec92d3ce1ab9ff0eadc9d00a627eea882b0e4eba669bb08657d7bdb7e7c4763d2f81f90ace24423c74c260beeb38753acd5a4e05d8b5309965455010dd53249600a14de4936970c1545ba4bc263a03464c10a3302046003b5b1ebdaf9ad66c6d5af5211555b656f08872da247ef2b8cef66521b5c60190fa1e3b40a5ecc9735659083692d58671283ea95eec0aa94327f902db9fe85b92b2995fe83df8c10e00511140c973e0bef3458ac4c7dd0c7aa2b8388fe067af17a112e2589cf81558d39f96c5d906905649ba255b5919c00db655cbfe65561597bbaa47acab88ab9be3304fc04bdc768b2a44e60d75a1dfb247226fd5d6bd4e9d1740b47fe49a0763a7ee5e11019310b5ea315ddddc15c80424c168271baac794a5fc1e9b1d1a3a08e2b444990fe87bf20981a57cf025c535d92f641c89aeff80a353d6175c24603ef9cb886239572348dc0ec379473d00d5b7b9f89daa7a72b0f0b4dc64b9a7991233edf98f9a9ea26a958b380f428a40554b8147c0831886182f6cfd5b3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
