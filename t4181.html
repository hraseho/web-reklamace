<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"26735577cfbca5be307f0c4a3df3c49d4de2fb58c49c56643999dbe72b0b0b642e31b0d24210dbde2acd5f259ae6137813153f5781c9506b7cc6b7f308c6a4ab9921e67b57a240f13b511e5a348e06058235192cd4d4ea72f6bef020194c013bbc851a8e594ee8d77fbed0634125056c84ff732357c9853c962d1a5df6afefa85370c4378eab33f867766a2754236d7b4760ba04330cd75b85aff0acdc51d6e8a4e0860eb0422379adcb218d243bc7da6519e57130df955096e2b7e7520d4e7d1921e5b9faa87700755d74da5ede718a90ad1d13991957ddcbe0263d239e6a76a330745ba0fbe395c2715df640b32926aa3b554dbad4b065fb9961a93bcdace1bde24fbf0613f4958c0aea238c0cbbcbcb68dc59b41e0eaa310e52eafd165a1632f871ec1fe11d546718fc10856aa872373ae088ce6afbb449849c82cf8a73d0f10fe9de47ca8d54eea3d5fe50ecf645af24ae2a6e5bdd0f15110b72be1af865d695d4ea4d41d764193535849350bc391318b5979e634be5fa4091045406363051e39b278862a59d59bc9bd3b419b31c29ba61ac4bb620097194ec39a37a1c4c5afdce4e2089c3c2dcd96e57dad5f91c13cd6689b0d29be010d97a365572017d0ccc29c1dc326c98183b826fcaaec5abaa7d754fa75abcb5c29b90171514134c798cecacbff7210fa134526debaf58f307787d81e18b22f2ece0f5eeb2907f825485eb19d64c0c340b5333b16fbe795078ad8e6b05947d761b26e20d3fd2a6271c72306f13e03adc26a45cae07189ec4059f43a0458f626cdc2e4963186d90d633a18838c397a1a45c97a89bdea904726495509d00b5586e3481fece40423c111e287a02b7696147fa58a4f4af02ea12c68962f6f25821d346193cd5cd94a6aa78b672c769b183fb83cf0d4585de4be545bb056ffb8b69e24329a180b5ca4071f12fe478d30e967ce66a620ad554899c86a341e1a0ff7e0cdbcc6318762f5c59e367ca44531e150ffb9356a944730d6c739ecefad44921ede13df3b49c802362469fccf806db5330f8253ab38c9c92da41395e74bbfffbe1b50638518f0ef0725e91402302b90735eee3b45b195b10585fffe957431f5174981e69b00f5abb993a93a8c30003ba8430efad7e05ad0230ee713d5e5f563ee8865c15090598b6eca4cb3f2ff371effc89f60b2c011a63cf19f04458813b0aded2b13eb1471d4b6def10a66dcf52c3ecb1e8dda3aaa977b3a42564d7bdf5cf7bf1ff260abdcc08b5dcc8f90c8c831b93ebc9301b96da3d734cc5166865ceffffdcc68170aca63db9e14106cb6a3c9a45aef9a0016c00de6343cb9185943c7e2995746121c1a7b0be892166a8c79e1a28eff95c8e71343e920e8a0e81c216d8c4ada2dd7f491a014176b6ceb5994261786224de7525368c5f51f37e4edea54bd4dff996876d99c762a51f5209acc876d83bcda42cc1ccca99a3205a0dc71e04819c823fc855221a61fe02a3a01b7df7c0e9e0da8db2ee3fe04366b82d8383df7ad06dcd587da5b3ebc5f25cebd8476a27afae6268c832b4fcac8cc69aff661c778332e4231b1d3001b8d04b5a8b75df19bb6edd3f46202145557c67b140c5f0558fe865e658c270631eb0123b4763d07fd601a8b0ab5f1effaae95b7f6593b0b82952239a99cd67a54857a5e127fe1bbd64604f81e327fcd47aa65cab12db2551012b4fb8b61e158770956954387a4c43ea3529e3886771ec0aeff4a6cf52a83cc858f870ffcfe8c08bd6a8d85a0ac45021b8ead3833b8e9877f3a38ac9970dfa9a2803e3606479644be16e0d30f384ef0966ac10d2dd65ae08c9ee83279a824bbf37016e98bcc5830fed6c4e27c7bbf11c1931c278d3f09d37403843276c89d6f724ec8e36d3b597fa271f2119cee074855905227ee725eb77314130c6cb03e9370209dc4f594cccbd72f24cc176c5fc6081c3dbe116b5fb609f71ae37be0f51c11b94e9cf978c65a021ca06930723b1b53c77ffac58096a9774442e70405aa47da2a50bb4bbee9d47631d27f430829fa923de0ae7956b3efd2a6736a4229e5b9f0d9e27438b794f568a40d69cfd49bebb819498b16882963155dc798230912f2f550819a5be869a35c5538a91b4f1e3bbb0934e9b66497b4e3eb4fba669bf58906842b1c933b69d579a8ca9766d2003f89b7a9841c413072fa72ed8366362f39c64992ca4eb8f441e2f1eef3a08d0de5e1a3d6a66669fa219f3cfa6798af6098a36995272ee59fc4636858d380c78be044fb2131d0dcc92d5fdd6a1cdca299e912ad1e7a77379d39e193f4a3ba85f3e300059cea43621e0dd155b79b615514d2f302b78ea1333dccf6566f1e2d8a77bd6c8e4e12c39b778bde17e6f63ed3d7e15dee5d2a36d78bd0c5818ba1a7d7ab9b1a36b98f3ab8665c072ccc7f922b85901ece473827e4d54733d89aec1789d09fe20b22b0eb1256a1bc475d5233131fe892df3748ce68d3a9536bc1f38fdc2457f16caef13f5e624953e164e837ca945700bf975c679ede343a6c3658495b5941b513b6e519ec268d1452f3d33e2fedebf45173cdb4e85afbd9b7b742b71250a492f5b3f74eae61479b4da4c80bb4408a27c553248e3479fe8a82b88c2ddb914eebb747ccc724c020dd10533dc58bbddd0552d3d4ffc73bde2df3029bbf939edc2e959920ecc85188faed1e57561795f7606f3ca9da3979fd19d86326a413b9d2508fe12e812f4b8e01cb595406b746c775237e570c8624149b57ff4331b8e8fabb63d52a75bc2cccfd3169fd5f4d371232565f8809f3eae107d3ca150b4a67c3a6edd95a6bab084469da991b6618372a90624b74a9bf6b225031069c03aaf4f6e29b5e451452024ab53746725cb9a3c4ed5d99144c0820af21afbb9a9973c43a42396232482badb3680f602ed80a17a028c2085d557fc5ee17592ada99c6161c36172151a50eff64ad3dfa235598e3b3a3d57419d0b4f217642469cf9ecb2387748fc15002a005a61499d1d2ae245330deb77277de11682f7c102b43b10cc855af35753e10aa24bb57eaefd29f7760439167719e87ebb62cadcf62019d9cb710328b536269184e01aee85a985a46032a9086c6d2826519f2ab022433d844d2791f49c6f94af6e165302322e98a0f606d2c8f5fb6a3d04d3569e4d61d8ee8c397920012a7d65434ae8a3b122c6209adbe187ab417f53616f20cfd3630451b3e8c563ba6fa4a638c489bdb86c7c77d6a611c4671b84f2cdc71e6ac4047e9485a94728f1084d11e47850469d6e14f80f80fc2f406dd27d24beed5f2b41b972c2ba7f690a2c78f223d61a042d44cf977714f82f5bb51ffeb2744084e82db03cbb750b51f197adae3800a93e49db0c4a3ab646597d171c528d6f1a669e26b6024213a4d8d2e741ed9adcf867c1926d6348007188e3bbda38fdb6005972686510d55ab9e148c1274ae390331ffa7dd62a00ecd303765b40f457f60251f4da8d90e1d62cf9b3e61216abf86899975b57ea5e0a9c5f7ba7ad2f17687964a143bd0c6906e94039d96838789eaf8f17423a0d5b90a9062b3dc0d5bd9a91055d27ed23a0a4451c81129c4f4c97ee803e32672d6d43e186557771efd396d4a64ab5e7986d9f98e755966af2b99505b40d6ab1c944d81d0262477a3238496d1f6a1c6dda0e1f75c2ed11d2f5e4a9fbf04bc05b8adabc000b2bdb7ee2e44bffe20fe96d73d40165e2546b152e4704bec64eb12176c2cf613fad453e7f385b7029be544172c3b47470b6639a4643f2580fe51947dc7dcfbf2a9bf4f495318570298962e666d01df5fd051150d1bf25ce5bcf558ea00388f58e95ef00f07329ce1e302f247e14c7534a681cda3cecb589ef93dd780288cf20ebdcfa6a677f08d5140dcf036a9957d8dc2cc33468ba2570e66a41bbc99898d4505031eea9f5d5174e8287a2aa3216425e3dd6d1ae6ccac2f78ed66ccde3ae5017884066fc90d847fbfc3253c0f76ba6ca9f9f76f1ea1647ce5ad23cfb49ba91b26d9ed04248b662ccac31f85c115ad571cd08dd7c0517a7653ae0825a40e6cfea9c902fa97846833988306b762fd8b44226beeb42a7f1ab1c52cb6c464ae9729559d45bae3665cfc37bf5d0bcf47697071111798b042767feb94d0cedeba440c5b5eeb226b6bff6afa9219d7aa22cf6cde145ad50ccde29215c56366c772c98d174f9ebb58ec57ffc440b3beca5c3a1f753182f290d9d330a9a9d74ab18ab27cce6bbfb2738b756c87f2d68f133bf5709ee5cc23165c5c9486bd11e00f1acbdeacfebe4ab1b7a403af365de3768a320382c0f34298885c885f015cab6f0cd185353d71140678dff9a1a19751927e67032f316b8aa2278a25be76bb50accdcdac3d233c66477c1c4da6a66e2d9d204a9bd2bd7d71b90969b0789e46746879bbc09954bcd4b53c39e18abfcdb23428cf562d5fa4bfcce58b3a0f9ed4a5a4540b945ac4e2bdfababf009ccec0f565aa21d2e6fb90b8032e8c3337de2fc5454e0a6c34bc4499fd366c70a72a175da7470a869238bf2e822064a14de2a175447b9b4e964be3e1b20c4ec9e53ab4f9e38b23e8188c8f7e5be2fbb39995c47ed2114389f15664daaaf5a3fe79580275746f6664e34c213d4f007cddf277035f54a107c226acb4c0a21c84bb838c8e3a1cbca25a71da3e057b60082817c66e69717155b5051559adcc11dc472a90799ba2accfd0aa7439f574b83a36ddc9b7006e3876a91718f8f22e675220f1441cfa352e6a5a0ac40c6fc047b1acd93e564b49741ef72c82bd46dced8461baa8ad9fb13cf99d0840b3686055e4035cee924cc0463090ad0f2c05ba865b3f477bd36b2ce32ccbbcc793a714c94461f9ed4d74acca4ad69b6aed36fe771b1223fc77582d801cff7f767e870c45a00ddf29f1752f5cf59eae90b5e275f8d9acd635c3100d7d9a3e07f7a47859d70e2e49652457e6ef11d5bea4a401dddf7ef6344d892f16732df521d1af5e239e992217c6fa39a1723723df11cf024ff1d04959d9e93a3be8e251dd3935e60d7a6ea995e4279069b942cc4bafdf01a40e2c3d6454e4120f367e47da669b875ecd62ba2478930a05b0fe0b609333be3bb3b3b41eef0483596d6eeedf0984534b8ec335c3b2c35b62d1dfc475e0f0bad0998f6e22cc2c787df6d07820a1fc7103560b1ae89177b5de36b85dcc8ef514cb2b514449b1292f1aca896b6d7414517cc057a8ef60c1692c2d9996dca248fef37b4ff2a7e6784a0f931da14c26242933da3096b080a32a965d2f4ade5ee521720f57a9f0023aeaa96d3521e07b29f639c4ed4d6b9ab40a40bc63a9879e5e021964a91cc0255a503faebf2fa6179434d6bf0f31ae30e0c728639eefaa3556aacee9cad6f53e89663a07fc7c6d44a5b768c03fdecf311c8f5c6c43d920a4988820989a83fff4961ca574e0cc93b6b15a88c4114089626814d2ca9d3d773fe99284743d5dfa26725f920fb62d10f0379fc3801183e12a0f87fad3170ca8e374a0fad8db2b928747f80697719613ababdea6acec3759177cee16f14403d5b3fac4c9f5079b74c501eeca82e30580477d472e8e7ef06b3ba1a7aeca4574790ed73934e89dee3ba792a576f26fdf31092c21b7fc14b6180744e7807a10860bbb030056dc1145c73c2dd1497c20b362894303b5658d0ff3660de6a34cf0e9bedfe29c7f107574562a06ad743cff07a6252cd4281885bdb4785e0f2e951abc06ba12709bcfa9d517928c54c3d1c8159181f044a525685877fec94b5bdf7a22cd595f209183fe0cb937fbda98edb40f9e18c056a21402e0be507d537ae832ee73da543176e48651058a7cb84bbc95e657f0c29552e3ffaefa42da5ddf024a246b383ce1374d2ddc8fc28ada7e70e4b65a8328967745812119010f2b513eca91a9ea143db416e7b74096ea46cf227829e60bc6afa5a9a8f61dfa8adc3e0c663d5e2974d3de05add410d776d347724d5bed1a571fba9761a61ebd9aae7d0b6596e1bf071062255f1d96070ac1e44ff5e1791eeeec58852ec8405d6a08eadbcd20e22a31c66bdb7f242c271c8dcd096eb0eed49f1adff678965ff1d77b06ee7ba48e491992da9cd8f0c2e0a564dd25a7d4c17ba394dafec2ff764b0764bd201704b722b198deb054862cd64cf1ff6feb67c09dfa08e6a310aefe48135b50cb4b5f2fbb27f79f2b27f30b1bffefb75a333effb75790e37048162cdc8ec450480063311b6d45aee15de53cdf65265079c0ee59526f57234db81e876377a1e3654c55960177cebd95e41fea95dfe527989fd4fd52b4189ec6b071522b71cde3a9e0598f9d60fe706fa05007c881163ba84fa8a296e7cce163eb781c0f7879c8fd9ba6df29c9067775fa360b17a9979e02018f9ab80375c9292f7de283511087230f4f363b19c72d93470f3d4eaa60273b37e5110c04ddc8f6589951b16053133579e031cf7f8fdb471a53898013085b539087de7965e2af5aedff418bdf90b37c580beffb3026a3561b72aaf6333375cdc6286ef11dca38cf87f58c7889d0e0500ea9e9719f57961f694f0d3ddb3bea680a5817619673019ea00a0ef1183b32fdd3472975287b85250caba2865d2a471e266d941475bffbcb41c626af71a052b243c3e6a35f2728afcbefeeb59b1dd32f2cc6b20aa5c314e80f088e87affb44cec5a7926ec830addfeb8c6f032d261db022fcba56a6fd92326b16e952398bf323a296c9b6316720f43545c4b9a62a2699c86218287d614aeb7a2e958450899fed6a917fbb82691135f934cd1262ae9a6c7bbb72e41514e0edcfec07cb4b0e20e12693a9ff0f4eb026dfbd6f481b826971ef03b18407518dded5fa47b970effaac1fa80795bd2ee1797b4f0020c0c2ad461190c539b33fd0c5b12ef5abb6ca92342139bf2e6fe3589b1725f7cc8cf882e7c4549df7648e4442807143aeda044c8ae341fb30af1889cb6e143f1555175a9de5b8a805ea68d19b6b5a00d30ef4f41a5f974eba1c05c7af38f2e3aa3edc2ebe8c346d65928fcf0d136868ab8b6f33f1999507c4e0d32d0d70d6ca6e4e71d9dc148009bcbd9e1e3d04b439484e36645f4402ba2c9e6c0b78fa5c0b90f72c222c50b40f2d77c1aa65c6731f2cfb391709bb4e5c83fee49c55173b8b1b45530ea04063657ddb0fa1e9cb93ce063ec2fc96887ddf3b3c20d768f680a540b3a120b12d1192ff65c58faefd61f85683861b9f5efa8bb9c9b933765c3e1a5bc476ed163d650769f0418e2bb0b66f50dd327d52d0541ad158349eddfcb66c22afe08741296711fbda9e22d7c0445a724d3db9f25ba15c1399c177093a692a39a0e4548ec269d9193ee048a8b7f81393540145488a0a4d912853673ac0de714b03ba48315b590b8bd9dfd6405049ab0858a730b3d5d531a5329525865fb6764553c7c0b0c0bf85223acd2c2062a9d5a4b2b8f12076f71ee9407790cf433e12db62aeabca40dfc3d809762e3d76e166b0354f9ffd3e118d3bf3fc82f40f0edc3c37f9e5b7a99d70d0ef571f39339549491c2acfdc0dce21dd45f606b7437fed3ee6b0fc01d1e7cb0dfa32c62ca8a1694d75a53cd4cf4f35ec67d7a9f03a469ec980cf552ac6a6224088d181c743742c940b6ab585a84abdc71a9cdd14bdb654d58a7001b0e7be668049facf8e9dd159c84c559b89aa8e2336f9c7afd869e8f0facd38b90ea28f9f61b6596365b6d084da5e9c017117d76b8fa4d1b797c392499ab1ec14629c224246421ea4749d2bed4cdfa46ceb361e5fbba875ec788070dec5ce65963308905ccb0393775cab396594253a1a6561b07b41f52112b8447ca550f258f0fdbb3fbc40ff2be378e2ec39e7bbfba1d5771b6fc3524596d5ed4770784d6d6d151528ba24ef487ea76d99b25ecf05912a91d048d7c4f926adb421e613bcd098f2b9bb72755e892d84167dda522867b9dd18fcd0e9393807cbb1e6fccebbe9c3d5dcb228e117abb9c558734081326839d8df19411f62fc9415650a8257d6b539c6f4491f4a36936e097a511dc6dea832c4ea1e4bbf44e5c9d325b762d62bd55cb8d70c37fb004dcfd55dbfa205be4da8b99713052c3ce33721cf89dff1480486560ac3996d607ddd4fa2a98201a631931ad329b6635df206e69bf02a74646936ecd392372e873a5a6774a88cd4f76fad4bcd52aada7932048c3fce7455acba9ab63be68027f11a3cbece44fcc188487fe95a6fe6277aff869325c03680b7941c7366726f04e2b6565a6c1bff170c67d964881a1f40abf6e914f047bb2a1257bb291557da36f8285d61585eee86583917bf45a69ed59429a04d8881b17f53aed58f150b66aba850f2e6676358e22e4d3d60ff0687aa8cacc13c91dee06e394ebdfdf679bb46e1e4c28e29346c6ec4222c0718e9a7a0665fd2e238220b1a11716229514af223c0baaecf5641ec21831598d66cbbc972ef1100d72b898a0a403ca87a54c9906184d8f5fd092e027f6f7b1a4be4c274a8124799713794f5aa895df82db65f0d8e1c6f3332ac0d89b14e266e56d8bbddf8ad6acd305115ec1dcf08cf6bf8ef47c64f6eee0afe60fd795904cf25dc1703e8fc81c500e5999e36628ad3887bdff19da5e11398103e2a61ebaf81b624d41094fbf842a87f5b9a01615d5c08b8e3b00b32fd646246be29cd48130b196b4d06329118330d5c4638bd3989229da91b43cf9a77ffbb77e57300c79684d4ed7f0434272bfce2a76151ca5d1fb068419ff16d61508dc6240461df6096e7735ab773f66ca6387c6edc075db3b5e403f91a1b3db9487457318dd56a458526a7bb274f93fbb78714dabea0a290c8a680eea66dab458500b9a1464ce3e42019e17923af36d2a01939c5f1026d03b7ee4004a77548b6fd7929e53e2735d24417559d5c108df85bebec7e5ef053a3e903572edc32d194b9923c9c20cdd1a3e84a6762039dcc6463b5e4dc75a1ddb47f6709446fd64459c206d4d61f56e2276c024f46fc28aaa0e577c5a8f838664a4dcad571b2cf793ad0464b94f5cf5c67b1a0f79aafdc17d9008483cdaaecb0fb89f45bec5f8ba50d0c4dab615ab92ab97c04038b090b268c051a75406bb51b69729262da922c165ad943be2529786b54f5924dd17d0d8dd709a5187de819fced8911cb73f0d3c7734e5469c5fa454d4e3f88556acd19eb5fb86dfa9715b4f9edaafc4585043b4905c7ff97da54708b641a8b02cbf222c8b3a61fd58e6ab689ae56996699a2e7dbc8a35957fbacdfbc83c186717032ffabbcd48048d9c1bab6b8fb0b33b69b1ab42340e9ea134f51813ad676684002df7960a4f525634e29bfefc7f513055e8476761069e2f76075c74c836b757f5ace6359fdb5475c28fa2be7dfe5e4dee8597757cfdcc7d762c0fc3248a8666d4c1840eef234668ce50f3f18a0f32a14d8355f450a6501f66591884ef60124b6e8ef5676c53f8d5bbb75b7f566f0a9d67e2d5f80fb790dd3f3125087fd2013d17aed685d0ca3d1d404f6c9e37611cfbff0f5b7a74d57cd5002e320611ba603a4e7b1b90fd1438157f6fed624cdb7cd48df2517e68f2facce04dc29ef9fb43824f936ccec7c5ce1f6acd60cc026cfc077ff2daee174a5dd616350fd8f3aa47860b007f507aaeb35ccd3c5f1279e7720365ed48cb2946544f9f7dc862caea44e5ca5354cffa9246f10267b4e05095d94d02a5a36d2b58d5241904a323e3d273f3dc608dec10338e98894e8ee9b5a954869f0dd39ff70cf8915d72379ed3d03ce0b0183241d94db7c8086e791baf9462edada32aa9487ef7d0857a8457edbcfdf79f68b06fadb03e9ee49f24b845b5d5354cb7b442bb808d84be1bf5a8924985625a31fe4ccb2a39a6bd2e373c99edebeb3dbe8dc24927c59d441aba3c5c1fdb309d6dec2508f546b51089e790278db626fb8489a2fe29c580988d50c4f2c41d0526fd38049b100b522a0c656b97f3a674214459aea5d52959a492ca4f8b21b08b9b480f9a057105a43b9eb5a5c75836ffbbad428e20f9e42bf4d7756dcf9c006aa068ac0df7a7cf575a680d98cf30c4b218433094116030ca90fa53bc55828385837d0224ce2d899036e46bbed8d901eb8735ccffaf64b1bd4f536301c31a2af88125e9c615b97bbe7e1137a44986b574a6ca4a2bbf0193cd07a45e3377356b14f42164e8b1a1bb2ede1ea80d7b6c6f07f22bd1b4e43276f72bc029dea72679e1712d315062044edcb2698cfa314ea5c52fe868e987780586b6a7e4ad5febbb8a448ab04b0e0d7105b35b125e3483d6eccec34dd18e09ce69d86a06caeaaa5a3ff50d86773aaf4ff5c745d56913ee4496bd2bf9f66b2667f6051bd1fe5ca76d0ecba5083beb5e60a063f7928d853bdb18ca9fba1818d380a08133a34b5f626b6f097f20165c9219a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
