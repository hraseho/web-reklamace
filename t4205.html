<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d983d96deab0ec81c1f0ce3674200b9426478acdf828cbff107f2d573ef14f5aa50190a4b221bb55c0d296128f51f8eec73be3c6ec0fe23d664861289daaf2241db902012643c03ac306da7720d9478845711b36969c7c664868dba0243c579f48e600b93e231cc7943562249d22ca4dc793a9a292ba3d4105f14d3f395314b42995470c972ef2289152a14adf7f92dc280aef14dc5fbdd0a615bcc7571ae87dc886644d81e79730c348f13f877c4d322c08163da6c51b1698a04739d5eb0dba4fb2aa94dd7863af50561e7e81e94c1ea5f201025e78510edbddfd53bf7a380acb25553060a841e055559aec5ec0895a7a880517fe78f287661cb6d9362b5e1dbb5971a9b50d7d86b86774c034bab35961fff38f6355ccbe75263d2efa2fbc7c3b928df75f96c6478af08978f4e38c9f26e6c81c7072667dd229989a49daf86fc5b95ae40f17ef32b184939e08b3ed3826bd011b7495952c0238e0f9d901f9bbffc58f8689fd072cefe321b63b7e40d83eea8a9c753c58758e5a65286a1f82ba75765c2754cab57dcbaf17ae033c1e1c8392565273cdf06eb05ce15ec8ab1d556840a3a303fea0251ec355e4ba05057e73050834afadfcede3be38d3535138ea5c115355f36c75d3e8716ab4e0e6b87b074f356e5fcb8a047f2bf0443a02e65ec1fba2fdc9dadfbc83773b37576b5a06cd73949a9a6a033e24f04befae4ed285e9503993bcefb18f3c3987fbe3f9f708ca586bf204661d92280a6119b209ad492ffbbc6af2919595db2afed14f8c0e8ce35d5a09d6260b70c230de13ec428f52e9bd43e3ffcaa05898abc8fbee9b36cb78d38233d85fb835bd416925ae550eab577ebf7a13a842477a3fc4df997eee603a377de21ca5845c7766119ffb34ec7164202e68e24a20f1d96972c08725a4da9b41e3eee554cf6142eec6fe6d9c52c4aab24f1be33fe43e71f01f67a2e5d7e4c423a4fc33f1228f6d5d4cb643c0475e2d6198aa9e0bdc1a7a1d4d6463b615be7080fbeb0556589a3e44b1877f94eeeb23ad2241633c7bfba47e0ecbc61c2f078d1f57631a0b4c0fd742d7e31746ce5cca466ebd6f178cdac73aee4571c90184b7dfe3f3b99e24206ec875779758936ae1513a90634a09dee739b0ba22394b73ade80b2f4e451fa8176c4b3df8c53ea8a0b863f3b7e4da1efff064052bc9915fcbefd4872414e031ff012fdea9306024b043c3dcf9aad6509e9afec5fbaa8d836fd1e706314475e330aa8b3d35bedfb051a28b6cf47637e6dbd01f22e13040ad4937b68f165a7e42d6871410913b692fe2127d8c2303c5c6f3e22d852c9e51bf76a7f6e263ce742562e437b3c59d3afe9ea86eb293f610186d66e24485d54a66b3c8c4a851714960fd1e77ccb55f982cedc06e20b8be02d6fba64fe47c9192413d736b6ba0c838ee3209914fbbb30ac35960fa9b20ec310688eb461b7d25f8b896efc3d228e13eee00293d1413a8f16ead46256b00d6d15cddcf5051518bd160b3a99d5ea2e2d2b8938d67ab7a709b700e9925daf2d085d893b061352a2052d7a8c7cfdc51f5e043a8bd3b975d0f2a137bab9810955420593e36cb692a0616d46b4f2e95c746e27970cdf6e424e3515237a195ed3d7f602e0c94436cd6325cd9f2be17cea8de069cc4ef3fdb3a84429354f8cc996b2eff900413d552b91bca90ae87509b76e1bc0d463c24827f21762045a33586271378728c16a27c6949add549e90c3a919b03a2dcf8d02d275b1a209e3409a0b4775e4d4816970ecdbdd866161706c1eb455a40c473a36b67d9a160eb0f605c4f9f08cd205be6d7cd239ed95a41b76f03741475bfa5de379d51947f33d3277026445c5c1ee5ffbae5e06b7822c7fbd3fba2c48a64e7849a2b8b18582f404b3bb0fb177b4f1bc2c160965c545d60b4c12e48ca1e5f7f7aadd660f06272aceb3baca892780106b42aa5d97c2f550e56c396d4663b086838c25a1818a9f3768022e9d013203b39cd1b54f478af4c400959317c79f27e23935f070f7c47ee5b83e594fc45a063603aa16e59f7c3f6521e942a82dd503752d40952fe9d77777dc2748de3bc07c52928adb04f3466fe989f40163bb81d079652e0ec8da1175434f6298677ee874ed19d87917d718910e93a9f298cb0340c7f294cd2eed7e7e9183b2662612bd0dc1dffeeba4481bf34acc1cc228d7a24ee6d4121986c760299ac70d44b9704117cacb45e8a7987246c6d874720c4c02e5e9ab46a1c3d2d1756d170d66dd48e39e705645de2ced422439ee1edc723da9f6d0fff04673c24afb1d9679c01a3e59e618f70ca322083b5908bdf785c01e051a03acce4594f7f92a79fa5615617ed960eaa7bb7a29e410c15e95aeb8d86c529745467562546587f96d63e572cb4ffce1469d8942314db3e9f0cd67e5d919929bbaab635f9e1be966cf458726ceae115102868414826a01a8c3ca33f9a330bd75ac9234d2751baee22432cce576e2ce130a890e0e491dbb347631c99456318038347d0d5cf432b419fa22f0805096b674b03f41b43534e0fd2076f18a5f50b2dcefc7cbdb06cabf5c04378161fa10105978764511dcfe41617500c4a3ad7155a909a24e0fbc45c017dbf4fb0987633cdb1a6c67f5b8893fe8c51cbfb01fe457fb3eb85f75c08610418e73a015a93609b2b245857af1d35649c486ccfcb4a62cfab16164f6dbfd42ee49e4d815a5a18abb8bdc35650c082dc86ecbff4f8e2e97902b5901bea3218b08c305754d24ff2b93f3b45d441cd21a9c95dbdd371c4ea5c3b9a73e3276caa6c4ec6282dba2ef47bcf6dd8b9f6481c616ff2ece0a314249f1586ee251e3c8ec86a953188c813057ed3b1d206425a63273343b4b0a2db7e6b01dc84a22c372be1a4cc5f8fafb444d52e3893a5b611cebeab136b9200fbb8f36363bc7889da058708cd5ad755a7f2389202e59d3248a1d6e57edd76329928584df743c8c603f5cd2559e4793dc91493341a70ba91b955dc70efecbb54f469e45f22a777c9a9b2077fb42f27bed7611084a456f99c8d4de81cb0f4cb28a2ab544568b1a7763e7dabadad8a697225eea5572be864700fe11d6f62bb2a300202871d56feb34f0e34dbada40331b1874d29527244abb1221b16a87a4738197ff2d430dda30a502706de97a2d4fc2ec9d6ba4206a94650ff3ff5b838b2678eb83c89ed26ff64655c22efa5c7030763ac80aa9d2d74eb8d5d18ce2b8a382896d79aab697ba370a398a03d9c875ae7d42c9a19eb4752b6b49eb9acfb3be3bb6a5f15168b465f1c5870ce7c12abb98db5ea43ca8fdabe081a6dcadfd9c90419d14612c495086c37e025cc1e9c05e395957e8e4585479862cbd2e8776192a98e9f7012e0efb0552d62b5de0054fcf054333374a2af9eb5fb9868cf0ce98838f44d2fcce758f9f606568dda27fe46ce0fd8709331c39a208dad32425e184df6781c4d94993e0536187e2f96b97bfa9624de3c37965736d124a516570085d25e20ab46650010cd2aaa4074f25e11b8cd5ac51c12239f598ac319dbab239dab20cfa9bcf7a5aa3ba33ba56ab883ced2a157587768496d8e5f32bb9d2d2b362ecf9b31c2ad1cd0f88fd0ec6a293d86974021b099e31239ead4a09e077d931955157c6cf981502043ed9e7d9988d7d82b6db9f940b69f28a522b1c9f4c5b1d949cf46ef84b22fcbb35d95713cd702244860b4f1ca4fe5e789e7ae45f4c90784b6784f487ed0fd42f5e73e315858cf999adee160172a89a26c7d165c09b3c9774abbce18dabfb14c9555af1b30a9d89c40e95cf148478271e0ba2a1770c9e6ee6d7d19d6d93cbb7e1fd2a060300b2c72dbe61ff38285e8c18fdc17432d8ef8d069382548fac957843850670fc86b26aca5dd006a8b6e250d758df477ee60f05b33bdca9993a6ef967f122c6048f9143cdbf6850f0fb7da1c7a0ca7a2ac3336a1f0accbc65bb7d0486216ae0b49e2c036e56b026c7733e27654e7c7853e3e8870e13000d6ec4085b66ad337890ed5f31d8a7e6b21de4ed372d29aa17bce84ff30419a3988f2f378bdce094e2928abfc03affece48452d3a64b15c91fa76fc03301849ffa79e93e02f21bae128c148dae08cc95fbd8680a87405677e30f72c76a00be2cbbcb216b45569447673733a1ceb53a49e577bca2f36b3f307a3dc94ad101340352a6e8d707e7ba9aef8e7bcbaceafad0446f6a10231cab429d3aa201390e618020dc9637d41b38cbd4339c7fb5f39026afc350da419957e61bcb7c6c0c97a76b8095233a85419df752346dcd4f8d2f6de7fdfa873cfbeabe4411a1a162aa34d096ace77e7505cafb0b4c4c42473e4265fa4fa0ae9490223e44f8237d6f83ab9686464b7e893f40edd7fe4dcff67156b3e395e15d70457f55dbb5b840f26809fd070fdf1be500990315b5b169e66363f9cced7707107d4066372f94e8bbe843ce20604193ffdd8ecbd4cddbee0b5aee3a80548de9f2e04e3a35d5213ecd4bcf023f9a44ca43f4040cca02e051b9d83ce389612eadcd585e2a0663c4e3d73afc3ab8d97fe90c95045e279c5de9df01a48acf3923afbe3af29a17309dbc7f8594dd75e45313ed4d6af565427f77de486ba199cb508508353bf8497343a6aaa99491f58db426009e80ffa858c9b0026c5590c39e06e1048a433791e0661a9c57cb0d632b42af9a4f7e733370516e5fdbcbba9fa69e5d8ff375183d4b99072a4ac51f103aa2b21ec0bebfac68f41521e1db72443690209fc22292e0c5fb279ae7045f4a804a929c9e485f12987051589925e88b84d27f449fb169df8312a87d8e4bc607ab5d6ab7f20d90248aa1c4542947c7ecf8226bff2b2dbd781d24d7b0ed2cfec1d7a879dd04f094ba5bd07ebfdc91eb9dd3e5b7020ae529717e5e481b6415e74ecffed914bd4889f8ec7e94e2e9023b3a1cfd2b31355a53aaf115fcc6835cb77b69cec107cd732679274fd90bfdf336fa7a9959e4aa910c9a361c3811ccf28b538b4abf3a0c319f976b22295a3435b5b8ce0ccc25cf26905168dec1494891fa60fd92bc8f709dcce5c1265083d3393d4b80761f1327596481a1cf14b1587cff78c63c45959f66031917fcff4955d10e2747abc881222528fc88b19726796475b99137e89004f7a4dff04d939e37be5cc444a3eb0d1028936d1108f4551b5666232c80f7b94cbc3fb47b5206c4b2697585c380e1157e9778225894c2079a26a8fa1ba192a848138105f51e87bd995993697f4413aa7529e9931d3eb17af8daebe7b076da9c5fcada1ae7a3631555328ed1b7e11feb43b3c2568f81074ad2c18dd492ec72fddd099d31153bd9c221d81382e96af577dfc1d15d98d4af141ec7cde3421d28d5aea42977d6939c00ce233eaa381d7e0d02dc1ce91226732d773e213b6a0acceb45f79f312b12e0ddb687f0c7878e2b5093f5a2003be10b0433152a019e802b1bdb324d6a42014ee377a7632903cd953e2abcbe75f2e318011d04d4d6fa28b1189cde94592cfeda1975a648bbc2cfe65ff2f7f17ec21c7994e2f737257dd7c93bceb7d6c9345f8468aa7d3ca93b65b398516108d1b399e9f3655da63e3bb1df243f97b7c5ae4770e50def622191542d24b959376555a47d6372af83783072f48c06ff0110c170b9633f2c5132b3f1a5c5b6e743b78c25164d6248d6e581d955728af927ede646245687c197955aeff1a3d217381cbd20eed6cda6ae09ce82b4f3d0b413b34abb924c094412b70720d1712eb589eeadd563b2e9aa10821fb9fc7e858576b5028488d271436c3f65c1c79d5daaada8872dffe2a84d771cfc1a02bd50045cacf6f8d9206fe31f981d8ab320ba4898cf56275ee51508914f383e0109394f83f34fb7bfbcadbb431e979af9ae8223f9046f08e38d906df4e534a0c35df705881e91097bdb5b73bf8f877904566ed0a388f8833655b1250763c4c48949e45a851c71459a5a5e7d73dc88a7a584119d8b6ca96392932f9bc94d054da27247ab6ad76a779d2d0903b0acebfb49c0f8b68d85167c24ed0632cf8de56c7c5c2c3d5880b0f9c44c4797a9a8d70ff39aa6716f5876af734af778d7c278d8c51a874949b7d4dd2804a665e60fca513a36093d5c1601e67f583cc8af34fbb070dabec8524bf8ade0f6f495c522cbc044a5c2b9b6e8a9a7ea4ec0ff3f5622a03897ef6b18e5ed4cef1f80763dddb3d740ce682e021eebdb49a0a80a8ee077a7e1c62c3cd072b0c32a8b20e1bf9d79f8c7b691615ba65dfb8366d62c0e67c03f95f52a2a2efa0c3cf816939c1aad702658c6e90319ea2838d99f7b932f94b7f66b0ec10d3d3caab7da83ca2fe8051ecfb31c8d8aaec877da70342b6f8155453f4227d34d4dab853cfed9f584c0022c671892a5a324b39bd3d17c0db2e2466f4ed0c399918e401992885f1e4b10bf8c0b30ddb094360cd26912f817a2f6db831b33f8bef1a0e60bfe7d5eccb83c93f96b8bbed73d2428bb014d082e5a694ac6f830b976eaefe9683f3fa210632ba7051414b4dcbe2e51a84e599402e164bc2fd2b276b794b94fa8fa5e2de389cb72d5445d06ca1efd4ffee3b843307d329627e8b837e1d75526e31f87abc68f1ae14458d0a4ef71af72a3c35b72b44d2a6f338eaca11f54b8b79d71c7156fd2bcdd8a7f804ad5992e68692bdee925807e2ae59113f6456dc3c564de498f5b369bacd300da1eacec757117ee807d8b0fcf12388f49b325e5b5a43b0f6166c3fb8cf30e891c38b11c96d44dc7215bfffcc1cd2da5fc1760fe090d44eb056360f78a291e1dd7868f9d6121f3cb75577012036de65e3522eda397b0bd4d61a7e9507c2e0f590090403ffaf0e0e2936cea4b7b1a768825bd1362ea6f0e7714f5a4440d87742923fce63e5967b0e34827d25d3e0067862d2696ed91acf8b57d8451619456f151b40b365ee870323ea8bb73c4a1ebd73272439e95e3ac7fc0cd0fe3b55dd5eda2c562a051681c97ad287bb36f5df83abb596f455b41d0014b3a62beb37c6f176e4f21cbbcf7d8f6903dc6f602106241b0c4c6f0fac75a456773b813fa1fde5482223f8d768b65eb77dce1f609d09ced20e2b377fda05a8cbd8863313a76c1607bf6a9ed9a744fbf87adcca5311eb775bf15afdf30ea331ea9d6e91dc08535147169d8300d6331686853502c0d96f6761090133333c78e3bc9231d9e812eabba21a710dd8d219c21271028d613c024adcdca9d6e53c68d43490f0e5e1a29a2843cbe41bfd6b391158a4bf191f897c74264d82bf924438a38be3f7e2205b2b24cb81a592f39bd1c841c6ec13b633aa126bacfe850ce9af889f7af58bac718435176227042ee452caa29b6b6c22740c0d5c94992c99395a441973e25eb073efae1326add575beb3caa8a42935e2adb221fef717bd5e87942eb5aab06d848fa2817a415144c15baadaae1e2147e1584836b09bb3f05987b6cfa88a03630e1e8cd570b3a4adbcf605847475d2e616ed86cb15d0ff859bc63f922c8bf769ad8d129a4a25aed686cf142fa8f015a9484b6f72201b4204af8edf2112374ee9a17749de2b1129c09f212b9b6e356379c9d233041870e0f4eb47d46ba046dd7535297c0cc02b88647f25f080de55e9825b205a6520280975612ecfb90a8047b01917757faa32458c4ffe14a44e18838691893a6c062271ff04543c73e70b7e82edeaa6fe1d448f383278c9b6efa58a81d775ce15d48e1e0f7df1975f2b44ded8e3ae94b15502e7fc60805bed04933e5ae990828adc2deae4423c32dc4511d2b57a7620754e8eda3ff57ea109932e08d7102454346928441d58d4172bb36b3464f6afcb84720deeb86b53362685319dc02012428bd069cd63f0ee01a1923bf285344b15e5ffa260011e205d550c8e36311ad869b8040db4076886dceec0a70909438f6efb9cb50933257ae9beb3ee67ddd141319ece1a6edefb1a8ddf4a8a7df0ab0b93f08b2bc3e7215a15229c1998db7dec9a4419fc072894cef235c444eab2df91683141bef722a902a506d9c83f35070667e306e92bfffd20fb6bf25db3d4a62dad384d1875273af2afd82509f72c6b26d171b5a9613ac7ec48346a298148ad37723c771bcbbf5f23871f92dc97fac96f4567d696aa7b5cd668124fdb366943e92b3b787179dd66472d57ca4783d068542e201c0b8f56dc523385aeed80d7b80c1fe0de49bb0e1e2e6ae2a9bf8a4717e7275dfa3d14d6f72699e7c60ed0e5760646414191c7ee7ea9f5b54f686729dcc93337c1a10997d16dfd8753c0266e5d4307e8a9b721e40b9fec6ac0ace5202d180d1667811451477f0342d1fd19955b339c38df84b87c35ef7c4e24063b1cea6ce1dfc4c417fbebab47eaa23a5226b8e934e8f1a9bd4e11c0d5d697ae54910e2c16d2f4d115053350f5166ebe1b1445bf4e61bdb07a09187268798b6d560bc47e91e91653384612805735799d9ecf3c668ce142ea30c78d634f29fd3506e76e1842ca9aa32dfaf5475cc77ce63d8072f5197acb947540b956ec64377ed739810741d3cb9312371f6aff7a3ce86811022b5c59d0caa6842039a775f02df894493359b9206d6e8fda6240aa932abc66f2b977aaa5a14493e167094689fd8cb282e5746dcd6bb24663216efdaf75b5a5e2f6adae4a0e195bbdeacbb983bb1e68d8cef33b1364bd0bda6a2e2a0f9240d185f832029eef14a9e3b4d964258b793b3e2e06e5f995e77e0928a3ae1940933c73354e0c3a817351d80dad11ff650556e2ff06f1c712293d60c4e9c68344cfa20b30983b43cdab9544d4c48abce14897e0f52c3c8b1815e59be40aff79308b6c8f4a0c6ae09ba565c33bb054c494382c8e3e2644bcb950fdf81a07d7df26128359ed0382635a0146341ff4940c25f3bf2fc052209571970b62982998b23c56cb72187e03351000db09b5ff5675edccc09b4d0d662914d330d728969ef16332c295fc397be2892d002b1155e542b9a23fef5b5863db9e82301f4be952c7f4c8920dbd989855bedf95a8304cc615a227155d07b0d7ac61a76ada9cdb0c90ae73aab471c11898faf5f6451653a3780d46469e4f8227728bb59b535b08d1ad9fe5fe5d4926f4a735baaff3d71f7d08be8bffb11108125163049e89e4ae7c66d11248edb7e8b51f3c46f83b77abe7ba6d82f6a284a12faaf49048215ffe002bcd3ce629827812df2b9cc4edbbb269be7f063119eb1132e064dae3c90a17a625078b8f149d4c42251a140013b19b5d55b1467f51040a6c633aa3784acfc1a92f70466a73efaa2cdd51aeae7acf9a0aab96e4ed31eb4919dbd99cfb3cb2cb9378978ea487f996e70eb3334d4d6e24c715717549772da6eb3fcdd6a3593b27a4505c1646b24bb9f6443d2ee31f34dbb2e1e6131bdddc949b11e1a37b5e62e15496448a43e3b022b7c3f04b45349c7b6ad5bb3b0c645f60992e0e2032cc3372ebf5a4340ad0b147c38f5b1ab1c7561915ec81c2e4820d91341d162cafdbb91612474c82680e34b1e9139ea45f6585b26f4d36c3c344411a412568e7140daf14006413d904337ac85a167ebe0b4077c6a3c066ec437e06b19fac13e322f5db3d69afd443707db8bc9dd42140e3b1df96cc9bf9a28e5fbef358058656515c51f5db61b45fa38d5ef653c29c6da6241cd82c3f50ba9da428e17f5d97507df8f90535acb8eca9e3a4711cb4f44f6d3c1392ec4c119e69318bbfecc6e8003d2fcd4af0ee7d9c4e250c1adaca9864403434957dae202af3f6b71b8079d31dbe73c8915a03981a503717860dd8aba24c2bfd68f286238e9c609d8b5ffd51bf81a81d28ac03646e48ae8b1279c1f2eef024688461fc1c919850224daec56cffadb1711414b5138c32fca9a892dfd6374d8d1629a329c64cc452a180bda99025f91a8ab7e184128ed553126eb6d448a728205ae9c43ac7d80c6aaf407dcac63b3f629b403b21d68923a49206da34bc65854691b90a298386","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
