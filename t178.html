<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f9de1d7e6923807dc510825af11da46d87b87dc7e976af0fe36dcef125ddda1532f100c9582e4cec85d7e0e0694fbe9ff5b5c739cd1bc7e14b346fc8e2ce45fb7d26ff9a310077ba09efd1c907051f8d35774c6c8819ea93337949737e3df77f5210f69b2d3dac9871e249f1b9bf5af46c729bb1be1b218753c68b36fdcd465e9d9e043b8db4d7b14069ce957b1d751ddedf12759e6691b1cbf93caebd2ba42e48c34f522e60fb00bd85e748d652c4afe6f439990315c93bb5300478f853c4ba1197bec028331ec8789f1bb0b4afc447a1bd88be272ca30ed8da8f88b05fa60f407fb3273dfaf85e2c38bb155f6cf22325bf9075e8c0c58d14f88e269fb5e930234ae04bbb96bdfe221d23425fc700d6d6e826ab8c6c682b21e5ff62382324c73293b39da2421af6d1e6363147fa57af97ed5557034a4b50bd4d125567000ab5565f5be1830c4a31aba85a069ba867e55ac2162583702a91fe0b4fcc7cb8bd40a9ac5ea8b36b6ed71d773dbf0dc26a9025fac933761307b055847f0010cb7efd79a10929a56d3f2e8ee399ad5850a0b847c850528451d4d4d055d40e1edecf4a0538728948bd1c59bc5f913ec76032e618f50fd9d717ae79d3d5f00462cf7598eef7bc1839153bd3c3ac368e0001a9b9fb9cc76b77337ef31eb0c74e321ddd4e2803e6cebca709e2560ef72fc67483287761662baa4deaca1b3e365466ee92fa5f27b5edadb9c18552198c55e955f7b71cf0c757b6c4afec2c3da25060a639c35b8da86eb203c926e0fd57ef540c2c80c93152e69bcfcdc85343bbf01ca93540e815efd36654f5115a69fedd5c02b82e55fd23a2b17f4ed91d31b376288099ac3b21fdf55aa78c11a206a7e9921dd22cb89bd3ac9b8debd3a0f5aa8b127f4038a879f4a9909f9fc1543dd54b89c3ce8a2a174a508594b66e1f1be7e18fc1d0342a93dbe2144143d726c6bd5f113237d3fe58eb4bd2f6c9a4cfcbce0116db0c3ac67a013d8ae439b34b0d323a1e4ebb2ca0eae13c538e052468bb303bed15192bed4f0443288eac55eef8b88c3dbfe52a715f4df8efefb9268497c54549fe1cc0d47669a9ad68ccf66ca384db80952c5a9a8778875c8528cd8425e8e9ccf0e69021bea3ca81f602aeecca6b974dbcc64d7a416b86abc75a4be2fb05ba40375774e3bef2f490779fe9ebc6fde3a9b5bf7239700c029fb44c3b40c90061e3eaf06ad8d65a8bfe41bf2b15d09095dcfa956cff2ffb8ac6261a32f759f2b88af63b157184b9ed625298a224336f0ead9654802a3e5469d86b2af33624e38ed1e221a8fb766a9f11d0d6670399b7673b3f7ac90bc8034de55988225d78976e7591b5f60639a365b2ba4229023309af1b3c3ec01aed16ecae7beba4ed551107bcf82f7da17011451e7d5b3bddf0ceb7d3227797559af97e7827f7f5523cf16786b5c61a5bf0b2ae431c22dcce82195e94c3f43d73e1d0ca8ce82dae3cdf2c6feee8394eead15552498ce5e1be35ebc7cdc38504b3ccc050b090f74aee263905ee05392673b14c017628cd2c70f5d53aeac7e0634d2131036a86ac789074364ea371606a51bb9eddd04eea66091e646809d99f425cebee6abe9c0b3152ecfc3ee829f259a72f0c07f6acb7edd8285dd4dbb14fa02c63e7f8c198a99628d20fa8dacc66ddc8d13d8815ecf5a5f3931d8fd4bf822332e46133e73f33433f846554221342645e2c3ba4e2a0dfebff8a1a49a7020dc000875097b41ce3520d7984e4a29621caaeb4fdfe379b4fef7b7dbc426c15515bc7ad50356b19fd933f384a4127ea482c4724d6ef0269f9deb70d256f03afce24f8df58ca1bcd84e473a231170f0395dc7417a26a77289081d872a02b4b96b85c119e397be89300aee7632f9517e593909a8e3f4ed7f7a8a88ea963efe8b2b28ff0f76d54f3eb8907b7d7b3902a4fd8627cd0b03d478ebc78b039934c1c4838bd2d1c56e6c960f259d308e11e06fa4ff452025698a9d84571ba723e5b4c9aa0fa7e8d5d49929f9944583ffeb512867a8fdf1f1e96f6a7c6b50bdb8193a0538b06fb89c136c11d55e26365c0345573738cf281bc4a89571b2931ded00a7ab628dbf53e03b8ffec9038515a6eb40382d636da23645c935127a255afe566700a5e5a180097a0e650e419b4bb51aed70b6cddde677086a182755b7cfa62490df24bab561661bc0a95c18a31a0a35538ff9b3959c09371206557b15939e8cfaa09e531a5c93e670f59ce4b690e01db376649ad1f45ed994d58fbd667b7dbd2ca1edd184f8d1d9e0e9947fe8425ef1935303ad1d7a37efccf2cdfaebf9c74bb5b984e8a30c8158cb65b4d6b61fb6ad87cd756aa05241c0175edb566cb901351bdfd9d9d9649da2fde0c4107d4b734001a7643df2f10377c0e9c65c57d620a7688933bd2ce101a69b9654c0a60e3792f1eafc14c8de9f5dd126d5364fd4a2791bd1c0d1b671db9abd0cbd36e3fae110e75bf16c5257f515c06aa37126a8c541c0155c92bd49596bd404c7e2f63819119f4002982907db09c55fb240a75f66e7ce1177f62ab5131a3095ba6b0bcdac04f86fdc48d3b9a8e7e8b1d5b9714f7c72be0d9aec1d7382595a96db5b1859a38b9aac82de7e89b76650c04946b5cf9d741388021192dccab7efb24c3461e3547abbc228582c1e870c66799f28fb4fdbed3e238cd300841ee846d985a97eb486cc922f7635b58c4b532c9507341fcd6496b42773a2b842886107633a4b25f67db96dd15f381522ada9913bf9eeecfdef7f780c3cd276cedf2d3f48f37bc0a16a780d8414d1d819851e91dc9c71123cf37f5620f694b6e6f318e452cea30b05daf834cdd0814edc5e719194949247aa8b47baec1d034b8dcec24eea882b4c7badb9f0812f52a4911e6805bbcb9631c799567f7e5bb7b0c280fde8c155304d8cbae1c68064b2cb630779d86d6eef1dbcabac01d37e884967e4152e8a959e6b95c7e2ef9527ffc818a4b4ba942977ac792a212209b3b4673f7ac6fd038d31c4d30faea184610bc7aa67c8cd00442f794515b5ce1859e0aaa287bb2728d06a3428cec8c22b32f1a3035b86936442379ce47f2ff8d1ea892e5ee785dd5ae637b488b76b36c8c8e42085751be3495016c4578aca1ccd7170cf3ecc94f71b7c2823513aa1990ddd731968399668f18905eb10ee486d3ad7bbeeb754b58e690a2083b57e38a84298adca9249454980e932166a75ac89de54813d81eb8559adca56a5f49b5abf811c20c8b151fe35c76f31ecca26d6ae45aa12a7f9df5342fd665f0d19deb7ed18c42684998b513b5ff9235db528cedc03f1efe49c1e7687217bbc346274ab60b179b9d54fd729c1a308a3d5728410b7be3f76ead731a708d622ea536ebb4227fb3d672d962695128f1ebbc89645ac9a4b81721c6c3b6bc2bafc455d7c49d7dcf9bbe313c9787d93963bedfa276b5d23f71d2a83cc2fe4f4611038d01b5001d40f0e38960b72e30e5c0ae6447a21b9c1128581cbbb9418a968d83d0e2989e0b14aed31c3fd662492b95174fa28c1dca0a22fcd6e52f9e985ec780b447bc336328da4ce5b9fae9386b5c778136b9ff619b74e4aa3b5a2a08e1509daf96a6bfd7d7413859f37d54dc3e2f8eb21b52782c47e2a04df36b3d83ecd687d74b6c7bbf87df77f6208923639af25d84b0b853534035590ffa4f8ec2ba0f9cf870c193038e25dee86cffb870699d41a17ea548eed2d1b41068c07ff29845c6e67788dfd3f5609b5903e2808247f61348d83c0e2bb84858696e1dd368d99b4ad9982afc69d69b1d8837e89e05f4908d8748643d655c443730216ed1da13d73153c5e66b41c1de759680ee013a68525bed9724af850e110b7a99925904a3ec8a1a368a531084fdebf5f0e1c5e5eedc96ab138ca5c2b7207936e143d9d2d0ffe78e15a193b0e1d84eccba71952bfd7d74fdde147556f583602481c2366db24f0282afa23d71a9fd99a51874ae2197f845fa6a065f31b5acdf9cc2e1e113b58fad144d2bebac7b152a425dbe445ef253717caf6220607f220af329a55fac31b931c294a24af721581553bb8a2a0db807bfb3b9d700710c5756c45bd8db1828f0a9936836e5b356c8609f37539312dc8f36f3635a6fe89d0039b68e0c581fdc686763936b99f15b1e75798cdffe48ea6a1ce3b85ab534baa749b8f50bb15ace7e7a55c396a96a30d7e2c8d4b2fd3a43e2676775522a0e866f9ac733eb66f507f0114ecfca5eee00ff0afda54cd4917923998c427029ebe75e268d3dae901637bf4a2640de8e8e924cfb82310552b2fa0eae38efa641cd10605de595c96fbf2e65bfe0869ba0175679088c0e2feeb2d6245fca460611b736f9fe1f6a6a64402aff83bb4f6e69f959a0fb9733c7ca501c5cd9478b000dedb31766c58d17298ac5020b4e6800fd343c108a800e538cc81fd9b9962da907d177f0b76cbf41c2a4dc071cf6c9fa46b7d5de60119f579eacf99a7b70b7d5eebb288d145073f6727a0b5d253a6e3411446c04ba4b3b65698aa1d02ed51b9e685aa2ce1c639c44a805607e49cdc389d91c6d4adcaccb849e9b2902cb49ee6e936ba18b8597f286061b2bc2d22b8f66e4e1374893d1f8e1f71ab809d2ea65240200ba2f456406dfbc0078bafd57a49eef4a0354924bf704e6ead50a6e50611bb9a6666348a6750979796878529db4f53ec46b9f42deee8e83c72a8d06835e26857c602e31a30da094e2a2cb0ec9af1b66e5fcbe519f5d7bc50a68469ac37b8c28cb336edefaa9d47989fb04130fd22b013ac949c2003f76f6d409156de0a0652225342117188336e9d97cb08f73dc1d0d34007dcacd21d7f16262e019575ffac09ba56aa6a86b9de1d2106d3e3153790a4f8164245780ed3984c2029956e5f0501535e1ac41f650949198ff845fa67d9ce827dd382521ae931b43a1dcc9d49a39755b19a9f5471406f1d11bb5a0717cf82e8d4c345d7ec3cbfab85b0e8d56251fde76c17268a4467aaef4ce145f9839ab7d77b8b7f3dea964c86787b9680080c5edc4b73fa0b3393149b42d0c13f12de11408d4b186b2da8767c0c2a29ab1efc435a70d6c7f6653049da19a02654e755d6fa79c14fa6d005e0702dd318196195b7cf8ac6f4eff0eca68ff50b009a1fda23a687d16c144c5df8a95632bf9d7134bf4b179e7f5fdf78a3260da7b10595635cf8127d92943faaa883af82e429486d6154ab41a9e8ee9e9de2e82947872074834f2175044dd85b9dec01bdac92068c96f8e21ce435a273aabdae3d658d94c164b20e8bc8a565c3e8c9981167e4362e2f88c552ce7c8efc5730b5807e0c17f6143e6986e699b5115bd2a75cead46c675fb83a49d342261347d405f5f6df2d9e14e1c4ea7bbc6899f36c8fed52de8d9806ffa62895bfb47a600b05f1e5ff96b9fcd0544eb3bec26879832a3f6ed4b777af50969eb69c36286cbfc12a1e83d14fffe32ddbb81491fb479b91b4ebfecb3591cb3532ee6bac22a4594e0b0657e3c27c59570454ebe37ca2bf2b53b5c74bcb997cac7603b88b9654a13a573f07eb865595dc4f37cbe85aced5355a6b6a9892e36322ec83f0b3428a9d54083decedf5826b09f0f3fb211de8a6a5ac08be5c945a6f0de57afab32900eab75b1740a4dc3ad25c18a7d35b672b410b0d4037cea44ffe3c51c2c4b01a4e30153140778032fe522e59a6c4f43494271d44a4b3db1c38dd1afa9250547f58cabc972e8bb238c415695fc037f2f09cce3457e8a6a586d4e67014eab9e57e0626c420991a6e7a386dfa11ff94971a698e39a42b5c119e42bf5b2441b745e0bf1285708850a0240ea5fed8d22b473bf413ca6c268656a5232678bf1e447b62abc6952d07fe83a62984c9e50198001da13d77737eedb284466c938021f948d40c043cd8cafe8c979e41b3ed736d223ef966ae36344949bdf36811d8b21cad49d4e13c0880fa81dff7b3139f2f560785efc88034177e18bed5915aca65755458bc95ea5bf1e458ce4c159e298e58e337648beeffaa0e33fae14442873f0bcc858622f88556391e1660393332798b1ba8e981cbc7cb0639d71d2be6d429e2c4c018319d0186424a4cc4169fae16c3c5555dd8cdc4dca5996787c50e1802cb9e5344fc3cbf924097607cb4c25924d2e883b448324fa9530b93f08eae470c2e12afbe212a6315c50e837931a9ed8b30ef959630bf492ec1d9637e4c40a305ed7a316341b541b070e783612bf0afa0895c4025ed35d94fc3dfb56e47d4b2fec82998c3911fd113bf29a7404a6dcfd282cfd537bf9440adcda0a69cc115ae5b61fe8d99b6ddb49a146e34a781f5e25406e777ee356bb6443c339e47b3885966572744e539fda3c0a03ff97f003d6e02effa6b92e9074a4b46933d53589d4041d77e3eaeb5c16954769dd39ca27760318d5b5938341ee9ee8c94a5c3b6ab35bf748ec1c1524e40c54348bb2bb4c409f1edef51e4b893153dc0dccf4587844b8b92a7f158843d821265d8fcb629226d3edf47c98e5f15f43da4dd7d7e42655b38cf6f9dfc8ccd490611cb4e9e71ebb01e53e8e35861493c9c74e975f40708e255748a671661a35a6c18e74e50b594be8ed442b430e05ae03b509514b100ea1e539484eecf244ac188f11dda52c4fb19204ead581fdf6ffeae4a79c0750773320b99749252e2961ce1f2fed1772406047e491ad38337ad4ad3bc945928439082bb4063fc1c6e4d24e7a6815e531ff9c99bb320dc6101cfbeb1baaef32153f43af432c5fb4aaa008ca51d14266ed8daf24392c0c0a96132e0c7fb05ab72cb26b11fab7aa4c619d8788cc31223af565bb6e7eb8892998c75535872e2378b691cb98ece7e57adbb6f077953fd29c3cdae64b54f211d592650182225fc2e6123e8a07417ae1bf4c33acfd7edd0a810fe178da8cbf6c12667b279b9e1c18f3f519436424517734a58187fedc47a7e531c12b8967bb49302ecdb2d44344c5ab49e6fa3d493eabca93b6f610b34fe84285db79ccfbc03a6ad7f7d64f2569e4a6ed698755808e67996857278017b2c482f1f56916bff83b6c3890b0fdb54993e216091c0301f39aa59110939732a0490ac6a2591c5d6f5d385d6aab4e6e9a87f42c31f580a19230cc590aa67daa2e823e688db691fbeb062fed463b208c7690bc1b9dd9652d06ecbaa3a73739cba85a566f5d21aa162e39b9e3000b8b21f7ba40c3d3c41ec0233482af56365af0a55e01399691a12d3be4fa9137ea1d153fefa92d58bf294fb73829d60eb34a2e83e7f12866468a5475a1378f0c7f0cd2f6e8c9eb369601c6621e017156b63f2760f5cdd777b7cec0772a8756f68dd3e519e1d465981dd5e01d4dc527f0276d2688551e6d1d9cde793fb447e5955b36c86545a657115bf84c19f4556e96de2946e7e984018d0a9890508d407203f5ffe359deaaa6b961afedf5d1e8922b0e8a57b053b92c0386be971a33b27dc37152337f5a34cd26da256f807d5a8cf7d39d543e5e8ef1a83a3d30ca443d8c5bd1ea256c847b9e3cf2389bbcf8e77809df8a49182555cd1858819158c94a5b541e287e30a1d065e3888878673a0a8ee2ca4a271537e50706957bbfb7184c1c155b19146d5119aefd72ae6614d2f8adfda78fa76c157bd7a4a5bd75b04b89e28881ba590675ea9e3f3fcbc014b6fb9cd7874d7135cde70c8c12c3a279718107eb6c49c740e3bd2df256447d06f7e69a73ef04c41d2ffcc67064f9cee026008240e8d0ad801e91f189acb3f9dbc996c5e6d41173feb1ea958c5e0406d22437ffc59aa4ca629dcffa4342be1c4eb48d16cc7ecc33599ee5556085c661e62032346511ef7cc7604e83cb4eaaede7b579a87e1d111e69674f8c4b35a8435c13e5131e8cd76550655b5405771e1a90b41803cdb78afff2066ffb22aa322b74c2fc24df8b1a68ed44bb119c4e9ce5d89947d2c165a464b1cd7539ae35299676e87ca7280a194387d2c29ca1969ea43e1ed8723a0df45dc41328d2bcb842d4344f81bc03ed7c4ad8aaaa0df86d7dbdfd007b8a44ea9ca903f212bce7e6350bcb7560b9b6cfee74340466bce1e323d1e56e29922f80c2a4e99d412ab228e06ae8283798e2ad099d6530bd3126ccf2945d13c0fa905dd2f32bcd1265173c3d3fed33accf1bbe26119b2ad3a91ac932e7b468ec785bfebdb9cb466595a5e48699f7057c505ce71b01841fc8d405987a1ab5f3c5eb7dcfabd4f759eb0ffdc2d126f1c9d5112d168cd2a97a95e65879732adeb650f86b2c04a55f8532235452ee44a28f3efb6891dd725b2831c527c651c06c573e5b6fe59304f941674eca5aec872ebb25309fdd3e5cdd7cdbedf71082fecaab320cea8dc2c326cfabb8ffe1a0e8c258cbfd9d4a63d7d7face3a8ff8ffba1f2dd0af3f0ba9d05841402159655cf325477096d640345099d701b54b9bed16ef8e515bc1730613ac92e2ab5bc2ffe903cc453e9fe0adbbf78be1d2575ae88dc493695498012c2a52594879266733e1de1ced8e48f82bd9552845f1aa59ee2869a44d06c6246702c5970e3b8ad07bb662d37e74c0be37f207b169b8606deb31a2894342e185afd0d6d4749581abb73298e6dfc30e3893ea0be41a2eccbce2678e296c3dfbf7c0b10797b95cb1af28b2224e10e6a37533222c74f32a46fcd7cc722f0bc53449b083edd105f27925a57413241ec9a4a770e80ef0af0ed6369d23c63f0ea32835dadcebc3189d741ee4b25d52672e2e6ede215338f45249028b30e8686e9b04a403860c7403a6f2341236be3defb0446aa95bea707f468132ce3a65b7b27e1abcbb31cff2dcdc158c221ec3ea7822cc8341e512556b698d7785ed196f143694313deebe80e8d65bdaff519d19f10357f0b567dd6036c05cb78bf2fba8a21f0b1bae2d20fbe3f9a3dc233f9bef2bbccd771e7993441426e6250ee918373d46217e38e1017410d8feb2cc8673fe610f776de4ab72f5b36fdf24b1fdf2653d26b0cbea4d926031880533eb0be239a415c13c62e58c44af05d267caa41c1d4043486eda2e7bbfc302d7575078b6c14717791c1e6a6fb858ebdc076886d13f368cbdc890a8a77ae5c2bb59a5e89ac8642ad94e08a24e9b7c0ec091fd27e35d347268b3a6056572ee7dd24d478d5509b1a355d93af82dbd5d2a9f172f13ff2597883d5d2af94e80fbbe5347d7dfd33997c877e2b2c43a5bd4306ff0bcf2d4883580bef959cf0f4448c5da2e383f43ae698d3814adc36d97c0e35759e98a9cd9c0436a05e3d6099c511a9cfbff6ddf521a50c334dc1c80f8619bf82250f7c7e5d852bc0540663c3f37a7ebf17e60946668c2630ac84e142c4f97aa05c5549528bfbaf20af8bb0c1f83300d4a93abfa7671819a36e96983f79e0fcecd1cbd1083770825996f3534228c6f96fec7adf54469efbf1a45b5561806362419744f5ef6bd601cdc517fb650f90b6fef4ea7228d4cb111a1b4866d8a69eb60d8fe2fdafe7a4f97f7491c03eb68e64bd347dd0ade2c413deaeaa42e44613d424faee32baea16adf0ce27deeb4c5deedf97893a9e298de82bbe49e8ed6393215a73a98220f01e9a4659ef8cee1eb0dedf4a63e6d2b852f8fa7f19545696ab275c90884c2854af4f3a1f9f1e3dac43a7d94e9a698b694c3e12d59a7fd16bc17707d619043577c8c6d94c3e48db25cc71e3458a48a4361c2657a62d866d2cac8e35dfe6c42c797333edd9a44eff6a06f9da0a1559eb6f0aee90fe2f40699eadff1508fdebc9fe3cd406156ccc426ae9fdecfff1031d7c9d5ed9864add61ba85f5641d72eeb96d120d3cb867bce1e3d61d943699","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
