<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe073262c22563879b4d86f505e4194ca8d73ad929598c250bf34d9ac8bcf804923e2a0eb293e8b33eb336df75666c36e5ec195e7a2a7281e91020ed3e33b8267e0c64d774a2767ffa9de09001a1bb7678876cf4f0c24d741e1267309872604dbcc3feb0bd273e9693c830a0d624485e4f19c501347b9c9dfe5205dad5d134e75d77a0d1db2a31e3e9222ee9d7e8df80fcb23d333d4871a8f03ee8413471239f1c395aae6d31ce370ff89c827dd300b895316c5d6efee10e20f05932c42e582d6c3ddebf2f9906cbbd6b47f9da6f7fb8eab1e39b7148faeb35a70819d2b99421054bdeef64e3e7bd8c47347b2e2e34e214e6c35638237b56d85975cda2e7170eff091517f02ba3a05de05c7fdab3d405ab164c3c09424d7088fa07efa1c337c64d57b30d7893c26d5e9432e58d0a0b4785ec4e29d0ecb9ef1518c15aa1b7d917a1bc222d53818dc229bdd4641165f253e4a2ca49e9bd885a958cc39f437ec38b7d0cae5f281dc008b530212cc07922b78c34ecd89929847e09331d9f5480a78dd68339db6e5a235d3b6ec16dfd6d252d760c30305a08f3ac4233fd250241d8150086e4b5585f883c51c89b9538157370282827aaf8ac86648e5934b3615daf578751c84d9879a60c2881ef8cd60bf8e2b73c612a49da9a3a3d314c8236b1ed5d2382f8695ad001a46ceaa809171d58d98658f7447aa594c9370cf74005cb093651f10920d0a1ec6609e275310ad4c8e1886c3825eaeb4fda9cda14dfa064c1e6048148035e417949c1921e77bb122d067886921ebaaffb1249f6b73a628ce0d5345f3ca121a6f99807e070600e3193b7d637b6f3b7a3679efc3edc71fb8ba7897a6dbd0d492fe24a5616ab975d4a9d134988ae234bbbdd28d2cf7ef58ccfab563cdece6731a40cf7767d8885af891477558fa5d439db888ee7cfdf42c0bc571bda2c05daba83171e5b5d25e329a8989edb586b433c0afd691c4427fdf43ff9999d1667afeaf6ca0e9a53615051a2825e12b8795c51cf9cab998a827878f9edc15170a62181fd3632856d4ddb97e06b28272e2355cc3279ebe5bc4b033343dfd50a492ca41f6d4e68d3bef82421051ef56a3643421196cc271e84b37b126d4f7699b39721b21b84ae3a3ddc5c08db9cd7ef00e8fb074168bdfb898e977537249f5b309625c97fb1f8d731fdce86dcf4e891547d6fa7e7fd4f941b159f6fa7ebb2d64f9166913575bd543c44b5d4dd292d94497fc4e7459d33da32675c63da5b4645b325ba2d4817864258ad5233ec2789e3a6e315c2a2d7abbabe1ea47aec04e60c5684ece169e7d23a10a1941b361ebafb68a7816f2eac391964fc812dafd1e92160130348b0f84b1032facbee5a3e5e8c89e4b135155c42a1e6ee70b3f5f38404213551478a69522cdfa9769b665f5abcd26f9729e3b7653dbc79158b5158ff110798e8c4b1d2af5c5a99e6c4e3e0ee6ecef4dc1181dab0e184e0774cec9b3308c36935c4d93d87968f30b0f529e3908ea16b206f2a0eed1c5780569b9721c597792fd136c774f167968266b45884a58ff5addbcf901b6e9af05209d7041ef276dc8842a929262e29a2ea1e6fa20d5bd259c823da82fde1eb01c7694ec9387355e018ae42d7f6f800faad2e379437a45df399e57198df37120f37e1ca1c74d6f58382bdbab37fa28576473949db8dbf94d089f35e9b952e9b8e31a762ac21097a2ae3f50564bda16d264f9cb787ef363d79edf3e40a4585387eca1db52929e33fa0ec1d4260f39a63cb5372f70be83d3686c5e632fb43b632cf623dbe6e376f4cd03add743ba4031da7df01b3fe1a8d033a9a06fe029de2b00079b2e5aaaf2da8a7ef5bb3d382a7242c4b2691b0925b44ab4be69c956d653a9d1d013e002ab03daf4819c6dfa2debd0e753105ea6ecb2a038e3588a52a9d9c7eedd9791f3ec7ba0357cdab5b08402f9fba2ddd02f1ddf3b49a91c361c236f064a7a005914759b4f66af728b44b7d4cbaa8fe2dbb6878c0ce668b66d9a85c808da77624826aa5b2c65e63f5fe0406887e4b3c84800c89aad68a4e1540429588cc8ccd9e3f1c2d7d26d2ea216b0acde66a20eb41a9a2813d9753cb09ebe9f1a5f95639a5fd7abd99cd2993b2ee8b03c6494377f745afd9ae8f427f550d1a63c757673870b216d7e2ccecdb7ae482f659f2fbdc57a164d29db03cf1d17c99b8238db6627d8eb44eee704a73f0ebb123719d151d689eda4b2f7d6120aaf4a60cc9ab94eaef50a8d029a1fa7f32643c4f845fd829be2fae28813f88550c51d63b5669d3ec5797721c06806e9785c0e59257e36c480dd74999ceb7d114e961a6811b8973c6200b644a97d4ae5a858a502572f10ac8ab56426d5e5de5a700692af776061b3f2d76576ebf64f1df02fe408df19b31d5f4843cb9cb1e9ce679717746b0434e7450fa683ce604334dbf47b401646966bc1b8f4b84edbe580db44eddb6a36e121ba99c6bd69430f2586665111dde5f87ce9c9d485d31a7617783cf9721143ab6b6bc95e0e7827a6ca4b2e85ddf06bd2f70d0118be392adb1e0c5e5ef32adbc7d39f494ce1a807e26f644280eaced3c2f302b5d571da0fde408d771db1deff8095cbf38a6b6f727ba05e27d14fd6b754aecfcaadf3208ff67c2af5a4059e3e160f36785b8f5b4b563323fa8e4f6f47dd16de35b7a1a039f668b26fa343134567603a301d5dbe7a04aafba3286932244d26e840dee478153061ab8e8a523afffe3b8000d5a904099abbe75de043566952a2e3158555d6197a034c1f7a9fdfcf2f0a98541ac772c3275a7cddf95ec5053265c5475e05409b30d8a821d17e4e27475405f2096d8dabbb2b4cfc88f1dc5fc13aabd41e04c1518088f07a1864fd638ad68201ce96f2b0fe3f738899c03924ffb1bd319d008dfda3dfdb8d65faba3349634dd5fae1d2843fa9f1e54bdac1d7e2f8beabd41f77f0343c75955c2c400c892c017ac16c18f0be941acdec64c5aa062a003e0658fd9bfd142e618963f60276482be220000dda62b2bc71ea405706450a18dc61a5bc02d1f1732fb7c1eb0d5f8b06dcc3ab0c9f83b59030eb2f7c29bd589bc9c826d6bc0e4541a2c878647cfaaa2a6835e8a6db6d88f6ec41de62477d2caebfe756e751851fb886b1f95015514799d89fec65b781c85d81745756ea3470dd12db408e8c5daaf3d3d2946e36d6157aad6bb7d1fbf42d1e193ea719a463b84bb9381510e008c71134f05dc8a8a2b0496f586c13738d3c2565455e30a218d95b82a00c694630fb60cc6fd18bbb821bd61f4dbfa0f604e24d6d24b7f99107fe175b88a4db36e8f77662f5831d1fc25f949a279da2e02e0f899cf706ae1ada72b4d7ece5bd219c9a6ad6ec8087573e802752adde2d49b84c0c74f4da45bd3fa3ec24405b22434a8fe42ac24753a6bcf3ffe9f7deaf48e13a4b0b6309d7295ac50e87cdc96d500ef02dc817071f07e2d31a9a522210a4929298f13b5b5ef8735a5fe14fca620dcf4a6e74d826c8fec47e5da26e75be1004f57d9e7b115a52d17fd76adb72b658a809fcd1659aca5a8fe45447476d1c480f74399c43d3449473b69f7cbfc597b25e84cc7deba92c7fa4ccd866b3a190fd12b810bc4f55dfdc0ecafc2fbdbd860aed1518d6c01b17bf8f1e4d3f29ec57facba7e5a7216ae753d98984c8801d8bd5cbc20cc9d75d5f7457a5392a2a9589d5ffc5a01629719d58a4f97a8ae209d803061bcdd79950285ab190a2db2f24a9a62805b1721efb49994f716cc8157bd2a8bef9f169911de014d994be358e17ba81b9cee8c3794b4046befffe146a4d1227add9638fc1cbb7eec44e2f9692cfb5e8a796a0c4bc87ee74d40bef864b62714f386845fadc1f394d37d967223eb020bdbe9ebdda9ddb5d8de96958aab7fa41d8d6e9d9de93c5c982504fba047a3b947283083a507bcf536819e52eedd286dcdc560b5abdad3b0055c44014f7be2efc58edf05f6f5a508dd3223e2b9a31116b06ca98e46038f648f8d85563dee566ad2c978d190fc4fc4cdda5bdf8484c4be6449c5eec7c52eefc61ac0c13de75a0791e2e9e67eefa30f343d5256af0ba0fb9354763f65e9f8ef898b33e5ba378522c15c4f896946b26df85269f8e06da1e6de81b77578e8e8227d07d24e510e2efac546e45f633d943fda0b2bfe17211c4bb272ad3c0e06267ece66c193c6adf3b287e7e3636cecd38719091ca37976f290633b4081d6d2efddaf6402c85d5b693a6c51e044c18c6ee1bf439a1332c2b10c5e37d6c082fcead27d97d7336e13cb4040ab1a80fc16038538bbaf723bf4a8a785fae233c95a4917501b3795e92d6b4497cf7402dda577b509f7af208b13f1129803759b78e35a0a063ba9237bca2e719abfcfaf29727625ba0a65cd6b2db91c040deaf6da96927df4c8dafc6093307e5ce1a5057a2a1e662639d5aa832e465049e037ec7fe129ae72c95c3862618149d659ee727a6296ab71124c6228e9fee6eef98e9cd59cef440da144f21a0e1ca607ed68b4d756d6666eb977e3035459e1d574b125297ceb68f8853189270d6b3ea1d94a646ca27a233e914be49a4113dddbfa8d5ff5a9b946a8aa475108fe5d99934c10d20e54e35050a7cdae13721328b1ac86ca51e4df0aa4c4bc01f6ea44a332b5668813a96383292777e913b6376f638b8ed93c0898da4a0b675025beb00fdcca244037aedcb267d303b05a82b49b798a23c66cd63014a896e7174eece020792abe7fde196a708fe24fef04c22e59f32f4d2669828e968c35eb04c53c95b91cd06bc0b8f5341d428638377ac825812e77c97b4ee1d7dca1477cdf2f8cb0b0e6b46141a3463c8d2cac98af3b0d33bf3c68fe6c6ac717f90c624d588a1e8c9fbf7c73cf9d3fb987228c1adbca38583be33a4ff52d8dcf628a9b36af7d6448ffe469ebf3fba31ccee911d81dc33020542bdf2806a30d9846fad12291037ebac5c37d35a021f1e4385284ca493289d5b33f409d8fcb48040f2e40873c36aafe7076f6a7dcceca438adda54fd9e3e8c3ed680077c46928e0a62f271f90f36e74d06b010b3c9383fe633209ed54cb47b934ba6b8d98c86ed4210df1bbb6b76e8ff155e0530eda85d934f7871320f00760da2f5259552cf8b18918080d0786a343b950f80cad27454c6d3c8600113e4b5329c0ece40c4aa8acfc8f58f16584ffffff221bfb130eb9bf5c7decbd90fa88d66116ce80dc13b9b8adf069f4dac813284a7445f1c249587009756eba633dfa70ef47b7d0d1723c30672ae62d357cb3d929d459dd5bea52432149cf1ca48f4aeedfb609d3855f166c0d01ca2a700e6c4f508e88781242a4885f31f755bca0638bcc80867da806538fbbac3322b50ff5a8556af0278f4c8357f4c0c1022a855de0d84495f793cc4893f3ce09e8b0af66791b637b67369f377fff8089da15fe65c7cd09fcd2665b0a5ffbc070e15153ffa04e8f3c25a65d5f449a8f3db58fa5863647e30524cd75c81452ca29d4f7230cd194bb327200184f9180207acd0b13c751680dbf05e44b75a25cf2d6bcb7bed9779b511f6d0bb2d565cb78b7aab69c79ae9a5c9ce3050303a7ff021d8d9f80ac241f69ab360ee22e1108a72882d8769def7af997443d95300108d076e6f84f61497ad6bed2679868cca2d6e64ea4210d0fda1f35888060495270eccb36992bc79b96cad4636b87dadfafd9b1907a349bb950aab8295e991b4e0b6504037d9c0e6f55412bc6235f1b2465c9bbcdcae13be811757824e9863fec75aa267debb9062e1e114c61c4c86e7d5592a396f84756e9a5e12629d7bbe4e26790000e6f6e56a6ee0f5d274e07c3145fdac452d5a0ede3f622a0f42fea3378bd42bfee9a98acf882ff597ad208d36d44d1bf14b902ae24a8444ae90c232c2ee23dcf8b0cb57b9075ea4c278a19db07cb1de5c51e9c5a9817991a522866ac6cc0deca46ec30afc6d5dab096fbf6aa5dfb7a8a9cae6d7b2afab768a87d7d78f5955a54a5008fa2a9dc5193f99a0d5a211711e47700738964cf5dcf55627ee538df8c1076bb2295463f507fd8b456388fe40283e39824882f3e9758a1be6e691fdc3b494103740b8d068ecc784d16df7ebdbeda59cd3561e36de33198e9e59930a906523c773f67de15d443b828071368a84f3b57c725eda287b66d9ae851d4cde6167938a0577b89e39dfea9c975c71b245e02846fca902d306baad2017004781510b045b739ee386a4fb17a275d1da7a988602c6a969d11a8ec0f3ef16ffb3259fb3102a6df8dc5ad4df88625e61092fb3f640ce0aad982031f4cf886153ee0000a6c21fae3d6c388c859690a1f9a7455d1e2f77bb56ca74f62c3e0ac4ab2d7fa77b6247301a1fe5fda2e0f9f422f184044eb65c8f8a89433077c3112ac93ccf69532d78c17c412e51a9bf0e12b491145db1c20ff25f85f55bed052fc0c10f8395c09540f9bceef3f68486c1a2f5cd5e407f5ba667f1609bfaf319207273a82aca2264fdfc8d05cfb91935fb787c542cca16b42930d347b674b9f73e6b295e6b48612dcda70a0b4ae2e99a501a8e39a767b10f81bb32a4e1f56c6507a90293d6f42aa9dc601d2e458ad0aaab4c92cf9788dafc789204cb407295d802e7abee2d7ac254188ec7791d5ec3c0d7d46c6f9c79be0ef3ba4a8c3441eb26ed136b76b4ca0d3f7227909a2f2d51f9c9fc1b6cb23e0d4af3b81c7dcb8b9d4023a9860ab3ed00b5c5a526ea000ea0814d99e1b694c4738db877757ff5cfbe8f625dff3875cbfbfea34d12756e6a9a02fec93ec3b6260ddeed626f8a82b3459bba0c7cce8e38b923478a4b4da796b29edd1eb3fd847b126c26d1b52664a4e0025e96d806ba85a5ee508041c9e778ba13c0cc1d2c7c50cf9111dfe4e342b36486c222880fb93c9239f52f50c1e0032a290ce186d568ad717bf580bf517b0a7e87aa3b36100851ad612ff30b825b9b142bdcc19d2499ea5824d0cb85d3d60ef490e22ecb2c051e677dfb97db4a0d5fe8ecc3a1ac5b1e6ce64287a197280686d6b178e841641893c891c108fe99a8a69ca3488e21fe28e2220a6b10fb823de50f3a76e8d13ff56e7586363d191c535f36607ed273bb808366d4134a3f0d20a78e7dfb57112e82b692be6931795c8583172f759edb80a15790d5686de49d6766f565c8b6fdb64de1d839a46c344343ec8254e50c5f52e16e5fbd523ab718f9b94e7315d8838bc9e990e6e779a596a69ca6d1c077a13130943ac1f3a3962804b90ff520cef25367b933540e5b47f44fbf29dd3407b8a5aa69d604c2a3bfdd91f40876cb700e65681d2609e7f4edb855059fbc3e8dc57cb92bc6981a0ac3322087b09c5c1d97a081b3354b364c5bbe2b52a2bf6aff6c310ae40a2c8b15edcfede5d4dc54612262024cee9eb7a76b375544a34ca0c2abf68222d0597fd70c23ad6071e23cb69d68626654bcbca78e6fca6169500e3775fad217f2cb793993826f119d5cc50c8bd6b098bdfb0115a048295d11e313003acb757a27a15f08710cb0c17d50d48114e48613487172d3706d684814db07392fadf03679866eba7d053641e45abe3eed74e7a3a0d81bf446e11c07491daeba24abdbddc117d4df5eee689260b43deda68f6cac418eeeaa747dc661b6c68c7dc931dbabe69f9c5606df06a66520d41e9bed9ebcd02db9da73c27e1a9449b7a4e827a8669466dae39f23bc2422adf36995a017543ec08494e81373d4d03bc5625049efd50edfaf8e0699a7e1cdd21ee616d9ed50991521d7a61f7df251f1a369b14eb0db3133f7b10b7eeadfe62d3046f07d15ca7db58e5b4fcc1d8ceaea5dd2dea7fa984e08435579e59261c25c78cfd7a5330fa3ad36f57663f917032510b698b3371b8e19c9ae8b43784f43ebdb3e331bcf12ecae8c262c59cf539a91c510123bd18a17bce324799ba3f90bd2e0f1bb67d99dc354df9450ce1205919250338a4b4ee0b84c154bb6ead24bf0bafa319a1003047d999c0354b7260511abde4635588db3a78683520433b110ad3ada4ddace18e42ef43fc70939c1356651a839ad5a36e26b0e2d9c6a88bd456d222b61e538c52257630c96c50f078c94931d0ad9c1ea7b1c9a3c24c58697813a3647582c1c2a7a86d0b371edbad958190bcd4520191e8cbec6665c795af9992dcc6ae3a87543920641615a6aaa14749240ad8ecf4629e44d66ef6268b15f8fbf9ac4d343845fe3edd9d7facd5631edd025aac0be00bfb45e3c5653d959104a81732c83c3966f86b527c7f63bbeee89e45ff3e845639501f780b8dd4b1bfd215151002b398284ceabd93088e8129cc92dfcd74fd040ae86c5afd360fbe1bc35dec41d6a468f741a163c4665ad53665878ebca117cf6891472b11493cb2eb1e539d13dbb70401772a73f74a5ddf084bfd40f763330bc42e523756d0006b7f959a94524b567feec76cae71d119f4c1f82dd9882e1a53d257fb05393dce76880bc51079c05b0bb4981cb4c6c88b4ab4bf56b172a3e0fbac2fe29d73148b864daab24cfda11ce0636c76ff29e30264cc55899bfad7bc3281b69255a2585234310c72ca852a809be182a5a1b015c6698a3bc41d82c50baea2350bebbab4bca0672932a124c2fa98110fe7844b5b83be95bd21e88c8c6ee6d916812c239267967c3dd5e44a7f0bc89c5bbea1935989e0bf036e2bb8cd804cbe1c12e7e1de091b220a5e1bd6b20f0a9a6c069e8fea0ec9b34e3427537b89c7424e7884e46ca82443653a10148ced7ac46ad2ca8705f99c83c0a4452e204753e6240a4298330d56b57b92dc87abd2e4daac4e8862883108a501096b51c4d8c7f15092d07106228c0dc4f3be24779a5d0fb9b095a4b9856e3a326abeeb636c95b49efc14f5246218894be7a94f619e1c465fc90d63ac08ebf436f195eb21453baacd740324789acf9d426b5ddcfcd8b7f01a58f527082f425a81f13ed7b28a7b69c4044458f88fb7232780c9d94e4155b4c00c1b2e8939f6600194710b545bc8133af50cf61703c787c2d7ec5b2d6c5c8d611dc597ed199485c4f455c1b2c3563774e0e04eb1d0fa481540293c930d951432919a9e193ee09a87b9a3441871ac7f5ed82773e564930dc736c30de9e3390ff58c622ec63eb5212da3f073dc5595101d9f124cd763918d8c9dfdc7625859b0b634947d8c1ac234bd9b1bcddf85926111f81f752ef34220f954468dddb85b5c32bb7ba637af9fd7da4627c80baaa08e2c7a36b24816835c3361308f9d0adcc2a052e0da66ac1561eb32d30946e5018e3c97bc78c8eaa7d62f104d72db39045a6f08b306cbed89a5fc0e50838279cc37daa4d45c0411881456a981a4486c8f554553c421fa298068df3cb7c395aa68e8391c2c1c4b3dfcaef735b5545882beb9cf92e7b5f95d1ebbc4236d31ef0ee37b5d7cd42460e085181989a3c16ec13ee37d6a2c33bc997c8516d21a592422a61422163f6d715efc8ec11c519ee7ed6d2dd2724a3d41a428f38aed01e7be75c856cd1e50e38271d330e5326c5b1ff08117b098cac51f130ca4faf7008bc1bc3dc8ab0dfb481cd3b0420ba645b0e2271f1f9100e1f7cade75da2bc5a95ea73223a8d93b226290d42e4b4036859d668ae5b8be612c98a0f1f1ffd49f844bfe9c19524b99266b8b21e02c71f27371bbcbf25f2f8032087ff5daf2b81284dd25bd6dbe0d2fa3c7f36ffa9791bab8e55a22536109c31c75380d25ad0e474e87ba259c8b8ef2d1dcdfd45c21e0e4d3249f17ca7b9a10a135f1beb948fec40b0608441b6453d6a6e480d7b8e1d34275b0cc282f1fa1d97300b4c9624548e63b40e90ace37f43c3af1d1e5d247e977cc11474aaf7fe237a8a3f64e80699cd0de54d9b2e2e95bd5a73718e44188902f4c18caeea643d59af8e0c383f8196657ab7c854b14a30bf3d13c8937f6f43f0bc510f664d89da596f710df3098c0dd75d0834c832f89794dee10ef7a132173ee695ccda5c9e2786cf22ae8338a26e50ef8095426414d93d654c60a8a5e43c4faaff0ec39d48dd04ef565b3c4e11b6aefdc23f1e305562a08e63bb77dcc494ddc4b0227555a514771db263fbf925ffabd7c05640a3f68c4d82955f08a167d219ffbddcffd1f0d49a48566d324be51ec5ed55757c107d60007abc383aeb72173f1f0a531be8e3eede8a9d3931d9ba8681bfaa7d056959c99e8f6f4a964ad35c92a209301ab7d3b7cd5c092c99c078ce4e804752246653a9bd744e3cb36612cf887856c7d23a7676e91d7b9381e60a9dd3aafdffe9244ace9967cd315236f9e9106c85521a4ade1b91957d0372a5c2d034ba5f615eed75c2037ae89dd91870126f3dab4bbb60595670c0711e581fade8cdd3a4663bde803b6d8618398c80b2d53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
