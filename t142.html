<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dcabe52a7f5635d0229a924bd1979ed4bbaab1618d375a6b0b0e365266e6ac20d7ad42fa64b47fa341a144024feefc51b355f9d327dbda62cbb3ce24d1cec91d7281dc37cb0320fb61e3036bfc4d332f95df49e05a020e1607898228a7e29725f9927baa756fc4fb0fb61d60f1e4d8ad2cf701cf1fb9ac9d3b5c23788ec5961295748cf1045f27cde361d0e658ddedaf9a1be055fb57beaaa8c84313a697d11c98631144fbd8360f4d81343f021dd0eaf0fef591232900d9b72ea46f8173d2ceaa3ae3e3fbd9234048d27cf1e32ed4ae9cc980da25ec98998bc65788229b090ebd298f4f111b66c0d96dc1983a556ae2ddf0f10dcbafdf0ee2925b5d973574523db763c80a26ea167fe9125ade0c4ac1aed33a75265b5d0f82f60253b49a735584d4c587e5db6bcf3d2c80c29b2fe0bb27622f0b73d5cee925b210337e3528d868dfbe023705d92d186477f79a5db3b77c6bb8ef05433c9ffb58824f8303375aead9caa2f5c86467d3a7fe5744545febe5b7f8f389ebaf8802e47a5c33627a2c5a0829842778cc6fd1772ceab1ce1e84e7dcc60ae71bf9ce9fa84619babd73366660940352035736e858db254f7a5ed501c7798c7f4f24c7a63004171565f9870bbe1a13cd6eb9152e5c833030d91d3f553bcdc568f944477b84ff4b283fae97d36f58ea03604e9c1dd18b4ddcab3667d9cf4783e7c2fc692a8b94362ccdddb391a864c178a922e09fa4112235151ace2b16ae7d35900ce65b94bd297a146d3e338869418802d4928e58ae06f548ae7614e61b14da4a53785931063e2b8921c03eb4e7c33a9e4abb7f5448c6ab44af9ac0249a1a5730f7fa727f52dba93c850549bd6a0c96c89446535698555a59cd4f5b82d3d0981806120162d6692be436668b5b844ec9c4ea9e7d001729e5592a7c4058a27fdbcc4a1edcd688a6280a0397edbc628daca0d7449ef3a622bd87f7e18514a853cf32b856f8aee1c2d3ba334fca42e72e467e613ecf24ffe88e3bae158ab3e69d1ffd41a5ddbcc28b7f7b67bb66b04c173e45051ecdf65d3334667f8a1a0c574085307d5a9c5ad710fc4fada477711703495d36d1d2316ff83f4ddda94f158a39243f7edd22fe6a65f6443179b95e2ee3058d063e3cb30ca5206d4288ea3f89e049dc8b4474f27e4ca0f6a5e5ea87996ded206f7fd0b7df175ebf80cf4720c7c6f6b95cb694cff2cdc1e65919cef1e737f34b0cedba0934d8734250d5b3201da50b3736fd78c80720bf57064381ca31b533397057b6740e1933931d1faf8134211788ce0ade48ab39436b36cbfbe50e71569f9ac62b3516375fbbf4295bf38a937dbda508fcffc98152acdd8a3604389581fe024b8ca30edfbdf9051d14c496862a512fb78568bb99c84a1b34d7f9deb4155ec874d2e0f93e591af500ad31e7632d02f8043d767fb60c85926f16650668c2084ded7f09b48a0bafb159fb5d559ec3f7bac0194349b0c73d1f65da947ffd2fa1d6f66beadd73ecf7e3566fcccb7d105af22b95f54e3b8f6bc92c03b4d764235e4bf80fcec38bc50a0493aefd710d6ed136e69e40d695d684f39782e4943acb8eebb78fbc7e64e460a49735176c9274a645c871d22750cafff855418a072063228e290d1234561916dc49725e0a8a03d731728093e94dc0b9899e23bc67f9eedad471ce643b10656062271b915834b6ccd81f4a4b1a5ad65282632a31f8d1d026172e22f49dac79006958a9cd906afd3077346d5282a6c26927a24b66a44d619353a5554e3b6254f588609f24be37578d48287e2b8bf8faf1beadd448956de78dafe5f83d45bc98d9f418975d382a6ec92813cb2f0eeb9742d400ab9d8c20117995ca4546118e7f7b3f3a00402e9fd91f528b7b7f335cb5f7c3add54bcdb479774472a405349b7d584620a94360eb1d1786bbed4162fac4c5995fd50c915997ffb160828a60b6b3bc87b756de7362b4e118592d384a4eb0994b21410e13f2d6bf51dc64c2ce16b4375d198930af95ac3b2cc8cffba8658f179af51c7f52228cff205fa0037f56f4feb26a7e438dbd0f28b86671889ad33b3ebc5a0532f7c0519e0c83330c05e8bf852d7c45126748543d8c0d4ad8904d3adbc9fac082a613e6b306a0fe56baeed13d55219ca783ab7d179ac005adb9726e2ce8f72f08aba19bd9a4f116cfa306d1e93876319d2ac0224f14350ebe2cfb2e9747dd45c2f127216b363d77924bceb05e1aec6f2ae1651ba01c5bd581b2ae701b068281177c4e555108722d27086153bbd26601c238060c55104dc89ed10278f74d74822ac7e04d2f40605978900505f2454a5e60a85bd6845dbfdd423c566e6ae6bb09c5b20cd2cdaef1996ff29bfe54e1c16dde5e5945dda63e7dc78a0301f3ff7e1e22cef88efd7e7f2e94b005578b35829d28992c19a3512306e2209f4e7594749b2b14e23f73643bcb8e8ec54b3ad6fec50986ffc5510b274861b21950010764466fdd8030cc70fe1b582fe32ac3dd11d1b8e9e05220cdaca15e0dcb7814c2e13f2bad414b53b00976646cc25cec0239f5147ef2ddd740c1a3673833505504733ad2e5a7c9bb302803d7faf28eb26f445dad1fe7a92de1f46a3266c58c09808f10800e71fd5ac7072cdb23d3b7dfde7890c2c846d2b0c58ee6d0d4c80bfe32a0743c5889b98d0985d7b3719376ec07f316d0c25fde1ed3bb31e21f46d1d43bfd06d46f1624433b545ce2b16194708a96e14049726436a30c93b7fce5cc1eb8948ab53430b8da5ffc59abb4a6c5f56fb35b62990088daa94e0e4ac99bc1f26f2cb1630a8fe81df3c3ac9e0d5c9ca2b558bb44033e235217c1dd4c21a6ced30aee15b37a013ef8b7a49376b25ac9a0bfa187cef8640960a9c72d18fdd4a13022c2f2c8e863d5735942961a57860e23a497498413323e6ddbb564cb2e4e68c09719d76a10ba3c548aeb91c456d0504743936d606159ac52bc001793913b7f0de11a52006c3b82df5901ddbe305280b24c94fc34c80fa46ac3f9f178247c04ada13eb861669d14c4b219c94577ae5fa9572182acf7cbc1b5169666d63af6a18e7ec23c59593a34174981141cd2e09d5434ae87a4bb9238fb583a462b2a5039b2da2e1bd8ba3b612ae87594ab5fdc3fc7b5e58441378d2d3b9a705fb56892274a1af9b71937b597e9820dea497922ad55cfe396d3abe5940ac6c9698bfccf36ecd2524bc73e4e2dfdaa68658609b0c76a4b78f2bb8db295579b17e052f748245facdcc43ab7ff6f1a2c49d126b4ec7f3cd6c2e071d2ce9573e5e9bac5e3808a8e2bb62627097196e47f59545e1ee5ed6b7c5753d6c38c1d2a947463669d93bc01f3872bd6a800dcab3990aaf6979780d9251fd483d69a1177b31e5b84e972cb3dd5539c9b9ed5e96942f7fc667a18d143995bf418ef990ae67182ab16c570b82ac92eee11c9c41e916126f6ac3e67c13c4182744882539b0287c1d498419f2ea1ff62d88484c9c81319de037e6efac673ec2c73814fe140eff7a425bd573c9adbed63ce9a9f1a195a3b0b8e11cb9141a6140570da04ffff91746c5ebade6d675f0d68b2a3132d70b935e51b99d5a0f979af28fed89bb8d2084c59a8d3b18ba0e1f3cdccc11f10a434175b61b60ae8c2d67c420aca60b4cc0330d3f2a78182594b34440853d97c8d9b6c0bc21047120917da5869e514def051c691a3c31ce68a76af19af7a370a3f9d73e43bc1bb816fd28d5c7947fe32e7e324b5f0a0b409052040fc2fb48648be829472646a8a84ebc8786e2ff112e6f84bc1ed5c50b90501af94aba1026774405c566c16bab60c8ee79a6e74e77279e1425e4e7c5b328564e823cde1c545b49d4cd109a30f398406e59476ad00f0e38a1550cebc0b9390fea7d5937402a68e688fc6ce550089ef363a39eb6fcd57be45f9e3b19fe627679caaeff2ca0fe69a97e0833f259181a94a027470c41d1d8a6f89e91f60297a8c211bb838a139537c42c96f7016c20e34b31912acffcab49b611cf8550c2c9c9a8904895ea0c492f648f2dcd357cb3dd906cb074a208e59b9faca2018abf72a27b677ba2bc03a3b01387f7b8ff5f38b6fd0fb1ae04f4d4494e6e489c15f7e4ae8f6cc22be37973225056bc61c466e0f22ab171582068e730a8b65eac82a6dcf076bd75f0a07b13ce61cc502e82bb5691f0e5e7eadf6f2106daad2a7a9ceba82016d31ccd59af571fac3b2943ebc6c5cee42ef4a133a955cc0ef42ed04fc375d51084e70bad5ac3904418d0c55ee1f26a8ed22d295b77a01b686edbe59a1d4c6882916c5bcc85b381bb1dd05db31164435d4faf4fcdba2d27b04ad4cf846b7f6726112df3166ff1381481dd80ac1b42c5b79b8dc9c0bcf8e8255fe4181b353c83ce8e7c4bc76be19b667bb9d97c6c469f486c6086e173293b9ea7af0837d734554f275df5707a3f2b3e99b13a6b60f6200e4543fc9bbbb9925c1bb7af92b19c9e3298b0f1cb301c7ac4a9b015a966c98f456339e0c92bcd302ea0cb83dfd3b6c593c36745d0acae714e8c99af1ba387b9a74813f471573367cb5935e42da15c37a98b00c7081c256e80126f44a1d89d7d823166e50de783d8b71c182464ca26cc48f2191404281502e7854891db19b363069f06f5fd2734e7d5e98c9d31558bf2ef239532cd63b80926a987f6e25e8eb00a206234b757e9cf981e69bd11561badeac11d8fe93333615273c05d4370bcc286b2e19c8610ed31e1bfb8e294a2dbad78ab2cfe8bdca050b382f84450d923debac0ebea66a68a1b6729cba566316c5749c32b6e65ec7791d605ea030817cc83bd321e4a1fd5aec62bc55b2f0dd7f0a7fca6b6a748d7f4da5e1a2cd4275e20606585bdd11776067fa66a12e0eabfc14df87cb698452a24e2efdb5328d164b9055d3063b38091d75324f1a1a36c682abf9759b93c04c16e383d9fc93a1cdf8526f39236bece6066e39e4ea6aef7e55ede950cf765324de69c88115775e2088d31676f8589e2d810565e2ef90e01ea06b61ac42a4287ab189e65773f0cee11afa4beca7280546db45d25393eb3488dcab077b0fc8f3278d55069e2120c540f7a3506a0a6361ff384e69c65f56ef9dc2decf1525ec17a1a74314203873fc6219f48593a5a1af1a74e285b3b0ef10e9a783145152de36eb9800d0c3a229e3a75bc24e8b37b2493f1f9512ebe22ce69dfd1bd8bffee746e78cb29f6de6b9c9ede47d3ded65e7be776118260ea5aa09a7e8d10ec28cdf993c1508f7f9a91b96bf3ab4556480e66965f64c0bc11422bd8c92dc9ac7b0575d2d1f0192c8ff4e94fa15bfffc43153e6bc7e8e38f5e9802f417cd92db0fc766661edc340c203e7271662f027b61012e292699f23566a6ff14a25277c357d1790bcdf084f23924ab1ac55c76f427da762686a9ccfcc11977b098829179cdf9e9ba665b56beb36c04b12b4218682b0ed013a747190df95f2e9198a155a71fdf19a6d64b1509649a70020e9c9e6f4891309e5221f2dce1be1fc7be524766011f1e9cfe75896533ad181c3e7c93a74b1e0a520672e58dd6be90e4984b33777d2b3b00ba0b57db22f515ed22f6d153bedd3daacc1fd4d62a31bcec1cfe238dda12f321a7781168f93fbbd79541eb9d704784f931d38a6cfe3bb24c60004d373434dc743fd4f44287c91a4c9e04888491669c0f59456d62a13dc866fd3f36edd5a05b25d7f0fce0fbe4fb3d0ad0b65737c6d07fabe1ccb532948d8d9fc5865c7738f074ffce74594ce1a9031381699755511ace19af29a074be958bb9bcc256fbe3ff4eb0280dfca543beb4bb38982881cfe0cd3f73f6b031928a0a029b8e87afcf0b05172d828450800ac948e147bdbdd6d5f952bd199f8f9b329988b940301db54779a3d7a4c842cf30b46385eb20cbbed68a96410560d7f526c479bde78271d72459affa045bb65e379216942c08c0f633600c87ffe611c2a17e6b92bee8553ecf2900422bfa946f7ca44cb22ec99a9f535bd930c8162a2266f767552df91cca499fa483690eb5facd25ed2544741c585dc1c73d98a4ffbb188ffcc7b7bf37e3fe42233cd1c39b40d663b3e2fc9078299ddb5c4fe703b79093b98305ba758f7cd42feb8d9cb81066244db371e995f66d7f43cf6450942e779e20a0b098d7d23b8cc8258e0574b1fdd61c836703920619fb3c5cbc5e2b08e55a37218e31735ddc8f6b50c8df096a1fc493f1c3df735a30f593a1d17d2b8ba7ea9353593ff840a258a97c13efec88676d4a16c6110cf2788bbbf876f64b482cd6badfb0120a1e895aecb24b87f490a77a010c9734ac56050bfa038fa48d03d69509961f95dc94f039a581561f9fd51afd44332f1dd4ce939714cb8da110401dfc0a2734b880432eeb0ff57c457f2efe5e0f985dbcc36223f776a49778af96160bcf90c0edb6bad3c6adec0ffc4e7818436d042a67912718c85bcafc0f38872ce1f8aede8416d2a092875003201433cefb475f9bc485f80e832eb698a21f58dcccbadca99e841f8f3b5666073883f04125da229f9b9b858ef89094dc81ee4b064302a4793c411546ddb754877e51e3c4f52263334962f8416f54740a47c29b2c4efcd12a87ce6cf7f0c509a6b4c818762aebd8ce2499b265a379708534e02d286d366abde819d99a3456aefaeec096fe6b330d6672a4e296b9bbb3078f7aea671b2afb821424055e555f9909c3d1935581a1c76d186f6ee82a16e3e20e30c56b2a6c0e0d765433fc2b20d1581a463b1bd058840cf5d08bb0aa4416b38f78f4d8cd708e6befb900d7764bafdeac00d2b3fa0bbe3098974e5ffdf7f0bd5777aebf241dfbc4fc04c83c4d94066617e333bbb7d4b193a61bc718d8e65ff0f0117986fe1ecd9b5a04cd964e52cccfad4c2b7cb277b541c980730bc48393874a113cd391bc0d318e265827a8d7905d437312b2ec6a8c13e90043a53e83f8e4ea0b2dd6c47ea079a7a9a23c9dbff64d685d3e395a7cb38fa87d7ba844f6fef41cf32c39e1f4e191991d35fe4450ae966c83f55eeae244d822f84de0daac6b6f2f58acce5a48bc7133448fc2ef5cde916385ffc56a63adfedda44b95b162f25c68a1568cf4ea02ab7840d717dccd70725811be6dbce5460af19e9cc4d49fa7ef02bdbdc2864efa085be5f802366cd0a4eb8fd09b41ca878f7b022ea7e2eb19df524b139b02a3065f7bc970cacf488a1054863c399fa95c19328a1ff2eecaa342cde0ee25109b2addbf9dd8a47a65eee4b8eec371c6c78f7cdb7d831608d2191f741b5224bb0c61b20da67e878665aadd5e12facafa75d52c69889d7371b6cabd7f4c51fef83bf812829a8c9989ee954a1c7ef9365fc69a0712dc85f74000f1e7a49e5713a4e830f24e65b2f61f8f6ff10e851000d6e1cf474269e5325e8d65ee1095ce60ee3dd5e9971b54b7bd38a780fde0a7f1bb96ee8ae6d933e7b53ac751ca28eb728b44d6c8f3b783c83041f5c8f7d02789cde3e7aeaf427da29380fcdcb47968fd7f6a1bc0c3da0a765a8e87d10fb925538b7c35e096bcee489c37c6634cd002b252ee912fff5db74b699d778c7d6ff01485da65fa2f6fd813a62b33262454dee26fa2f8f898afb6cb2763aff2ef7f3af2c6522676ec800d9bd062d9cb9634765b5d5f8b296ad2fc16764804d46eb6783ef5a58dad00c6485b272646e31b9feed76474322c5e6e1d50d48b2beb9e112b1c3841c04346c0af1d2572336170a3c17cd9d7d176c37a240a4bdce602ab73f70332fbc6d1a90ad238119e5bf3f1c18579be0769c329f0293fa37a540b3cca20516322fa7755e99efb04bdcbc69922453501970d9a2682b04933860b4d897575a91846814339bd207e9ef0674b4dfc4250fc8e7ce87edf1692159217046e08f8c9dd135cd6a2a8b6fc49a153721a5b39bcd78474dff26d4b8eb247d4c0862d44204eb37713823d1cc7af29b43bdaaab6096882593d0fc5cef647de1956814a5d92ff72c3c8c8fa426d2c7375a6a6ac03fbf10a3274a9c56c9428d1a12ec5bd3d8a3695f2512eea8d7093d188829a71083698456e6dea0bc3f98c392a6a2d3369c201dade613f3091d310ead32edb48c3803473c65e93545a16a63650cc422a337672c809ee5e4a748549295eee14a4e7b074e97a08f464dde74cf9eb45f918451dffa2f858202b9fd43636e98467b8b205547552628120a185e8624bc895760f7264c84b76a358ab64b9af5ad5d9e02de41b26486222d017d84cfeb66d9704943fb0e07dd5af03ce40a22d03265aba711bd76cd038cf870aa910a3ecff43ee379ea899a9797c64c948ad47ad78ca770a8306f834eb4435294c0e8d799fba013ae2c0536bd7b4355e796d1c2bc6a6cb885f84a6b389f25457d9c33a21dbc56a79f855d1043062ad3fb1f54124474fc9fbf587c860cf9c2ad5c451f5303bf007314f19c46bfe4e89cb01b448c20d802300b3ca6c284fde30d7af9bada7e59abdc118bf21315a36d055ea1753601629eca8e57ac460c90ec07286bdc76cceecfaaf3f4da18325055562f00573b3e7275b6b117d1036f79908575eba7a9bfc84acc52882b449003b9ae1340ac90beaccdb475304d6f99ad30c4cc4b7a04f3a11439d8e5ae67d186f7aff148279cc59a63e955f35915991253bc2a0b2e5998582440f938adcee43961ecac06bb7626161f1223919d163b3241f2ac5698b432c2013459b7e2b4e659cfb7876a4fbff11bffaa1b42ce1d71f84c45d58135965a07148652efbab91a1ca06e451c6ee27a2341f95fa8d4d3b52f3eea79becdb7f48b43f6af06f8d4bbf5f81d6cb1c2dfa62af70a89e342b40e61ae0e8f8aa9e1ee2ee40ef72f2e1c325d89deab86b268560cd4eeb19d8274d7377efced0ab462b14b88fd05865b317c692fb6f21c54168e5dec4ffee5171e2a33514bcc49ad785385b018a1d8e239b4518d7cebc2b9e7bd969773578fcca92d0bf6c2fb862ab3ff7a2d7c7db946d7211f2db66b4171c69dd045de22a35e43a2188bb024ae11185ec20d3ac04515747733686760c3cc3d9c884762d383c2e9b6a4a7c158c248ff16550be0d1d4fc0471148789e4a9e60878528d013bf34db86c1e67db8089d214e54d02e83d4e41328efcf49b058c9855174c2033032378a9acfb092ceff296de988196fc2e1de8e9c7d1df7f34f77c69a4c140e87c6a182e0cdf4215de3d33be01032a18db8281bed0fd4c19beb6ba1d17a3aea3044852cc6b83526401fde27851bd728f86cfe5f09945de7c743a026b693a7e36e49d303058b69b4e2de34d783815e70facc82629669e17c3ea69f1d10a6da8481a6917570d7d5bd2435d82ad01beecf6b645b61ffee66a8f06d701ea6c607dba81b9cde1c979f0dc90a49818fad050ebe8be8dfced81a693bc05f68ea5858195746119b2f4328981a556a779d0c48d83af4362d5d8c835521c32defa81bb27e8e33a70f9b0fcc08fc26da1b4fe5cdd04c34835f4b29436cd3969a993953f2d4e87c5eae92dd0094551707c16a2fdbc42b7cc0644e16b4ae95ff232fbdd3ce02e9802e396ddbc4827a0768229cbd1601cf5c4acd50e90c47281ea80be91d59d588798530598b4aef51e4252eedbbecba7b7120f1b67aeae0991c02b80685eadb8efbb4c88bf7acb8f557bf56f06fc9f00cf21c8831f052785a7fd8d8efb57c878133811dbdfecddf05d4b605b5051f6b6b21606c766395cc45b3929f9a7378a2d909c8628c46be0dc3d2f0b449cfb42099df4d64add78ab621a1864","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
