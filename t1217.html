<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e04d6920eccbf1b97193700514f6efadada258bbdf068feeb9bc73538bfef7bc70a300523d03aa861e7fe1dda01b025dda123ef2a49b5f1ed7e6fc1fea3af70c3416b067397f4e97e82bd5cb227340f8e895778359c7d9145869092d34edb5943df926bf6b13eb4b707225301b96bcc344ff8e954bc002142f0688a483e77d805785712b5ff26c79c5d11179a8c976a0815ef9dab806ac9653e1418ebd807e94532a20962468fef9c133143a5e93fabe5aceb03339d26e06a063869971fd3f364fd71c994e2612360be9f040afcb4b637cc8acc9f9a9c9d4b70f63c6e6b0b12a58c9ba6cc4c370164193308b568ad24c43a332bc4cdf3d0b0a583658d1db3137f99e29e55594a93b341ca4f48ec7d8a1822f472f9efb4e110a3908ef8a0465ec5f5816777c2c326e95c409b0085eff65e587a178a58e29f3b3b30fce988ca642a01d0d0203b52177a29d0c4d4effbe5255c3c1e1886a2615e13dd7e056454f915346158cd5ef7ebd67c7595b08e86629f9f8cd1e191d56e0ba2ed81e7b5df5872ff54520525d21e3fca0fdae0a7ca601411a4cc2723ed8d62ccf7c52921c14ed2c49b97b2ec21fd6379278f8591aa5d6286e4cb0b71f096ae21c4ba673d1853438005e123194d9922c03f7c033e90666098a9a259ae7e02cd60e504a2976fce34e27855155a9fa1d3e74c1f1f0cae4e0e600771d8af7d7a291084b3c44e2c0715ff30618f0508a5c39da9f41cf03b50532b4f8dbbf6652d1e71aef38fdd676582556b71258975c93df4a8a849661df2d9f6359df21bdfb36a276727a5e86ebe0c227e270cde08bfc193138e93957c78c2b54b00410a5aa0cb60242b5716280531d059ced77ade7bf6cd86a4b6f1adf747e1478066759f8ce456fed8b8bace90b2170aa12eee897a3a6de5a4b0b3adc4eb005125789353dc784f04df4efc9a212211d0fcdd88fa3c25881b42e0dc5491eb0b2d2d864dea4429d1c9e9261801d429ff518f605a1c5b7e12b6dfa29fcedc0c24c90a69d88871f6c28c5063911967703f7e4959f9ae458ef89d8dcc628120f20763d3a91e5643bb1cf1abca810e8d4f479f46e61081eac4cc09dd38e2b75ee8254e8f03aa5d2f16ba60e60629fdc898974885e10818071d9fd8f85df9113c91da2852925a784c7c9f3f080234ca2c6084dec7e8a1ac30380675651dd854dff1337b00d24a36a6c8d8e1388019155a8b3050c55219992473eb3e68b3da60bafd545d160e411409bd5cb16afee90cf840427dbe2a3ed0937d181437498ca04c2cdfb84505850f59eddcfba9db10830af7fd4c700e3b291e0178b20467109aa037e8b566c01c414adb15910659e35db95cc3e9a91bc8b29a505fe2b2c418e02f43973c1b056369813448757f213087b206f9a48aae414bf96868226478ea693cb743f271ee635326475801c5d39648ec95b04b88e02c6c8dd8a697790cbd4513f61661e26091b45678c718fa645f76983d0a6e6d0b7511caa136ce2c8ecd5c5a443535261774d14ba8acc509826598b10dfd37771b07f917c855e29ca5284512b157b3a63eba98e0c8db1c87afb978b3c13471e95aad420e7e1acf5d3def5c8a34deff3eb6d195dc37e5b065477806692f4d6c5132c6b974a35c2e82278154300e2eaa7b103b932f511f6c5f1cbb569e083046e0245daca702548531cc28050b72cba4683ea4e759923419bbe9568d1390d6ffd8ce1967c53580ed0f71baff077745ce2c9e4190d81bb50879a8b3ceeffc1172dd66395dfb0b8d1361046e4cfd0e6b614d3757a75f2509611ab3de7875643648db5a779147bc698ef77b5b80aa1c1f796fc92f0c8c14741b614824e0956dab56f1698f9a6cb106ef2e39e6293e506c1f306301671395e7eff11bf930d00a8e60c59d7ae908f17a7ce1cee198846592cbc0091deb81f491b43ee18a973af6cc5695c830a6f9b0280f30164af5d3f19b7a25572807340a94e3713df5c073f3e94262eeef05b7b2dde370e9acca3c8520c5eb1d826213564c24cb7af14a9a5608c1adb4a91cc7a627ad6d8228e46ed2deac0781010dddf64dd374bd7f68bc9bb346bddbbb2c47d6ea155a85716e9baecb6bc58f9e3d506f307c67b335f3e2c3432f10e554cfc5a9790cdd6a3b41f0d256278a13226d403325bcd1e78beea4783f41ac81bfa219dfe2e805e8ef97c0f0efe00df0e2994556ade31441c3d8fe6535e0d09f24b135f91a7012483d2637c93ec3cb58cb04dbd9fb10b27a4925cc91be7fd3653b2cdb2d8376d71a74390026f03f792398e4ea09d91ba1234f905269df9b004205e844ad935a280de6e10d6800bf8ceb79edd323b969b9e5d93a59402abcc50fea905b7323d134223199c29ca16d05c71f2748281269f44a06af003fc4dc6b3dd8ecd2df8a2c82ad4b6a049fda262b089e513cac26d7e905e2db42445362b10e5ed4e1cf5b3503ef5646ab164e779020dec450f65447d8c15ff093995e5dd2297e6b7311f781c634fc4c3ea066ce16e4f7ac4e6e458038c4173a395ce0fa1c56ffd6b6ab574c1f6fdd325ad446b5fa960bb776874a69b8bbc0f96cc285a737897bf59776f6ac05f6047f631e1111af6e67bfce586844dbbba6d5933ed676654815558db6b17ca0ad9953d7ec170fb7d4f9ceb94b8db6bcdba9543f71bf15d6d03eea33be46aef168b4225ed52702f5e0328a7819691eebb09a93314c752645fb94a80b6a69e9f5020a23e1068d8b799bb90899a18c9efa0b16af0e44d5c479ba1776cc80522b472769255b0951ed7b83e72beffe5949f2cdf5814e8235f32fe3d1ec23e6995ac7a457656288747c87981622a54af5a3e7eb029585fe6e69fbeec649b0552206d6fe07b364f861634dcc71cf93a3e8664663011ed9d67491db46fed9582cbd8d65b3204354e6cd2e704f6fdbc2d99fa8bfa7185a03afaf6103d9b387be63859538c131314a36bb7dbe51495a711cdde59619517c6c29ab89d43e49dd87c04b5c7f404f87e0236dfb6b9d105104f51e5b6df166d9a040417841fcdc30107dbcedcaef22fa73755f3498e9feeec2aa1f947f9813d16857045308f125939d6d538c9d9e60049d83dd702da6f80b483d2df7cd4ac4ff52575fd49068ccbc9a28c3d07b5b7b78261e179dacbd84095a823c733d1931855af1398e8c0023cb8cab820e39c6fb7b8f0eb26c75a2df8d13cf59f072b01030813d949ee18611105bad225e05bf408998c32cedfeed4dafe50f1f73055f02468a7ce0c8d53e634c6d70f0b027ab220fc87e1affd2045807bb8b66edb2ac3bbbdb4c59466f9e8e431ece89f375a83d30dfdbdeccd3e7f8e41f4d057029a3d4609632d154f850c27dc6e810cddc0e71e68351787fe9d8d8f465e1072a22073b43b4142030f2bd66f0dee4b044cabb4908cba4ac6a0ed96571cbea3b99c9652410f9a72ea2eb25abb7cb2b8fdaa05290dff63afaa8c88aeb3892451295562f2bc40b011825c38e560cf1786691ff32d553e2e6dc9e9b94e740acd9022da99f73487177764cb01902843c28cbe9dd34a383d540dffc7d8b7fbce444d1115a501e4f03cb5476931db8f628c5bd5dc4f41b232c1b3197377c61f7bd7e66dceb6369ffd229786a72815a3acd5299ae39300ac0de1080657d11c3eb282e24e97092c999e647878313b6a67b6e6bd9fc652753953c0385d6b147e4cd3da106a962f656143d647785645985b83a9c8504e128593441420fd89d0d227e4f23ac2c9b0854f02aa726f6df8007f3cefa3008e7be5bfd43ff1900044c47b742737fc5b015b832434d42e0ea86228aa223ddf6ed2e081860cdbd7925336407acee3f6e4031a9a936419da3b848c47b1b35093b3b211c14aa6ed64d0e8fa7d0a4b262d90679802c587b722114cdbcb029f68db3ba0c9644d10990fb697d0638317bd08312d6b17c68554675b94d1d3a9a87df666037bf92061da0085e2c52b8f30226629759194bdf5ae497f1463b083167181a88333c7b2c90bb7e83c877382c3ec386506a96e874454c258a7b152944313c7baed2066235d9f407c7c6c8a7e39bf318601901b752456f516919ad2351998c2b13dcc490564abe63ddf8b39a418926cc4e06f2289ac920f0d0a3131a55650621d9e7a525f1bba28c1af5548305364860e83f1974821fe9c64303a2eefd5e5423554bfb3db80ed6010616ec842ef503eea9ccb39f0982c029e846f2391a390fbf90172d80bf0594f83296a0cb3cc1706776056954e21284aece54cc72c9fbb03c2f981737b26067cd1cffa66834d3c7f82d684aecc7454668cf9c80f46c3576caad7e929620aa6972222fdeda48e60236bec1c8926b65ac6dc67bb2ee69b798cfe0e9ffef80260f2cdf427e0f9af81d7cb94839f795031cb27539723a90b765687e43177f05060eb8c3a6017db91f933a16b34388c8f05f3d18db64122c738d9544645eef1f22f333ed7f41b8ebe237bdd735a76f7d23167326e8d25d9c74a99207ca01579c22063ec552e9fe56ce7c6d76e8b162c5e602acde2de0f8f3d4edaafccd291facd24298742e3f679fb5230b6ef8516ed23df32416da8a8a95044dc439ebbc882b86525de8c7b788ce855b2a07a4147a5abdc1ad3094f38d7a842c0e97707be671bf798bc7fd86b532aa222bcf09ecbab8040394bf55163d37ca34c62e1f30c2329b2883e5c5d69e077f2a407d0487fe348498779a7b6121daa97cb761867222b2e44fb70431fd8cb90a908441318527bb1473c2f3378936150d523f482551c0ea3a9d6ac9b6b050baf62389a3242a509431180dbfce8b876ed8b293524c4a17f2357e75d403dc6e2b8f0d94aa7d49982ed7b20bbf188ad0b9e254000ece3d495e30d5ae626de0e15004babfeae69d53ad46e6bc40d461d59cb6f4f4e66e93481447e6ebfcb162b4b84231c6a8a5701ee7669f298f39a78b294a658137099ccf478595be0b261c4a24c6e84110bef9f9ea1e5fa3ae042d0480bd6c663cf656644fabd270a625c5963b818a0bc4bf63b1ec58e253d2605ded5758db49c2d53cd32216a008865efb58174eb7eefd0b2eaeada3d468ee24b309d01d41d73fe4c355126c9b038a01747b32775ea48ce3c3a43067c6040ba1a41efb20d5b7b172d00e34ad8f117869ae3b5c87517d7a7cf685328661965aeb78b49e3517a0dc06c7607c405722abaf00d5ad6dc3683d9fb779f96145a8e869ddaf63e5e5d2f2c807b1f839378cd52347091b5e14710f3def5bf98b18e652d02fe9705511cc6105ec56cc11f2eb44fd3b1ff1049cb4734c3d2e0a2c719f5eb1b8563407553dfbb13020b21493e74ee34a36c584c248ad96a4f200e5f94b1f9e88c0ef92b7feb4219988831b04961fe417693c09b745aaf783f0e08140d63c521222e0dc20949699c8c373c6af76e4c4b0aee98eaa06a5a5a8ee0c45d253286bf1571ea6f4819192bc083f8682da80c15e994136646932a1413470c660a33fcfcf77c4c889156cd1139d0ba4d11b8e605045b841fa0982eb2e2faa7850a7b708aea0d050866ce235e8b2ceba862ece8a37f11b4629a93ab7084117ec10bcf97beeaee132cbbeb84f0f2a54c853bd8c0c2981f3e1cf26a31163f8e3cfdf0a4ba420ba82824ef618b4eb073f1cd2543200d787ffa47ee3c82dda16d6419b1b4f3e0ea3cd2edd39836f221a68e0cd07db7474e7e402629d937f56414dd434e78c59821758c5bd04f28f501cc72a73e37f8a96a3ae738000cd98786705559187075b47253d3b327849a5b00028f54477a2e29353c79cb7cd142a004dbf477ec351173e0d27f875b19f7ecdab291fba68cd1474ea5e3dcfc6d1400ef448261f816f183c252d8bf92f7721a2679ada9b062f57c6886db9075326236b1badaef7289c27f05005cc2882ca180b1f1ecf680f9f0226eb57832973a4aaf2ffd21167c97eeda78f4d1fb4f82f8f014ff8b71a4125a6dacacb7ba03ba7bbc52b65c209275f3fe712789d90618f0757916311238066d810883e441b81452690e09471b1290de4a5325aa3ebeaed2e3744aa61f8fb019ac99e2429dde846108e5026e4827ff9eb4f687286b8ae40ea75cf57a2cf2120b8f1dee45568fc43104c8a8b595fe38ca5f66dfe073e3100a95aa808685f6e1087dec6a262d3af7572008ae1384f43291fb3f589c842fa114b186ce4cccc3e5bbd2fee0db9584df97e9cce7f09f134a713ea0272cf03d37ababf44b37c9d37212af32bbfc24d60812ae75fc3001125ebb68093fbd9881a9fb43b18a4578946a421fe68003db68bc7385490f9155fefd67992165da0385f6fa1320ebeb27619b403c8e56a6767319f34f4f9b02c842eca2a6630a4845847c908a79adbe251ec13bdde4df8a3238402f95770b57520cfb57986c34955e3d5bf6e3be2366986bd277ec9529b6fb4e22d817848b6fcf631f9cbd2e112f03f1d3a71261b1ee125f339920b1a319c09d308ed40b811e42f3b31298cc73b96154e13097c9522c6285665e7192bdbad31a6c37a18716c97cd352efb83e2b808825318c30c7ebb2e3d056a1eb9d7f2cc3641fe43742e434c9b30e871cedddc23313cf744ab22ec8ca7268a63453635a93e5b92367cd1f54e976a5de8b7891c40e06eb833e3d2ca6bfe40e2a217c16581a299224a26bfa8dcd8cbafb2566bd1caa9dfdce23f010d6ca3c83f5a058bbab10664290ebc331c402e1a1839f6a941b6a5ecf9b0bd60b3e09d24316a735598beb71b1af454f561abf7a43733b049daf753bcfc5d1790634050d645e658ec911de14aaa5935faa43cd0b3401d65528383ec2106e91c200929913f62ff33d465d6afa8087fa33e78485ce88a8ec3bcaf05b70ebdbdb789f8a820be5e2992ce3dd822e8e7a912fd7f70c68965f987ec2328583d24348479de55f44a82e053080a55a1e8409747c9481e32a59af4cdb98fec50bfb2a58282d4083a5ed04b8bc7aa06ae5c713bc4f2fcd76205d64a875b1018b4c579eccfc1c318b2f078ffbac00ab90a10f580e7b379945c83e2962159b1489cfa1b297e0c3682a8d288b85a1f0f8ff5257af303296ff5199687419072509367a352253e36219fd9cdb8cbeb72d030d741eb1edb392a515f45ca74f1b2c854be0a27544c51fc7b361ab01cba263dca74b49d7826afbb4279c6b8341d46e352231ec880859f9221aa47dd7b2b31315cebd7968358559b14fbf9300ede493398a226beed9b4defe55901f57d7eef0909c8f26e9f31435069adabfc90298bff1c528ae08d9784b9386173c42115e0455357ec3ad9cb2f01a2f26057e12052e6059d0c6e295dc0d5453c8a8ca563dd3e699d2417816d84192d152475fb7a87b6361b5d7c052c51fe310acf8b8e0f67b2b0fb44cc8cd77ae82322146ea7e1f941fd2638bfeabbf35c46955f65a67d0cf8907e11d40d4957dd067d41f52981a48d18357e42c8ea6310e7e3dffc89f1c442182b0e8eca081c5e43a3f625e2a6dbb7a8bd5ac6063c68c5d7d3613d3bebbb808151ff0037fa91fec42dbd8faf75f8a823e8b16589eb568f923f040de5ac78b56d67deb355c9347ef9cf15a132efd94ec2a2621f54e2719202d5dc41701ba144b7049a7f2b64a4392d573bd3cee4589cfe7c4cb9f8e67135008b55c407c384f609367d7a00f61c7f58b884910ac6719c95b4a92f1009d284065aec4bc7de101092de7f4aaff9910404a54b0b3aa25ec59ea02c16442609f1e6b44dfc6da8bfe3cb6d375357763f7d6cbfa29db3e76aaa4ac912ddc383ba565bd0f75c2c1771b6334d491402c2ae613120191a55805aee7b4db70f8d7359901386cf0f4c584f67b5d5d669c306cfaad989c838e05ee046e2c2af21812d82a1aff94fb532e57ed7f04a11411a9f746c783ac36391f5c7e334e774c47459e9149a73f15d18ed81ae92327b2075f7f72c170e1e79742922774f2c8d5d970d465161e953181721571f4206bba4750baec05642c09c9c1e4ecf3564d42ce899e08527e9e9c2f02bc4299bb975f4a4af6b58a978588d12d71c5c529052ef1e247e657794a9f6c9a5c3c893a5d0aaedd8495d79dbc0d13bd738c85cc5349fe474bfccd658311d3f179f43cbaee022291b6a3c1bdb3fb976d7a2b28212857d91057a31e90b84603804cb1e9346189287b7fcb35dabd3492c27c49100615ebcfbf38af9eb040c3b016852e8ef58775fe29b2ffefc00155d82576d7cf3748e1d8ed20e6bbb836192274607a40ccbfe19573d8a917f2a8be2dd821e5597c16ec1484965359d6030c738ca6138fc095bbdc1d837d56aecaf6ed6487c40b9b51371978f83f8387a4d966ab5ba6c08bcf93fae56e85b040ba8c340ae65cfe35c5918df53fc987d67e582d887654f730077d08e2b793d9b3072f294f61848ba1c5509d873601a956ff017a23602eeb4a83f41d79acc024cdb990e698cb9b6639da3f1032d2c25249bb160d9e5e635ecb2da94d8058d81e4bf7b8d8d7561f229f7ce35b866314078210ec2a32452b2798e9d8dc7e66670a22218724b8a0e643906a6779de9b7841eb5b198659d4e60468caf556707fcc545ea6a8bca24d5196f6440762795484a7e3a276dce52afd96a80af66bbcae24a8998ed0f27bb02c638f229e8226c66a3f20796492f1650765c1f97f48d701ba683d77ceb7a688b99cec02e4e2e58318f952142f97c181aee7b0c5bfc02ce823c42b5e1074fdd1168f2441e9c504e6a2f55f184b0b86e4947f908f38d0f2a51b234acd628903a19d22ba86a54d87761c2d0d3603e657206dabb08216d987bdbd451bb3510d514b479d8230bb190dfec30dd7e439729cac78da20d657b40bc4dd721173923cfdd18f2a7208e1e1ca1c8fc791cb9e86d290d226d27e9f35430a2e3c61f284f426f0006cdfa42a77da4c90ddde66e745c25e75135974de0545606118b26bc79fb162b0956c64d559fb3cf44ab713e3428e98082174e8f9b5244ec54d673c6618b65e466b1375700b25e6bae6e372a720af02bc40c5e0ffc196609bf2a6b4af54505b410f19fcb6f76fff56852dda86fcf7b97a50a4847ded77a6c3c620777d9384214e9900bd22920236597ec745040836263a9c6fc0073d0bb520922f3e6a79504bc86021d6343c9a02a269ffb21cf40e453c1bcaf0ae08bc94fe807c8e4d7386d20e6b435e1133d5a6fb4a09c188bd2a99f8a8fa82cefb3fe2efcdb712db7072aaffd3a31c0d96e48caa4a11bc39a765d0349b279f87f015a27ed3c5f7b8f4d4e7d671d560947dddd46d55c77e506d56f6fd0dc7cd22e7dd921716c89cb7d8b4b922923ae7f7c7ffb215faefd5ae362e33f4dbf44e4ba1c6fa2497a7d526fc6197aab823e309c6ecb3c2ed0a051a68aded41f53f03d9ca44081b04c8f2b907ae1a50d772fad7b592ed9c5c28a629cba69d403b99da6c69f68f45d332805c0a9758e45e9fb4e0258a4fa082a2998da8ecd9d5fa4d4f90eb128363d2b5d7faf79ee5bc9e041243ec28e99074fb27951fa59b9528a026f76abea1ded8fe4953c5c33586031b9404c438d32d39e1ab71303ed719c1d5a514b18c03cbc93b1f4260b27d7277996e71b8c8fb9043b47a9c220d984d2a497520d255a36f0b27ceb93ac67fa8578b81664389ba9fe5f5305a6f3254dd5c515b6cea5a5e9e71c835549ce7659d3f974195dd035979591d50235e2e91facbd8a8ccd8580dc4fa10aa0162e994d35f8f8bc8aa164cf95c6f622f5e4078373f6a0fc6ff8d18c8346c93e4b9dbe22112d5593e40ff54920132eb3a43e4282501c964dda689e2107aa28cfcbff90f0b4bab589f0091417e8d7a6d28e33dad1568df1ce74a26f89e5c3a150b47d05746f2686c4f2d2df9a98b43c94639e76446a5a5c0b2753021290bfc4704100a44a1f2878bf2839fe48f07d5a84664b773194c5a609f0f098b04e69f06ef250b222bd16d9664007758eb0dc7d719a8a274437024bc9fe4153c8666379f0b1db94d59ad665e455532b98956a0950216d37074c613c84383db4288b8cc3c42bac718ed983aa3580cee38ccedee5b3c640ff7608576bf3390118834f49b3924903a74b81372dcfc59a8b859020abbfc0f024c8b99b07f92cb1cda406e1712fc544c97bf492e8a35ab8c69093cb6011e456f4014a31f03419acfef4748f135061b8dc149dc24fe00a7bf7f6980d14f953779f9290e57aa4e1e4e75516ff0a3953afb5f6f13aa19918daa3be90a2b64553adbbf116d626a0532579fd93d4c57b09ea84e72bb297141ea51d6e59e0e177e8d2ef88ee28b6df9c46881bf0c35c25982366bfc71b1494e632544701213222fe7adfbb40a7e5bcef2b07143b833183ed513d19fe7a24ad5536e1b1373d02ef375472d65f63d57e21819d74005edd3bab127bd40a6dc37248268a3bd8bde9f4f31a92a5546a53336c74b907defe1ceaa25862593a153d9bbfedd6cf6c169023d78d0ee7f37937da121072977b9638d6e2d8629339adc79ebd7398973fba4959d53742d94ecec9dc3e657a7ea5aad6fd5a21c76204e4c74b4fd7551710dca76dd08a2e8451e695ea98048d29bd8d8d16dc5f1806a0ae4c1d1a10a95e763c7b3b088955f9ff157b41b69822c462a647b6202c7fb2fb00bef12ff5ad1c31bbd0b473ea6be8388c9a6cb825372cf61fa8ef3de7b29c9e353b69bd1ffbf0a9530729af06554a38cb00bdfcccfbaead4da3282b39875d8b34b37abd03da1752c055a13943f7ecc302b176a74eaa890c1b8c1269cb5a9b4c0e69bd4e5ab25ffe926082083829fe7bef0a0e2e4e8adde5b60788a455e750a14da19e37276aa5b510be532f77faeecf73e51dbe54568c957de2f4ecbe02f47a2558dc3af2339c025bd42365a6fa6b88fc7fa2aa5a32c2712620a79a1fa216acd0756cac64f1d52070c3cd6ea2dcfd5f72c8c8c682ed6bd2450258a4002d3f6a18c2348d82908866c80aacf2facd7bc4269ed286bb5e7a8b15c5a5ad9a9a1339f4dc5a846c8c4635e1c63712130bf1e10ad8bf4b405e5940852ad6288cb8ef781274ac7cead26fde8fd00ab012a4b9a83dbb35f03ffe51bcbad09bc00367bc9d4c0586c7462156f62b6e732262584651446cf36e20670201ff7bdf82a20ec69d26437d9e75ad3dd343d64aff6d2c7ea21dc32898e4290b323d088e4cf83786e3b9bf6bed48db6bcefc5e77441b47465e75b2bd2e1f5fa117604440a86476527dcd24d497bc729a7dd794960eea1ce25b5c477c2a9406a0f2b333185c557bd13929c9f59db8aeb5483904e8f2e765c24500d42059a0bf960779b6bd4e6ae9bb6a0b86b3b041346ba69c519e97c4f1b8c851bd1d36056fc10081d55bca91ccfdf6eb9fc56c78510976b733eb659a4daf54b53e2f2530b72f9a9f069aaf2e20a441231a8569b4ab100aebeb22d6c4f0b0f12820473f396345ec0d136c76eff031c776024f6a38454ba39115af57561b9724a198bc5bd4d95cf5fb0df07bcb793fabac04be8c63b1274d3883c7ae19bc081f1d63fbf1ea7cdb10ecc51531f239008c42e3c6db89f96859699ce2eec92afcd239c65896a82559c763ee61782831c5210c5969bd254b23f50d6cc6475fa180215e05f5de14c610a341d6839b51c500833088294e6550463c213a686c038fde9a78f1af0aa03b0822fcddf0bec2c2fbdfa47fe471364a95224d558f0a7cdde0633bc94e74829f115151103e3b2dcfaf20118c873803157b37026301fedc7318419dc78db10e569f19be053cf3b2d782b33ef4605e33de38498808fecf5d1a4e030588b6d008cf15e4723a4463ca9633e3d46b7a7f99de55587dd54b49ee0ed1f785dbfe8e9ae2015bd7fdbe4182d4c52161b7bc8347ede3fb34731163f634f9997090a5e2c79a9428469432bf9ccda00964c909da5c1c7e18e18f506b64965726b8464cd0b4bca70acc64ba5d14ea64926ad0ce367e7eefbba50b268d9209a3492e9dbb28017ae67b09d809a4979521dbd9afeeb0fe4f5aa0a68f3655a2365d9c5b1ab412a7fc0da7a52239b462f3e0644719fb5c25fcad121d4aa0f5a39bb3983a6ce915df8d17b4a1f3c4b14a20422754acb482640d805e7b14a2878a18ef15d9ae6ba6fbcfc3f9e657f7e2c593417511874aa13c2bb9facc827208db3c2b7b3fb935ca90811e7b6790d0980811cac0c34b8706d67465356acdccb71a4d395dcd767bfee660bcf2e6331710cf14dd2326f35ae3219a66bf2895fa5296e7efaeb461bf16b969262bd28ce0fdafd18f861d6873575fbe3e2f0d5211a77c2e347c717ead3859457d3b11392944f809a65cdbdd3259ae510ec30","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
