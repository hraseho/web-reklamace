<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c46bb74451fd9999ace53e8eade874970386a18afa55923fed09ca0bd4223c55b896337971f175e402e81a23703bc0a87031fb16e374950fd3e60cb7bbb7273857cb631bc28fa34d560fa39adb1bc00914ab3e803af115e3ec001762ceb7839764a0881eaae87303aefd5fe75b6ddbddeea46f6db23f297e164e0493eb06ec4f12a0c9f1b82e6d89b7ad828e4248105aed2817f0e69ad7a6430c181b60d92de79fa0ae7831c957bff2a66af5ef7132c43ff9952dc70ae8f4c82274fe2a8172628e7f6c2875369aac569e3882c2e8d7b510743a3f7e13f0f3e65f18d613385f1951d2f6fd389022dcb3cb765c389a826007a06b012ee42d741fd0887c7ef3e084076c45bbcaa9562154ea696bf94627f56013bf2fb708e842756583df15bfa2f6f035df7599dee8f5a32d043658982b53e69e4e0b9c9d73d77f7330393d20360718aca6cd48b20f5656838cce4515614e597e702291fb827f473801097eb28688a8de574920e5256de4219cd75e94eadf8ef30e57fe5a4439b683d340624e3691367d40783b0c75e0d88ea2024b45a03b7f45cb5df4fc8d2dc3c2d93f1a562066fed93ce5e4766953e54de8616dbc2ccad77932c40e89515e55e780605b45f8a6fd92dd44c8e774f4ca3ef7c5a3e63b2939ac21f5046302368038d0e419827f61904d4198cf8e5267e31b4eb0792b7d73a6f5784e10d51ac78a906b1614840ce769d19703d4b76d246867afbad749c6d51c7f7ca4fb85a4c32b835c5a3ea2b27656f5ef9b6c707403d8e8d76539b7cbf2cda31a2b62d4166497a67ac43a2236cd75b58955c84595a22925d1d29cb12ebe8e142db8f2b4c2d7fcf0e5914c300d213efb1a931184afda77ea8e376830e34fd979299399bb3a0708ccb42d490359d4db03a00f5f86342451b7ef75e535fa76a68d99e53d88b550e1132640e62346b6e4900251c405fc6631345c7c5285154f7ceda515e147ed13a52143110f6ee16e75498e3808762009f378cb4e6d2586897aec774649e41aeb80e2f05b001bb96a6f5f9dde94d5cec9ba39cc319884a6ae4bf97d6b30aa8b735f474e258a811bc734941b45cda0416fe04be7d0639be213b8501d84f2f55a475759b1ec52fc9e4be59c3489318c0000cf53a25ae45717ad5e4d831c9c19bc5a42fa701764c635cb2f7872d6b52ef79db95b5cceac9520a8ee5b36613b268af758f64919725ee43ef2fcfbd66761ce593bf5522ce80dd0b7013ff0c91275eac51618499674272865601914ae6a8287ad42002ce09120eabed5ae1973ec3c52fb007fdffb78a2abb187d4c5b4c9f70e7b62ba66fcc2d5b32b6590e84d313088f1525e1949a6c406516204f802133fa2f71d894c34eadbd63b0c44c79e42a5a9968f6360cf7bf645d8551e02bdf8b859130c3be6ae9c22d5100b074b8559c7a82f6cdaae6d7ccb7dd3a7ab28f6136542be2fe3061f1ceb4cf64f5afd9cd77cb4d1cb44438482a2b4b1b753904058d2a2c9698a12214f383fd5e8b88e1366f66c74a3d7a7efd2c5c927a95d78eaa757acae2876b8acc65083a8890720040819ce1dd7d6dc05842651b30c7fb77a66324f0b4515c521b4fa6bce0cf76ecaab69f9d92302d2a62d7b2f3af4c7abeb3ddd2fd643bee8a6fa0226fc3edf94d1a0d871f0411580910f71b9e51dc68642b3f6bbce3d9b8307c6b1e2972dfeefc4c6b0dc3846181d4d1e95a6a05f2c2b9fd86715101ba0ea355d8da0065a66057a1c71bb79de7b370bcae6605f2ff4c029c5f6f34f8256f0c060900012e8304514f26d04516f4a6dfaf441c3089dac281bdd4f41b45793be8d48b74d462c5b09f05acf3cf5ec3131471d128e84a7c4385deddbbb497bb6ea76b29f0aeb905f621084a163b37fd57a2c99fa90fa95c39bbc14add0b899bc4f9e9f208f5b358f70aeaa01a8c8038c941d048ba38eb4bf96fe5e1044d470b374f7e327c36538f37d8b513ac1e9d6d53ae76cbfff6c41f152d10eca134ae0fc887a8a76ebf7dad419f73a9fcd3d50e555bf84822f8ef71e405809357d9b466d68e841496468427b12cfd09ec2df5ada6f34c109dbfb053bdba0a49ec5665a2e7437031a23edb54c924fc5b465d5ff1f36cadec08c5741822611b6c843d63e5ca0d72b4e2fc4fae05abde3b488583750de47cf23d1667456cdee80188ea6361d6d260c231e89a85ec174e9269f9dbe142be63bc4b9da324789ee80b550f711d2c2e662f46f2a311350b0755a382b5e163756ebb2a5430230b9d6c0fe4ec4b3d3653a251046fb4f90b41082508d9c67488e6aeceefd187aaf3c16e4035c3f0c827c3458f555c78dda1ba3ca3277f90388838e4af3b782afb2be5f8c629b443382a1538877eee4d82a22b7aa2a3dfd609463a4625129b878a9bbb15108a22546435e26cab506139b95a837e9de557def47b026df69ce96c291a06ac9417bbb7a443d3d4650b7b2292e5ecd7b7cf33a9f846e3cb80c055e5bdc3725f0bb395246631db1c5fb5707ff2745a03b50a20b0a378bacc000dada3f81edcc679dac76cd0a46b8a4bfeb2c26c797bf0657b493cfbfcd9b86143bb737b40968fe95d5252f0139a4651c5d31329aa655d50533edec609a8543c135fa5ad8dc79917cc4ad7e59e60f925e324fbf11c902bb504cebb5fe4fad559e1812a4cf18f07e07b941fd52b6f0e380ced542d169050d532c08bf897ed1a6cb6b7ee15e5fd47bbbd12c406ac11b88f080188b30ab9a449fc8317baf2f6ae6aaf796597ae2a5bfc1badf7ecf821de008fdc2e3d6cf5bc8bd3ae2a416828585773289d7f3bdcaa5d940c73f4fd4c987620abac9cd5e600fdae770eb813a070a2f84be150e54af53b01265fab9f6a9aacbf7b2fca97a4d2a11fc2d76d122f4bedee0ba152fecffecdd0251064c4af3a4e5f648ed98eca856d98d3cf3df4e364feaf6917ad9aa8cc10447b2d513421f68713dcbf82cbc8b41c1e9800c4c2678693fd245cd551054df77676d41551371579aa8ecd78b239c681ba679da26971e360fdb0a90cb478444ff946903a3deedf11be94c1bc41a3f8133262296ba28882a5e3b2b31e43a7df5e402aebab59f0938690f5b7259f630f6bc0e424705b63b9eecd56f008ba4725472e97fa56525537d8e402d01308d2446b5ebeab15a53df3dfbb51605b9a95b82264a834e74781b1715755e7f87cd653f89761d484843b3f612a67555402ab75f0573dcafdb968795c73ab1318445095794d16a3744e89ebe6d86c9e91509f3d6706851c9698236f5a166a522e541e23bc92480adc5d3a668c1a3a1661a4e20e9f3bda75e00e24df0ce789f2eb883bf397699238a73d0499d26dd605259875e50988e0c79924ded51e0cf05e3c37e961dfeaccc867773e5a7f28e65c5358bf98418063aaf7fd8eafaad1bc9de41027fc1b26c97f88c496040c8cfc0e74c2cf254f48354d8ff5468f9162b1fa7dd3a51a9d0ccc875c50e4cc0f4cc695f4fd976f4a6bcf8ea83a9d8d05d8a1db6a312227baff380470c058136bf01e68ed15be67d55c5fdacac01c10a25ce2657acbfa7ba71af9dab17599d46f64f467c7f7d970a854b47ce908f71d5ce18a44abbfbf9109eb3e7f09f5f07d0dca7bb006103a08a581fea5d4504dba9fe28ce0c5a037fa0083dc9bcc7886b141bbe7256d70cc41fd9c6e893e3505184e24d30a3560e9b4cdbb7ac0d88462d95a16f21f891bf30613976053816e79821e6eec897ffacedd389dadd8fbc6ec2323475f73f2ff1f1e5a5ef7d6dba986c7ba478eca83e6b931c4a576a88e6ba4042d69f715d826de017732ff4b9dd504466b414933ffe506da676cb76e99ca955fe8b29cd474e53b6864c76d850a0dcb62a0c1812a60d23a6091acd7853c7ee694d48acbbdf0b6707da6bc730c50713179e7965d861c997ec2595dcd8a4b80232592caf037b9f036d9586d5d85cc0a36ea97f221bb231af5932148e12b1cd30e4bcd6d2fc1e7c7d0b1da4da01fd9cf71ac5910794d1ffa3652632a8da88dbda4bfad26b805636f14d4e77d118cdbb53597269c99af5b0b44af78a624d56a5aa01c803f573a1be02be81e87d982efecfbb0a887343327e568f756e1551f55625ac7d8eb2bd5c0eb4430102559d9bd015c7e1175da643e346dff0c2ae28fb9e78060f67e07022e0886cd5887ced4d7570b8793e0f06299220f6715c78386d0647dd8f4abd5da1e1106c9f45b0141af8685acaf0b4462f31459b554dd6ccc17045fb2390985e3f0d481089e7ca4e505e3a9c1e99372091160e164c71f067c8ad6834faec9c8ee1f6f573dad375294a92a5dba2d31164146c74ab2c4464271bc1c22e151e1f4da54db5883fd470ce1de9b3f10590d9381ed6293eb39e7760ee269598edada0ecb5d5e00291e553307d0bab44c1528c1e60bf57f9cfb301f31c8a4eb02cdf3952344f0d762af39b5143645eff7b8fadb4cdc20e52fcdefce90a94ed9699e8bfbc4067521855dca2b8c75bae37f82243876a1a25ebede7085a98bec39e81adcfebc2db78ebf8845935be5b5ac165965b9eac183ec00b7c575a6f93e78a3d4f7eb779ce096ae784398e3d95dadae32f6aa2c1fcfb2880d65328b4899bf52c4e3f39c84da6f5346c21462338601b419d712763c45c353c88b96beb119ec2ea56307f8e472b95e1c1d135e6f27811f7745f99ed931a3e1edc697f6518fca999b4d338fd6bb993a965d6d8b91dd24650ad967adeeffc1286bcba6d8f5962cd7fcd95b4926f0c1e3a32eddebc3de232843839f143702a59e0ce1eb5b68b281420f5ba63cd67e452a598f52e07af2e59237c7d9007ed8baf8ff19b46b8e5a06b1655379d20d3c20afccabe7eb63decc3f4dbbf3893f734c5977e7c7309fec0dfef32a9a43e860f81f0bb1a233f2bdd404ef67b0d5070545d507e61854ed32628b43cdee25635ddb8cc933aa0df08de13d3d7ce9356e77e0adfb3a402c77a59ebbe85dad5276181cec8ea97e036ae48e7a38e1695be03c85223e783aaee7eaf7747dae39be9f59b0666cb0b9e19c1ac0ef7eded5eb453515edd11d4e498a4aad145178c50fb8375c1af55a8ffa7503168e0f1f7da31e9e2992bcd7a3f9bff8d6980ac147a3533a2e3669ddfdb35999639b036186c558ceb16cbabc0ef2faeeb236f4458cab26528327da10ba6d96e3fbc8c930973bd8966bd15876d4f11ee0280196116c3cf8f7f149da61b5590951fbaf64cb94ef16b303d7207a57b5b9892caeb49dd550c6be96c31677685e7baa08470191f55d85464822399f8651b304e3b85a0cd230faf5649222d27a3f9f347c72b71c2a03fe3090d523e41038b0e023af3c50713e7f75b4f8f3dd816510cb7ebbbbc80b128a27b1447d24f15f0cdacb8acea85131611166567f8ec6782716260a0c856f946389ff01678d489e7eb0bd57c82ef777cadccaea5525b716cb56105e0754251e980b22dbf60218bb0f91f209808e31d2bbdfaf7b4a8ce266ccb53ddce53fefac9e6e117be2f80405af67e4b73b29579991b3d0ec34e374917ddd12e4f999715990068382cd145e3cb0e030af396db576c7222889fd09c475a972d6d5bdd4a90d87ca0ef775c74b68f0bf08f06878115f01367d389fdb1783e7f50933fed19ae36af5bdc1ebb4755ddb0059cc30bdb90f8135f42aae79f5f97faca485c090f65f5c9f61965587a7199d77155951c45595f555d959bce8fd81c6bfbe73f78faf3a1ce8daa995fa80c49844eaf43f74ea1ce572d0ab35edb8e2a010c77ad2062bd1c434d236300f547fe9ae8fac4d411a4b83711475b65eee4ff64b66bbd71d49e07b5ddfa5e12da1a4e48aea67292b41df368e2742b30adbfb90e792e1bd97953aeac868aa38da3efb8c4062efc344936a7927011e93f656068494b9ef11ddc157f650eecbe402e1f3991e99a9679c5f49aab1780069e1d890636cf23066404189029da2598c5470daa8087ece117307e2a8b3f44f10a64ddfb5fb723443fdd9f3a0baeb493854c090794e28bc71cb499cfea3aa010f789375f1df3dc5867447a4c71c0e180f9c786b7515815bca008994898dedf4b7ad213770a9637422c8a1656d59bee062f5def57465badb212031fd2e331cbe27e6068019a175d749bcddc6614f5351250607af508db551a17d366ebfa29db546c14d14afe41119d27cf65a7c8cc493d23114d148cf142cb74f83418568355e487a547f794f475bcefe0d05999d742964ddec9fc8ae2e8b9054a1b199d25878084e7b165811bc04d6c79030d953b6bdef22efdd4ab691733dd3d761157db5570e000fc2a11e6144a6e16fafd42cefd90d88861cb4be3caf03d7eaa315354a00f68d24556c50a06d064fc5d2f69e73de796255bbb2e2bbf70c6c041c2d0cb734188dfe998911a0e3e81f2bb5c9693f7bc294a6e3cc2ff04e8ea0d48b9038417b69ecd04a81eb8b82e48c2a219130355303ffaf4bc3f56fe2329beda9504a1079dc5846072f10445ce37403a3a28f171f762dc55915d8208fa5e2f9fbce26e49e603d0c4984c676e172ad87c05e11d11baf67e4399a41d91537c536726392eed4d046a81c11b0338bbadd9468923aaf21626659d3c9e644b04c7fc2388991824ba9ba68c813765e093e27895557ae7304e6f5f7ce65a494b8a7e4625385ea431a7f9b956684c99fbd682fd70d8f2dc63eb6605c8654b4372e8ffab308ddc17978da1fd8d14140e4afd81b549bdc51f3193306366b5247ce6a974b32d9e67fad6fc82555ee80413e73b801935b83889b4371cb3b777175b8378092d8220ae36f4199d4235181eff124b61d27c450640e8664ebdecf9b4922da9453e33a2130f82c552f3bd8d4de1f101fabc5432aaf2f312bcff3ec61e193f481cac69cf662b31c8196a13c33c729b7cc6e733a00d7900d99f86304dac0ac6ffbf5bd43cb46658ab2466b6503750452c5873dce314739aa79ae6f470448a666dfaec8dea733e4b021817f32ad5216cf566e0de9ae43dde09f4b02bb07638bb20b75d20e000f8695a8de5b1471a70804152f48bdb0468fd40d6bc44eabe470b46f9ddc7fd8e1f40c1dcf3e9475201f2f14f8340216222d4761c8038487c6e4a724c0f147b11254911938d12f386975e3116aeb9e4cbc149dc7b8c5df904ea6ff26d8c6da87eabd27788071417c3793ef33f80d58ddb5e4f844df9db5cf59d15778561f409c9a267730ae29df565da00129b553ff328905ca9146764e14e0cf91a56683d3a36d7edc9116cec6f3f4b787ea6f9355bb39147c6a47fda438107bddcd9e3aff8f1a4635fa108d86ef23e860ef10b9d33ba2e3eff9455a9dce317fc552ffd66ccfae58223673cdd0e0f8fe2a6bd704b1729da60dabeb2fa529550dbd645c4ccdaa8d1b0a72e593659118092fa772d6ee054acd373a122eb70f6462e3291e68e9a336178b989e2cc1ee1f93bacd8bfc475e356bb55934ed6eaba94c8bd8f480ea41d7abe5e2250ea1af706699b396ee5acbaddad16831d41a50e56d445050742867d73acf570f9df82945c03c78d677388c5fb61857892a99e31204f981357f35c26684bca78a7ed1fa79e41d7a5dfd8dbd5b3b2081244649cdf4b25a962ecedf1b474c3227ad629ad555561b7ae6330e7b519998e74770fac6f7f76d7c6028d3da6ec4765dcb943b0499f5c74d046c7e88c1cf96a72c85279bbfd2e50f8bdee46fc29291fb95ad0522fb66841ca3847d90bede215e699f09c3fe31863e0099e6d235fb31d4d616dc97b3f713ff155a8bd105074e195373c9f90349ada7bd54fe55b413eb4b63e38a5b95b391ddedb2a87397ab1894afd353b1636c21549f01e03cdf4e8aaec38bd8060e151ee10d906bfc138ef1118178f51e6251561edb4fb39d5bdea53680cb34b06e6f4c425a0cb93eda66a2b7bc23cfc8f84fb3591b8735c29e87bf5a834cd1b706707297e4c4d0d992bc8b6fdb066f11df0463bd4857e999da6932b3509151a61033c19569e6844ecfebc84b2d184905afe55e88a3ebe70b95d23566d7ad3a56b2ba9514585ce8a21b0125297efb5a7463175e994789ebf2cd562af0625d5e8e92f677bd5b428d7d0ac554ed9dbf7f2e0096f4cccd2f4c83763fd748b62caf988246175cd0acd5306c552ca1e38a7cff236fa2965b2b2ab6831af2a7ba166ccbc2158a291d33d12d5db5385a69cdce9b302b4b394eb48677a783fdeb38db3579c824b474ae20bee5ba4b6c3175ffb8d5f4004ec102567df0406a679c5aff6a6ba63db4f35e541e99da42a3b11d6ab6fff453e2038261f829815847680748247d71fae2ea6669e41fd6275c4b0ec29f9b073504cdb431081079164579050761c8080b065e0e42e0123c7574d131b21b5522130ebb2ce280fbc87a383f354629202a70710ce29690178b5557ff90534b86b1b6909ea1ad221112c52eb84947ac95d90d4402549111665b906d506cb84bb7d02446037360c25bd65162f1b2fe6096a0ff8a4e777ca313cbf8fbc76170106cd152662e2683d86b3d4584b9fc64ca0fdebcf73d65fd6de2ffc56c59f59c47b7435c804101747be38f7b9b851029d3cf78e53b90b3aee46ff6e99bbea93e61d2f8cd0ba2ae88e622825154c08cd8619d1643e29b316b82df358fad687f4e0a424fb0da0c8ef28ad681a66695dfc628c6307795355e6aad30cda61257186685615f1c5f0b08291317ab97b29f3043d5df06290d57eaf2e2c30a10001ee67568cc189159e313b037624003bdf7840f9e03dd1152718ff687d5ffa38bafbd9a9a763295e6d841b1510a25f7a2a5d4ed234aa41edf9a1ee5fc1555216b16ca00a9b42551b1ec20eb5093eef73b9898df19b1208dbb444708d5fc796d953b433cf255d59daaf63711640eb093ab7f2fb07c73a4919aec87757b1a2204c55f3d3c71401f4af4d2d0776e4da373c5b873913b972dcb4d696a68b88d93d071669508dbe3f9bda7054790025d7d3f10283782a3ff6639d28be8a806da37a314a79eea8e8301bd87e1e63b8f75d2d20421c73bb8919fc0558b35ea6a66261f44cdbb2b66ce09f62a4b592d7f9f6eee86fca596410a55e7cffe6dc6b02ec4052bdb3db6975aad062f99a242b0f818c1e62421b47bb0fa2efc350ad25fafa251242a5543f36083942eddc7205b5951f98a42325f20995e5635ddbce2d14d7f1469072be428eca7728482e8e8cb4b98473e0c06414fc7aeebe37ebdab0e37808c788bf8ae254d1b67c8cfb6d42c20bbde4989ff1b1b7d391815ec8bf9e60f0765e89c72a952745975e216ed4431fe8438bc233a74bac184eba46b5a5649e8860275d99474ac80bdbc3e56ca7c61af647719ac4c85c220e75cb28cf70d2c978b8c4b9df6827603c56350cb764a2eebbdb1c341b6d834f2f15fca56d79d001a8b67bce70a6893ca2284314460b6a309d4ccc13d03784dd1227be70bde7e67a7a6de1084d9ecceef7974bb14fbbc8edbfa0a86de0e92ef58ec3efa743f5b38f5799b8e299b45293d3fc29fcd2b02037ae3307e30ae3aa117a9fccf40e16671847e017615a1378cd847332fd1ffaecd0d22e57c4aa3223c60b2f4ae1c838cad55c3e5cb091cb39aa7dc70f43f0f3970bf1b8015acf7a6d39767664d02f6c471e19271a088efdb8a1954d450accfcb61954b17499728d086f3c83c379a99f5edaac413a4f0eb3f1ab60845005a463b725cc2d272806a9e03757c10faf50a673e54efb7e4331c1d7f5f631d9700b1b8ece33d59c081334d1af45014b3b29f2298cb5d8bd97bb4a4d6e55b7dc5ce0fdec2be5beeb2af37764ebf664fbb671bea0a8aa0471adbe4653c5e4b2a79b64df762136742bd19128c271feb98e4133daf47f976b1d67541c2bd2115b35ca858d409eea73fd8763591cd2b9c9a91f4ea204b7b177414fc4f2500701fdac996d40d9a52a4790be65f0853331e67caa9c92c75ab2c62da1ce97f8b684708388698982aa9e64192a68caa84e9ddee8e5a5bc99af1f987e88a5e1315399ae41c3c638a1720780c758ba21ee4534d19f3b10450463672b05d23666332ba67a5597c2d6c7899926e138823cebbd66f9623b75780d7c8cfeb99503778f8b31856525b5850","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
