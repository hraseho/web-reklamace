<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"977c7426267399186ed6fc6fc61343d3f533617e13609dc094b2b9d6a59f7979aa2331a9a6d5a98596d48d5cdfb2121310e1a650ff6c967e2dec07bc226ee36e4de0d6d16588b32e4f082c2b93e6f9feaaa822834781a219e17ebb606df98595d90ed04b1b99e7826d8cbba873b3c6f7b24c95ef84abbb62995177d7443777c339214391db3ea9fb1148b73cecd99a79159a1e0a4b943324a61d23edfb0df1975c056c441090138d0726dfac792c38990e647289c3e6253f4a51c72b8a71d97150b93f1d9e83404c4192468bf9eeabf410923f6c85dea5ea0de8e8c663855171fa758982cf86f2e91f2858aedc1667dce9f98f3f28dda15c10106c5cb0edabcfde4c9d33d1b05ec13d6972c4850208012c71a0da5862dbdce77d65b56a3524bc13263f899c2a54d6568fc5160e0664d41fdc836a15ecc86da4699c44c4a4258dedddae438deae39640940a82f2e2ae31647a9e7ec1c2f23313b5fc00d7e6a21691328861bfcf64540e883d6996cbff797a0aa0e0425a111c4c24d79958581a3cc1a3f54ea27fe5d22d8fb6460262e8ae78e7fe97686fd84e2d9334017812628a8fd935aa7e82db92bc6524623c5039f53a1f2968e980c05cd15c2f3b66ca65a784e8fe16edc4b13744c2d4f4091f787b610b47e4d9926d80c7b8047f4526de45634351b329f5492bffdd8790dc255b2d669b4d203d43e65e686580a4fb10d50035a60aa595964a6d174ae0b5e9eab678437d3462b701edd64eb52eb8562b999c6b81c4c91c153072ea9e781b7bf7f2807af4587a1f6e08444502e80f387fbd55b0bb868e5cdee70c4e9204c5449b611d257476526332f09474c52036228e2ce1e66fae10461ccda2b67cf79f40f2f7df57aaabfa2ab6374d13e755a2e457e0e4fb3a0a0704e422fe7d81c0ad76d7de4f3f4158cf0dd4f7b305fa2641b7c1482a56fdce27bfe02e1cc788f5d0864d4c94c70695877c1a2f912841e13b565419c742279baf49bd200a6a2b2c05e0b47a2f64da1ca1b30099c6dca0e9c8ff0e318263c9586f1c8db3ef094f7a5ab2397f31dc5b94ddedff0a973e9b6265bde63fe788722cac07de4850580af9183476c1327c74a7cc250ff7c38b9b5ea1980a9f40f406922c9133531af93d5cfdfcfb837303e3245bc86851c5d30809092a373249a9d546c5dc5b5a2566859877c5497d35afcbc0dc14f3533db5e5c4aa85cbbba5c1d846ec9d83bd67919a67db6c966ed3465907b6c2f28c261f8b04f7c4380a490181cddbd720a8348eda90bf3c956836f6347246ca9847045e24717973cfe757663129355057ae6c9ea1c446bae0e6183216d354bd4379b901845aaac3df9a9b0511e5c38e77ddb12350a948ff3b5f7b41cf61999af056f0219c8a984d2712b833766c10920573f846cd503d785e06e8bd1b3e429c3cdb57f6fdae42d5a0ecb7a2252528156b6cb41aca8320c2d5bb8c1a79ff119fe209e4fe1aaeb0fa29a2d8f2d45fdf5464ceb363a5f07362a706abaf765f2c607c4b93ed18261304a745eb1fa3b5902f16beed9022e0d39e55062830a27818678618900f730a0412fda76ffef6fa940a85e226f39dd61a4af5e4d844ac8c7ff64314daebfb36b3f633b8e33004df7189103dabea021746a715c5c1cf8303cae5be701a007fe3841d85c5366788bbaa8df8fbeba5f2a6c1e5fc73a0399444ec39f3f8943db6ebae4bb309532663edb0221a2baadd90d3fb9735b0f21556679ea14f5f2ac089d8f76ada8dc17352bddbd30b0fc62446d94b1f2b58ac161fb72ef50f2cb542ec1911f5a051af74bf57b04a1e8d02d125442f261592c091d20e62986305cbd578ed613376ed80253747a5e4ed6ed5851992ebc843ac0b699d6888b3831483ba0e5c886f3311570512c0f68eff8b535d272da6fe46184e2dd3538f7ec73012fb9e0c2d973181b184a59eaa570ada5e9d04601566d250656905562993668000f3c98d9724791a84314737dee3251e0fe81f65fefcf4d7b53d0257cbabe6484fcc64f153223bfb5a3790080edd9f2d79e75f917825ca17e3b4662f4a69b59f815a3c687ace011e3b46b7b4c336fe11232da1dca2a02c7192ba7243f5f2728d61ee6a1a42365480149889031f1780fa2a712655aea9e2545d86444218c13281553c7fc6e6202ae6e8fd33479a0368b08de332951e107b52743328f6d14e2ed0ff42a0637fd8499a1a0bdfca615d3acc75a2c554955a60e6833d50984531293731570526c62d707d446ec11cfaa2427082a43812921aefb71eab4ad38645b6a3dd8743b39fcd7a7a0a8e4b967153a52af2768bf1c4251d18b4ce98c2cd07075c3f7ae92f9f96f066981516b377a576c9b41a54c3f102cad2f9f057af2bd42ae2dcd601237baf416c517b9a8108d988d2e650174e341fd9f965b80c37f68e588140f5bdd5f79374f4ef17fb8aa802707d2314bfa4d94865d95d135ae516cffe5c7a50e9631f3496742504d2b8e5476bb071071fd5443c557b4fc34a8216cb19ae2d6f587912cc7d936c57887f2e112688d8d1de75132bc2e1eb6319e5a13b9d32818d28b4c9dffc0c7732b8635b65b6321e623d785457dabe65c968ad39525616e69dac4cf9694aaf9454fd4610e4a01a7a4276384d834d9e8b894d552de931a5908f410c3ee81a561fbb10769a9ef6a372d929c6fba78e9a82867ae02d5425ee68716d8aa4d5db216d9af41984b73a5788ec77532336e798ca1ba0505f736f32c0c1f9dbbcd98cf51643951ca1fda129dc139b08e023064ec10fc4a856d91fe852d65f8ba1900b9a2645fc99601b2295838fa5db9354984ebf6f05f9d9dd270b002829fdc502e164a1d3e7a8f57d964e19a8fdb9cbee8caba4c62a114f30ca04288bd0610c3ee227ec59ee927e4eecbb10eb02bdb50b99d71ce1167fa737c140aa9898c683a48f538086c605c5ec5d0b0e6ef9616a2a6db35dc59b3d79957c1bda378954ef4d6eca1f8b45d41fad015f4003430154f913b7a30fdc3986164350bb0ca25dba2108410e4ea6c32cd512a14b71f358d57bdd01a062b832ee516d0ef0f44d2d13f45be17b4deb4db96d137c0366c9faa59f310dafc1be8ebaf3f2ddb30de2aea0bce6b79f1636c351b7f30ebc0202589bd6ec68bc72288c5ff12d39673e220e9dfe3891d358a2350147956e8e1e5fdc71876713f0b306fca67db8a36f9aa331bd5342a1b00f1eef0f18ee88c52f5ac3fa6858e8b0fc2617809ee7481ccfb3b39ea578eea063af2e1d6693374eecbb1606a20628fd56d57087b925f4c3b43e137c61f549d37ec22737f5baca8b3ffce3c439ab76a2cf68f622e21aed0125a4808742c947c7ff8a230eeebf249a2891c142db711a8c80d79d4990df9fb93277072eea0a2f6d4e4e77038fa02247aad4e7939a08fc2ce58010b5442a2249ba5f5424fe98d582a915c61c71b84bf56e192622b13e187f9de99d8dc2833689c1520e6e8ccd067cabdf7af91134ae2ca1f24b49290450f1b9e4fe249ad7d6bbb8cd24f1611b98f31af0532cec3b1ca5995f83c76bf49c8fae2a1ff880faff8d5302d0c7e51eb03d0459d48816824884f3f5adf9e3bcdd2b2a140ed361939ac7a8444edc997a6af73a5b3db309f0d8dabec1c2f13737f76ef6ebbfaf128b601e29aa12d47f485be942ece5634ce22a094864196dc437ae7d02652639e18d9de8ec297bd53863fb2afec9002c83451b8172ccd644cf12b808baacb9e864c3ccc134905873301b3de524f93bf2785293907ff8166d10df2972eac26111ffbb5a671d453537f8dde4c0b29d0971782ac0135870a0aa242b86249690b0c41067fda8108720f3965b279119d3a7623121fb9ad55beb88751d2cde2d4b0b0202ab21d0f38a8d81897cb06060a4a1df5a7134951f66e42b72c4ce0a606480b993ab61943eaab136383bd012ef8d7deea695151b4b7624e46ba4c5b8beaedc1bf9186ec89eb9bbbb95ad87ec975dda97057b483e44021cc156b462cd0288a99c25d5527d186f4af0f4bef45219e02abb83c49f3cdef1e37c349d4c9841a5be257cc9a3a5ed7f4f809b9d91b605f958c7ce43c00414f7e212336caa886a169459886c91f038278b63c0e6f2926a01fb671c4bbdc8afcf5a426226f48bd89d372308edb191bb93f6c34d57535dc54832552b019b690a3bf7213bdecee004183112d47f9e4ea33744ee952b8b579bce29725575692d35d7386ad49a8f16cc1abbb32c1325c9dfa9e4bbaec8a7a43f858c73d8fdc7de09465c6e5513f09954464438d60fe2637665b8e38706742d9483ae3d4b919ac0c8214df494b776c072a04c884bf465e11068c539bcf890d75ad09888cc4a74ba8773b62dc648493a505fbd424ea846b1ac84c743b08d6e5c1df04e13170bec08ef4518ab54cc54ff22eb7ca89e30a7ba630d9da7f481624d42b26ca1c5f4f3eb4379af9ec0919ae32c3150cd6cf3588fa87025bfc59ee9cad6c100727f27b9fcda8c0ba68f56b3abee8e89dbc1a24ae5afcd01ff5a092f0e20e661b2e670f9ce51704b86ceedb85bf4a0772168df4ed8f8993a0c061db274b0d6ba17dca3a10b6ce143cf1da9951eaf2bdf5ed344965d40a04f2fa700b31792aa126789ddfab06e1cb216085f9996f4c64bac48fe9a3ae7ef7049919e4f7777c1037704185d5543d98fbed142657684a9b863f555078a3d9eb996eeec42339d78555a72543e5edd08e9c55bebffe4b40f810cd3cff6028914178532992d355564d0317203a88ced369e666c0b5e2916f52fbc72682b03efa1a92184a77c6ac540aad4863de19ea5b8a34cbf78511a50bb90f1c4c9527c7978998d1772b74f149037f20dc366d3a27694d3e7b583d384428d6ec988f7ae1fe6bc3d1782f224207f441befe59b77091916cabb847230f2feaf4c68bebe764d2c8f1f225679e58cb9919b97431b42fa6795f6e863ee18755cae520d434fe2773bf485a7c8aa1c1ca00e81ca999c7dad01947a6e2e89661623a5444e03cdd3acce78a8920805af971a120046ab74b69dcf22a4faefeb4ac1fe798c7dbc4f9097424c30b7c13d4722c570f6a3505232ea1fc19ffa2a72a5063d1d568eeace99906e6342354c0f205bafa65e131ffcaccba08c66a35c124160ff4475904d0eacfd1b556eb64c3c24e2bb3bbf57942d3eec50ec45e951601cf160fd827699b712826fd9786e3b9806319ffb18c1c34c3967af8574cd78d45a3e05a6424092abc309fe8edf89fe8ad158d691ac2077715ca967e3c4f8eee29702442156e471c997a47fbbaa00670bfbe005185022b3612c5adc11c56209ea16509dab67032e164a56ce032d0097db7c5b5dc506907ca0dea683ff77d208b3c37704af71935237276dff1b87ef93ac0337883a7fb165d057ad73abfd0aae0a3e340aff526a660752cebe7de82fd73d238904e8a4e6645993b2b5ed7bf5085b904e3a5f70cb3b6b3bbd93536ea11809f4015014ecd1c23f2264e36cab46c7c7a3681516fe4398ae071b167b16da73577ce311b298e064e044a0ee4c8ff826b01c0bb8d8d4347765b5aae1882d9fe0e3035e15b1506bfa286515a53dddb2de1d689c2b285d265dca52497757536898936a081e47f71e57cf51d499f7adcc433c07a17acea9d8cc7c17e803b6719a7bef634e9c61698b4b96d9b38404a971b302ba382f9a6ed2bc80408a7b1513c92ac9538660663a07cc78bfbc356f777611d6bb87d0c7abc97de0705bc98effff3e2c12f10898c44db09fbe85c2960b85ac9aee00e2c57c71469016edc8693b43d6d79a994678a8b9edaf9d9e82666d0e248ff61b262fd1e02821598101e80b02d85d131f6a4d9640476e579a5004a7f4513a2220cec3e1c774e2f48e6001041f5925745401ea956e8802143c837e1eb2b12318be1a197a8abd21a7670d0ed8cd9a7cedf8f47f901cd3150babdd7beeccae3a9741505b1c79ed135337c8a3893193136f535a6104a8e3198478fd9663ddcabf380d9d2804cd7528d21e3c04c76fe12f16d5cce30a311f22fa3b27441380c0523c3aafae7059bf46b1547942ded0578b24d2455da88c8073e3b8a9a137842417664d0becf77c523e588ad031a500c9fbdd132fcc1bad597dee9b3ccab6ccbe93bf616c4ba390771c8430ce42beaff9a4e01d59a8b8e34152a3f0101ba4944d87a213d4e7ea2bc0747bde1ff2791c1f9d18ae2811f8c199c04a113424bcfe553638b5b8eebe471a9b41f910246b65110be3ce6490ecb5ea4fc682ea4734659f98637d3abcf77a2de6e0c8c0d18d6b9a5e3cf57b0ece5cd6c5317c40db2270e2d8c09cbe32e4f85608bdfc30269584f4b3726eb9454c4f7485b59e2b5cee86a550376452b23bd75c764148605777bb0735757952e39219e1bc5ce686419ed4c9256a2ffdeec64661bf13c327acedd8b4d02263cb152bb5b5089c46e03c58091c41e206bac6f528aa165c803cfa4b76618f4ba0562441fc411a7d532bd89c05fdf61237839463be2e81ba370e795ed31748d72e1c867173de1f389e784c1e1851b395343a013a9e916956da731954f3bbeacc3c89f58e30a8d3ddce8c877c69a7a1de59747cd92a5ae2435e44cbd275d41e4355b98a25312285921153304ae4165b0bce26985bc22c661cdc5c708a99d83fd9212508632209187901182ba08a2ccd4453bdc8a4f08635eef106618244080190c3fc88ae7888c18571a6867f445cef8bbe55e6441112740363a6ae1e14162505ac9cc10bbc3c52cb4cbe87b3b2d2b4880f0119d51658d2f7a0e7424482b69773296399ce78021d51975d4dc8daa676e1c8a86ddeec95ed8bed668ef01407bf550f7581a0d9206e5a5324ae8e10662437f4b02dbb75f5bb1e826f474b56352d80da96452fdd3557ee0c2035f3d1eb6d737e9bf3c58870ddc4e17ad74a7db81ab45e1178a1cc2ed29b0a4838858422440f302c87884468c73159aabb50026cc72f498915313dabdb87627560928942a6c5633b1074107490a415220881c2914b24714de70d5e5e63c62ae08e0ae4cb547bbfdab0c4ccd6a5e012995ff6927519ba0f6cc779b4351c9ac725c78e26a95db47a87111d617bca6498b35a5e8fb5cefe43f0a3e25f5afdffc721f790c3a1278879e491fc2131d3c5f91c499720e78bb546c458bcea70f251596129ae81a62a4867f65faac2fd14eddf3aa69ddd97c98037a90dfb3913f80a6bf1daca08136dd96e769e27cfe790691b87b818b3f38fbd46a7b62b207649480efb7ce75cd40533fc412a049a082331a7b595cb5d7830c15ac85d21f71d0190120471f77fb7473048eff63ecd855e8ed80da58fcf38d66d5f64db65329ad4ad5d2d07bfab6f806ffec5cfe8a6472adc7aed6b3fc043640327a7aae73417c33cdf8732ce6347982f099be3fe21623ce2be2517d8cd565201c85e597c6e9c0d4a49823c74d86daf2edb8a6ec33f9b99c34fae586d5a2ca83605da6601e885c9563b07f110a516686d3d667b43735fc6960d7778f25838e89444e3c3a76d0267d1bcf3caf574fe64fc34e7b848e9b65f2e11b6f9d02241b1c2d506897914c104d16c052dc13b07580d6453e993fece8914b033230593bac4b7e2796ebafcf44bf43cc44cbc64483bf68e56c8a62903266af1f4630e44827aa47791dcaa8614309fa2abef7970b66d13438c6e2fc895d1293fe53adf8e6bbcfb4eae47d298caa7370a01b90e6065388ffb2ff9e602eb48e3d6468444dfc521b3444ec1018702264ac85434021c6911cf7c53a1b51de7d37851cb67a3d9979d1e21b1539c74cedafaf56e0f737e66282b41aab63369a1ef00bd61367b4c2bdfdd10ca6f17f0678e3240293f9804b3c1fdd5198d94258c916da4048ba74453eec7efddf6beeb8a89fbedc96e6e5e3168b9d6ae4e4697628613bc41cd747c54254eecff892c5daf10d437c2d0a83204223e1bda6dec9cea3741320a5d0081dd38c59407ad464eebb1aa89ab0d90d080614231041b898ea10cc73bfae99a3b21d74435d90e3269e8ea5656adef56ec160906eb81e11ed2e19181f06acd9257b31fd332d2d338b847d9a53ddbd53d6c58bae5e5b8b5b7ac5be1f03ef3a5fcc8076a778a3cac5d61bc0ff0127c0f3d391126c21b9fd6d5e640065ab726eb2598e745415d36a0c8e75964edcaa438065521b0e92384a459b8c4b5e3fbdded93293abb640de5923c35210b88dd7a7854ea2b12c45e917a86fd656ef18b2ed336110d2d00c74f317e9a8f17348110816a251a96e656cd0891d1659c21f9adf2416d0b8a609f130b7ad408c4edee3b52a990cf8eb3f81316606b377c1e06ebfc9fb1d42f4562234e1a483cd8105b41df028ac49a4f1d428ec43c704c58e80bde4e8f322296c7ea466fad3f551a9146feaae0fa3ee57ccf72c2c591d3644f6bfa367559272f5a23b2f2f8b683e34db92cee1cdbf8a781a4b798261aa13bf2d30194191278ed2db8406c9dde514162940051af235998a4c97619a620273a1a7508ba67d0fcf21d4ebc3f02fac2fe971fbbe1b401e3dcfec5b21d2f036b007c2895ff9f25c29459828198a0aa842837894a1a5b90a82329da8f839a2a7a4140d79c2f22766b19e3eae1df466e81408c2b7fc7cf0b2fbb00c374629e1b6082ae464b786711925e8fd7d0008f2e9893f7c30cf337745a8c2a0e2029a3b78a3ef6e955641c161c9a63fa63f7c37e8363c9f88c9704c4ea92601941b8d0bf417f24ca84afb7973fd62cce9c203a770b7a6afd64060c353189435ae01ac5f645defcea0f8f14830fe198180725f1e0d388453219e579d513ef8e7213c73e8ad5f24a7c63777dd8ef4af5335c223f181aa36b7e209b650fb32227924b16a5dbcd4a175fd505d8578b8f725f7d0cc84eb7e274de42cecbd87cc5f90d2ef56932cf31945c0fc52d5ceff57fdbc686acc1fcdc2d3c13130cee818635a852dd07ce4ac5b9ec8ac01ab98a107c0fe327aecc9fdadd6e88661c922b3f9c74cf517411435ca22e8768d060cde9931d77c7c20d1fce7257ac6110eda8e1e0cf306a8bedac12e7e23f01f9619b5ad8f3a58d39d568d1361566eba974aecd4fa5fb5fca1e3874e79d82f986820ba435da9345c13814df8d2c18ff42c70850ae2d687a8ed8ad6badb19ec0eef61dd7e0b6c2250c49e613395ccd0de91927c30118879213115bf22844c59edc394d26107ebc58d28f9fa40108362d69ca561791a07862184f0fa642847fb6ed81b40dfb36a9d8f0057877529b87009d8f381245377d899fa598841853e3e0b908c4cbbfbf70b163c312f0594e3239ac20525e021d126f1e291adf21702997f0493145b2d48fd95eb122fc825fff9015f5143fc1f89da1f336f7a567b13c6df9370688b8ca5769a49e9642a19f406acf67cc9762978bc5dfb0414fba3c5809d228c9eb0ef60efaffb2e81af46d5ef309b87da5ec629e004a4a41ee8d674c15ce7d810abc6955a6e0d9ea5acd2585199a47f9d154889be2e9153d8dd7757aa75286d4f39e18228faefa963fa4c707d5fc8105d90a7c0b986dfab0b1be6c9f261274c192b6724c2c3ce645577944a7cd10b1288a24c6ffd458d8e3ae68945e9772a882ed0553d9c9fd8bb842c466e2475d2ee152327837e0b09a50296509c7265f23cfafdbe34121ea14b1776eb62425a1713d8cf94df16458b74fa00656533a3d59a439ca21d62a20c0becbbd42bad1ded56bae1afa460339db205bd37e62ee27b5d028cecb190dc8cd2f9c5c561d6008b0e4a3f38f33778b16bc2d262ef94c116257799bd5ed3d86ebcb0b91e807ad19e2d21617f92294a5bfef00efc37a386c73349e3267f0c6db948603a3ad84364f3b349717a26a992a39377cde5ecd773bdbcb2146a4b30bef1ef70da5a46b226cbf773b88c311e34e99667d2c83e71e27c9c1d361270ecea1a6fdef27a4745685fc947c67aa70366bf6d436d95cd806a392872e3b4d285c247fb35d61be19534322dd3fad3185cbffccd90985233ee56b03da1e398751eeeea44c0e5e0c953001ed22ea3744a34a0b6867162024d850b8b4224f05429256563aea51b343d7a4ae4d25e47557eb670a9a26ad6d53b5d2bf622488613b23db4674d2521544a98011a649a80867799710e53f006f47b07831c28a264c223dc4ada6caf10cb14e8d0a373e43f08d23d9b3b532b09a64663de837014f4f1a470d4171528e3f93876ea742789e7dcf8d16d27f25cdcefd3432f718afe0a5774f995b71987ad88784e9ac9b19b339cc72cb66d8334e9cc859d43e69ca67fab8fd032c07ef6ba14201a8d26c22509c76568ca1883f22e29a875ee47b4f04ccf9222d816197d31b0254470ec98d6cc67be6a2f8e0387c57c2af1a575203eb2e5811e11f247ec789424c98e0d7e022b33df9c50224e551dd99489be5ef208d61b160ccdc85c8d0e62275b6d96a0fb998152948e6cf5ea3cfaa5705608078d57898803fd9ff4ccb5450e06590948a6020eb9db49b48c86f1dd6ff883d1a347c42cdd522f3e22fa4dcd2128ccd22df83337b4f48f093a5c21c17bc144c614566ea7ce3ec69a7b394179e1e7611dc18f235d10b84f17b153312c15a01606cf3c56d15cd5259b82f32854647297c662ef2e1afc5c42906ef7a520b0a525e52e6fa5adeb9592739f1711aa3c05fc44df60d1d7c760958e283368b7b1fca954a7e11a8ac52695205708225527d9500c9c49c61e67761c5274448cf135a860ec5401de2a8ad79b51f58e0eeb453746d9bd5311efd7a18ad9682200b3f6d776e09308b18cea4a7a7474eaf8d8cec6aaad2139455aec8455713487e4dd538143ed43d0f9159ce224020975f3ca92d39cb4610e7e6e6cd91dbb35efef1d28d2e1fd322394f12f16c228179f8aabef9eff2b1e8f6f8c3c71766b5f9f572c475c7b3b167d02b95e808d2c7e789740e754365643714fcb92a4c8490efff92f8c33a8324457a18b46765e54c16a497711b6c9d595df1ed760f4eb3699ff6a0cae91ce23d06c74f1779074498dca31e8755d9f42bececf7021cecbdd002803870cb8b6b711cb190f56d916dc94521f10d08ba78e1becbdf430cd45495244d59a3f026af600b0dc36ca5040bfd41a3396f5b124a8824289ee880fa1d3f3ba2b2c45795131dec85452b09358f7841328503d57feecc0944f59592d573feedcdb7474527f48d112ae65504ec22f18b68383e71dc3cc2312865bc535ae236a47be457b265b26ca828bd346810477fd455d3d2aaf9ec868057f7792e54a194c008142fd78a122caeaf22117f2711f7401fb8e8ff2791db7d2cc3267db5d9a20515ed85008e10f60ded9ac6451e244427663a9a1a11f42e98c4a3e65aa06ab07d2020da4a9841ce6c99958f0b6acdffd9ce3ff2e742bac9049da1196fc659ecad09035cf9ba9eda64aa577465ea387d23df34c32221e9c0620ff1e540a4094b70c4be6b2bae901236cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
