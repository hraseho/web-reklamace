<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78479359218edf45200b83ee965e5f0f8124636a96fa87a980d4e64337d1171597da33a0dfe007b84a12969c5855356c97101838358364d4d07a9e7838728bfb72db17ef9c9712f0ac92b36ffd1a9bf3cf999466bc8bc10b11055f1e883e452a424410afa67d02a8c76fb719ad095fc0ac84c4113796ec12e6993cf1a926f9051bf8714c0ac0607182ba124d508c3391e02ab19bb4c574fce1953ac6837c3f5eab21387d65794a44b3ab28ecb898f01ed00bd4e17c20a8c143ee3bace889395add773c61f15184b8978f1ec9af26f54569ceff4ea199cdbedb5bde2024b1e1804cd266faba4526892bf3b54d5e96846a6bab02071f80ccd0934e1d8779aeaa074fd89d409627d147e49f622b2fb2f6b4c4a60ca16a69287f8a37c8342ff1d1d1195690fe7c37906e6cb866455c497ae2a261389636bd5561d5ab8ab4969f16399b4cd51ce249ef175af668e5112c7c1627b2a13ab8c80f4d474397070c8951144ca578d3beb6751557a4ad32f1f0b38aa6ae2951b76f9745665d405803524bb5e5d92e0d7f6b71806269c811da3de545db5f98d91f35c86afcc3d9b9848943f36725ab731a476e9a19ff5adacbf57a3229eba98f2be1cbab64169d60ab226f6a491e355f1db084ca110ab732076e64864104a5853ca33d4322b84f07b34b5adb59df7fb430ce22f4f0987b142fe09b3348f916e4be0021ddf23b1a3d1f2f0ecd8dc38ec684684be5a7e7d6ccc6ff97ada540b260b6a0b6ae1e8bd75110e2673ab33e5b877a3f1794ef0110120ce3b6a57ae5a0cfb67737136ef15e4f997c8f732d42bab6a9794aabfbcf37837d0f94a90dd47ba7f2b4524c663246c2d02df72ea73699d38fee5587cb9c2031fec594ae52227193771251449efe88605d08583a44c49377b345fc6f75ab8f6892227478aa668a39ba95c3b0436743c1f9bda2a17576c53adbfee5c97c70cbd730643e7e3ada8d90edea77f9ad76b1a604048403938367e4e07fe319ffc3aa8850190953227c1af8cf85658a0c77d255edd3b2b0ca6c9ba9e9d6ae595923dad5c42725e4c64e2c364dc8653c2e54de984f2b418ad987515f9341dd4422491c36c77dc16cc6b4ebad16b2782fa90e6028fc4b8b31c91588aec7910c7006213b7f307356589811a66198580460f209ed87e7b29feddb5e4c49a2f9e8efc905dfc66acb1b75e32468dc9bc04f0d080dbf67204cab194b76811d9ecb6e72e8a3e3dc061c68114b78ec49394b554348badf90411e13b49e1dac68924dcf3a17afa84e856918c3d6cf4a1bd53654a0d9d859b244ad6923edf51e1c2b37c3620c8673e06eb28c0766961cfb7c20c1fc36facb3c6d17a4bb1c16b94874479fd52e63956cd829acbc643580e82447e64ea13bb93a8a1dc3720a9bf773e6e1c806d6072fd059019d7de095e70190a7fad4b2c620d0f27462a06e8bca0b0c521fdc425b20b8bb708caeb3ef6cc05886743726f4dce882ec639b5c4eed0f8e0c99dc7618ee5bf46a1482daf09606c85307532e974cec034dac70b7608605b19c892253b5ff0f414e0a0e6fb12e09e9bf3f680083dbadf4405ddd374433f80adb801f7b5aa2b7201cc45c82a5e30167d86a101cc8f340d8c7475b1bbdaaa084787b70d396d37e2c8a627ffa697b58c0261eb5fc798090e5a3504025464f6a8ec70fb6c90d372ecab8954ecf8a667232bec848663014f1289d71267583cc904b2e02508794502bc8d7296537e42884207dd72bc73d507b279ceb58606adf61d76d9c0436d55f692635b2c9c3fa459c36ec3c98eada561653158281e5eeacb84584e47fadc8dddcfbcd539bb55f1b89f3559815a5a8e9536c03a9411250db2a7cef8ad5b7e2246b465cde9ffa35ce541563f51679cd7a1990f70d3854027bdb836f4173f0950ff9b1b529fd8d0f9e788cc8152e9a35bbb2f8d8e3047a70296c402cd83f5fad38ee3383b76ef7a22b9a9773e55759816d5bb90da0ba3c777b19b6a81fd1ff112273856fdd250e685b0c6f9568d8dbff226750aaca60a50e75d0e12c795e28711e0824b7b673952176cd7265545af6bbf11481ce7589c26cf6d757a6746397782c603938f87c0fac0da5d48af601686a5d5bc4576830a03f5f95164ede6f9a48c512632d45ae15b351bd08e498dea9d44294c6cc130fe9b502ea6da3ab1bedbcc4c73b26155ff3a3f9f1bbf02fd114e993eef3ebe71e7d663454317b0067b7a7ec61249fdc9e5b438f201be7121c15a6dfc7d1ef20b420a3ba06a16496455bc5d42c8c4f847595fdd57af93a847c5f1288003ccf321951b08cff1e63f7b0b7dae70a556b4d1b7eae100019c3779074737ddccfbf89c6d43ada9c3606f633d8e880622dd9c3a2955e83e4521d99f7a2197bc07ec1bf383a97a91e4698c8442ac391d745488a85a6ddb3079427ebc58cf9c45c91a2fc2ef7a4f1a40a606f1d97fc3fcd45da419d49b18f60f79a2bf00555870701c785e8a60717f17109e77999890a5348ca2cec59a92e22f01ffcdd89a8567975ef1f597f9f122c23b705da15558e2b095b31b065fec4d11d98499732cd6869d96b62601aec9a97a8cc7ff0038b7af429e8b3ce96d43947bcd070b667e8ee93a565e0ab8d60e2287fa99b8c6178537dff42348e6c840f3b4daabcde26fa26c91386e6ffca5e8b472c65716d00bde10b93ef8431e58b08cdf2732368170efe902d88f73067a12fce6bd291dc90d3973c524b6116811344cb4a926c556e11b5d1a1df9444556957f4db0a0bcdd25a9d6d86e3e617517e80ab0ddd502a7c2ffe32b4f0e546162e6bb3e16a58ef7aa34cfe4eef1745c9ec2518d9320baad888e29964616199a295d1d32c57aaf7152a70c36bd0e1147555e9911e9722b031545106551e9b4138e87d7ad7a02e5ad4f0cede805e852f117dd2f9537940c8761488a33b5c7ad74a8bc6078b32d45a435a0b678659bf41391998e9497f17221480ddfdd56a07587475383f1bf51e56822776e146e7eb5c3422bd5741d27221f24bb4bc1863bbb49d5e511ac4f2299f92d174557665b075fa06585c45db07c354033052e153346b6ce35935546f191568c6832b1d81185869c5fa6bc57a26eeb3d855f5306c1fd0fa816ac94a6656c3ae46f7aec0a28e358a3b592fbcb6d6b0cf52826d473cd608defce9b542410ec1166e391a98f0e19f04e306432f48396a71559969b56fbb417c87e417757acedf3746ab1fe9cc683b73064492010c2a922b0187d84e1f190e06cf321d38a3db0e19fad5f35ddd6ef02db198e24fe1653799a04b9d0d956c58e7b0bc1ea60c8b11f7bde37cc270d545df35b2dd77a0fa445e085debfe835de56aa63bb17e5437ad452ceab14bdaafe40b9452490613b6f3e91f57dda1dcd07df8cfc79ce3d0d056f3a8f4a2f344ce2118027399d5104f043fe702878177e2c3bf8e4bc81cb0830198d9bbfb650b6ed24f065f7e212f5aa2e2321b23b592f1539752fb25b62fd555dc49a7e7bfcb60ecc6307b2cc8f325ae019f47b38ba73ef9f19573ff15107c8c06ba8b323360b1d7b673a76a0f0c3820d36600ff029f30b3fa39d6799e7cf50fac711ed9469c9451f154f5b39a996303d19d1c4135e1dba1f456591fba618adfe9c78b4f5ead15c59cec71e251228a0feef3d8598921ec7eeff70765dfe8af8d7d4fc4cc251a40483d7bf84f7e8e7db4271f9b302c8858c7e4ce520df64e92b867980793c1a8bd99a51d21634f1a4a45636d53e66a4a3fb246b00c3667e3dc9a4be670cf64abe317965233bf2f5eec117d8b832f3c45d156ec464c5cd9a7dba70cf84aaaf45899e264d3b9549aff58b9e088bb063406ffc3e49cde9c0c2acb02362995a8ca84b0a9ba49be645a87c75af557d78cc67f7d5b94af96f7aa184cb8234be90fda8453370e126e6336e4a9b7b54a042d910d6e2a8fe99db6a0f6797886fa1758a60303214a01f70586a11faca26553b9d9ecd3875e70cf228a918eb49ea7dcbc56c2202a20811521624d4b5e625f9ced2a09bbed39c4da5b0932fdf1b5da311cd62e79a7ceae2828af729764e9ae859185725ef8a3b8f6748aaff93f0f652177a569830802e1244b0fa06ab7f309526138fe99dc2903a8af97417f5197e1eed5c8fc9e2c483aaf055ec00d2263b160a42bcdd3fc1ce545b7db61623e59e679d2525bcfbe4f78a0622011d7b31d0cb3b20263cae6828a6ec2c9191f4d8b78844237ae973dd8aa47e51bb1275f8d11788a1a814e3b6d054d9fbb83ff490f5bfbec14fe30b30f275ed556bf034fd9f654eb2683ce9ed1707fea6953622e92aa74bda4755e65eafda42dc33ca90b513af55cac8c9329304ccbccd1f1106432b910347bcce417b098eb67f2540db5b3859b1fc86918ddd4522aebc7514cd8fcdfa16e6b21b14c7903f85454438f9045aa8cde519e22cf7822889061d754648617dbe112eae00790737dc2c566207857fcc1468aa5e5e71457220e9b743fef915737e47c26ec6b002541aab2fb96b84faa563537ec1e836ee88a0025f72cf87f0cbbd296df09c4e6f98ba84e592d7c430bb705f677badc50a6590a0268ebdbf364b1d09fc0ab963946541b32682c35dcd4fd9b7fdd2a589a04c2bfb98827b6068e5b61b9f322b777a6a3bd060300bcb83a38761cda8395b478ce73dd569f6a5ddb70695ea590150b1deb579a0871cf12f9d428d377b0bfaaa3ef57c9eb5eac4945830bfed1f16a31c9eb170016605825a935cc160c09e00144f69f8a851aaef72e1d50adc7acce3786adf41ef5ab0c83aca96743303f4c87031141626e57399f5c22e8ab2feaa82d864630c42caaa690e55b6abe5b2795628a6aa9ef75191c4a53692e3921a8f537ea126c60911a51fcab48b576434c642a1a16b2f427f5ffa9c349c801a9199f0be170c79e73011c41b76685d8344708086f1b9f039d4d4bf474e7d8e6fb826ee253b997adf55c0031be623c6863b172a2dbd152d9ee1471ed01c9860cbb8d792962edb1fe10bda8c1a325fd0b0e3ec2aed4007b08e0f9ad93c82c2f1f9e6cae38f426a48954070968162c89fd858fb03bc44e893debfb8287bf1faaa95067c7af1fe073631581884369066af9b889b77d90ca05d21cece69915d07cc904333adb37a65bfa7e9c8db07393c7a19c26bee99974dd435eae0877bbf0df270a5e4b19a272039877ce403fb0b8aba4340ba9f007d3d8f7438450d9eb3ab4da56664470cf7dc906005a3b503d5a19347d923325e56fcb58778be9f01ae067701bcaa1172416e2fc18ffb0cd179dff29bad04521a6d1c99723b4403e29a19cc1ec4ee86773c9f009baf484cbeaaaeac390c500a9aa955cdde42babfbada6771ecce4e85cf01f1b78268c2c759ddeae2f000cde5a6ba8c6002154a48665b23154763ed619cc27674d70a2bc629449072e7b3e0bf75c098c6c0a489ef3b2d6a8449271043f0c69c8ee9948670fd91ffe94a03c781b27cf858661207d947e9893832ef04b9a6ddaa2b7c3280a63620fb65a91cfc01baf4a94e9458dfe60948a836cc042f265aa34f2e60eebdc5221156ba5072d96f49647d8a1b37dc3b127b9d097fda3b7a6f1282e5f578e0d002c114af3ea6c1eb2b4e8fd58f0ac3e9bb467b11960148682be8942b33c778077db71c401ecb76f4865d6387592ecc74e064fe6482e1589c4ab966d7a6ad2362e9f2df3252cf411017b9b49d247c6c4a6a70d544fd3eed294701f680e2c4fc481f3c5cfa102c0c8ed0f03bfca9c7ba034c9345a4aa7377b73b05c815813bb3d4d2b835dde9fd956c2abd580e1d5a1ba141a0c9196294f03ca3263b15a514c686cc953731fca7e41643fa8bcc6e3a4794c4153eee62a94adf3cd6438b17f7ab550bf9dbc6cc8a7f8973c9ba9c9955bcf17f2792b55f477ff59472c507e625bfb187606ca11712f721422d406093471c0a8eaea000d121ee5db095a86a02187d65a55c5c6dfc24925e045b79c1318871b7d93fafe8a5b6d85affb6edd001fd4cae57eb36ba068541d851053bf0e0c6913b7147471a7c0f77cfa9a5c735477b39cca90b1833f8fbe42498ca7d383b93ad4069b988b5c9fbac0415c0f41176c2229f532c784e4b67e2c0dbfa006d53cb68608a737eb54db76e15cba48c25dd4c50da83e1faf72abf5b9705654cb509a61f55aa1f1bd21f7c433c2b7c254a2ae797c98fbc896d6e7150ba2d3ffcbc226bc6e1c0c959db1bf5151bf638cbb0b834054d19b0b17034baed470b870d89928559829832284e92611d4cc200a3a7102b88e7d20d9e32d495bd4d42f61fa34a3c235f45d480a8e28ea3a13291a179bcc68de108afe03f0bc27fc0e0d238cd5c58f7832d66da2a73637b805a8bc27c92515229dfee61b6a7e6564a71d67a46e656e060eac0af6fcedcfcd07b3247b2b8528c15eea9c603a652c28ae3bd5a73e8047750be37e2dda2d12bff18a51569721df37905507ada53d8888cb60f28d2ab45f16d7f34912f73b7ccac8cad7554c030a531643bd2dce0e0add92da7597904a7e149c6f22a7820b4aae1adc30b89f367e6ba114ee875ebac041a61ade82b0a1848b4e38aa13c2b609c28624af51f549f8626096b22af3a9f5b3edb2cf2380b42f96bab0b6d5490cf6684b0928e9e62cabcc0d6d97c421bda98ac10f885e75ef8c447c5ffa7ede0b56a8ea77bc199f06bb6e84c587e83eb9667771238d3c99b7b9bd06b13427e963806fa03acb104650672c9adefa24bc6b04687c9a95743f0be7e63ca228f15437a13f907fdc21d508cbe171f882352c6e5fda6dd2aac346be71b29a49d9060a526ebb8b416095900ea4c7ca8895ed486e4a2c6ee289fd818e583f29854c44406678738b09e6d90e333a1e4e2bc50857612ed3748b60c28eec7b6db6f7fb9d8ab2b3bdafa8e3a087aa08180474ec412b6aac331d4c94cf412f7a764b4873ee699d0052dacdf33ac8cf5dafac4496847224efd830092fa2d5be26679477ad2e9fc87785c69ccdab72a41d14fd7d7a662fa8df966adb6918b0392e6e4d69db5558c2f6fc5ddd40a3ff38a9ffe18826d660f39065d09d167d682438a70df7d53fd5a348d8f916cbfb509d67c103543a05f70bd4d26d1edb66d217f7e332eec7a399fbd75db0b5a03ab8a5779823db56e8244aa89b67bc86d61fd5d3c5c6626c68e25a304ed6f5c6d2906aa40ba3fc602a8d097e56e2fc1c365dbf3e656c8113111134de34340419d61615c389c8982f755c18e104991dfeb9d44a5064cb7927e69f15a1c3b6e71b828747f3d07c5bd7662b5b4aa1f378cad94e6b4c5dfd1b3e4ef5c115cb95051537e657494e7446b75442f9d6d779529ba07ed86b0470368c7eec706cec3991f55e227c5a84323f264e66a89ec76957bf9e17db5509504fbfc341f1a448cf94a66fc358dc850d9555176b3d0b8d5e0f1ccf4e3e42155efd5e3472b955c3b4a620b96c6c5b94bb2e1efc099a3383d1e79f9bf44c8dbd0081fd88bed941ef5bd1996c39fdba34774373446fc5949765a2eb892ea48a438dea1ec811d0dc690aac1a39e4533852b56ade6f8aedf65f38e39fea1e9c207ca5d6182193335d08c83f09140c6d0721d99aa7dca7fbced58004874b8309c57e41cee1a8a142d72f74b93b8dabb7ff1308f31beacebc2c5934f9667fd2637ed70b242a72b126a6bc8f303bb66874f49064c2e8e6d86a0b3e8143495f02e77320e5bab63d6a814f95fd46e8a8aa8df7e997073a22d9cacc2a9918863fd0c96619a6ab53ac61eeea64a25375f0a516f62a02b66d59ba446a3d0c7b74258250968be486f27317feaa6ab616910f782b25e5d1c8d40ae8e7ec068054cfa138d9b1bb87faa01e73df1d0235835e4504591f02c3d332c76ec00a1d53d1dbf00e9ebc93e58f2da50da0b8c41cff41ffd0b5ac45513881f08c3fc64b8122eec51a651860d47c28c6b6149132b20c2f0246380880b37fd9f71ec3e9c4e167f4c36fad2f5ac8ebef5b7e977b13c7c47f96b8eeb3def6041c9b2d40eccc761c292b9672ebb5e78019943899ed9f3b4aac2fc6d9ee93d8860bf1830037cc634e379784fd5c7e5d0beafe6b5ed75fb4843473da378acf640269186e0324ce95216529d16bca701e16fff16a7867bc5ab9606e4a46d58e027107c237322dce398a9bf8d3a6a809c8eafcd55e0271a24c87fa99fa6163e0739523f360bd5d7b03f0505318f7bfb55c4466d181a238bd1f6c5bda2f583b18c8e29f70b6477fb5be577d0f3db5c4ab5c451329eb238da5cf121b04c51d8b1410382e764a0d39759d9993bff3ef66e65096d75bdd17fc92e5c2c6e1d5349550ef156a471cbdce8fd328e39bef7e8f1638d90f342413fabd78111314ded5abb33ca5f34d33604732f132840520cefd3cdcc5d31ce96e82ef5cc59e6404eb319b30be9ba70f6931b3b66cdcd3256161b15ab21aadb6f83b633e8b35561eb737994762d1a8a6d2d379c4e65a72014dace0181691fb00c52c537d6821d6bd465650789be9293bfbc3ed70f13d5058825455809698a3b658ecb7c93ee3f897bd1312fb2767e630ebc377363a897ee23dcc41accd2cc39b562a213b0b9132ee07e6398a077fb6066ce5c067ce4925aabd44a488826221ed2d1283c014c0b8e9034b7e8747df2afe36ec9af9a26510a0c89936821094bbe1781030c5deaf20d804402eb1909492b7a157918fc9890c0718c215f0f099843a38f2c5e7da06598b9f16cb70742b273d66283f0b4f4f4754376fa5d43ba2b1e133a3ea2bf7459db0f8ce348a8b0e5e01b966f0591df10c2b558f3b10331d232092bd6a5f93dc47829bd77882147b618045df4cae27fffb56cd1024fb9009a20953d39639bfea573f12b7f035f20605db6656f6496875d84ce7d163f2fbf87d769f57e9954bc6c12208fc8ec6928fa116082441e56d92998ca18217851689309e7c287f0b471a108a8acfaf92fbbe3a860a2e625210576f0e0d6c8a4ec4c752a00137aa2a90671c7ac5f146f06830a4eeea956ed367afc9d724e4d49e96da600b966c07030c7fbf1bae2f9a38452f0d0012add8ea9630bdf6b9f4657a1b8163ac93ca4857edcdff727c0e4cd276ea6db0828fa765ab3a9e195ea88b54056feba0804622273f92c2b81c067eab2cae1e54dd6975bc0331962068dd04019476cea28f83b76c505512097837ea7105ff7706c079ad13bb74f49b71b77e1ab18259b0f810cf1a987691a7b1902caa0a529f53bbcaec45f2f04f7961de1b8c81c7a8aec011dc00ea2be3e3d56a096ff549b82e14527a1ee7e00e10894070a48e3870c0be17b984303ed1d11c9f310d4386a98583148578423f8f9fe8929408f5a5c14e972e52c349ed6583adcce5c23b34c19c893fae6c971f5923e40dc76f5cf514fff519d6ce6b0728d672b40a4445d2ae2db30d7f5a3aa035cd7411038ea8ac6df80709c3180de9d8b1d7ae319be328cb94191bcf0f82b3af7cab7749b20bd1cf92af72f1384cde9db389119befdf568ce2fa953d2fd2e201fee5822553411dbb153452dbdc568914cc40d78f582932cdbd19c8a21db6074197eb704da68e1010bc1fa6795b6ea463c50d84df4b2f638d36e67a4c6a3bd738f5ceff9f95302d1bc5f5b1533d6fec1304f0d20b5051b1ec0b5a3a88d3f213eeeb40f249ff6dd244e205446028280e10c340e7db46c14ed0b999ae4fdbb52c3cc95d0b25b0c25db0fa6e292baa67686a8be73baa8866b2e60b94f9b305065130b69ea53c558c634d9197407219a0de433de78a14c4330e1b56dc89f24a0daa3e2bf12364ff523949ef100c153f1f554cfa296b9ba9daecc5dc144544b06be36aaefa52136c5dd095c093f055629a4e090a50b96bb5f82759e9b76233196c66c40eb894dbf3e6f1214b1bb3f00bcd0adfdacb98baf08bfa0c4338cd5c374d7944bb0189c92a6f6a8b4e0127e2224bbe8e115ad9ec949933ab0c084d32e71938d2dd79bf3bddb650de260781daee6385b7e187889620dadad47ce92491f030f9ae8b4d4d208dba4811352d2ff7503f8ac104e9c8007e04c1e0019d49f47c3948ae88570419d2878dff36faa3ea5d7025fe6558dbad21db8365b5199e585fbf83a17d28397b09fc086834ec1307fdd3f1c554668a700d6cc522a6d063493c1be3491809a96de5cf5079039a53241f4049aeeedeaa15d3ba95f937724526caded15c7f56a03c1bc1d66a5a5096e6f19eda017d66726ab98e9fa8378d1d227a3cc6681279c3755a5b373a830387074b193271874790af2418bbd70e9954ebc724dddfa593a4eea5b8012e02f2952467c9b8eff4b17129a966c49b07c70016e3b82ce5df2f3a5703d1c1380577d171cf6e9e3d8a94bfb889850b6d919db97cb081b996734e1b643c9dcb7dc435be904d2beda4db3f45b84267349acf52cc87ceec2e6406b78d4dfe358b2fa0e08e43fa5134f106809bb4eb7040dd114b15b9cc9b7526e7db2f50e8ba99920be759e401ca9857cc5210fb374eda088a50da32fa64bf19675e578d0a4573ccd3b3191658857517365cd76a081360ebbcda52fce38ae70e342d2dd41382d8b2686c8ea0826d1d04159f411601b5198f6a4b6c9be749bbfce9a534bac06b9ce9c74bcece9498e9688d0b55b62b220a5bf1e993facab5ceba66f5e5d508a762e1e95b6f9470ca0e1b4111517d08a91645b8623c84fabfe5fca4fe90819ae731f5e335f6b838e74e95a3a94ed1fd904050d95d762e43728ddc53aaaa0d2abccad929cc4089e7248ab534b2c65cb5f13a042ce451c9d2b1a43473d40ae075d4ab88ee305581230f5836d8a81cc6109935204ded7507bb80d2b4c90e2db7ba51f68c506d7bd23e191fb26de69f64ab16b1ad9a639139feed6a160364928e4b4f6c50329f89122b1f5cc2234326b35100542ad53f33e45002773abc0b3883cde1454b119150a41557da62ec0ce6c83e4f9c4bdb4dfa4d188a7d971f867c792891029687cf2e5c6843909ffa8ad5e25d4f05320d7faeb83b03af8b5a3853341c162c29a9a7205728178899e34e999388f5aeed21f9e2ebd412c880355fd99e2e9a24d588558045540d9ba945c02f514a5a23a65310f3cdb1d6dede529f4ba1bde420360f79634b2931de06120ebe9c0d167a30766d4820809c3adda229b457633813dacd2e4d105b93f627c6d52bc509368278e0acda9b97f684cfd03ccce093a5737446710e1446ea6648cf622ac4ff9be002473fc9db54bb85e14110049bf43d236e00829b613134cb2fd8d7ddd2ecefa4035c09f06cebf2999d70bd39cf2e653a5b757c09fcf51c6bec0b14a398411b524cc78a5e814f49f89346e31798608293dec77565c151e11537a5067bcbc6ef3e8f7a407782582faa2e8e3b6e83b6595b66d20c565d3cbacb7e6403d712b6f2e46f84e1c73e12c84d0190ede544455f0abd206c723329e9d9da395ab5f57be4fc899e092e4c85ef8ca7951fca687f394973e657e57580a5757ee19321c68fa0dd5e49316cb55a67c2707f59e07cfc56bac127b73b5f7aa6cf4cf998e272941363170ece18c1558daf4c863ecd0b5e591a623a5b4b2d7bddb0a8cb4bd2d530cfb97d074ec5d2c5052125858f79734a411b823669e82ae8dd5a86a679c4a87d7c18dbb7b2d3089c9ba0e1528fe9ed00f3782394540147b36abb209b3d9af0960a5202cfb9591e83706eb06f882bc559a1c6f2f031e72f0b9d571b7072dd5c7948c44c81522bc92d53ec9766baae21a998c15303305c9d21ec3cadf29de170bb7e659085f671fb8f6e77d44eb063074293a689db3ea37fc6487cf73caa299d868685d0e7c4994ef33933cc68d854a3230fbc688d3da48daa0662d01ba7622e76bacd89654104d997575661d19452569c6fbb349181e9331e5e8660d341524614124d06e12eb8ce4fa184fbde0aa3db6f5919acf4c9fcf8ada8283b5bad593c6368b7feb2e5c5a0ae40a0877396179a912da830af66123a345c58ca2c9386855c50d8f950e65c5dd7043f829b2c274d6dfa03e8e25f76ffddd5174895177e8f89efa72acd661e34046d4c1a9d0bda529a4917ade4052460dd56e342590296f24a2ba5e41950d4a21a1f6741bfdd425a50152580851f42f695915951848cdbeb8aa9b6a3a801a2d69327c0fd67766f2f14d3dee5233e269f373051844540b8306b5be358a7799d7990bf3a4f4aa2d93ba630e20e6640f499bd85ee05307ed28703e629b090584108e5a24609720006d8463ed692fe25b8fe99ce50e9e4a58e17035703dee188f6e5dd6c7456d8297522b1c096bcf117e99d3e7836883ccd4546a8c4dc2871653d64ef98a963a6c88ea50da18921d2a0e3ec699461b509e7838ed11f4ec593a8f32bd1d44fc27e4e19f81fe59d01e314055b4abd4495ff499e5430236aac89b24021df9b15a5b8893e2edf63fe79c2791de834ea2039803d801aa3ece4466c7c4018f33315bee4edea5e04134a05b9756b2424905bdd4b441d0d873817349557c4b7ba94922d90fa6937e75080f24e78b39d39ca69c710e29cacda55bc55a3237ee08efa54dbf05a511cbd47f7d7a5417684f625b7e6c6e19804cffc5e7239ba4ec2164d2c749ada6435de4427b8552d64f5d11e8fbe5456fb3c12c7cbaf19cd79a7c7f7306533576fa21eb2825d9fe86c960fe80a69be6788f62a7e26a5524792be405f02d9dc92bf808b96948bd3fa8a2c4485c68a84b67279c133b45b3a1a39d3c5ae47546033f23ddbf7ec5118de74056b500cf184e31d35515476a49cf7412b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
