<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6386ae80ea35053479c5fc6aee78c704bdfcd98c6aa6389f321b1ee6a9f78925363d7095524e722bb007deee1e1d455544656d5c55caa698cbf5003d461a3098e020b2a8a1ce2209794737ffaf664a387fc205d56c7e6b08a2fab049c474bbaa97206339a1a5529a123c38bef4b2621f1ae08499e305f2f4c3f9ee11946347289c5107ba28f4cc8c19c96bbc4e76f115faca93e7ad2a50823fc8ce4c64aafe9961b56634ab0a6675081be2476dc6fe99c3d56e1a6540dedba533c0e1a6d1d00633d502a9a852c1db956dffbf8364b7a0943c32075a788372b3f94c848c2befd6de061778df5c7dfae3476a0897c91eaf1b7ca296f8909b73a33120939a2893713ed64b9ab85c0dc8ca3cb9be6251d0c23a7f0c38875e84276e5990d77a68b3cda38797d759f8ab6293c5cedfc5e877ffae613ebcf10c8b5e6df75cfe913308a3cde8c5faa99522cfe3365996ab5b6c300a3d9762606498f1d1a5bb8ac821e4d6635931de558babae3d37ad874b62631ffe1d79db53d95f83930349bf0f20cf99f0106e7e54719db385b8291d886dc01d59d77f470a3fa6d36d36fb0c76c3ba576c13d0f0f75a8065f0fd7480f0aa025aeada7901665f05d85734409fe6bf76f1a505dddb9cb8c1d585988a3dcd1fc54793199ea103e3ebf7838bb39509f0f0c6688ff8288f2e7e78e0d83bd9d45c7fc662e902a7116f35294d3b9b106be7d02574d71b60b1f1c2c18bb31544e7605fd505c2d86bc41ece2d0354d501638a403ac813e4f26984f18dcb0210bdb9b485e4be7f69f7fdf3c72ca12784ae18477dabd4e806be72b9756a37bbe13e1be2710b89eee2ea02a6d286f90126928f37a9e1423133c54ec1a24b6bc0e6f2095d37dd053163400bc997e69a49d4d1cba885187ae7423ce6a8ca38da13b66236b4c93c63c3edab7ab1fb392e3b93a0757e8868596d9030bfff73ab5b79078e46877d93a99604b56af22564bdc353eee642e7e84f9724624c722d77feacd439d8fbc066d0101bf1d35ecddaef679f49e1ad226846dc7a043d7d11e4b9bd9fb4433f081708f33a644c8d816d390f40824f6df47a9473c2ce1825114a2e84de20d9396fe74e8d76c62a42fd5065aa777619f9a6c846b7da8569a47fc159bb7df25b5f77a183303ee699e1a5ff04c574236874e3bc22e0c2712f9c2d11e3cd4b92924c9ec248b698e3088619e725c7fa19206877873499a0dd5a69114020919cf9de8e3e2c69fbf3f30072b300c0788c3a06c9acb07c01b742086127107196206644c7aaf4c8dc928bd54c7cbe75adbe5427656dd676b391b436c308b489530c21169fabf8deb0c46c9aaa9b21e6762363f6a090d12310af1e786d5394f8c1ddb0a5397300eab09c27997e7e224990ada4c8f2757a0bcff41d991004a36b0219ee277b7808bcb7a5679b3695147b61f3a6fee2fda36f6ee36e814a501d63462bb1edcd23f161ea872b64732114f7fece81d90bdc84df7b2c627d3be5088f1581e176264f70a9f35ae1d811b64286ac68ff2eb0581f4584278840099629e1aeb57b83dd60d8d03a197ff303f5a7f6ebde55e6611800e5154a433ed048a0553d4d5ef2dfe1b829eb030c220db0db08447c5b0d830226b525e0598b61c15a7c8b2b785125fbbda5ab0f6ba8f809c2cea433c98947924718b8eafc113748ed524235f5cbeb7d5269de40c955518bb571ffeee7df7e2d439f79cd2fe129463638216a46dc49ad4998c5b48fcc4f716893d6edb8e745cd53ece2d5ca8aaad69cf9c8388fa6b7846491c49cf2f0e4902ab216c742577f75e3e6bdcc182fb70eaaeb719bec1a93e1f18e30a41ee03a215cb9afb55ba96eee12f49dacd9d7d8565dff8e0d6ff9680461d5fd6fecef867632702cf2c9c7c5cd4a9c6e7c75bf74ac0e3e6d271124bbf980a07c7c3021fb532ae4bf10285d20fb7aae5347682814bd753e568f55d402f51d226a8930be499dc6d3859bb1fa33fd41cc465b2bd10787d454c70ab87780cbc22cde25582819fab5403be8b4f1a4b9a8d7645cde0442a6ed9be1ab0ad9ea83c6874eafd40b530ad1d0b996802ebef8a8a47454fb35262e5c40d6afabb7331ccf5c6bfd23e5bfca0a785bf3fdf87db08effd209bd6a206a3d7331847cc919cdaac9314e532471ef48462a0c394328f5793c5948c16bfd4915e42fbe9a5cf98018ec60534e6206ed2ccad77b477cd7729eb83fdb0b4ae19f212eb62cc47054403124b5e8b67d288607ddbe33b2dab57645515e51fbd308c29be07b76fcac0374bc72a2aece0106d1f9bfbba77ea70ce8318aa20ab3e39a93b4b75bd5a5630ceea8942509487a3fb0ae47d59fed1c8a839540643e22417bac3daee407c5848823df88a85a1a42f141ef31abb3baba69edaa63e9d7af06b8bfef8dcffff0b072084c2aa8ebbacf4394abcb20239303d1d83181489d7d670a8eaffb5d6eba422df1cefbd72a0cb7e18003c3fef63346fd0d08cd57e99c773b53e54dcd4e12afef05443f339ed6e40e6309b3d6bf52ecb249f0f6523328854c1fbe5901893d73d47733737226406c617b85c84eb1a07bfda19d337dc62732915a29348037d84175b8e0544dc26388b6b1003c318617103e290b29b5c0c0d9d059bfec935ef421e4de5b29ee19566f50bac95130511c108673a0dd7e0a75c6e854a0981fc8f8a411a8ab7c6ebd93a45cf74885815fff6c08b7230722d0121a673ade0bb2ea0cac9e79d4ffe8a404cf4aa063746b17c51bb3e13b5bc110b11c8ba12a68224d0633034366432ead5f184cc718046833df01d538d82baffc10659d3e95c4eb78673095eb2eb217caa9607b37b950a4ab8cbac446cd410f73f875437a30e75aa2eadf399d1b792b19f35a5c5be60a65310069013afcf1f2dd085d17a2d3e8f3201433c27d2733a49ff03823ab19741037d763f18056ef364c3647c08f6eebc8f191011b6ba20647e4d40ff9f2db30bbdf790369d195997e6c4a3ad339cb10ed2107b3ed8222c82cf8236a8a8cc2a0cb80a848b55a04ca9d0d0b89bffc50f0331172d624a83575e3338899979deb3ca33cdb74b3c555da6b692bd86555b0f78531ce6179c9ed3b2ff0ab92abf2023f21a9921d52d8bd7a037b75423c1b67ee01d9f6ac27ffe745b755b37570bca30c35f1a49e464ecb52a475931d9f3e06f4f59b823dd259c480d5bbfcd41472777bb92fdb158e51d7f46cd111ab8cb7a7bba63b5ff9e4316d90b8725e754b2cafb708e653d59b6e5f7888914b91b05371951cb3767333ff162954a69d1c0c45bca4ebafefbfa7fe9b7aa56542bf4001a5fbb9c1842fb0c169d2c2d3befb98f1e39cff278de540a1dcd45e4c1387256200bbeba54aad5da5fa62d9c31b6aa450248d3803da089a1c064e7d64506e01d1bd509a6967fce6b6a764bcc7b3d91b7a54f84ed4062f2723b8595b05ddbb644a3e8a45435755daa1d24a93e401245e01ffac90459e9d8501b10f324825c232f28ae6cc392ce9bc0c6ee81426df14f5877837d5824ca9d0b32d5a27eb1742afbb25daa689c1bb9f933be623be13c3f7e1034146ba208a22d8f6e78401c1209fa3d50facf98ebd41becfd750aeeb2c0458b9db0cffc89e51eb63c6e26cb18a74f993b4514c026e3633150090e914a0f8a6dc685ce8714df0e725931c0ca79d792a9f9c6b8e731a8e89f66ef10c9ec008c70f0597bc7fa951c2a2866a8b3164d23d4f60a6ecdc10fdf1ec2658c54572de74408656d6051f62f49814f29e00b3804082d0b46f865e0bf086bbc32d54145d003378d08b5a9096b6629cd6bf7108579e15c5e752f9a86f7db7ac9b0c00b4d9f5d86baa3c3f13356ad2b427d8d0f921fd7b631e721d0de3f879ba4cd9203b96eccfdee4c401986a53cd3e16a4461f140da66b2498363f2cecbde4bd2d718ba928b17afefcdf8013455a0fbebceb4b33c08f4e12015e57a71c79607f2ba88e6194da780fe6ccdafc857482c3828688960c949fc30a3acbfb5db9c390779d577698342b787a7c04914693da2388bf8302b83d593426c066f20ada4783e00df3b8d228b5ed16e1fa60a9226e4ab8d33361358114461e7743d871008af6f5ea12c0bdb0eed128d85d6a90c779fd545bae3d1841b457b8bb58f9f029058ef451fba416b280064503117e9ffecfb7c176b5b43ec94db155c7908cc707f7b9235a09bd79733c8e46a447a131f251662b1ceee101dfc7aba65e5bc89bd7bc7e0f5ddf5a37083fd2c1bf06892e209af60d67b62330ce8d0e2606dfad84252f441c1bfc06980555db5ebbbf56cb4645b55508395325287149f558d7bddf684ea34b294dbd534d9203a16556d920480b1583cf64ea8b1811e20ce8cbc1f84947c68829bc9251f64972d40eb07f5790e8ee6ba87cc8977cf022d0e6829a9bc2cdef24f642a61c69af359234038f5ca920653ca2b85cdfea87db0392e16b35c8f13d413f5629c1698c983aef1079fc92acab452508017bb4ebc432afd3a37b852c1e9de83656571f4182c405e8736de90efc0c167d3e5a09afee3370ffa3f06bde426c82ecc1477fc8675299e83238ba6bb6532d7228497924a692dcf71ea268963f2007d203fda34ade6eb17b6651961a6d2382f924d6b799ff6ac3cbb63f6f7cc31a127dc4ac118804f637826745a08c9e188cb12b2687f3118a06e5083e78c01b8b0ee5caca7653608ef2e42a8ef20cab0c6162dd2d5cf0c46bbeb71a9707ca13df14a9e7982b86982e8c5021f030d5878baffcdd28e11cbfad092e7066fc998895921a856cba3d78e480c6febcbb830f736a8f5352847d64ea67428cdc731df2696c286f23c98c7c3d9a8584528f3f8ba0019f5536a4702b8f598a1f9e0c123428e4718e22f4a8852173ab5c7faac40e03669397cd907f966e6aa61bff49296ddbff81460dd475a96b6d5d2755927595bb48f6400bf46097bc6809a3cefafc6535661808f7a8bcdf04816b370d8aaeca73e5c8f69424b6f255da8d205ba0f4904ddf7d66ec779b037a3edcec1413f41646db11acc82b735fa52e7a9c3059d03c3ceee2a75febdb22df2d683fdf7ce1ba03d43c4f427378d8c4c85d04f48a3104d416b90f1436a06d04b1aee4698199f77cd903b1079aa3a675293932ea87ea1649d4b47a72472c2fc7186fedbffd79cd1dfa6b58ec9a3042f771be3c81319c21ecf19611fd5a2ba396bc97637f0cc419d1addce6c87e86c7a31803637e14cf0665824e8d4d15368bc6554f7f377dd8981787c8dfbd650e8c4f92082c57a1218d111c67ab6e8ed8bbf1241208136084a6b45a0ed3cd77ef563fab615fde7e6079d240407b760d08417480a6ccd89db04fc70a46ba10a5ea20572654b43e029d2c5a739a0b5b47762960f319d59807f01ed01d4e075089c964cba6082603e2e6ce932b0ea8a66dd56d3a894e61f2c11dd090939f170c06a62b09014b1f21e09d7d709423d67700ce746001287fd07b3e8c2078e68a01254264dd5cd57ba2c30af26c3a9beb05e9c8ce6a8957a6beaad245ca45a1b8a2bbf64c7377f6a15419012d605be6e23cc25f221ccdb23d5e1d5bdd7ffc0c261c9769b01bb8a3eed1a9bcbb58578a93e84db4e3419b5cd647c72bbce1d1cef3a02fb3b437a1101f36ad58fbc641f2950468b11660f1c0d4b12a22762823906be3be2b33db5dbde1e0c3e9a7a77670c16780c544e42d8d5c54ab340da809b7f66af1792c4d00df5f784298f5db05f65f7da298180fa1fa80b0c71809e35b49ad73f5be9372e4e5ca127fd85d5f6a9bb5a22d9c93a58ff69b3206888d37c0323bc7769906998adfc3b7692dc5c5c0037c27a088aa57a202c705429701c930afb46dafa2261787445031cce37e280db02b7be13e25a90655dd261278420d9a5e940faa349b4d2222ad6da4a9e4f2f4f40f2a7e0a2f62ab1fa74ea5041efd6c6207d8c8501f0b0ec147a5ab01b2148b807b765b690024020cb8f2cc37dde02141932f7dbedc7cc6985fe968c86bdbf75dca8339c2e9b85d02f2a3f3005b4994fc24e95f15055c8566397aaad0b00e0f4c38134c68a0ae6a0ea3aa3f97ccca8c0715f4686e3cbc598115d605ccdb9c75d2742cf2d1c7c8248235820040f7786a9858f8d8df1d9dfb27d65c1242b51cddcf69a1d70821b7fc2e2a3ff6825b39cbdfd2e5db7289ad5e3891246ef1bcd14f35430ed83b8ae60d4601d511690dee926e7e22e143c76bba61e53805c04c0fbd17f740b4561e2ea76bacf6fb46dc6e431f3c5f86cdbbc111c27767c3ca1e4296da977b380d45de37c3faf70aa9fbbc1e9c76daae3c07ccd7e64f8bc09820aa7fb329c03a722a4248946998b7b28feb4a0730d9781283bebd5630d223ba3d6f8bf0aae790f5c996a8d447139f454982ae225c5f112a7ab089de69566426b40adde8695a23cbb823cd3775abe4cc7b09ec5c7d264a82d3581315ad2abdc07ad16911ea28a6ef1dc6d29c83b1f0a88224d0b967eb6c3e4ca242dc03483fb869b1a4ea1b0b525873e67ad11f216bf8e107523ecc141497996076794f61675dda1d5a5d7199f43da88d8cdcbb3af8e7d72c5b8dd5de2986fa5614743ef892cda5745f6ab338035c6d799fae3a54949db5f436a13f513b6deed9ed2eb68e6656aa0802c387ec7f305326157db131ae7cdc071f646565d2dc9a88d281e427150fe141be1c8dcfa40c4a910ce676779f62196fdf9b00c619846e3599761cd8d9d91bf9182d083ae018385ddfadf55f7c926f999fec562cab21d2dfa0bbcc723ccd9c3c9ae132adac79cdc6ab12224dd3a231516a03162983bb29742a16f8a43fddcb3612579a8dd89ae948ef09f57a2c5f4b76cee66783cb6c582405378ea7ea7316c178b5be319db5132d03dbfe60f9547b1a69c21d455cd908abeafee7f8eaa6a49748c26ae750ab9b0e5efd0040cc9bf300e259194755fd25f396664cad20147f611b57518d46ab91641d05515fe7ce6108321e199f3dde87d90b075b5d9d6b20e168fa24dcbe3fbe89e1829cf210ed26b111f69f592280ed3b4f54c2039f81521fade36ee56bf338d8b9783f216387587de4a6db2aa46686f44db0a2e25cc3e6d59b183c97fb57de0389a06865b853d410d5de82fcab0d9cd76da82763ad06476d3ac2c8464de6fd58cd102cc9d83c6fa8bfcff5998128ce862ed1a9fda67f4c647124fa8332d2ba4f127dfbd8defedc6cd73b5c3c6266bb373fe7815848344dd2431ccc7441c1a01751e41dbb2525adee67f438fe97c64956fb936cc1d9665a47df646f1eec074e8a6c38ef689cb50b5f8122fce7a4ce567052225b1c2e8e243d6415be12f29a31d3aa0d7f702e2ed3631202255ed0239db414c9dd88f77de17671474ced8a378b7fd15606ee19930b3ddcc94f35a981423bc4efdaa011659cad498ebd0f142049718a952a915481b83c414002c282a8cf82f0dcaa72cbfeac49f165e9a0f64c9a61ae13fd3a6e727f9c93e934fd27662fca4a2a2ca96bc169e24f6943eec224b9ec0a7b11b51c2d3c70d69bee2b22a45734c8c48fe51f06b7547f246419359d4231270feaa7f60c0ac586e0bcf747884089a76adcde0cd174b1811324338f6e3015aac06cc542e8c4c254a4d8cde1659a971bb531a7d6805b85c8a96a86c46562a7a426fbd42a254df41d8e9f747b819021e0cb3553431785822f545218109169b25f3fdb3c510f2095664d853961d24d3c620ac9354cc03761db74e4ed5f2dc4824f4af62408a7f609f407e30ce00568613416a8ed42e59a82abc0a0ea6889f24855c9d2e733dfff2e21af0a7b8783276301621cebe978045a58c400ce5b556d9d55f714f2ebfa41cc2201854c3e84b574c42b195e8fe566f2950a5f31674f4f48f6f3aa25b8085e76ba7dfcd524dbd6b9519faff79bfcef78201ebcc76a1bef8f178dc9390e80220e2fb7510e712320b15c52bb17409e38caa82e33817a71321c2c901718a8ce45321e923cf453e22f3c2d99339a5a187795966af4e9e790154ea65f83b84afd24972a801ee93c6caa2d864faf0ed117de289a3ba888f14b18c87f4cc4693173ad7ee8bd578502f02729c994c0d29351345548ed4773a66e108f5eb067d30a0244120c82f6c152032f56086143c00aa9df7ee7166aaaf1f97f785d55c0a3978e9ab42450905a8b2d97b9218d37f70613d7525f135bccbcae7e9c847312b6986d5b736624d224882d1bb0c0c44a7908c4439858a00107715e28b29e8d42087eaeb55c51c55d05b854f8b22cf11200107a502b0cf9ed7784872782cdaaf9e569d207ae1ae6d55609ce8d468f9c00079372580f742a2009415799693ba6e578a0c79ddf0c3f2a1982427342ddf689761dab76ddf4803862b32fb02f2e10f7ef32be8cb6b8dfbfc1fcf4ece82ea5b0150d8ae90f78f5b71189a6fa00f1da3e5dbdc6892b1ceb5a04de72f8343957d9e010c4509a9d35935e6ef29364cf8503bc579593d0104e104454541d18688480e643c6afc67bc174edb59dd87fc844b2aa6304e773ea78d81a4935df6dea7d4cb21a0e342cf75bb5c0289d667018883f30d65044f5f71372a792fdbf21a239957d885ec9b1f9117d2b0df3887125229c82be69372897622a854090a638d31d10ba3aaee26312d58c61c5d1cf2abddfec7fa0c0de6061a505945d0ee2acb85c08552304c4e4beffdeb3e2d449f6b9c4ac4d632758eba1f5f437943eac2108886bb0328165063caa2a92d38eb0c6e80f9a20a4c1dff403ae4be0b073fd33846420e1ea4f4d725049d95eef7749235d87d1b6d8b8bdd15c58f8a43bcc26d31f3453ca2d89133d5e3e7afcfc4589cfa74a1c48167fd4f70d8a9bdb926596339ceee128a6a8127e01f85345aaeb667f7f5fc4aedd42c94a1f392d735a708ff76007b974c650e4e9ad4da0f2e65647cb4ee10b89f1f41f59b7b5c4330f8246069424fa3ca45b40275e5d0cfba93b1ac83aa0aca35409cebdc1e020c2b9e628cb60b888e9228dbb132449c770241cad478d5af75f90410d81e222d10b768b54e2531628545fd338d5d0c43a83d26d809d7f59ad649aed556cc62ded508b3d6170b1327e77e2d4b577ccb3345c244bff773a3e0bb03f9e6e71073b37165bee2ecd5000b0371386e254fd42080a45ed6f65703e7af54fd95213cfa32e85278d338b4d1ea6fd9e3bdafec0664913fc796b3249b39f0bedaa7d3034de1dbe41b43c9fd4fe302e1c596e0db27ef9e75b380f820b385a3f8b65e453703d0c7497809bbd5a026c5d08d45edee3f98892b4be995d1a6a33b176422b1386f2870814b6667a66e874bbb6c03a9cf93ffe60c7c97a7a31314ea9c1428eb50a3a3fd95654a6901178e5fba34804f9f3cb5d9c8a790d656862fc8ba7798d7a8f3bd8dea48f94abc63ef395d3fb108334bde09a31c49e7b6fdf0a74fb7faca5d781ee16e9a3f6d9e5e415ecdc73b543c36c2f24ea6999d5dcea5084f865d63f7adba264a998661a27e749dfa924e82b5117b8800c9b5fad70177a260bad5278d605c091c304306558385233011055080bd92682a16243a00a321f858892a2288a44321b14f5bbefc8b5965baa301aa35890af118c3e393c2841f6e35383a3a0c88d1bd43062788624af76d5494e9a839fd0fc596fb8dcb799c8de8a1b53804d43b505ad5b0f5a5b4d8edb07797e09cdd9ccdfbf7c2bf82dea2a55ff4488e01471e5404fd5532149ef2a3ac040257cc4784054f5ea83dde3add869b6c8aa94e81c1ba90a2b696be49a4d2fbc310a339616bfe964f5514facc523ad976530d1fb3926e567fb03743c1e742ddbcdf12cc40a14b0d2684e6178ffeee26aaa18bf9a4cb19d941cbea0cd812034c58fe0cbcbeccb3d33063f4c33251bb3d6864170bfb2c1a1006bd7785e34a09437471db1018c982eab3c26b082b2f8081287a614f570567857879a508cb94a1849090a0aa7db3776592fe611ca3dca1588de223450d022d9d4b38eff073cba8243ed98e3af5c93f11a7f7067bca55ce5f785c2fd0b29c9d57dc3522c6203d6a291b7166a4435f86354a5fc18277084a2e1507e6246b6871410881a1fea0739c901f6ab37193555b3339174809a7d27425761ac6360e465f6b6a473cd08b22f46642b4632a4e4a5c61eb742803e1dec0a60ec84e650819d92f0c4c14f14e71f9689478165c85021ae63617f8752207c120d267973384144221e5c3970cd82d32d1611","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
