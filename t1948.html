<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"86ff4ecc466e2fff1a23a4a07fc049d144e9c3bf3239b040be7af8a0a4bd16c5e4bc785e91a037259e610b5cb2310a90b97f8c21ddcd3190bdddbe92e0868402e106970fea56360f73b8d85193434ae9472ecec552a919739632adfd15db47ea7f3860fc95a0392c5b0b529cc21f8be044ec73b4934674feebbdf49c2a3c4ddcca12fdaa5c0873300810109588ce1fe813c594495b13aa9376856f0d938728f4f710040be5c3929c516bc49fe638ce6a2fcc6865cfaaaa0ac07d0b9f9337368639f8b6b986eef4a645ea9229b7987e22465c051b7d1e289728f39f02551dbe2b20788250337c9eb46d2aeddb988484e945fc615578cb9f802f763aa88e8874ecc9105b3cfa947b7b229e7d1a22a94650fecec6773fa1227771ba768d19666eb5f09d0001eb6472320d26d1711e48fb8129e2a42d900f5717f6921984ca54b4dd4cb9be48154ec8fd6739ca19149ceff122badee269af814fcb60c0893625d1d8003ac8f55512cd612dc7b6a6a47564b0b9cd045c452b0434a8961a44ab744a8297490f8b108623be8b315544fa15055c3224a4dfe3de112fa1df707fa3e2a5f95852139936f6d86c7662e95fde0d28c14817757c5e579d55146209a523c9bc4648a4993ca2e0a6c60f2c150a40f04d4972946e45627ad3d4dbfbd489fd94a173a7e5be1f2ebbf7f763e1b78f30b662b15bcaf707b59e518dd1f5a2ddef1038554c3da6eaf63e299e9130ab4901ac328b93a5850b8a20681b38cabdbcea2c58639873f756a6a3211a51ff0cca59120ecfe97de86a1036efe83344cbebd6a96c4eb94985fafbd04b10331085bb0e97b829c1be781a167926815a2760ce87674a3f8e0a0a57b3813dec74f399146153cc1125ef1ddebc9b022550d645397cfbf5be640541e52963827a6651da9a39ec25772c0287866c1a887a61a27bac18b6f162eff2e5c4d9a2328653d0e8b70214fd005b09712cd2e86b903ecffca4fdaba7b09f1301dfe48e92119b9786d7be65996e417ec14ee122ae645366b59a18c889ebc512ab0801379819fe92ec9aac3ccd093ff5c1f488cf454da5204ff68bbee2da3e4c3702b452daa9bc043c38f943474474c4ba280e23b324af44af7d07ab108373843d02a02c3979700eafb7e88c1ffabf2a026db272b1cbdcc82c43e2ff3a00211c7cd0c6d088716e7290d6cc8384a4fc0b76198103e21c41ada35f29c75d19ae30feda1acc8c3ab7067ce453e9b0ab382dabae8735c06cb4ab493911cf3cb7119724918714d2aff34339a3e195126a1f525fe1d32c692a0dcaa345b1b4d0b04342d0aab2a592e34977f55efc6b99a4ea4ade6a5f2085691c32bfcde516b73d8b0d7ab99d6e503759bd4ec728b15b147433c88aeac84487a1382763cad17d563260e2a02ee5e747a8bbcb6483fc902ee9c2adfdc94f6970d78dcd95d007440a25b426a84ad90bef91c2823e45602658fe09f7e94947a68dfec96cd1a024c2d316d168482e6245bd49323250173da97d288da2ac2ad8d3e7ab93756a9a58ccd8e823f3c29a5c776b72afb15b844b636b6f709cad97a32aac6806fbea1e5bb5222ad331d6bf89e1e863405bc0a320efd867137fdeff2f8925852c7de8c8282b9a62978a1e75c8300ffa0ae8a93a6c79a4b099d3e5351550b379c4082b54bff4ecf59c68752ee81ac9f31c57fb6cd17c041c9cf44a413a9d54692f788f4e7bff4e4645f31433a9997535a996d44a4efa8d69e7ea89a7470b9b7d09ca189885246e3bd684e9759d00314b4bf9abbd14cb572dbd72fe47ea9cedb9fc2d76b4dbcc2374b3864135144f6f563d36e86894ce642d281373d878a04900af122e5263badf0977ef22359e2cb78394d98d8c176bcd71804b6d55ff377536bd0007eb34c1cb7d0304177fb1d347396cf053efaa1d933f0397e67ae183abc17817e33c9c976be0a077d19750e4a3fc00286f19591efc6afffc7f9925dfc56849d3ccee5b9968abf8e259d30d4e7a21c0f9cad40cb1a7ec8ec70b2dd682bac36842b7de737636bf838bda67a9ab833600ad20c0dc9ba17d19ee3091f8f57214825c36fa2fee59618947da3e72897f372dbe87ca53450ae0ccbca131f45748582467394516f5a45fb631239021b7c79792556c8e21d66f5cfb40460947aee1f9586d1f40725fc9a1a00c01489d9004748fcdd9c1b1c7e4b290c2cad0da48ce70cb4585bd2f3c393ad290e3131762665bc5594c350a319e4f43a2fe7a7d4e0be57e0a9b8ae4bf9c8c0db514c437948aa20e8ea1cd97fdc58c24768167c85d90236a7bdc30852bd618296a738c1338f1271c0d6c88125bb6bd3fe19f19db4e84ef1d0be734fa92a108fe59af0bc6a6f3433362198222ecd52c89694ee2db51bfe3b8fd7f3a6e80a6787c1c83b0200400f208a9634d17eba8c401ea6b0f6d2f74a0fef464aeb00749f68f9234d691ee9ec2ecdc41af30f2d330f7f34e9dea5f3d7a7e5ac016c5f917d18d5731a6518bb55dbb3305466985394085ff5da7ef8988a70844502b3dda856998c119864597e8b6cb8f250b1d71c30673ee19029a3a7d13b9cdcd85709dbd1bcdeb1371eeb602e1f9b66a9564bb8b6d1a7718729de0b037addf7586aad71db33850489443400a945e3f67ffb228c5870ebc18e37edc3c15d7e4322d7394f5e67dd5219d3bd4bf7bb5046ebdb040adf73fc53e166d9d6dbdff40fcb0a882f81de92740242e3c86ff580f60eb78204de71a4edd05fd5f57e5d7a84b9ca8b292aefe2f232318d064b2ba8392ca614cf12790382782b2fc7ded7f849b1eac245cb42fee7de603a148d906d198320e816b23cde84c0b89c9a9724e5bb3f36ce17e5f69aa1cd93ca60c450009554fff3bd18d1c63f10ece68550b80e034ddf51bd0a1994283ae2c64f108095ddce5caffc0100a4357a44e3c317ee307f032027f6d75710a083e414e390ed862d97e3e38a507d1d38f7bbfcbf98bf66099c52d24e895e5aad7d4eeb3a3140314e61f39bc715aef8567d95aeb77c8b72512add974510a6119be694de47e1c9466b7437aab2cdf3b267538f0bbd49ae7d8696833be390e10afc130f85f423c15c247b4e4b2e5395a44d3aea07efe0b1664ce7be7d9f151cd535499348b1401a712705ad6dbd576f328061a009f81b1d1db6e5c7c37d501b6fcf7cc5b3eed931e38c314e8bf23ffe16efd245db97aa87e084756ba411cde3a70051f44be9fc19a55908f7667dc021dfbcf0ff39d457347c0b681ab0110496fc9384bcbf1a1b58cc3b5b62785313ace696d53e6e1b3ca0a8a72b1240b53e399524151191d1fc6215e771dc85887431ef5a8bcea320a2f57db9a085978851c15cbfa42c90f5537a242e3c04952757ee90e95892761acf0957c7aa3d7d96f23e3079a027f6785781ecf208e8beab435162a7c23d3c02318ef02d984ee684e56d36f5c1bcdac4af0ed74e52e119f5ebcf73fe49ce2974958914a7806e3a875d8e0f4c1a7e8bf07572cc3472f628698f3ed3405f361bc449d0bc2fb60b112287696857545132e4e74c1cf523a00fa5f1fced663c5fced0109d2c49097a8528a5a19929b99a99a731b061369b6ec4efb7e42326cb540cb2c3cfeea02dc9ade64c3569190de376ffbbb3720e2db692879f57999fa994e8c98d907e7d0dcf69554df77ac7ab9959b33e0c9c7d3da35019b18ef10a690312fb75dbf82984d369c0a7cc44fc10fce802232fc3e716e7a0e11251d3c3bd0810ee67f2c6dd69e83d966ebc4634811c33805e68abcf8332c5f0fbd219a553e92a4a0dcb4c9840d5e2cfab58dd4ac33d2055603baec8f5de6ee944fe75a85dc785e7cdd34c0c42604122166cbdc936ce815e61b18d7efb45e74d00bbba6b53828c3f44f7a8ee4d4cb94105a4ef8ff39d857c12cbc6cbbf8a7dc18c5ffe9d78e4e463a9a4d7f7ec7606a688eee7d7521414f4cd52bd755e6c4e221d547e5a0cb8a7d220f3f6a84f64720f69d436025ae0001d4acf28b88727c410dfd17cff5bcfc82a9483b64e08d0ba7849fc829d3276583ce8676b2eb6bd43b4a387aa551a3cb20ff82628098bdf997622e34d684f325aa107f3c5c92a3dec71cce06dee3ab3b4c9af33e1f1061608f2db863637eee1487f5719c227bd14f7a7e797eb9135a69cb044c8de68cf130e5d610b6b2b966c7222bec82a296823d49ba940c32e004663da08885cce3a7d4fef84d1056b7c062276ca760ed2a6573d8f9260aa884bcf88020c0d8f20ebb744297d4bab7fddb84187d818c9614ba1938306f0275d1cc590e23ca3151fc49a67c9c0d6fbfa74cd8f8167d6c1790d5c693b667798777b9297b5d1e3c85ef13c8d9fba923157288c6b56114d25d8714174f5b3e9ab78359d513e9003206a9b28ce807022ec047f010f3406887d9e714cd64b78449ccb723c2cd86801be895aab278ab4c33231a71850557fbed1e156074c063bee66504fe09485b3cb3a650934cdb19c4c70776aa689e0ef576bcbad3c792970cd89984a42e3966c0ae0da3284153519aa3cd5c1203457915c4a84059bf77dac57d37e98c122da3acbf07c3df881d307b169a0c25add008f30a0a6c690b048d7b9e0afbf06e1418cf11caaba8c86d9083b4ae99044b84aca0609a5051e99762e1a3b520f94f39c02a455d687250332e35169ed790bb32460766092de218fe30b69ae5411ecd8fe830592831c563c68bda6de90c132eedc41e9503f678a3c6a2f232bb24c8587fa48ce87e5b92a9775d4d9d5f6309b3f66690af35dca232304cdccc706181ab34c49a12a2c008610a03f89dd1d1d4c2a1d83b7ccf1ceb40d49cb604425f37b2a88180fd7e14068f32046cec41f97b704973d75a7169871769231bc49a23385ca3264f42f1f319e503f5234bd71303b334763b0a9874886aa78b55d5df3919f1b4ad5b09ae6e7125f8a1ba371f9ee8ce9969fdd042009e84556219c9b0e8e1b2d4f8f6b3a7d4b98c1660c2b761d23f14486d77b3b55a63b89ded581ae8696f70d888bb88cd27aab3bb80bdeb50412f9fe2b54bc8695c5c64de8f78e20e93ff99be4403c9193a7635d299e5c2e9038582d69c2b47d008cc09b4bcdf289773157cbd2763957a5ae9c8b1a1e18ea09f368d2ef9b2dc06396d45fbdc3987ff66f0ce4a22cc79493a917c9288ada1e24b30f9441e3afb045a53fe50b3571ccf209869d759d5fa25a0ac4163518fdd14d06027f59e86ccf4d835d0c434e9ebf0f70f4414b422e612de502946d38c5b5b7fcac75ac34680f7cabbbf0d45d69641f1c178707c579c37227ec7cb01784203e7adecd1b1644b13388cf415652b8ff853a1db4644126852233df28c4494914ca0e70cd6fd62dc29db893cdb1ba4b3cd1ed489ba3685f397dd8b23353bb1e5577e769c7d08d92a428f428f889cb20e91c383a213255476094e3f8c8d7da31fb0d30ae8203745459127b1179912eab079bd348a10ad78e0524288535e12076a909b884ce78e0f37fe4c5896d7191d9ab47d75c85d899176c0ec3408c9d4c20c3f46de92903b3ca8514466498a8daf14e9baed68abbab823e8991d76f68b2a75b922b787f492cda1571a61299429d53d81f291ab7d28b4923b037fa75f3b395a265d53ca6dc5ce3a4174e4bd0922c53411533336e766e0f75bc1aec6f98cd77c4c02f1a347e73c500b85c834f4fb7423d7db4a8a9bae59e0a22579676408fe5d6496448d63aa0ff13855a79162aefc00b4072a3d46844d3c30d3ed81afbdc7d96620bc6628f17f46c5d1ed77db5759a3c80fe3a2305f4952eaf03d8d69a42a6d9e208f4130a8272b4346150942434acef1eb8960f428079888af876fe1f62d8347cfb48633031836a8447c47e4dc5a0dbd8f0c88d5aeaaf19dada2331ec7fe90691c8fbfc4dfa9fbef3a4828f349604799ed167fc8d947bb09198db8d09c7fe5028f4b01445c1b2e895aecc2b17cf48ec53b5eabbf7c7aac83e364bab3346545ece5402a77b3bb45869cd4c4be682b96601b45184b3597c0bf425b17f1da7a79b2f2a5843942f068c375267b1050ca449bafd0b121a0e98e57acdcc698ecb99ea1c58761bcca1f077349384b2b8ca1c0fb9a9c1bbab243a9e51931b294b567b900d3bb7b65b413be893f74901416d89804eb18ba1429bd44003ffd2340283fbcccc1a625de78ee3f33098bf25319b520757fb89fafe46e67ad40b74b9d6d3afc4b9edf87b03a95a5b850f138ea87425e78873fa5b4707b5bac0868c5b8c3fc5a857f24eb25231322c596468a6a4f375ca0b8db1e49ee090b607791934088ce78fe43a991574b12f870877a23a80758f033e31d4688907935dade0d8123f7371d0f08e13c67f7f4bcd68522744eb7ce5d49d7996bd743af170f772284f6d4a319b452988361bb7c7c39677575533d8edaa602187ab5b59e0032c17201b1782f52f79e68f1e075801372e4aba899ba3d0feeef10ebc3fd9089204da19096e37e3caffba2b8867ac93316a957205a374bee467b8dae3a892110f26e0e7d9695020eec0d5425e4ffd6494de8f5844a244cee492f314ea793c4f12670324213c27e38496f9c766993fc6b51bad4c65f49fe7d6da65f1759f0d344e437aacff0e153b5971fa48b25f3d70caacadf522cf4121e5a07841539874e61739c33b9914179ce29bef6d673aae30982f7fcb41bd9fee6c3bc3050ff234866c19b28d916895f49180f5d32251d2b6c1241e131decc6aa1bcfb5de038baa7d3c5ddedcffbad25a97968be12c4f69d45f3cc74b5281edc66b55d1379ce8003970600531b9ba505d25985277fc51a5f422934937567b2639cbfb66247d2f334ef27e18e73650e7365f398cf86997bcce6e3206e3b0ead602fbb12259e7ccb1eab29c809cee6c3488d1b4b49392af03676ca5c99076e7b9315b83cf36b5064f983d0ab887cfbb16b584c7882b54fe90d69a204fbbf9cb426657d4d695ec2c50a182a1aeb6fe5ee0dd7be5d67d4c99576d81e5fd4cb3a4280892e0f4d97e0215b1debaaf474126fc67f2b90ce746f5dd764b0a1a6f2e5aa4f3abb1880578fa3db8887405bb98f118b0015aab1f798486639c1929d029bba1b58c5b47ae3e7b14a68ccf5911850b0f384471bf70797950f0181ed549647353918c7d2cad234919ad4781274f375fe526a7a0907b84f6a9a7fe98068dc9d54ff95ac56c0336351d1d8c36d8cfabd884297416f8b12c9546debfefa5b1ee7f1a40420c7e359bab0a06124e3765583f8b9361770b9627a0fa935bfa9373b1bed938b95f7d4dab7f90428307011c7beaa2f4a6cf8a6f56afe60fc5168c51d0152c8b029888952fb5523cf01c44d23ff36ff39f5834799656a32d2c38344696dc34b038047bd618528f2a3096266eeab8fea8854962167f40de6066955278e6fb5bcf9098365c151655e85d42e497ce90e8057d0bc771404397f7f4a9ca0692638985adb3f9ab754e8ab1881655935719b6d95287668d39b8d85d1afdb9a9bd6ac74556945a7ca5f6d2b8b05f19bf950c0de7b4206af5d7783623e625e15bc55ea0b7637bb9bf44822d5f5de8de59b68435fe7bc38bffb3658f26e56b90513a780539a2e8325159e0e219a8c474c0d31fa965e7d4760dd5302502f8c8802301e959225492173727e1a991c49dc9247161786718067a8137a8628e34dcf6d48d1255fed5dcbfbaf7f3572ed9ac38dd2378822e2663a91317bc6d47a29bf88201e6fee77d3ea675e2247826ba2fe6e95b19582f9b05abb692c8fce4d2431f72f4ba6c1ec05ad5591bc0375724c08de5300097de5403d28bd200b843092c7546f3421fbb0bb742ef2ede8119dcdbedec13a53ad7889ad4e16fefbb365e7428587049b333ca184901a609d616549ffbfd350c17f6b586e34482314e173c1c870e29a7d60fbe176f15f0e7940d303263f2516733211880ace91613bc48c3250bdd5e66ed4a425d68bd0b45b14518dc501146a54e5e969ab1040ed4180eadbb296a0e76774fd15543387ba9c0f8820d4ad746278ee9520a826662e2f5a1c9f722682c4abe4f973f074e89b227bdd1b59ede4919e9e32af4a04ac48e959be985f2b3918e670c407279eb0c8206512e1eabaeccbe0f0b7ce9a28b5ec0638215924ecf887d2e1cee27ed1e4d559e476bbc10406fb1348264ee5551e1908eae9a5761ca4bd9341a517778c0294365596f13d97ce1f2e12e11239e9cbaf969350e353afff7ae3c971ec104dbfecf67421515b4899159cd901d45f544fff65d8497002ad49df745e643543d144228283ff3e06c2f057e745711d6bec7157d4178120d7591d39c8bf06201b95dfaa322be1d653571fd22dfb88b5423f6549058c0e4c93d5eebb963fc45cdd27bb557df13f86d71fede2ec9a1c40db6f6487150372dcb11c3dc5f68cdfb5cdee5d1194abcb4226406a3622e55ee1f6e71b074fdffad278fc116952997beff7d41feb60164cbe55aaf0c5be59d57fcad53dc7c0a4d6d68ac1add935486d20d7dbd196b79431aab8d23dfedc55ac575ced37057748b8d3712c06ad43f87128f86a06b3d6b28b1fd357eac07f967116149f6e5c51a60a399bf10afc76f113a88445a17fa929535577522e32cdac5f556a98bec52f9fd2c2a2bba1076ac2ce861fe1a4679f733beccaef9a90d5ffd4ebadf68efbcaa2aa97aa118493a352daf370770e0f97f7396a465cf35de35ee267bfe2e910b76ab5381a901ed3731fe2148a5013cd37a4a86ce0482ee835f4f0ec7ef54588a7e1d691ee5cbcf83cddb85997eab64a0fee06220f8d7f58f322e2de334bcb82602249b9f4e63bcd9868a54761154f71700261c0f741795068f5d9047d8bc6f2c71b52e6113b8dd988c6969a57047f6a298a4ceb93158d12ddfb8044c25ad7a0edcf7d5f09b2f7abbfbcbcaeb67831ac31d09416327baaf8d0260da304897ff19845eeb96558b02d03c531946f7ae0219e7a486be70e84cb71253aca756fd61e9f3259843dd3e4cb162629a58d5edd5d4460b6dc355c38a8d6ac578f8ab915be10445f2c8cfe42e17f749efce7c88d3a0e3da09c42a6327e6c8368293cfa541ebe6a428c6e7581d6db6305a05d6d6c17de612233bb85ac8eb17a3d8cc9240917779cd78a5b3691db51ef39f9fe1e1facd4e1dfc89725afd1e316b8231e68b52a0a5be3d396c91574857496167fbf62ea7d6fe05ad90e9aa33e1a7bd7de54d5af58a63e315e876d03ba24528a4fea29ef325e916efcdbd3fa6ec291c65b5d5c115517056b4e08dbeb220a6d8874f7fa35ede193e11e0d55671ea89b278902fa9d414ba7466a33fb1659682f05e636883c06e74d700b6df1a51a2c4712c6dd0d4706aaaabc8d855c946c1285396903b8171fd982914994fd7b51c51bdfd2553f2d4ea2343edc7b1fe82e1cf4b22bc0c612ff32616026ba28fb18c6771b26a542104de3d7fe4ea25a39c8cd6575c74d88083c1e9ad56cfcacb59873e9b825f383941288cf660659e0dcae2107a35848e347702ff8aa5b3ca188f1a02e7e12523e0d74fddfbbd6507b4faa79ef26f31d8cecd07081dff8274dcac5cd383be2bd34958a2f82d832645697e42896d1ac7bf5619becbada32fb0e1f2a02ddf13dd2a7f93aafec9de16ba6c8200a5717d795f990e78b966316eec5868ff1fe0ad6baeeb89bf3478a517dbc2338c19f628866b8f7a98b89263d79c87756798aa721d45be1aaeab4180f7266c77d0480c539727c38d0ef8d047c3025f33c08d7f163883fb39bb1b1b0fe1f6af18fa5c300c6889780d3716e8341bfee875a44edbcdca43d784bb45c082adfd2f7b66cddfda4a1c725d55240244c1fe281fd66d0966e301620b454df245ef434957a7fd2d25ec2510da4d1fdb44f11324a2b8b025b09e83a4ef778d0cac30e6246031c37bf5b63859548fbadaf3740b0a221af8c2578714b3f7f864cfcabcc9fd78953c2f6cb22ca37aeaad19d45c412301104f63349103098ee7e28e150d9c7744d8aad727cd4bc8623e41987e854d454096f4eae2316d3adcd5da3046e8c37be048ef398eeb5c60eac6828f42ee0522784","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
