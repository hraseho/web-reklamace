<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"256eb091d7245ab1621b6911668994f0b491b5062046ab8e9fa933ff29ad98fa978658012271b4427de09088d7f7cce0ec689b380fb35b31858304ce4eee3d64c2d1fc37b77d36e33ace46a9ed9f867bf389abb2f026b0b71403402cd06aeabdd86ef95f1ab10637a394019e0dd698b648723e26504a06f53fbe02e7f528943b43bc063a66240ea928803e180f9579d73f9d40296f70f99f9f061afccfc83be286a4051bc82ef78c9998727b859d43a96a038b50b30b86a8664e5ed9e21d832e9e3889b582488fc098036af0a999b53a66cac99efa874c22ecf076f7c9f296cf528f0963d419e66c77994152be382493e0672e58f2acc9a96e2c60e57c56e1053bfa43a1367151bf265fe895fea08cac07f1e3a80e05155de9b7c0b550b830f2800e5151265dd6d88012ead34c0cfa18cdacf93f8cd65720881e62b42bcb372d30d6723f0ba540a9dc5a7a9801bba20bbfdcddebb64ded33271a2f910e37bd3e8c59794a38653351942765142384d8ca49cbae8b943d836c08f453b3c8c403dd871c211ad03f4c243df54632d1c7de873ca88332e77272d2a9ecb8ad4e5df93ce16abcf5fa488385748bccb6ffeeed36dece376574e3e1d863eb4b78a662af540ef80f6f37e58d46a6a92f456b5a8ff3ab15cebdc004bd00c188dbe4ea7769eb35f24fa3f29b3ff6d06bce6a08f82e8bee571c559d366d4dff81c4e9c50386cc74b9d8e9239e0c09187969ef4fdfe772bd975533751459650a366c21fce9db3b342905b8e18dd2499987461ffeff40afe828778cf3e43a034dc728be201b1f3d6b8d78b228215a02de209ede5d18f440460c67bea8fb71fb1f49ec7935ab79bb1c87d758c0a71341dbe1802dfa1ed651dbad6200677ae10301b92c1905ace9a491e7eabe0e182907a6ba564caa7075e5e806ae9828f53bba3a6788c20c19ac69e302236d02db645ec37cf31b5f86362e35e1248df76651285e10f609fe4ebe7d1bb54cf586725e560a343b304dfc5ec9885615e39e3256185c68ead1ab6df8472d7eed642760b8e94e67a91d65351710d2045db0c465bae88cbf456e4ea37ecf1cdd3f662631e422b491e9df3bf042c64ea3050cca415a195625635df85977031b8c363e13f12050b9d538ca719f8417094e08c921c2c8107abaf4bb4ee9843fdbf41d0d26f173e80d1151a988f1a12df0ce72d419440fcc3726efebcb429137e37176556f2dc59dc754e5890877d3cf1d6eb3612524968f9deb20ebd67156b3f7e84d2e09323492bec426ac24c5884e0cf598e5e8418f83b8dfb1adbd9d10cccb6ec119b67633b85b6b5f610f327550149c032a8ddf4817ff747d58158a0787fb11e87a7706b7db8853251b245457c7d08512b556fd49c9bf33f09735c04082c01d4611cc237527e0883b100d344900027205138737b9630552509140841675037a7b1f59b9aee4e5de3c444beb96477be28eb9194d9b845dc290c7f1c90c13b5e2cd2d94abac2ac7be87ee23e64b2fd306cf85391a7a2988f2b126d1b2dbb3ce9e53dd509cb72a6ed4dc70125029b63e8334201eaca84ef0164921886598c3608ac55d23301a228abdf8011e0f4f10d29f6a00d622ccb5d9bb1083305543c1d896f628d79648acf422e8a2c519a16506c26adc6bbff3db72d8030e6157e03ed12c7f0ee6292c6d294857e471d84ba60894d6da44e712523bbccb550da40999739cabbc3e8e6fc50679e9213f7aec8f370c6fde9fd0e0995ccc2f03085eef249f39f02da9f29d8b7613e6fccd73e456d80ee33af8b9578088ff23a89c89ce0ca28a5e2274a4db15af93565506fa22081ab684952499e3905fa1c5d9b1ca5b047592fd0e8bb8ed6da370df0a46823344d43b9e75e927bfd84fbc018cec513e51b287145fb1becb9d0eb44f5798e4d23f3d5bc250be8c0108bd402362d8eccc1030bf81cd9db36c473d388898a5267d621eba249d696c227445756def0b293b0a0cafad9dffb997fa71752c28844d5e5bd73d8e3aa719c2f31489d3e8c178c19a430206895b247b955f2f1bd6ff819d6129311e0ba2fb09017a4ee6ba569669f857c8dfb4e468cd597c443905cdaaa4fe4751d44eee1490c15972ce2716efafa21a14d3ea763afaddc1d81d73e7d7d896aeb3d6b82ca7154a7fdfd407c02199d23db9ae40b2ec472adf4c369176cdbe5eb2d32ba90df9b87e78eda41d1d770b168749beb996a1ecd341c4b7bbd77b97bec6691375bb64e187144d8b2a875b9038edb766b19f457b3b63fef578d9a9bd379647756c73eabfd8463a698174e2aabceee05accb7413e554e03051a4997a480bd2021cf234d8410ee31ed1b3ac42df93cec251d17c5075e193b709d9de511e92eb121c8290734e4fada30f83967745df2a9fd97c1176bcc66f295de8fa7d76360e36a752cd267288eebac551ac3991eb196c491b64dbc28c0e05ed3e5ecd7f603d4f68652791ad3936f5b716089c4dccd3f1ed61aa0cbb2a0a41f84d1e6855bf41b6186569b5f44b0d3b65c5967ba00d4e736b9ba097fd18ebd465df11562a3fa63cab598882a74d861fc3cab4057df7764cc17c18c3841516c19d0abf645176a4d2ffe13ce8ba4fa84a8e0f58168cd4cdb1d23e35d3860c157bbd464f95bc8b22248138b8ff54c5c2f7ecb12cc58216c92282d27c5942b6bff311455287e00a4b5abd38b146d580049bac8578fc27a261b29616d94d242cbf9f1285c084df60ec2a26069fbe1cd34175ffdd42e91d89d9a9906ecbee95b243876c7031daac18dae5b209f17871f2fe38a34099076cdfaef186cb1180660dbbe19dc3b84b5647f4433222617086f4e202b83a6e26e7c3296c41f1e20011b2c88b0321500ba8423d0a5eea22ce321f761c8489ec71dcc2f57d0371ae7eb9d35b28c1d46d3438a6e80eb66b969625abe5ea7b577c34c129d39066a2e3b1fc01461afa467a87ca11e59a3ddb3b61ef79e8214e5ce643c3ce2102228fbc887f8bdd05783af335ba3cecdf55f32eb323710b473c6b1cb07c2db5366fbe180c0b631273f90194c1e4dcb7719c8809db76228ce1d08cbb2b8b26f8eca22f8d227afcfa5b5d11801d72a46326154c308472d91bddd9e9fdef6f257b6eb02646bdfe9459b22e24329f40f41b44554582cf7aab175d9a869bf5c69894a4fe8c97ba274266f35117e1239d27386e56a5ac19d2bb872eb527cff1d4be8cd43903f911457fef703199df31bab30ef9a455d949e11c5fcd20a0c48fb93a7f0c3592078a5813b59c7e1a6021c0d7d0914f27467b378920eae90062de89cf00b92e4da763dd1842854b0d28b5f69aa9b6f70ffb8e83ab8261ae33f69884d8809422d9fd8bcfa642ed0a130daf2009b45c170d59bf36620913e65c58d35170dfaf643ad9815d26b23c42a677034f6e16fbe9069ae18fdd315232eb888fac6edc3da433eb817ebc30ac1d14ab50dd981a13a86f5fb3eb359b4f29e5d1ce42e19af3001f7691616e874fba039cfe664c205d61bed1939268b5148be67099de27efc60f611770a77666044d0192426c3bbeb0ac70296e763024e89127c95aec10a31f90315f037054017340c0a0657f84b28402aadc9999d7ac6bb2ca321ad5dbe295ff0cb2372376f07d0e04d734a90d1bd9415ddac25bcdd6418ffc2d117161aba3c4503ebee2710d1bde02f967670f45956969e3575249f5dd375f5ce01dbf3c2c3e5b8fa66152bc05425edb3a2882e93f8f5a159d93a653b7a363165ce121d5407e5d7edbc49c51d351605114b950de9d78d492f0ee57249c1344ef3badce508e9cff05bebc9b4540193960ecf85f1faffeed99ba20c716661704e8f60104ab29742ad98b75a2e804492021c980eff74827f57484f3a0654102e63d777d240eb54c7790057adf36bc780ca0556249205f8607b26bb63a1a6a990b90d7ebe6df3c5d11eac10c1904c13ab3c801b33f2b00aa67934c387e5cbc18d993a360f5e2002b2b1628609d30bd0811678dc4a8a58bb20d0e22cc012f71ac4072817d3f6a19ed16e536a4c82f0caf341bd671ee53937e0784cda4d64ccde75f0853a09138964579a8f549ff45fc75ec4e0feae3bbef2c2a04319a156d8d2304e86fa8cfe505cfed307c0d421668710c85c24840bdc44b3e114a4f2f9fd4610868f4e899503b9fe13ba90436b309b46c77a44bfcd67ef0b56d28e3e6ea4a8d235d7d567e8432e742957f5e631da901256b4fdc933a49e710985d114b7a8da9216f3c6d5030dce6de2a995dc4cbca1e3360abd90cee275cf5cc1c56a740d0a3ab5261770a0bd06d2feca631985b0ede239ac39e73c201444ca66f38b4908ee5d7fed348f05be2aac4addc8c80aac7dfc8858b4bf9d66af4e20e547e85d9c7044a3d7e2fb355016235c850c55c0b40ad5068d0e4bb46054977fb5b1ea72029064b33b36678a9aa70ba5dfb5992f7ee17760cffb1d0bf239826300dbc61a355672028cb3ed152a859039d1233ff64bcf8b0a12ef12713a0ac49fc1aa12262c2ca9cdc664874109f43dc90b71ef34d8c5290afa3287b7d620534a1a1edaaee47bfb6d7d85f72bec9f9c514dc4a76d2708e43e8cd6ee4dcc739590b334371dedaab340eb80c263c529552742059191148bcbecb6a4ec20c890f974ee2da28ee3c5bf64ba630ce5adb3bf65af4334ef469a9c0abdbd96372892dba8aee9e9e516b58e66e4a27e41c1e6da21663876d265410e66fe6faf160998871d916f517689817fe3011bab62860d9b9dd135c343a9b54763e85453d042fe22e78daba9c14f58bc642423e70c00c6be3d8e2e73b5be2ab4c3084d316f347c836e4fac898ab40b30225d7ba5c76ad5835a5919bc514d5351610708ff0b4e7f8a8ec539a9fd54b385f7328c60335f9a43492d4e2704a55e841c8f661524a51d4d516ba19351530809816bd768c89f2876acff9d3c6b66ac3931b7ab547af47b3921de266a228bc88bc80b897cdce07d0a6e58addc705831a2e232736caa27ed8c884ee1ce47f776a10dd8779c10282d9a73dabd6e70dee4d70a92c9ec3189dc8aa544b2040346c31e83d974e04d190b553974273bc60424ac94ad378deb38f9e26ff00b9de200c53c89665e16a8c220406106d7f46fc47a316ef45b5232a27b17ade6bc91f3f498a622660f7a9363ef8679550ff3e08b43b157ce768d8ffaf43493d728ff08045e15cad9142f180dbdb31961656f899a65fd98a0b493ac8f138ccfa942988474218591ef8def5cdf0eeaf064bff8175d72d03fc956a8a54c1d14856e794afb1a2ae2d6c3954e1c01a610b938db9788ecbb675ce7b51cc24394226a4a428a20afae47d74268773eac38549c2aa1e5d94758e60b8ee746658dc84751e1292120bad1b6cf7d4bd84aa8f2db2166d5299e6c9ea83c4eb4f65fb4a89f869e52765715f057e24367abfd38ca65864b9420604dc63309546bdcd45443afb5d67b0be875b44f818482fd2e69a49bc504a67a15407d417c6f279965493be2f1c8f4421210dadbdb5df62487d1e6b9717c944fdf410fa87224c3b0074e0a328a8ab4b914bbf0105b14436b08d043d31a180480901ef8f23ddccc77950842cee043aee4e3da1e08736520bf3d90900d15c265617c7ce3ee308d959953ccc3c18c38ebcca6eb74baf74ed9005d9c977d5473265a7c3f66cd534ae6a23762ec6d76c07b4bdd33a883ad8bffc0d747ab428fa99ac038f857a68a519d2d05d0f3f6cc1f897b64faec2862cb22828a9f626efdd6435bb2b358026a766062bce1550766dd1ce9f8fe2d29a971c9b9c1e33950f55ed72027c0baa149b7e026f6fdca5ed02111e24ac0e77a42f38398d5914accc311a1b8020b2abb44004814f6a8a8772e182620320babe82e0fa3c12f3967c8cd98c24e7bdfd1c504d9404a354af6cf21f08963088c1a1cc1a8e6843d8456404de7f19087bb8bb1d5920833ef4d3196b2d4601136a6a31340b089fa957f2a5db94135e3b29a27af734649dab9c9be4204b905be366ea3f4de23d704137c5dd12c9c86cde2f11a57854323237cee9ece25e40ef44b4bd007d7d37937fa6493db9d85d513b166d824158720f46b05579b89845bc5d0bdb1b9c5cd503ddc08ba0fc5402f6a45cbf330460267343ec5bf54fd1de41f7c950298d7500945a3a0a8ec860e9e6ed108c0677cd16c24289705d519c109e0ef6387ba6e3c456533e5680ff09dca4831914d9f1d033a0394e7bc4fd10ff2d961b27094990ab63eda94f6ede9ce65e00e215e704f7163612c524b084ef26335aea0c2a7fd25c29c5bcd15fab16c653c64179c880c0640094ceb835cde1295ddc17209b9a13043979cfee7f6a0c4310e44c5e41a5f3a470547275269c177b0a437ce66cfa26e888a6abe0866dba35474905a9e595576d9c2b7b45c892c4e9287c14ccbe996b196e87022f195273f8cec0d63d48d8997a733199e5099b5fc88af73f4f5e62147d2daedb159ebf5113ebde3734d856483cb406cb4586c96115d9393580cd9c0fcc8120c531ba1993a3ee8afeffeb229cc3014c1e5faced260d06b1019751b1965f02d369c8b99f94f894f54469b916e35d8bfa5d0e10f1d4cac47f3eb6868ea7bf4c4cbf1ed4c0f2857e5becdb94362a7308d883a912ad6a61acd09114c4cd2dd8675adef89ae2d9829571aa045549c7d0bf3ef677941dfc9ed5649f2293ff6d74a940409fcfe8747838f563a29d67a913ebccf27ae466ea5855c597d8e8346a1ab93bff01793e47c6be36ac33fc7d6c1b8b99130e8c103bd55392f5efa68b55ea6d260dc710f4bcc1da8b608f8d106a4883e444d8d07aeeddd763e4102cc4b9f4dd14479babfc7afd0b0224e48287767853c19560fc2d2f6c578b0337abf4a21b741f5a389fe24dfba2d006e9afa77e564b6bada4c02a899c07e92ab0bdc80c56f5ef80188de58458c906cece833cd98fd1bddd0b8899e65d343b12c9e0372c5d860ec86e1e2bb7a5c03b3f6b1f28f02c8cc0439c2b900dd2fb57d3908ab0692dd7e7b3e66339bae84b74a0ef45f6f7d99ee30d39c9cc98245608dedfd7487a13236e610aaca92f9982bce7d2d06069141649d3360f3a150934cfe140a039a44c4b4b49c2cacbba4bf8b0ad5cee31722a50f16d3efb273e24c0abe33dedc32634e5e3244a291d838398666f2e2838b89509dae55ff7beb43835e722646429eb74b12059e4e9e70b228ae45665aefcbf04389dbd4de4d0f2023cc1ef4c0676a83b8aeaefe7a46fe1e0279bd8eeb75d678860b8920dd347b3c5a14fef132fa407553e8d10ee54399b7f44b91a98b7d5fe967a01032215449b9238b3540f1bbe7fae900f88096c731b7286717a007dd0e1a3b8cb608cc3b252111b2d009f15155f37137edd06855b7dd0bb859c1bc4698a337bb9168526f7ae58786e4ccf2be9c44baa77a56939f5edf0ac78400bc2e548c96c2b68325591795ff931a9366cdea254cc542879e15ac3d9cb6d0bd386afe5ab4e04c0bed9472d1217b2c71899264317577257f89e511440f531f17c5db52ecf692ef5176737d0709323094c54d28d56d5ab6b6eb4788239ccdeb366744d19c30ca460aa9b321f84b818a0ef40ff6d409325b62478f838e5b1dda4e7fe20ca7de98ac13b4fd0d606c9c66d910f38e36ea4521c65b039adb5110c974d7382bcaa9bfcdf913fcfee8086933fc18f666621b255ad976ec2d9a9247c780b1e609e2ec516f0be1025df64f4e9cd3c85614bb98ffe9b18463a205b0c045d75bcd2e5a89028fb343e650f0bd55ad283906f9de6d6dbbdba36454e4c41d76e9fce9a8c72ecb428946f1f654ac77b27d8dbb103b73b9433753feca79f68bf13e97d8b1c00fb175151365c042032afc5f4f4e3597a00710bf9e24dddefa0cec7bf9ee4ba29facdcabb2a1a307091d5d80e729698fca755b7ce784fdfd2e7989f39ac0d1dcd9bf3e14c5c577ad6c6e47ae81d5aa87815730dd41ec5fc3b1bd839cd019d2374096a22ac68b9a6816da23c2b22d5714c060b2d8d5c75de02a4bee1dd701682a51a6ee4b902d042951d62e6158dee97f71c9254c67feb34cded25e0da8820cf86614ab281bbe5359c2f3d176ab7b39d37406cb380ece7db336e4c3c738361e433bd279c644d7c0f8fbf296dcb8c6a30b4b5c4595f2bc954e83c64e555f49f18c092d72ab631ffff7069856511f288bf0bb3fbf29fd7fd642fb9fe43522ad704d2dc929c544b0c8891413d66d56911bf4332c35b7cc52e3ea5d415ab52c3f536b6487f7c8e1368b5c6103a8b2faa175b01813334ae2a50967ba22f482fb2d2fef4987e71fbdb20caab668ce69725ceefe0a08d81ca2b949340c7a5f43832453bff22d6bd9ea620c8d8a0f617017559c65feeba27a24ffd6c081e1310b55427b61629044b6163532c766f33c55f6ac3238ed973591574eb453bf26ff59d44b4c32a7af398a86c65bc04d1b9c0e4b0ab4aa5446432cd4552721314edb68f3872eb4efe4f24110b45198628e96cbd149a400eaba27129b0a0010e676ffc5d45fd363df8dca1f496d704e7ee3a1d9e45f9998725c49c4493194025266338123ea76698bd1f324f63a1c7cf15cd875b1ea9a96cf7be77cf4df8a17fb3b639a9dd8912426b0caab357de4fac7f0015ee15f761d0152e6d8e2ade55ec039bf317d3880e2866ac727b68d44aa0f9840491104325f0eac9619ce866c43bc0c31bdc41d6d3a29865b2f34ce195ef3c233eb3553677d3e657a96b8b3fbc4b4218603a265292966311210a740103b13e184b30b0507f89f4f025b9e7e1c3aec75c80fe2669df6f140ce8bc828c65ba977605ade13dc7c6edf81af744a70f4a2e7312b0a568362dae178bb42ff3df47e0c17f8f387296553d73759a1655f932ec40a0d46c260c05993425f9be6964f4737311d4b3d062b678a59294c3b75670842efc812b19214f7bdfc533e3c03645fd1ef172a7133d442397410036cd04108ead324ed8d506ac98349a70b985ce4c2cee8a8f11b8ed72bcd52f50af80dfb189d3fe39aee775ac45a6996bb1de93bc86fed33321fe706b6c5c7100cb4e77c031b065defa6271a562b68dc2170a5cf204e42bdca46772db7b2e415d9b7ee147d4189c92d5ef5ef8fef961272ce4c46ad147bff3da4c8ff2661be226636b6e46d1c7bb8fbf97c71c102094d6d646370b75b9647f5db20921d0bc18e9f4381ce947671145b8c4e528549d81d311d9c8a0721157b05d21756245a5c31667175cec11f16425fab41c07728128dd3260831fbf5de3bcb7f73d997636d03f8bacdf409c91c4ff82289f361c726c5d731360221003cd798dbdb14245ff2dfdb4a6263c204759b7e3bbc2678c60560130c60fdfbed127ad7c90c2d9378d3da21328b8a33765770e7860aafac68460e3f6aee52740bc992f38316cc98fa0275ede85f83f432b697170b0e7d94194c9a3e24c56e1685959af80990420512f6e93527caa518f4464fb16bacdd6af496a6929083d8f893bdf49bfa41cd026934ca52f7d82165bc3b84bd69e540b8c8f0adca57186029501314ee617211e98f87a1da674641b85e08fcfe15b0c52121be1986728ee993ac7f75dcaa9bbd792220e8b1861677a73b1ba0fa17de5dda35696f6b50cb028bb7924f86493234085008fca819026936a967264b347c5317704141dfe960bb28609e391eb7575f851db5576cfc04c8c8047e805f9d5adee4f3a8c85a6736089fd9e7de1167558d185c5539c75688c17feb66b28093bd7e6616c93dec05b4b22c33816f0186ad447d98a835893283256c850a44962b200c5acce58bdc9162a193230936f9f25a120d658cc06bdcc18e82e9fe7d61120d595223f14e1848269d66f9bdd630ef4784d14bf501bbc4ef2e7c36b8214f4e7f92f1efe415f369eb4e4c7fb87b899c1f5587901ba11119d7a46ff6c05af6f975b8fa4681a229c79439392cc31b5c4fefa2a73a7f7a16377bca3170108cb3ab34317b2850e6ccf15622cd8213de4f7ba883443c3581d052fd475f0aab934e3fa9d9e03d6dfdf78c17ebd60d52b66163a721dde6f4218b392c5f617dd2e88d92eed2ac66d5f24b881099f197e29fea183ba0ce15232d0aa1be610c7cb655b5acafcd7c5f499d1b0333c78dd7614f929a21ddb0153f9b28bf8cf1faec0b78c47c7a0c9eb68479688f67020382b421a6e88a265a3ceff2989b2634d3dce021eea7500889d79a89cd2d477a8f0b2126e7d3783408579bf1b0a4e656e01dcd0d399ed9e18a20dbc1992a4f95ac8a4f5a610e14d4d16ae22edc94d0aa329505debe403bdbd9b232c78bc2f8de509242cafda0d23e4ea3777f3c27f29f00b23bbc568e7cf671d6eda555f1887900f9f1ced591582826d23bb171a1282f8c39627176c081148243e42828c13f4c800dbb0835aee1048e241c33b549ded37bb15864720d4e48ef5cf400d2b7c2ab51f890750d953cae26044bcd2f8e4918bded1d9798b8c58d6551e6de609a241b5c5971b0a65819cef5af20becc4b59ebeadf2f23cd9082480daf1d8c1d3cb48245b03c01f81f46df2c32983a0a18fee85c87d260c536c7bb68c3b5cb30de71a853853311097d39185a8e83abedc72b247e01675bf934b85f3eeddac4632dbe655828148abfca8963f16d71d9c60e979c2cf6608191b74213815308b7b75546bfa38ec622a66e9e85287be57cafbf9dc397bc8f9483d40721ff2a2ad4a24edc2e6434d138217a252620ae5d36bd287b72ef13fdc6fd139b31b0d2c762e473f6e34c3f2c4a8426dc1ecef5106f84b760a32433ac3d617b8ed437ce916174ef951218635cb58af32a4db0e3c705e57552a97de4691b33f8590c517c668445a228adf4c8746205a294a31517215eac1980178c145cd92b7b19bc9f21cb611e910bc24d019a0e747a4194510acf3d9542b0c5f829345a92eae1b44ed54b493e89b38604e3afd1ad14de07f06422c49d24e2f83fe966ea2c25d80ca0f1de6f2592743e487a6ef019a95b4d5cecac4846cce47aa3d67f713a5d9ba685f36267b29710f1c3413bd8fbe472c0fe0fa2b198619b8a7f49ca56f18381a18f0a9fb148140629d693fd4b4fe907ac410a895072933d9cb04c0b30d4a3de993e3fcacc0b99053ef654cfe476a7b4ea9d682590ef5c48a15689e8cef0865ce5e46dfe7440c0998ed5bff8f77da0484b40311e90ea2cf941deb69adc50a1c053c72ce9cf87b82f70760a615c558a617341d09e085643538f6fc3ebadae72f6a452c9f2caeea39fae60d3b787869e387211b2bfe8fa5cd168ad9154a37722f141f9fe5b3e108f5f5192f1539a1697c5e6537b312853ce50e019b07962c59d62b2043f31370a3f4df20c3cbc49c4883e90dbf8888f252205aa11a2be0b52b80099aae69c0a28abbdfc8831ee02aca85ba03c9f07a82b6a74c3307b1624ee6f1dd23022d19304ebbadabd8e58537c2f5d9a6d8baa3831258b3d364bb20146481d2031af48eeeaf16e58e2eebb8179dcef60d1497d8e4049ada9c2c9b5e41efc9131a0ee9311d73bbfbd33b82e5a6a8e5dcafe5468d7388f44cd0d199a160ec13b681685363177b9b8fcff9770f6f9b8663b730b8cf8dce643591a124ceac1e5e66214a11b72b54b8f7567b4c6fed2112e435952c21bf94a796bf75de345109b91b708f926489d7c65b589a60be645db674d4b36db364aed62ef833b777894a238d7dbd714d298fe18448671fb363a3de819748483dc296b442c26c242ffcdca5688728e9b0644cfcb643a664a80639cf196dd37158a0fb16faa5fcf1ece308d5217deb62a5f8cf49a458f331b121fc7c652dd54","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
