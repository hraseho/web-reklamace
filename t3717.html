<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca0cffa562656f576646b670474abe516eb42434b2b9c69acfeda7e2f4e5d9c51f33b3bc68f573ac455f0fcada8e1e5f6bef6f41d630fb2145039077796c2d3188f9317db39a4ea848a7325a1bf87e1f1c54d95343b8c457c664fc06355f27aa5b119d1d1ab023f888aff6b80f5bc5fb53ab498170b1a9c0b3c354e1c8f07f75b25905b34b883d2f14951fb76a38de2bbd80ba794a98fb0e688623f5677af7e6c8c4c3128b206899667599499be2b548b75c01f83f869553e1f5e7a6295fcd9311d953891e415bbb78c7aca8e533524275b7d303d50a05513268f40c12ac0f99f3e8d17a38f1426cf4dccca67cf8ad62fa5ece4c7429f30501c966069c98326d1d74e0ce8695313ae29b66043372eb596e97cba7f67a446521d26b2a7086f4ce180cfeda055e23287e171774cacd5bee4394519b91d8fd4f601117e898fdf78c5ca6b3ceaaa8270026c9a2055dc718736ffe53b6ac81136211279b02b2135f5aca31e0f5331e6d742d89332169dd8c32bb66449cffa51be6276e08c55950f1a6a55de369e5b2330a4dee474feccb06d9fbb9831bef25f52201ae9bde7934505c6691708875719d10b43afe4f6eb10c460a49a972d6a5cad3fd42e1f3ff74a56fa4e982ac0e261c8e4ce88a865cb40c8ae2fb26eea3e1fc5b2dc746c7be76e22a4bc39fe418f5ef7b2de3654c0681fc3e7a347e50a8b47c2eacebdfda92f8b16bc859b14a9021b057228b5c4b41e9295d5db8fee8bee0415297a40953e04cabb512d7d3ca32d1a4d435701436b5c81c204bc8db160c25f09a4a372cb82215623e65fb20f8f34d8ed64a9422d72298bfa5cc7e7b26330cec90ee2fad36d2a207e0fce2f7866472b542a4e4c79e0b28948d950f7fdca39f2b742440a743cfc1482a0a79a6f44527f60c4fce910976ba481475ed84f4443886962ba77125892de0c12f81566106d2a3d449f5ecc6ecd595e3ece498ecd48ee66dbb247b60925bda25c97a2b3680d434cce7609413b299d6f965711f49c55a24dabd20ad1178d62cd5b31eb444dbd41498c654653c1031de2811bf17c8886821c8a39cd174343da55694fd022bd9369ea0745bdc0f569b00a34aa8de48177f6173a5927195130306850e8a02357b60ebedfb22fb96c35d8cf9458a22f6f554a325df68d92f9d74e53ae16e99dcb880525baf682422d4271dd87256aa518bebc43e345ea54cd99f63b7b3ddcce4e8b3738ed8e7f5651f701399a85d10c5a6c6916ac586af5ac3c1e05245500701689997ae47ed9907b9df044c2c878cb0502ce4e0859ecf061ca2bd1c3ab83e9a15222c4e1f9b35aef93006a04956e925a6009e8bb8ef00216ae16964fd45e3a97c84f6e2743d6ba6b1eead0b6f911a39b8b850abbd624a8674b48f86198e4ebb2e089707e9d1d887621618bc804a20a612566085fc40e824a9feaf74f202da127acf729f3a34d4d7512ae12b9578ac57b4e6bb2878d8781743b5d6278f1e88661822012ae6f4d4f6de6c8f106ef04adeea8b6dd503b604177cb595548e6801cad65948c6263c35282e4dbfc773312dea2ffc7d07f3d79aa763b011fd2d6c45f5c7887b7486e0fb7e90f9219b0d817d03a5f2e8ebe1039e8e7287981dcf90c42a42943b1a2892d6d518d0eeee4bdc7134a29984c777ae5c4583adc38c8ee9325037a569b506a5d3162889b693eb7f299b6960c416383ae86bd51f4af8f3f7367bc007aba38d885259615959e5ea201c7d99b2ce789ce383ce79af2e027345757106894e09b1212bdb4ecc489f153749302e513cf24f93529fff1d173c8e0ade0ef643b76c7b74986250a4ccae32fcbeed164574b91f18070b65a20e527c75a4f30865d6a6f81bb0138a3f5c7760760c2bf455d07a2a700e0e968ae45022cb27bcf84a8baea892696ecb851bc08bcfab9212d12814ba542bafe57b71925842aa1996da5984e4b0bc9929f111fbefaf95369835a8dc433bd964b31c636749add0ce8cacd2b6a936dc8e600bc3e6bee30bc955c2f5faa8ebd4c012ad6758f42cd50411b3352676a84f0fafbc9aba54743a8fb8348ca4cb1b8f2fe8bb4b9d591431738955faaa98296717de1766c630c332abb3b58d2cadc9e908c1bceb7e2411ff888e1ca843d86a1aa7af0b08d3dbe02643a88aa3b28ce847260cd98fcf2abc100b16bfb92710bde6c9895cf1d5433abe8e399651e408a49b045d791c72f025620072bcf5f35e6958676cb7eb96bc9b26007c467070f7855b9fcf9334b99e4251f776c4ccf259a2aeb4c881eb1c6911904e59d2b154b784d0102241b9ebf99bcf7fb12686becf23c69a2c5c63138123d8e80b5213e66985b198b2c8699a992de6b804bb8ad7d564fb59645f4d9162e3c006ee6edf49e3ffa7fa9c0295be1b138f398c5d4cf9d69d9fe3b7b5d47e70d1970fd27551e4b767b8140bb924272aad71242b30dd5a8251aa026222ecc082d1585125cfcdb6e089a91c77fbcbdf49572d87c5b4faa8d39d1da21ed4d87494e37e0d5ad372fe602808cd54067b0d3016af01f14cd8f9df7fe9ac7f928a24855fd1af7f94e0b54001501e9454fe2ca610e5af9cbc389718a1544885783a32600027e722462f7e28caf1226e3d776903fad559f10398a6e2ba8e6e749bac7bd3679bc9e798b17888b8f874df6822f1eda2732a89ab09ab33f59f3ea740c6d11f8eb455c9d05b7b0bbd9c554f9c23411e162e2d42c15d0a31a589e5d22aea3c43feebc0b2b0a209f0a720761048feb7a9a9ac2e51e58fe0f146d809574455246b8fe0012464b4bfc9a85bdfb2f9f468e9211701261dff44036ceabc227d3e800d2b96a28badea0a35d2f069a67ddfbd6cd7659cca671fcb1bd8836b5a9ee8227eeb437627b7dcc3d04d039f2fdc7b97d1cf4271ef95cd21b8b4fe49e2886847ded921bceb6437bb9e1f6695ab68214e5e9cd4f69bff9c830f5a7d85d0be27bde380be8361ad48ec397dce2456b31914dc8b54aafe3f11c1ed993f80ff071d7885e84da19b63cdb1a04ad1d735644cade56feb4e7e3131bd509b642ce6bbee5a19b37939229521123c495473a8bb068770aee3fb4911effd24d249d3d833c74ebb74f722c1bf630bc77c45bc79d9be9a67c58b728bf82ff557c5973852498b2bff5609ec00d88b69260409a0d4255f402e1512c0552ea1d3f7d6b0cedac2a3ac66e343a7f64202a7b7fbf53925ce5fe1c0b3955bef32846291c125bcc73f681ba3e81d838691e00edcc0e30f1bc7c65d722a1f96b3b6c24bb7c34cb76e0b4915039233565357329c3014c6e88c304e5579265dc9c9cbb9768e8fecba274402410865051b789a8443a5ffdc0c83f23cd6a8d2a538decf804a1693ac99e4b56a5b0250abf92fa3259a806319a4832f9b41e6a8774bfe34faec4677feeae521880f612dc80e4ca44db311e0ec2c92b8e20a1a3e76665639517d17929387c3020e385be34d457c0052b4fa7b816489d51070d016caaf78da64b9a9a72aa4569102771da5c6ad55aa8cb7f46bfeca0d2c66ed39f74cdf96b3b6fd7dd57b6dfefda89a5c581048754453790ed838118ecf7a59a5c2b5bebc0effcc315d304282ded9886a88a2496aa7a277c8807f3938803267980bb8ccccbd1447c0df686e324d11e01cfd92ec012f89a72bb2b2231a448530784c76bc118c694c7812f8ea6f88d7d7c8ba62de0beeac3d79b5e9a4efb5bfe59afbfddb74ded6f95fcdef6acdc7fb79d1ad853e9ba6f8064db452fe8f0be16dfca937054b71a393afcb8dc3aad66327210c218c80070450eafbcf2d1f0ffd069915aed2c5f524423257c6187dd185d85f1108e00384e5127dc0f4483224d17fbad448f6003f3006f31100b3baffc7b167550544608915421c1f2e2c7b39d541aaf67ebb217de2c03b1da1f36b64ce67b9b01ecdebbf79d75b873763c490d2645f12754ee07fba2fdedbde157a9e34e7fc189a22b98d53ebdc59b24c753862959478868ad507fe078c5ba6f9c958a1ff29456f917d688ca1ed2f2a84b52570e7ee3b65dd8348c83ecf3fee85b09338716467ca52d1a6e023c10ce8a6fb8a91906617736ff35ee14a291e6749180d001984539108c32bd9408ba4601eed954f422e32780507ac89f5370bcc9e7328f29551c579e0abd68d50489b1a50f2759fe59ab6cb545aa59fc7ec45c2c18b6d4b8689c0b33814e582e2ce3422a1f642f2d9455a946fd02ff2ee205f45db4e1e8ba9a1f2c538026bfc9a5faae7344a24bb17c6677d786013e91797da80b68fd5977dd8e4edc34ad94310c6e25956ea0409f085fada645fa14367318ac0795db090d1a9b5515506ec969d45450cb6888ceb5d41af2b68d5caec317ecb3245803e79c2be4433c554765e4e86b355e7b0e2571cfa08483e0007ef41f9e32b9225ea652942461d51e324280b9d4616f3378b858de665976df830691c6e2707d191937a34fc8261b1e2cad782ac6952d6f521aeacf13812879d1819ec4033f6ec2546b92a8d252376bf1de0ea2109e603151d2877adbe21d5948951afd17b0658b52c4d74fd1f5153c54ca714bdb07cced45a85ff0eb4a64ec72a64e9d7758937e33adf644e02b9efb7c6b3a3f53dcc0a2f903abc0bbe040b3e71893cd459f111cbb625044cda47a44b124a97364f06619acbd4c0b6a4f510212717852bfa8b045c9858ee9ad44ff56dddea04e2c2ff5fdfe8fbc3f2effae1048b310c9abd7306d52245f3add350aafc29642deee4527e9f9da026fee3f260b173851664a26dccc0bf9ea99f47e73eb8bacf1ce65ce914b0a5050dc23b519809fd1c8ca861911151affee2e2a61f292e65cb7ecd228d55f208633789612caf4217b9776e9550a7d68c5f0541ad590b4222429474c4de0547f9424fd26f3283b1bddd215daad98708df1f9d79cfd36e2f16f1a006ab26f2042952f8a08776c0c6433152d82706e5e69abd07fa669a3d32040df90ecda49a5c544de053167b4541430f26a0341250bce2d89155b552e8538d6b443eef03c106c761d21332177437c94d9c87a6c03dd17152a0987ad13e9cb0b22c18c1d16bd31df40ce7b7d403d2d8e8318710120f98f57f89acdabcbf88f6916299bceee03f4393bd9e72a4c8cf4b92c1bb60724edfd8172062c13d5c668c19f3c6523e97e17a94b969436718af9207c25a2951fc7e59f21eadf14acc2216e1e8077c781b8ffd34a2228076288b8492fa660436b476206dbaec622d3acc780465ba2c782b1971dc9993ae754cd923eeb490db21a252cfc0f5607850906dd2a88af80fe3cf0155d1c99b129c3330bb35d8003b4cce69f9fbb6da1dbd300b157ced404d1abd18ef4b4b5a4701df6545fef11ce23aed744cc1a32fe18758e7483e446b7f88a5b5e806043583f54a23d6646aa3c707116a03da1186aadc5ca4376ecfcdd6aea27653e64f5331ab97eda5965524e4722eccf28fd30c832f3387f74107f820c04cb434f46713bf41cabdc32cb9f59b381aa3ddaa95d1ec1963c00042fde52f9aeb4415f29fc4259cacf9d2342ea4fac480f4006909f167cb2f9c49b12c39180da84a2da586e780e74aab41eaab535b9caa7b11a6df40c1064e74e14a4c8b1361471551b4bc70335a5f1e703ab5c6761b832c6592ba1cd0735047eb4d152ac71701f2c94c0e76a02ba1946b4a82189b287c9f92f6071eca7348ec876abd8767efa460675346535f3bf93772ce5d784dfda719fec905a19b652e379d68b4ec6038c62578977bab1d4787094d0eca3a2b0a74e5b60044443fd89e913958e3b1332ccae59ae08fe67b50e97a02bfd7d7750e1810b2942684ca3fd56ca98eeb45fe28405d57a4ec3ea185f2c36a7ee08b5007e024775fd66f00b0eaf9743c3eae20622fe7231e3c16cbc6d3bffa35248f5fbd6c5aff2e096303879fb531373a2981440862bfa9c91b3037be9e197ccf522bb6653db33b608b64d9d0ccf460086a5d4ead44502c14cd68dffb78746e58f14bd95d9bcf2e74dab6a990f2556113fc9d38dd44424a58ba0264ad06fe497367aa80c5e7dca017cfb578da9b74090b4a0b0078a12a69b442743ce37bacc307c590206562ffb4ff34df6a3a10cfc94841fa26fd7c439662c9abf26eecae4115993dfe67ccfd5fc3829f245f39ae5930fc541f26f324ba706cc2b4eb7f645bd8b6f5c93ffce5595932559cec24e02cc171703931ec52c26d682d9c9bba3d09589c5a4d3f89ae32c84dfd31e5b6bff1d7669170d3e30d4cff540ce02772fdc5d6d53b7dcabf81c0495a7a7df5da31ca4e21fe0cc05b386dd794d323a3519e74e41d571812d2254c57ffe23608d2f55a0b56e6ed4533a2c3fe3244ddd83b833bd5a4c3da48846579ad193e1ccc89b60887209a6deefefdf6ebababa9d9baa9efbdd7d71f5560fcf0d2d3cb95de5acde45e6b649dbf7c04866f52c772c8e553691e0a70aac26dadc811c2fd5f0748834d72e53901a161ec453be1fe2dde40db94732c8e64e41bef17e81a742f20a9997b72d73e9b8cdff785e97c2bf26c6a541b60d320ebce8ef74f920970a18c6e39d8ee92489dbbe23c190ae0947bae20f8afad2a4a07e61d06cb2beb574197aa2d6f17add267d3b7319635b206bee082b847779949b73b852a1b0c64c8205525727fdc9ff8daccd56a48430020e8b0079f3ec9aef3910a049791b0dca091ba59665e22919c94312e011a3346eb4c2ef121e67c773999f5e0a3fe222d66d9737e8114c66d8f81fb1e119a564b16e7ee4ac7b4a63f8ae900e8181f9c9e132815604e545fe879dd9ccc63166fa48301ce500724cc797f371d235c27722edc67db7b3c9108f138166bd76299184dd25f9c72bc73d30881b205daa669369fbf54683b911bea4930810e3bec9a1beced1f9bff94869cf41bc19f354954ea8be37d6db227d5a61c093d6f09c1417836c1b6d112acb8ca378e4b57c343a2c390558e2f448c32cb988cf0959e176ef39b3c300746568c8dde15b227df3d40124388caedd2833d1ed70b6b686e94c322f38bce4b571129c82790f20b1e226eafe94b79a8d30e25d271e1cf71c8228f958915a987b8921e63518302c128a4fb2116d704a3353a34d6f50e194c14722a4e84b0c6497014c166310aad9942f7bda0aa60e52d364b0674bc500fe9d151983cc259a0805cc8a5302aff4526be4d2d12faea39d02220b0e52b74d872f0649627954f4dab4f69928100f9c9a25ea15b441f19b5d18afc544a953ab370715ba4fa643d53d3811d0b8e0151d873eea98fa82ef03f68e86a26302ae17c1130a5e99fc69303f0ef53a068d9a359f5f6d2b5c48a14b487809012a221439cf8b05e8fd789c8d57cdf267016781ab218011f342906bc023a3b29954aa716ffe275a1a21883411c6eb768caa6403b7f392cac79c29f2945dcb105efc7d8ca2b662bc87680c20aca019f02d51225692dfbc11443340f9c9fe6655b1b99c5ec69c617de6219125e7344a70c82bb25c103a73141379f6c565009d29a43e5a3b8f815bf29a7369694a7956fa04cf77454466c7192cade5390108f08d26386e77c53d2afc13933c1068773714eff5b1ea734c56527711575b63671a7e1dd92aec709f38742b485d76d7a15969dbc8de4f79ec243767b9e375b9140ba1a179956beb47222fcd2e8bccc51f3fa6f935db267d5096a52ddbd63a2cc15fd5d97da625a70d254c30bc8eae2a372b5372a583286313ce343bf018a6893f325d42257727da8030f7898a6eba5303e547b862fa1218a6114ee1239b38ffc1e28cd7af725180d8e44a9ac868b1aa7a48168aa91516467f860bb8eb486964f9b74e65b82658c850f58886c82a0c22d66b6f742aaed9e7c86e0f2eafa617f5bbff1ad86aff58dedbfca6da2918f334acbf4e50fa6819b71fd40751a117b80c6b35ddd52de04119ecfee6303759bce162d11a5425c2154ce32d9bbe547533a69a87bd6717aa5e71bc1f31136e3e167e4b898b912b0a6a5d9fb64f4f3abec1b75f01ba7ef4d572592cedd578d4c2a2b6ef1fd834246dde47cd7a6b65ffc8c419ba47654728f47979a2d843e6ec4a8a7af05d364794cc70d17de91a87c584377595d047764d7af370717d9d0b599ee163c8a15c83ed0a9a6b96513f361bc31a89f5b53be38119a31c798a700c4505378b3c262bd7233cfdb4274dedb527668125390652967a82dba13e3ab8956b5844e3eb19ffeff712fbf6e55e83959167b6d43a11c10987533cb4fb95ec61dcdbf271f274f03a4080b2077ee6e9550e6bc6505bb18681b6e54deb6c96b160fff58c69362d3f253ef521208156396becef8d819b115e5698d9e25892fc20fb76c598e8a51acf93792e382a183ba8458edab8ba9becd9f353aaa43bdab215ce7ec54d156c67a11f035a0595fbf43d99cbdf19eef82f2ee079347504edc76e532dde18599ddf3796d9a0576e598d69c7e2196906d29d53b1a4c6f97ef05c4ec1d2111098be0bb5fa5af10611bc70371ce13e0583db710727552af1bb4a0a3d2cbd5d8037cc92f3b0546cc9096db94431650a901636460a3678a22bb3b9afcf073899009bd5a563a3422c18f30285e138ef3f9bc4328dca099e9780c2315bb49532f6b9d6286f1c89b20172425e78e0cfae7d3841e257707a0748cde4e04dc0003332cb59c5e7d7b5028830d118e50d52c5e2f6114e2ecc2b024be9f9ea89cd2aa454824e768544a1cd7c0649f60ed74cd0ce43e5cbdc138dae02b2a2971ea1e8701facabc5f0f2cff91e2ab57674c2a1b85ac7a2d37057b8590fdac2427e513d2e4d64f32107948f68070296a557555f6235524479817319f99a3a7b20cc155e7e96aa8fa23c6e34b2eed4797e816dfacd60be57a25840fa0d392557c92951e8bd54fd9d51d567f9bd2444d991b80f07f80ebbd1f4d5945b0ac5f61b9c8529d02819491edfea1c46b2cb080855acd3ab01bcc6d244b4faff707772f47684325ca7ad4e1cb6435022fbcc433d10f8c51e96ae997cbb423a8f87f3c0e13b5bdc9351e76d7cbac384b48efe89ad23c593f010c593eb80288abd8661f8b968fce4b300c14b4d125378594d029475bb85517a292ee33d79999221cdc226a0ef7ffe8b17a70dd1a5a5f0b42694faf1057e50e228ba12ee76c85b72065ed57612668fe2c74628e3ab6d28737a43f38c6c67d84d3e997bec3f41e8526537f00f10d00aeff33c3f01f5c5c2f5f0610ae1af2a22953288a5187aa08fefbb6d29a35f7223fe9de3f907ed78ebb043b19c0c91277c9ba6e1377770c331a6baafe1210da95f35ca686dcc28518583fd1f1f70a9e8996841bc5198b7604956264c4f32de8495cdaa296803e099a8e2c0e507ced41547fd3dfad2bb5761d1050a3dd2da118018283128be573583f33a2f4fa65ac566ee8bf8feea6354ebed54ad8cfb4b8aa0ecc610eb9f759c85b46ef12bdebee208423b3f107a08c372499cc3d064235da0c8308c6e42c7bde6fc0d31242e3e25b2437fed3beea1a3fbdbe716b1405a1c2d9d0d7505ea7eddfe267bc97b961c92d6eb7eff3ea3633c07e9ae9b8b944dffb01fe2c307d1bb1ea79be6ecf21f34fc623eec4c0db647aced4fdab67958d176f8b2c18d6367fa8571cf3c0a6686bbcffd8bb3d7d9cfc862297d99a46efbb15f6be6fcd9c0edd92e27f6cb7581e5a02f762f6a65b0083aa0c6bc7b3e7766337a2c8b714782eede1ebece2d258f6dff9f763082dad77297e4ec493b1cd2e38bffa11522954443474ff8823be41f5265b49014280f20a89ec190be49be6392dca3c41ee82a5ef5bc60ac76e802577f35d5bdd47e833ec70c44cec961f5bf14e0a17e82cbf5914ec4dc697b0dbb1a9dc121cdf3444a97ef5581fb23af2c24bf25984b5db512494cb1e11b1668a9c343ad65472cbb7c1539e631c2e951bda343180f19a2d31e2a39324399494b5cb7dde459cec3e35473e6aaf8eca9f8416a728b31157c4694981866a1d59645627ec978e828517ae7fde9aa68b55e412cf6d9834cff118639f683d8f7d7e24acd678e39886cd0e2021b0a8e60843be1cc6f893d786cd8efd7fe14a8cc2928ef95a0f1c9b9df28567d46f8154035ed88598598d2a945a080d920ad71ebce64a287ba7801748ad957efdded43d28848fe3e35fd4a25a2bf1d3a27c95cd199125b5ef434b5e93775ff1cc10b82f4772a421fa040d88cb86bec118d969bf698daf1a6242be8753511ff1ceb046cf69ac9bbb09018ec483e6b3bb4e8cc9998eef1814dc913baff6020f35bd3204ed78af65da6b3b5b3345148c049bc405ba0773d1b2481fe117ecac2f8c31e10987aef282cd838d80620ce7ceb0d5570a4a1c4acce35d3bc427dcfadbb4afd84bcf9c5510c1e3d513a113d5fce7e1c07e23450028c27feed2404fa6ec49da6875f3725522d510c28eb6ffa5d7e8d034c6e58b4973f4b5f26bed8b9311e9c7d7d087ab209ad1cacc8e582c6811c2915e021da12f3b61ddff8519a9734252a3eef8f5d8322d01e5b76c7d8d6d2b94f6cb920d56451fd30fb1f643d8cc4cbf13b660e0f86953ae67b4e405649113dca817c503a7d0402ba4b4e2786f6985c1c76500c77206d7e65c102412a3a02326d21cd121bafdee102e595252b73a31135b116475551457b959877df71598a4d9c0da052d0f99eb722f92add7426bf8cc4898eddd868fcf14db03d89909b2f83fb3a5a6c7599a25ee32e778f370b136cc8246787e80a9d003d93d307dadb2e4ee0f1b39273a8e5a5e4115af473dc9c016268c0534abd6465a8ae8efe90d26a4ec380ce88697b04d1fa93cc774ee8d9f3d43df6a8a3fe64b63bdf7e4925af0292c59d3d8ca7395c8906536658357f386c4d1178b731440f715b8c8b310411a7ef5915f60d0ff86b90983c00838ab90d32c96319aba299538787550c7c773f293a663e3e2e70fb596af15825d5085b4a1c4c805718c9a7839e69cf96583979b8fe655047c23586d4e606d5fcdf4c8a93074225f1f84d137d489b8b5965acaa59b085fe68ce3306e69fe0f765a3f8a876153d5baa20aa53a49420c62b5910a37a571e728325601d5e75f085b4820b9de7dd07e833dca6c2d3bf0bb6d749f86ce24bd650c24d8bddd9c089cca3ab20e4dff31aaed4806069d5b3c9ca1ec53d555256e4ec17c59ddfb02339d8f869b2d98c7497d2af6a776fc0396f38123875a93c41dc0cd00ffbee19030bcd42d27c6f90c3650145aa9bad4724b2d9cec512b4f7afa15f2fc0071436cea0265bf197ff89c8c97603a8a504d95ed0f0f7348abed9b75dd210e4e09a55c8ea80fe38cdf9516d66e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
