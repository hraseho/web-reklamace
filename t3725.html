<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c2e7922b75e5eddbc8dacf079b2f290ebd05edf87b62a8c7e5f7956bf89d8ab32f75b3af42a097389bb743b2ee31dcd44ee5a8cff7052c483c94bac9d320f4c1e7ded68ad7752e1c2f96719d9f476beb214d33598d07ebb5e1458b11fc28645e23c152d598103f1d1b264ee069c0ae304504f5bbf5b628e4595537c8483d123b8921468013d6032f4575666c3dcb4528955a89d2b62d44fd1b0e07b6ad0fd42df2bd9e5f94a6ea95d4075e0d9b1fe634d052f5cfe46cda2b3a3af4427fb3356dd34624f194ce09bb13f219165f456c440fc246bf94810cfe9b3fba355874c07cfbbb682448a41fbed693f882e7e642f8c35e754685bd023713b7c5762bdea2cc273dd1d7483082149794d4a5254310c4e23a22cfcb26a82fa6ec7344c7862868f1ccc06bd3126fe9204fb763a45f0daf5e2d35385a12e4c740b602fea9faf2e50b1be85b27a8091ad09270454d5eee6523f2599cb165e5ed18d604a1ab2401da33379469a89fc067f6fc7997a14a41c8c5d3ebcab7b4f2b227934958448972236154be945fda64b8450a2bef1060a6af381f4008a966200b20565eb5a2638556f14dac7ee3134dac3ef372b4d60efb4ef05133efd1859d43b779722b319ec3a18c5f951af1d9a1e69b5a1375283121d0d45328233325ade553d7937744a2e3a1139135a31961818598aea083deff5626e323bfc589985869637de8a4e44bca2265eecde0eaec9288c02570920fa4a1bc8eaec5754107097feee725df12088b22dbf8a4c55ad03c92565fa544dc5130aff12a9ef695b350ac45c287921d557bde05422e870ed3fea876b328ea80b9458cd4e64d475317c878bb932c1e1913aa6eff4ee6098c89271de9e993536263a7926bc96c084b69359111ce4a8a85e7970e460ffcc68b02ab5e195b090c12f6f9cd35bad752ef433b0f8790bda57d6f31ba66c62d5d149e29f05a1f26288de086bf513e99ee00a93638b025bc7555542a04ead6d036a505a70386cadf6ef14f88a1d4a413a0758e301fdf36a6f3217927e659db6ed549415217995326741077e139a75ca8d33ab567414be04f5e873b96573b70d34a7476acb4260b31073221c0b3d096c10bdfa741ba6cba200ac7206fe8b2aa5a471c75e67799dc7705bc7fc5425ab3583ad20cec1ff6b3d90a46865f94eb466197ab98f327c812e0684fcda829ceca8c8b26c0174d06779efbb68d4536a42776dc53e177657cb2731fadf8b01fe79a24c9b6f582849c1de720383531041250f437fa49dc3fbacc8ba61fece72596727f3929a5615edb5d8a2b398dc48165b9e70d958e287e99c92ea979550bc1429e5bf77823d4645880d7196cc159bd6954dbed1f25ce668eca016bde56fc37d54f865b0f36768302501a99e68c1157cfa9a23f5ec5f8e1c5e8d5ca767ab8bd54e2b7c91dacac6b1ee222c5d699db3bd9e240355377b29783fef3ee2d5861aadc922e08958af6fb848251ef0ffabf8da77e666f872d44b2068bedbd316aa1b67642898c034c85c0a14c56627af520ed01dcf7afeae62a311323453bf595a390d7e50245c62a30bca510e1ab62f98569d279e09106458bf2349157c3f4d66ed352d3340964120c683b2673a61f3e6b7c3ef65f51b2ff69351b6a6f48feb340e8278841a66c6b020853291aa60bc4352a34a6753043a3979bf077cfe95a26c7b7cedd20d70e7a5153c850e775b7939f0f005568bc54ae92bbf9f7932af7dc5427a97aa525137ed2f136f5623bca8c88ebccf384b2bb25df97479904585dec467d42b9be8b53fbea59472492f321453ec461848e96fe93df5c0d56f5dd692d12dfaef90598d341c93c6baf763a46e3c83ac0c176e41b2d2c153fcb1a7e421008e702af7f540b6c41c2aaf9b92046210d17aa0808cb52b71b5742acacd903f1a7046c2875278951f5eee672b4fe9b884f1c27953c736a7d7b89d9d37363d070a8b6d58919900b0fee94587f347d5d83b8541f51f3b852c4d0e830591b33e0c548d876b46b18691aac203c1d070ce18a5fb4653e429e1c604557bac331a6c2adec6b3d64494e1ddef199ffb65ed3399f7c9bc7eea9f4378a02395d3320f15b9a3ec130b6ab5be536a4769cd32abadbf7508f79e16ad426f7a31da5e28d2d0d5a4811b3c4719c4f18c605e11a3b3a45840b74c8aad0ddd41f53ad76721b6b202da103f6c30486c26863093f506f9b86c61dedcc2b8a8d960b9b670805d11ce0a901363a06c71d1363ac091112b5bf7aff867e236908005e89297a39c1c2721ef38c15cc767a9eef43f26b1e1de8941cf926eca478133511479d89a6a7f4eac427e8a89273a20497d46a1e62241f654a9835017e14266b41231318f9db6584c2eeba08ba843cbee457d4477d38b492e9cdb576020e76ad4b49a38d8acdd30d85e0352fefef3c1bf9d97bc9e7203cbf00788e1c5e0e4cc14ad6b7bc0fa8eb3af876504b728cda56a1886126d16daff129183ca4d829743ad7c72d26104113499f1bfeb2a38aef7f909fa0527d015162c0d913aa1a82ab56df23685dd3a8bc776d4fab0155a43cbb513a9d23c35070291bb3a122b5d72b9d976f651e3ec2ef1ac12cf6cd54013ff5ea9bca4c5ad90f42aef89a5c293813989644aea08a240e7cabf777f30dedc4e89d7839dfe6b49a94de7e8e04cd086ce48f5d3cfbcf174d2e2c3257eeaed6728b9efd468300efd860841be1810d1e7d37d69c56361bf2db904fabd84b4a7cd7ac87f116d08c5c3cf52d0764caa72dc7aa2245ba239dd992467658e58cc68b8d6e2ad109978e33489986fe3190193ad12aed3e40f445d410b7effcc8879f191c02bdd1beee2d9292a88376ad9590adcf2b6190fbe48fb477721c1e6d71096a4ef442389665e31bd22601ea0b93a7fb7b819c145751ecb247033f01f64137c31ffd5cb469db32552970888e745ba44507e7e14458b14702f97520e014cb1a2f4c4bf6b580448e586cc1c2cda1dba39768917c8bab4b87e481d77c184a4b9b0fc1ff6d8e2c41e4bdf20b4a9889fcc90fdd1a9d890febe62709ad33d030843ffdfa6d6b8c2a76b7c0ede16a212e32e89d8770690b7a6bc6d3edcd96a69d7c01ff8f7e0be920de3a5489c301f84cdaf2314728cd7aa90b7ffa43114ec7160ad982e49b13139543d33d8fb83fcb0b5be36ac4b8e5449ab2af54e9d7ed82d058136b1c0c6351e6115fc6c279763ea381f18a19106c5840dff054bf33d0fb371ea6d17b26e2cc7ae7680addb42c8148b5227dd185e7ab35394b7f362d2bd07d697458a0213df2de51e06e093218a7607d41e7ae49bf4f8f7b61606e0128c887b11f301f1e66a38ead0ce2ac884da60ad4a7357b4932c5be4a21aa9edfb9109851e4cdf0c2328314fde03038e91c76a2a5c209698bb7f979a012ae024c16ee844ce7557ba321feb9f46300ca3df143c522541cbcb4568838377e106b9b1f79c00a5a0c488566ddb6ce85af39dc9b7a543fb4c5a4a6fee99a80caf031b662aed9fbeef6e9cfca4b4e670d94aee8b63f3fd8b070c5a4db7f109043655813cc08328d4af7d5fe6906961a0ab7a87a5dead7887e6ec3813d2c051312cbf19515f76b820a0a51cc66302808c707f3f849622b0e87661b00392af103be2e5d4f7ed41d79eab7ff668ae8d7b7eee3190d8f618347e3489317a69ec3cfa899b17c77669ec2cf8898c0a8e5947c904db1935844e0726b7e1c2f69230f0df06914b8b1da2ddfb6e3a0c7a85e57f12733561d08189ac79d38c320eddb9b6db07069c838410fa617489967485778ab1984a22c707e285b7c13d60170ce34b00082d4cde1ac6ca663b915393ec28b3fda5ed47e6af52859a51fb68a0e10156723b75796a6235273c4b0bdaf2cb64d1ecdd0eeb2eb02520f402de3b762b5eab2fa422226ff1bdd3d32b201fe3d5fa3a27145d8bade859258c3d6008ec32c1572bc3b2ac23628d4dbfddcd7accd17b5724a336a26aec8dffd4d38591f6f2c22742f87360b645962b327c6ff005c2b44d4dea9519f2e2838724f92b26961914da0fa142bafcbb3437d8bf2aeafbafa59fae84d712be4a11373e3e3a3d3eadef3d09aa309b3d554ee32788c7b1ab710b1c5580cc5ded1899cafe9db41b2f2565f1eda1ccbd266bfa2d71174aa92a5ae49c393e7c4e26e79411c776852ed9e892cac92d9ffbd4e6947b1fdd655ef655affd7fd1d9eb310505d0bcb235d757c3f85dbad2ac02ce60aedc1146e6907af906a3cabcf3d15eca1f1e03a11306f9454df608e9ce5e70616bb8b905d34ede5f60166be680e01911e074e1c3899aeec5f01f76dec9728a40ab3fa58a27c8d33347643648b686b92f8c764cb50f3c22a7db7b25b9d6ec5c3dca55095bd1851be4a68fd1ba732790402331e665d90a77dbc73da8fcba40a56117727b209c798a8858fb6dad66d7f8f0a5cf6e940489d330c8b981be61aca46744c75c48f85f2c45328a3d0ca0b14361d3fa56fc43c4438c7eda826afa737f4cbe47ff48bc6acf63e7ee3611e2a2fda144bd42165c2e9decfd0a3528884af8c6da1734b56ae3f80f8d8b156d900bf28306edf6d3564846e17d81227c7187d00abe6fab4355e4260a835c0d033c23a1bb8a7f95382af1c3c17fd719ebd8d625c1292a61e0689b17e5713046f50924f0e110b1453da66b4d08abfb03cab7e4cb71b3ccde45643a298c8812d440dad0e4477c4c6032a3f549bc58d6bb221a0b653be6db44dfba3295134fc64951666e1b988b98c3a7b20ede14f80fbfcd306bae5c66eef2b86431b3d5cbc08b559442b74838ea95ef1c52e54fc54048416dd444a6724347dfcbd23d0786b45102c893e7194e8057b79014a31de1df585948483800d84cedb5bdbadacb5df9652723f9a2bc5870e270812702f778fa64f6a4156297d730927c896a50b3c78dc0149efb5e6c3768e7a8d3cdf095c7a48adfb158dd3865ea6d1ab818ad5568cbd65caeda43c13f54443aa9a016a75acc924b3603217846397e93be12401d2b708405a925b6ca899ef4a43d3f3e3d04b02ba3c23931274a67d53f1b38923897adab55413ea38e56bd8bbd5897f6634ddc8d426eb2e1042757cb80abb1df976eca4ef5a57b13d432d1081e91383f6a6cdb37db04ed18e55c0843e9f027c9f9e7c324ce10f386d905322e1a153889b704c9b0a08cf354aef4b06a0425c4b4604828239a9eebeea242ff63b4007d08a260e7110e58a8e3817763d6058f165ee67cfb7979a603c884d0ecd86912f28180704f485ccc7e4f754fee0844363a030e7345ce367ce9cff7804ec3bdb02b8e174108145d894b64dcaf6d2bcc3b5756ecd8c21512242eaffc68d3d5378c8ab73c46b3d2394b99605ecb7b2fcd48bf37ad207d904f5a4cb3ab5e27ac19258ff0bb9517bf6004849f331ac598f131ea75449ec4bc3aa652d1cc344d0b9ffee0e5d1477089da4f56b814eb2e2785a9c0ef3798347ebdab28db0721765890381febe27d16449b3ea1db4a5b5b0682621e225d89d234f27061ae3cf31bb92bc48deef2ef1c63a94a863439b6d12eda20135450e0c0f8e684397d44fba95a8b2be7b5fbd032b27e6e169fcf303e1258e4238571584777a9e989d83d6598b61a048f2fe785b45f44333b96d457bbb67e8156b3f1f0abb0c92e837389ae3fd2ce212183b860593e981aaba785c54623f2ac7f6815eb88e0e509c87319bbcbd85fa983055d53bcafc77f9a13b7fe2fc9709e9dee61b8c3e23373ebfd2b515d634fc7eaf7bd3a9eb42742f01ecf87c50056d46098057fccc5058fef8e5a55abbe12f5ef05a435435ed04c90865cb3626ae00ac59305208b5945a89eba986e2596220bb2eb7e79f51dcdf852a679db2eb1b6f564de3be1bd1f83b7e6194ed412cab66623a7e8622b62efa339fe90f5e0687bacea4b16345cd20b5e14132448b41ef6904d098881c028b248ae0277c3c691ce142b8f2202f3023d46a7e86da18414cbb2b2fd8db5b4fda1e9bc26ae1404905cb24504afc1806f4f96480b480f9db60f0938b5a9bed5e739f504606cd68fbca7db6d6734a545ff74619f6525a01f762111ac193582f151da210ad2e6d0389c2c287238f0920a1dc29a05dac76f13a31d8eaef609be0f773060b9c21fddb04837ee401241941530382c1f44577e3589ecf62981126d38fafd43083160a565034e6f34ce5cbdc65a571ac28d492029d8302c7c9add59125047aed3711a05f4f02af8e8c0d85dd79d0c36d515336d0348264673f705a91ec29ed666fc0478ee81e766ea0581ab9e59ef557ac59edf8c96e3906ef30c9b4f109f328a8a210facf536b32a22aa4ce1971c50890cbb25221bfa8518af116ddc29ad90ca7d93651c261c9ae6a95d470762e955c9f4465895b426121b2b96ae76305fc7788aae3c328e4a21b03161f442a31e5dbc7dde31149eb4ee697c4871cc7d5afa18626789e3f5585c88b15eb5051d04ca4bf4ad64288b55e969c2400dfa1aeee13b026d794baf97ed923cfd6d34fa6cc916b41a4e573fa22fa7aed6a503a9997de8ec05d6748f3c9e58a51ae226cad6cf1d10d60c9564d895f54fb9203585629ea34eeaae349840641acf24c798bf9880405248268d1c41c710d0fc71c3571fbc4fc6a9fb1f1fad7a7e691bd5be1de0128933ad9dea8c8bdb4f524dd876d02ab248cbfbd201d44564668d3576936db0158f8b2c486c70ce60c5eca405399ea57969b5bad26e17ccc3105926eba9ffc88f00f949df4adbd9a6effc2a744b48b5dd4b300e05024fab73d81c9aec3f7c30cd7e9cc5863abc47565a44f688c97584b8beaa5d2f5e1bc6be115ca5467a1c737b5a3f038f04733c15bc9b2bcd8f950da903f024c4ea00395f9c76a59a4ea57fec1f24bb66df7b78f1eabca4ee139d15e883bd791642174bcecb4859015a4a662b1940461d8ab93ba5c430ea0a45fa4e69b989a912e9f3acb5f039ed83e1a624fc8f642ea4c78fe65f68ed4889570f56c36fb068eeb5bbaafe5cef42a920a6e19554a7f8c5222125bec66b4e00171c71ea8d0dc6b00c565ea48ae86cc9657416e3a36254e499932c83fb7389046263b7aff4a29cea473167313754ed64f01c8328e615cf9697fc39a89969b474fabe6fc7790073076e3e367adc1a9d91d2fc09a20dfc26a1ea732950db1066954fe0deb1852405e1379930acb34fd2bf305e9373b6f953097d5df6ddb94ac758de41b096b44b0eeb523072e9a986237255ce786e04d54c0298f7df2069956eda37560764950ac2c6b8562ca625a8458760e2d6ba8ecacd325e795d6da0a7c1bf01f8db2e19c64ce4323803d8c989ab3632a5d5e4475672951e4ae57ff1a5969a140ae11986803f9c54892fc9c390c2d6af0060c3482e1f9202d6e87b8cd6037080285fb72f024d5bb667be7031ab6da609c0ea0d3b6cf062b1369535282bfaa4b132a795561a64a793bab764cb13bfe56954043f50087977345baf44b445da5dd49efa9bf4febd3e7a00451195f1357f8960b0efbfb41c2a97f7c2f551e1b25c46fba30f1de013bf1b77680575c3ea9bea7474fc857e57dc75fbf0d6178faee7cf18098b1a1f2ca759170dd554a0d80164f680dfef0f1ad6b055cb57a213f9aec21559470234ca804aa6c49f00de94e589a6a9951252131dd8ef3b52482c3e77efdf2f16d10bcd469b8bf8aed5e27c3e31992d3464d1e7ced3e37c572f9651358b4d3c7f88e6c36e516cc9825dd464c97c209d956776ef7aeaaa847c92d0cb6b010277d556abe0f95fd66585683c75ffab9c2fc6c5a8539ea01202f1086f1539f3daef2ff3ad12f203daedced7a99401efd1be88e08b0df32542cc32264c22138605798b856fd73b652a39b0b814b82959cf6f2c06e4912c8eaaf3ff256ef849e8b4146dacc91be4a85c6f86e2435065524125f9b210ec869e03d4d9bba9e9afc07213c6e598be261114a9f953a0aef7265e0ee9d16b5cae437b9e8cb7470c783921b51703d53468ceea71be68d8a2fe43d981aa4a064c4af3ed2e172516071f31831269b6dea84c2199db682af51c8de3490ef520503f00a0543c004bd44ee9e5cbf95751e6bd42d0bb943cefec4e1da884a7c5ee12f429f3b61cbe7ea4d4419d09ec36c8d2802476e7655b7fa98019c66c43d25b383b6778ab1ce83d1727323ab9a027933029013991b711b5817039d162bcb18aeae81c62aeca0267a6d76f0a8d0c353ec99c89928511ea01b2d6deaf9ab8ece01832a8cc91a01f4095c496dab4ad69d7895967de5fd0101bed06f7e657df49bb6aa0fb52b18a15ac90f54ecd1550977d35cc4de5703fddaf7ae5766936044b2d40367bb73771d91718fcd648430f211fa77ead5a694967ad15db8b9538f9a706aff2dced4c5b5adabc1407451bb3815845f630847e3486b35090a22a4701dd0209e3018ddabc586f176d81caad8329265ade43d0d6010590d2ad194d10a10415514e4640f72de0428616f4c5bf9b2889a7e1b1b1e849662b8b7a1c534bd18f7b6ba5a1a12dfdae6dabf718f9af5490b07fa86ca32a36284d95a850dee153b97515542ec670c262d3227d1336f0893b00a484911091ea0bf82c783cc5009144f58897c3f8f266467fe30a9496f4d0cf2f9868fd7f0f299fca49a7fbc202eeb7be53491e52f47df0d56f4852051c92bf9eb553479b136230ecf027b0ae5fabfb7d304febdbe9d511bf2caf1e6352a5941da63e50f709bdf6141797b7adc0b01e3a901d176c361d79e0c62c70faf6e0fb74e94da8be16c7959103f4dd4e1bccb0863fe3eca7285e48de02c05bf9767d2fe9391bffc4e6ef3e245a1bf542ed759e20f0891c82fc65354c4b060d1781b2faae1ba02042a9bd613268bf020c2426ac8319be2ce738ac239daa1234245bb35fda7992a7eaf22f22fa8b1c40a0547912bdb4f265588326d5c282ab25db2c8f952c48933396af4e5c176aca0c9dad4d14408a9530918e4ce6085fe13175fa24542a27cfa35245fa2e5376f7a2b270c4e40ab5dbaa5bd0b197f6c222951dab0e631cb3561a1963ff1c74ceeb5c360d7ac7a0d8fd98ee4acd9d9f0d591c888324f9d014e0f3348736d32f111a243a75e04d159f228434941b50b75dd7bcdc128f573d5bca45801542620f4ade2a15dabcd40cb490c05b553bd37717e4bb55cc99ef12ec6df1c10a5eb3d246592105b3897ef1a294e9a115f7f65a60ea9b103c11bff154dcdf20da71f3c11929a015bf89c83c1ee5a26462996210450b24d7165f6960e7376221a77c175f8986a10cff6ac5a4af502cb6a849372acaa5adc89227cda6f194e277704558b482720d645aa91af1d3019de76c0be7c4177039a32058d62c18a05c67233d59c1cca8c9c7f3e7c4ea4442f31c7b0a9f238eb3d23e7589ce9b21ecebac0c4d2fcc44ff51e61a99531fd7645ed6f298dfe091be6df3c7a1f64ec1aa58cf877599412f07644a90c58606a389d96ea16cec44d4e2ea849823c3f98240535d72515d0e07f1c9bf281c0608be9790ed51ea62d8a0954499a4d6d218a7ba1b61c2c87f89c4ec7398757684fb57c771b21894a3c8aa6369aea5884e3cd21cb011cb2e2e793920397d924c1cea29faafc82d8df7d4ac021592dac3d502bd152fc4fd23a0960a7c8103353d6dacf38cbe70100bd87808b0ace8bf3dd100ef6ac66ed9484a42568c8c87d53a76f65e09a6ff0ca2b8ea1aa3c4a80efe782f168ca12a50339994546f41ec7eb4d4798ced4d350532b9fe7a34beea1497226733b2931ca214d5da552600e4751b402261bed6d0131e10d6a20330f4ef1a054a853d9fb0e3f6e68f50a65ef6dad6c63516347ec384f452d702675351c2d1b81e4d98397c3b1fb0e8045e7afc41b18c8c193b4d53f089618cc588b40ad471c7be92dc18b477254b9f0e2ee27cd0ba747629ec9c667ff1aa785d949f2cec8cc38ee6b7eb01826398dfb6326e95cd6ff31fabe5f9de76cf11b5a7016f15b5fdbed7e56d4a7a8a45ec4a2cbd6690229a04e26ff39712f9e1a21a4ebed6a71686bace73ecd62551e315b60ce68b560f47df2d36f25500b939af5a1dd49dcb0e403cc536a2142813663eb2d25d7319f55560810314353dadf67147b89a195512559a24108c02fd68706c90e87219284dafedb882a18b289e8013e48ef1b2b176b773d27607764b45ea374e66114e66a157733931d66b70132f76a514b69a959e7e62882d77788ea4222ae74cd7628d6e22fab329bef1d2f2dbe192e67da2067ff6ea99d0b48c3dfac8694352a6565b1be36414c14ae86454da59528683aaa51d4ca117012208ff093f742ec0c3e274dfccf9489bbf89cbf64dcb4b028c108dfc61df3f483b0c827abdc62a7c95a13573618c70b5108a8035450bfcb4c0bef08b7c3967ce854feaf2f0ff920ae521f79071c15bcbe7fa1da08ea9debad1073227715bb957ccd6ef03545b3729a98f063de77a4635ca59c883f167ccf593727cd4718f196aa295066fa6fe0d88a8d5dca70f7d46f21c70608092f530d86c33b99b925f5a0bcf075901aa2e6320affc6cbf9c264b1ed1d58d9694b4058a6229a5413d1c52d3499fbf394c64ab410a03219579451c3df06464a9f85bb1e2e6ada0397dccd47ce1f5415ec3dbb71d4613fca3c6943937612345557f46e23de7b0ac10e6c13b79a91d22a50ef29702d1e472b6d2247648703fd58e7ba562e0781c9dfb2ce2272cfac0d98f9020a49dc17cf8562ca29ae8deb8c1d27e3fb94eee409d25560830a582072ca71275e69b9fe2810905846b4661595759ac933d168d92876044aed1bb1709f331a0098719b3e66f2d113a2fb3de18cd141fe0378e993fbd8c719e31ebc5d97d416dcb233a2ac01af65721bba3872b5cc3bc7bb2c84ad8bc3f5194817cd015bd91287ee8e8de7736493ccf7994b854a5f48a2a3e5c0f76082350af22b29c7cb1a646e9134fb1e6ee211e55b76bdce103f2c2590b99be472481f7e2f91059965c81c0ea4dd421f742e7fb752e7e5fdf0aae0939d920d355c17713c2daa19915a12faf762bb5bb5465b9ff7966f84d62464f934294a05c892ad6d64890e35cf424fef9465092ea1918aed66282e9a4975c60e762017c72ca570a49d670221534836c23fc0a6ad0375a17cfba16d1702f6d6465bbc72a5002dc54b3754465bb1f50f1b34ce7765e76fcf5009f32c96c26a6c796759e41280cab308ac812c62460688a4a069c550c3319c739342afbe461f13d01baad72111f76d13876cf93188e8fadd2001f8d2d0f4eeab72df9b028bb74a0c651a831a73a6eb4dc0b83d427e10bf3aa37558861704ed627ff554c51a50865bf8620a2cca0367dcea25fe9bd8f6201658ba7d5c1ac06355ba87a93842fa730b739b399bdc660dd6cd78c77cfc1b667a28567b0ee1e1e1fd868b6ea8ad4c85acb4d87767935ab2fc1cf6f910a5e75","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
