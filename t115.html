<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b41f5503ec302bdd6092871869e31f2a0fe84b67d197ab25633564b419738f5dd62a565ab9adebc5d683823ac45917a1b1d11da2b1549ef620b086ab769ff94235fc20ee9ea428a91c813e2fbb9299487de4d3367f0a89ec347ff28356e9ea5a36197797c958aad22978f27c575566518f4a7c803411f5d8e37ada29bacc722d10ae61a36cdd81022516778bba9ffbe72e89e63098f3273fce4929e6f643d56d56ceb3f782783036b9d8c6b660865beff1107e59e107eae77e86e016d8cacb724c7f93a8a4c2d4dd4506ae98f97c59b1219b10efcb85d01a84cd731dab2acb5a4dd5e926ae56bb33af8be972048e0f2f834b5761c71b4724c6d1d035598dfb7275aab5dce82ee6099281cb9071a4633032d80f8a472efdb85e22b70a6576685f0a2d259487bc23e56d1f81ee209385f1468c932399e74b95e3cfa925b33f62f082791ba75f89f7b983d06bf7ebb49c428091353117d57055cea97abb4b564ef91ff1cba180cd838016daf9e6488e4eab3ba6cfcfda797ae33a37947c4477f701f78d6fb652bbf18a52eaaa289403250dc32e74f0a9573c0ecc55081bd4b01abd33ba34c09341aeb052526eca90b2f280e140c05bb136b30442efe53fe3ac740ae9a2fc7b284a125c8af8baa18c975d713001f563120735324911c709ea96685d10bb8c5ff272add331305fc66d1667c5c79d09fd52e48f89ca2bfa8632c398dcb788e607c3eb3ce9c4a96c816087f5fb591d2109de5c495c45c7ca573d9fcc6dd8ce69c3a7b704c00096918e9b0ba66c0c6b1a1c2dcd40a9324bf645ad53ab60dd0a435fcafb3dc36f10f542ebad1defeeacd8661a24a6d2377f9ebe91429a14cafe3ea661d9822fcb83ebd502d443bc041dfa6d25ba061a83995db34db6434760aa907dbf08f9ab8f0c9658272596824055127f0bc034763c9e77c7d1825b2e071754df9a3c19330feffe9c9b0cd97e6e396e9c9e719e6007837eacebb96a8f1e353c16a0791e9872b4354a067e90bb6630aaedf9221c75e780ab2b32715b451550697bdcfcbd8155829522463163fdab0652a41ddd29b679e1ad273bb255d0b0c3421dc9faf51482701dcd2a4f6241e5b5694df8cf57ec0df67659d067fe0e72cf7b2f0a6eec8d1860332ebc3fb3823add65bab88de0369c98cb2f51ab02704a5d8f1335b79ccf9af72b5f6f44bcbf56665cf764c42da88e80b9db237617bcd6802de101d2c109d79c7201c421d8c1f8ff72e00cd49793ed1c303654b0c91fe1b29641dc7777bd7a496379777f9a87ac4f9c9db84dc4a7111015ca6ec5ce51f2936ef38194d30d813bb9dab994c2ec9cef2bb87b1a70cb8240ff7449ff4c7e819f108c0908ecdab71ba90af63f074c2af5600fa1cb03216bd90af80ee4c01aa340ce05086fcea8f857d0023d8dd40186e219aa5163c041ff3f4339a7eb7c77ad8a1ba7cd617952374e23a6f9ee9019ddd1d5810afc249aff8c21808d9595480a45780217540f91ba9d5dd2e93f30ac761da345add50768aea99f900554b1258b4e49e01025400972fb18803e2b76a39ca24515e91c6ccb1b1d6f9976781446554f98fb1c68f490f3e2a58b52983b5c266b437a65993945051d3c74bff383b793cb1f071c25b9f77509a6c19637fb9c91aadab58ce245fe1eb7d3d0f7955570f351190aabdb42403ff14ce0c28710d6e468b097a0d590ba63407c292310afd8431997dc792f076b9987017f2dc5d9eb508d96c7fed22c4e4ff9320939912633e18904291d7bc160883239dffb892c3e770e5dcdeb62844bdd2a700cca393f4de67ee9d73204bf623b708b34d2eaf9968744f2bf9eb3f07ec301a9385895e97c565129bc21b0689a116ea65e78c07c7b076d8b609792c9bb09f9c359fe2fed6378118bf0b2099fffec53f408a04e8f8584080e1dd7b5e29cb25798720b39c4f726add1f11497529d6d7f7b2d7b756530f61a09d6698b1d9558fd137c1ebcf23962893ee0cfa51d27c0db56fb9a886b0db1b9ca527a8c4d70638d7da7c2eba2be62c43d7ed8967742a8719c5213e99bab77f47a3b0d568c327ce56d7c8aa96db91c5efa510f6e4cdf60919d0136e8063df94f4a8a13b6b11ff660af02c63ae22abe2e6e63de439ad42b3dced39d4b32f21633f2c3a80e487dfa3c4041bb914d4a5e2224e0467073d8f42e7faeb2f0c8948c83fc3188e89f55a3edb81742f40a00ae6ab69dbf1100a8e014f1180d477229f08b9a592e8d1191cb23a28e3b576e3237b8d1487b20abde91d70a148dff613d6bd569c3801b79f578108ffab8ee034f3831ddee2dbaa281fda1b26a92d68edde1e2fa10a6c6d8b35de931c6bee47c3285c7133e08508bc5a0d303442eb6a8a87d8707d9e9a7aef2cba49f811e5459b92c84c89c4ab2ff90e1a891ebc6c3a5c3fe6dd2facdcf78e4a7419ddcde2d42c9e46a36efaf57f9d3ee3801d1b6c5b85352f1f818594e5d4bdf2042244c5ac785c817ca339c6ad9cdc34271ec06e86b9dacfe0a1ea58955777eddbe41a649fe0753055407a4ce17783a114e169b4766f60c4be2ce23d7ce864619e253c746fef5f2d7cd67a67ad1b5b610c17dc82f10b28b74909403c061de88c5bef4db0e972558c9725edd1afb02599a176c1a0bce0c5576324ac3a6dfaf03680e779b6223f4157995046797ceb2823e71705e249ff03f8dd915ad5351c350c8021575e4a7c9ecb8a4ec5106ab49db93a2343320da37314a8ad50758df25bc78abd5fe60dee0e1a4cc00411f141db659468dd89044fb8f6b9dfc3e659b206a9b3e831441778c60d1c9f7cdc126dd2407cfc4ed0062e25831471a4eef3aa3e2f3ddbdcb6fc44a6447f6628178a6328d3c373dac9d3cc0c0500dbe4b323e71da4e7cf2492d7a2a4fadd0884943457f9d131ff69ddb16a049ec0988bd372b73abe00d7cab03d5e73757c1a4474a8d90756ec295bb01a2786e21f6b12251c79f41e667c56236b0f44abdae49fd25805532dcdc77cafd173e4df78137b4ca8c1a7648116e644c994c9d047fd826ca645ce20e3004c3087c61882ab51fb7d576c2c21a8bd46ae5620f3008d0ff49ef4c6f194e94c2f1ce54e61dc706bceb6e4080f745cc1677b40d90fd82a0594ba22ec1279b8b7f690ad6a3fa1b399231047531809cadf6ef69620c0b7a0b5b7cb591d5703087b868da76c6a09e636219434d1b5d8ece580381bfa881cd20e14637c785c9026188377c79672de935e037e39cb97eaba192a1af425e992648bd23b50f404cd779a8e4ff2067f1162238be9a93c2d81240827f2e471e46c3bda7a6fd25812bf015dbe4974bc95192a963652629e009b9c2285a6b06f2d937347b0f1d62e548d2775b259c3415026a574b07ab01b3aebd3c224736b68f074d2ce3fa0d88e79691af832fccccf92db20d16b38bbf1acf722ba2ad831b535479fd6747a903e926c9d7973959ca26b79ec97d2cd33d255022c4d90e1165d89958ff283fc4ae161490eadfcfe4ddc0c82e080729c35cde5c09a18999a28445ab489dc0814f4ab1d5def6ffba5799d9fad533851abe082da674d75ddce48585250847fc2ab4a7d7cbd051dee79a677e89cb7db8034200c7e41a55f2e0b6f9314f428d600ca0c3429aec945966e2978751ca7c663530f96a9620fa809266ef94f45b0b757ca51eb059af84caecb31d3bda76553c9b0cfbb7fd75104525231e105d9ec62c5b9891bdc7b518bd05e580024770f76c39d1ae08a208897cb86e12df0a5b503238e78103b7a5f1f4e6656c794d1faaff9fad94c6c3929a7e8d8fbdfbdd2295326a80c9fd92368b7e731b1a6c5bf157ba2488de95f9bfa6d1af5b6b68e637d1b7b00a27969a7a7e80d49d272b8a9f1d515d0788598e08327f601b8b34a7aa43e6179c2c5e81f9f941ce2f946b326d7ead3305fdc118bc86270745315fd6d6f71212de7a43d5223da02bd70c8fb4012505ab055b43b5e5a23ea89cc929222f9098d27fc603303555e2726e4ccd345e02673d641b4062c7b1772a776dddb78445a1efcf8dabc8697864bf1cf3553760a0e08e02577e4cbfcff6dbcd0ec34d3789d14f7aeb92407a91d17ddb124b3bde0bbd72fa40c94094e9de1dbc7337d83aa905d9c488c18452c8d62a0c9e8e07c843ccca0993e3628d7dc209be067bd63d1c61b4d5dc1674dba96c3f61228b486ab0cbc933e6fbeff321e4af7f903da21a35d5913a0d28a9cc0759bb45785b3ddcc8b5c288fa1761082719b2fedd825e469c5921b3d076afe10e9698080c0ee554d49d0b0cae77dcaedb6940e9cfb53913176df7998ee4dee4a43830e95dcc6486f562e3c9d26a21f01d82ec4ea5412ce09fd90819ceb4e3389939b481cca03c753f91a91211e3ffcfd4b87fc8037fd2e1c1e228f11c17401f0808b70104dcee8fba77ba0eaa1c5bd4911a58c0d866f2ef39382502a0c2ca92ce9ee76c4bd883a8ca6523765c7295dd441c9a7801eae7ef96e75c9c869263b3c36f7c5d29e148d0f8c28b63e85158fced70ea4603245428601e6d99becd9e307b0751504a6e2df288c9dcf92dc1e8d91897f7226a43660d5cbdd007419f198354b9892a1928b421ebd34f0b3c081509258be42eb546881b1f915d962d73e62ce3ec20a263ffd4e02fb01f89283b6b80e0fc1ebd308bf2899dcd901e99e8f450709ef0df1bf1499ca3440199064a041618b2b297dc611cea76848fe56dc57c61fcbd7c512f91a9d081b0c930b456feba984a1cf070d9c5bd30baa54d299011d63a091a2cd79871eb511e1961e8098cef9ab494542a4ea97fa2abb9bd7ac858989e032be76b2025a91f61702cfa9728fd78214cb2b54c692808143581cdf06b13574dfb14ddf1cb5d10ee53f7d4604155427ba25ce3be32c5261d818f44749094803cd08356b89c9410af3e0bba8dc0569f25afacaea31be4c40e2a6aab116f6bc4e8327a40a3699fb627b4f13867458cf7b43f10ada7b253e9b2e573ddd23a5909eea0f374c951905668ca4ef791af3b3121073826679642345ac40f7d8427799c345dac1859a78f22a1a3ae2b2e16ddfee98e6143b3309f519a1f3d7c7dbbb4fd280ec0af5cc715204f788e23254165c44970aab800928f2a266b412df85b629a278783db5a35b5680e60c6941a988a7eb6004a4fc1e70a29a513a102b9577c32d5fdc15617072b5e4d3e9e4507f63e734cc5ffd959ab40d41bed499e32e190eb733547105ed2350e02a72e666df77eea27975692d97ef6cf5404449b6473c1d36f8f85a00e84bda1a3caa570f9bcf0463a487284bad7b5dcbc573d6d86771a8c73f99cf2d3adc8af5bf408877eb72c5ffb5c2503de2f334ddecaefd1992bd3cd1817c4bd66fcfe8d349d449deff70faf19edcf88a80ca7ac66aff44ba7bf8a11f791a957d7a13837654adb799c24654f443b6702e20cf5dce63760f6802bdff5faa5184a25c4cff6c2d9c93737f21d297d10a3b9af3ed01aa9c4e19ab2249d01edf51b7de8dfe6f845a72c5c32a1d15a3da21e9babd681e519cfe4e0e6efdfc1bed983a4d8026a4502d153eee1798bd7984749a650a63845665fce2b7a905b7999ab2fbeb423d9c8b6145938deee658fd6b8f65e3655df07b3f418b1575139a97a76d04ddcb74baaed3a5e363bc2aee03be6c65f1018898855548fc461627996e88a9119c4ea266ed928f36859dce19d095ad6b27e9df033ed2fa5f294c28fbb06433259bd23e4f85ef34f59ca51955197f5c21a9c64246440cc97cf88e3c78f4ac82de3f54837887dfa6bb9a70fc7e38753e1db748d1cb51f9f16af127f42e8f030909024f441deafc3db85fcf3c01243fc0c539c6d0fc4953a7a201de6a572e70f830c075e0af73c607bf5163d9786471fca6abd5651043fb16847111668cbb6a3c2b231c83ca8c7f8adb82b25a467536746cde3d311eb8b49a79c2ccc68d8c333f9d647edc1c9d93229ab0991e6d07fcdc3f8b8d2b2c46167a7af7646683c5058741959926728948d6b17a52d9dbbc6f5b515aec8fe34f5eb07d18dc50c8784486c9dc3e64d4e0b907b38543364a45fe5f26fcce0ab372e73f90bbd5d9dc6ee78d533e0e1f29f9cb93bbfc591a938242940407f5ab430df9bd52263f60a345a1ae7aeeaa2fab1dfb2b1ff07be1ff3c012f564920b6455450c644f16af5d4d6f8ac7a50038b0bdc04b8aa07eeb5fbda1c8b9225b2589321843e706bf36623c1947f5eda3a79b574c237e35b9329b9e1d146047015d24af3aa6f52f1352cacc3653ecd4f5d3cff13eca22de3993a491b2d2dc99438d7366b5ce2e9e245b81bdaef7073401d16a68adc2c3244a6dd766b1e734ed60a7d0f4fd8354c645f360d6517237d1200407d08eb227c15540b80e183118ef7001ceb593bdc0c20272499961d488031d0bd9bc41a511c2ad0c3d3eb10cfbf384823cede58eac4a9da60dc0fe001b4dd09f2faa6bbeb6b6f6e779176d955e793f006f5ff7555b6ba2022b14e4289f531a691c4ed7a7ccb9142dc9b8ddfd3a6f712d381d505c6bd22927d2b379fece9eb8b05e42e08de73baed0bbf3ff5d6bc74e0da6dc9c5ab41ee59c15765c2f4e72a56c9746c563377a310b53125a5aa5c81ff2162f749ab51b162578c6a634b36f7068392329d825d5772b9d515872a15648ef9e607a99df842843870fc1f8ae289377ced95037e87ce163127c8ad0aa6e348374f3de4f4ffa90c3ce645d314699c9a665bb4e9d3be51d4ceac99ee73af7d29b175547554406da6f9a90021a5ad72de3f706f40bd1ccbe5ac71d33532c2e275629d55ed4065ca57a2dccba230a2ec4435754c2527df2b2e74967efd18e5666206c41387e5414e51fcec37ca1f1e5318e9430aa12396499f66735fde53bd034c139d217a16b4af12802ba6785d2f58d3b8c954302edc93697d8701c0bdb4be71784556fc18e893b3c17c19ff44468545e88ebe3789006bdba8acea347c7ceb943a3de19493fc7d0081705cd994a32d1c3e566aabd3e47718c0899be263bdc2cf093b68af75a94a5cb9e64def114e448d5214d62bbeb0b13cb6f76ba51318d9561f4a4df0e727b81c50b32c1a92234e7410ac394e275e36b94aa9dd760d3e2d95fd2537039eac770b23e9b802f95b2528d514c5a596fafd220fcc6117bc433e01caa0ce9cf14fae2ae4412912812422095aae3f20c90bcbbd619c407b11028697794d9d99dcceb7922558701542c4268ef881436efd8cf0cd6e1366bc1a10586216e13e5dd06c6f047786ab0372c87eb838018612c659ae45f4470a998baa5453b3b5ca86429c9dc6a143983915a5811c84a43e196f1173d48f09bfdeb15cff42df909b282bd104fab7fd3a5cec9fbc137e6d345fdd991bb86021b51c098bc4a35f0de8c267c789290743bcce79dd4afcf6f8706dd774afabbe6dae74b8727cf8f93d62434d52e48fea4eeba7964ae61063b9c2e61e05f06c04d8d7dad63c22f2fc383a67071a5c0a8da4c382f8836418d7839cebdc0c9aab78da5241bba1de1dc07365f088456dfdc5eae05e82e4d8b497255022ad02f08bb55ca00c4f0ebf2adcfdda972e8ba6acf946db6a004b5657d61ae15b8369104299f0d72bdae0cc2fbd26646443769e6fde7e0f52323e32e6ce512ce7e3b2119b1dc6a93fcd7cd05cfbcf4a98a12c43d7323cf405659fe6e3ebddad9ecf152f523ab94e9f8b7be06902f056fad745cd7316d5c307f7594c36ea94a8dc71b9ec36b2d011b36ca3c10951827fdddfe1406efaa5c0282fc5e6df8a97b894ff953335f428c4c929e83e5b207aea69723c4ec8457b71715347715bf55e79c0cae7b8832597a7035456d000f161a140ec0d769390a88de0ffd6ce8ab81798c9e7d457e20762fa21af4f6b9d40b70386146234568f2986a2a2c69aac4ef81c8cde71660537166fd11b7be6ca7211c1fe287c09888b4cf3d30cf1d57301b42e8aef94ddd4bc1e91d0c7bdf7958fa6f3cdfeb6c1f9b15bb9b02807876070888f59387db278451a1979ba97aefe24bcb49f227df5cc3746e6dd3cc7481b273c391ddf8af442aefd76eaf856fa19858d836a0aafa975478d28680ede3c8101f57910e2f77953d15688b2f8d62aec4dc134578fca40a1c24c79e585bd56026f811da1523b640743a61fd9e643023a8eeef740e41d88f8ffafdbd6374c1080a8e3a135da0387d266ad14a17904180036261f8fcaef91c1e9177019e4b3b074983fc05f6d845e415b0d2e618f1b15e0e7d696c2b2ef9d4fc66ac3f0aede7a8ff36c2404e4da5a19fd3fc0533ab6ddd3cfcf51ff0623c9174eef4d992fa16b757c26ac57a59cfb3475745db4f2b68e5556023606b7a4672f742e2c51bd0757e15101ea1dacd486c912f89b32d8616ef0e349ac9a3659b2cf5af2bfa964cc5eacdb9b80e14885458d10d3ba4d3bd710586f63ada372a68e383f4d64d1ebacc3ad6212bbfde60d15571c0c4e375b0384512fc8f1b51b2c8edbfdb8ef9241413cca99501dc25ec46eb133987dda534ce0f7d95c6899ba8c092039b78c951b0466eb5a02d30990ffa1371dc0b507bc83590bf98794bd8b30df86ff7d69236ada3cbc93077a6c8777ab64f2832eee9d978658e9bbf4511046bab5931fdf20d4b8be485c92b16e6361cb7b4ad0b016d8639ddc517c446d1b42c67d0105d69d76c0d8e5bac59777d67dac2fc8b899f2de58ff271c7a52570e465b26b5a87f50d645d96cc17ea69d6b0cc73541be62b410a099ea7d58aaa615a60963eab7960087645be2aef2aeda5ddf46e23983058331b801bb996a1786aca93415497e25f1eabf150298939098a9019f5067cf0cb4f8c387cb6a572e5db66cf00261e1ca129e44a06b406dc15d4c4474b24dafec15c1bd92f716cc0637c300436edabde235125ee6a83c512e5db352bfc635123e72fd6157047736dc3eb53bfa2ace69dab8ec1a49d37477731d3b2ade7b961ca3fdbe0d427a480408f9d585cfcaab19b77d37ad94ef16ef89901b538503081fcf6dd860877b543a0de1ec627c3a552d2bd6197ad4f64f7b274d68010bee918baea8f00daeb2d9013aeb69fe68c9fb827e0433509b657cdfc58de9aea4a744a37476e1945fdd7a289bab3c6da555fa522aa7d10d1069444ab698cca2f1b59779e23c156ef8eb4c03a0ab6b15bc5db500ca3c6a6f79550721d01bdf72f62d79e9373bc8307ea24327535fb80a1a4fc862a3a099829de84e2867bb99fd5c42b05c76aa1cca1f847524da46ac151e296ff8bf5fcd969057054244726e6c2797175a9991c87213f8f6cc6be14be0d5d95ef3e410941bb84ec75ce9fc7a4279d55977026fabc2fe30fadccb24f98bbe6daa625ce7e4346b2e7b81a897b128691960ab474fc2a33a580ce64141a2d97a4ef2ac6f061176493e4aa9e2af6b8eab6d9fe4dd3ddf89ad66056e6b6ec1ba8bed0fcb3422d92b97b641fbba42a9fa956ef629a89a192e56d1a2f6b0461d69444bb5ffd311358da009fc958cc65290f13d3225c3d082976bb853f6589dd0393859a28d245eb53022b72926e294e0bf67f335a67ae7c73e18bedbdff766a84c9d2eedf09dda3ccad356d6cc0f6f7a1bbf8edc59712c93dec01686e77946453310f2c534ff7f9dcd06511e51fc22fa90db3fcbed7504937200d467b280da3cee80eb7ad7557e22bd6cdbbdbb0f787807400341065d1f232867692870eaa147d031ae052124bb4d3da744eff41546eeca23970477e01b336ef53bc6c2d11be6da98a4623d860e98691d8f2e7de98dd19bc32c6212ca8845f598b92351d3764d1dca5c42f451e26a7d582dc8e33a1d9599603317222eba8ef2843847f06b8460c0c336083e0dc0e153ffda02e5176c929f23685266719893d62e8a54778319020994d1494b59d6ba51fe0437bba7b086d784c5ef710012f3016890bd4095a75747833de8b6e3b196b160b2f021bab9d39916a4bb0826cea4ba1a012b1d32424fd0e9dea5484cb8249196352a0321b5fe06aaa957faee346056fbb118bf80ae525ee8ebc91267cec0e27815e7352deb4d2413030b1b2964077b39ea364d36f7606762b4110641b4451f4d4a82f3a93c277da5ff2b3d92552c02f7655bf2f136d7a9532b4c651d34ce9ee1149f2340601c4322cb8705e45b9e44e1c734f268e329c602a5fe31fb4687f6372eb95471479dd6d5a72d114dc2904abc92df1327a8aa9edfcd1341f4b8bfd2e8fac291dcbb37b056cb13065c310aba5a6459805a43f7020d237f8abbb73e63bb20d036db23a1d38a09115baf856c2159c3e923f129f8743e0b8554f623ae22408cb15abc11cb911acb25cf86e9cdc2c420ad2847803a7f8feac5d24b13d88b4f65a63e8f66607dec56634a3665e948754b649df52ffaec2cbe53d4ed429fc6d6d135dddefdd805d90b0fe06679733e35658c3bfabe100d36c892eea873ff75c79097ce15e5ba7ad6c2e37162d28078106047a0ae4231af2dd4ffa6682cadb708e6c0286aa3664686c8cfc3dec669bea13079ba56c7f975bdedbf90028075a80744a60f00add93621423bceaf51754153a256c328b5413db02ba472f0adfd3c77bce2d99f52db9976247c1f7e1dd62bd4e8f7591bccee4d44c0574c31124f53b17196a741a3b61831f35008b9ea5c000d7912ca113616d415e14d3a7f2c2e4f72d324adaac7f0a716642badd22752c9c7223b1a0ba0c101f22cca6bc3694bb500070a89340b80174d6370688c3053e3183c13eaba765ebc9e2064dd90e6c0e1d5bd1915856f27d0d93e1571342f607725356be176c611fd408e41f4be8e2e53a058d8a71a4f6dfed7c3f7e4f3553b762ff32b844f6d5e122e67dfbbec88f915e6cb66dabe43dde3e776985e3344b9a76e901ee5a7ce6610127bba97858195efcda9a70d047d7044741246c8e135f9ed338069960df1ee2dc4051f3ed1332653710143f66c40290884e4eb76209d87e5828170d5929bb34e65c098c54e08a872e106ed12d1ce752b236568ba1f1cb3bab861377198a1497f7c91d538d3dc426b4c4dec0b1c02159b0fe15a2379b02afd2e7871db71111e64085a4225cf83976eca3ae8dae3b5c70c020966b86789d51fcae8a1f7af13fa6478239f1f250335f36fe13a6f5e070d8d370c93c60c2466d748f38ee05966fcf2b625caea3d12a228f353a41c6741e026ba9d28cefb0527e97272e13c51a0be1ded7e8b0f970d0fd43131bbfbe6c12afca9c3d08895f02b33170a15e65dadce2ab5e147ed7e1fb2cb49aea0bb6e6be60236d94bdec4bb1aa7660fc6470cceeb3a5e9d60210357e266209501f5293c5c46726e8feb6e6eaa654c4a3727f898ff40ebeac7a040873f777cecbcb5a81899285a88802cbd54c8913c1b5072d731254a87c6b8ae1a551a9c795fad45a25ba633460f9ea11ee07630a4f7c6882434b607ab32693709126e76ec35ee5c0ed21c2ca7304894937a68586e330cf90f4f5b0747408f5da8cdf3e6b4eb91450854bdf2651f8aa1a24ac6319398bd2d7fefcf93186d5f4dadbec5f9a9b50e36bfc0285594caa4ea140b85a40b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
