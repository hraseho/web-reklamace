<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca3068f80021c38808fabf78c61e59acf1f790885c660e23ff28c420bf4a18cb39e4d78de05685ea694231a212c2c83131ddf3865d399d9688c021741a80e925d3d4a782031d297054052016327d175ad32e65625f4521496dc3f88e452e263942c446f6b8a07eba1a77def1fc8e88fc4fcb9698bb5d225e15ec8489b41f419604cdda81de7a27e7eac4c2dca72142dc855543ca7ff5dbe2d37c3588df6d2ce8505d5aac851be73c82c3ce3085fa49b6641b8d1b654f7bda2da2be5dae100346c976f71a50b672fd62beccf11a2766c9c4e3a851c0c8ab5d31c9c077d457aeae051eea635fa48eabb03c1b51ca56066e202f4258d39de8abd36b92426248f8c5d9e6c6d8fd38717d83fd96af08da8d383f56f4fb285945a26034480b837044593d57bbde6df5709f3ce582ea54b16f78f23b505b81198d54b690fb153adf5570848c76aa339058b7aeb959fa89f1ee169fd68eb2e6011a42ac022e4ad93bed4933e61755279e6ccc432fe26fa8f3bbbe2b924887fecd2fa449237a20c8da3434efb06b3f7e2d42d83a5518aea37bbc2ab3c6d3a31136bc82b503232a21a588a3df5f464050429d4cb5d04c5155124d1ab070af4cb5b7b9b2b8726c5d6a7364e0e1a6e2e365d13af2234c8cf79ca2e8c406848357276a848e04e9298cf80edd6a5dfb65c2082ed0ad698c7588fa354bd4558b0148695a87db7ef0dbd8c2b22d448dfaf15de51cb2df692b0ffce2157bc179ba38a93bbf69b8a0fff79e7658a849a1553db6f3c701f582041a700ad68a97c0459a0a8213ad30d4d6c60ede9a5a8ea4e201e4bfde3c6a871d06851caf6c1846a1018a2436973fa55acfd920191de42f3b4bad1d2aff6f9dc35f7e0c5e88c5de8b1d75c0ae6544fae576bec65f3a7d9c990d8f965ed10f18bfae26a39ca5a1104cd42074c27ba549ed66dc7f6a33f76ce937c2b85b6c1af8f31cf1155ac7e6e34d6ac0f49ebf894dff9a858886940087c55836cd7d73ec90bc6a9318f66d9c4c33fe75eedc52d3446f68568d6bdd75f037430e6259d70d82e00e2e0ef382eb8edc9cb5c51e6ac499803ef225d791730a59400757e12eb1ad9680e6f72621430676077f22c80110468ecb8a76fddede61d5d3d5862d598f4065a9f2ceac51811a4cdfadaf0305659a2820da505e3539988030e78d16f68096debb56a83ef0ce144b21357d0d2624c1fe419cd000cb1dc0e41a9b5b7609b17af62559c95891692c1f5a0d125876754d8b7c355ae306cd406c72673515ba0d46bab016d4c2d351d63ebaa4bdc147de2c5d0e2c644a137ad18e593006b660589a5d0326194ae931d8e28ce87bb6e4da69a4f4e62b33602a223bca0868be7eb42ce0dd1e99dd807f74488a745f685600e8d94b0d42bc0dc09fac961cbf07d0afa5d0a1f00b133e85c0f3b6e5adaf00332b8f42a1a8b3c0d3645ea9e6a2dbea42ff5c98b7a3af03b53e107a0cd6bd13216ec81f31e96048bd94e7c305afebfda2c05ccf64de8deb6be75601d81c15fea3ed15999d833e42c552e30b9bbb509364885c2272673104e3b098cff94b36dd955932a0b352bbc5631f63b97b26328a990a285155c838bf6b73dce72c148a00b846918ce7b9009d38f8cb0ebfbb9ffd0cfa9a081674852407b236349b354bb6541df1a020ff1909a3506809116c98c71374df8f4a262b68877b9782a996be1cf4810bca2f692ec1fcefabfc86d24d7603859a9fa8bb5b95631ff58e213142393c3cdbc3cab532fc573bfd7b10048e7a1cfa52e63876d4422a53a2c1f7acfc70b45a470f9ee954a5af03107d098dcb062259128df61f39c412c93741cf21ef1fec544b15e40e7ee13cf34fc5eb9e678aff5c774c8fbedd1b5aa5d41570f7b3db8da19a4b32e8573a7dc431bd85c2ce09c03751cf0547d48cfadd756347132f7eac40968ac8edecc3a9634b4801abe6daab5926902cf8c0c4534f8daeb20276de862ecc0938ff6371aeaf00609d3803f26d6f7dfbdc4484b4b76ddce603b9c24c76d85efa4b8c4e1008a184b5331429318946e3bb649ea9febc34d9bfa088f95a5940f05d941053576d76a5320f15e8ef348ed8bc26b1d7584db01e2758f10ddd06f44e95222b0b57d20cfef037ac7cacb31137cd6652b97bdad581cff9c2f2c8a9265487906f37ac845b5e2d7dda1c0f2a3fb846f4f194f43d673ef7c8e8f1a71bec98a81178ecae90129fe46411bd0abbdf53e4a3ff2e0b302ed26037324d1b5299eb2017d3349c5f454914a33a6511212b8c000296881e8aad498ebdf0bd77d2d7729afd07a1e335343a55c8f68587eef8069f29658193e87e817ab2f47210c803080edf8bf1f2d8f4c42fbe178b1f572590da600e39d9d8a847c50106593eccd34985adf2de563a82457691d3d32f83aaee329f1cf4a99b4f6adff1d48d2a1018d1e93df1807598d8b15a74080e78ba37c6425ea305a33f52feadb77061fc155b96222961694b78321ab25ff2bde1c8dc9ba83e3a261c34638009c759b4014931c47d6eb393a34bee8f5d9bce4a5e62a09849466ab2e822a1388dde15b8bd0bd1eef77c737878150b9462447fb6a1ae18a1dfaba100f67c2db073d4881760f203c66891e0c2a227502851d19320dce052b2db286f45b5100fa46cb173842e0f700f14943144bdba8ba75be7cc2ed21005554f6e8a92a50ce14dea9d094d25001cea40ed1f892b19c1eeadbf357a5f83f81a46c1d8bb16020c665c5f157f981ff78f442827d94ae673d34d94e935f1dee3a77b87265a0cd6e8cd935cac55da2566c4a16af6e98f95cff901a72d16ef505630ae3c8315c213a36187729c6081a3b2c972a9ca2fe73fb234b894fa6a7360f90e92c95bdb9eb49f0a132fa018e3d79a4bd22ca34a9fbda347e343d111928248ae1d49ce59d2eb5abc1b4c2ce258e7cde05700b20fadb8b756faaf19a41a91e31d59f1ca89ff2b2545d814ece5e72806d8fcd59e41d663880cb21ec0e2776e31f96d3fbf73c0924c09956ad9c4e0301b25d16ebb6cffb51a0d7a62e1e24be98c7bc1c193472c7bef3d16499049f09a87fcc81dd1277efd498b43a818253c6166008a38e0ef1d6026359cb2c816dd73139aff29f9d27dae3bff43c0c8927b33df32b8841f1bf318a040ed9a0448cf9f5e53fd98361b678ca2b377416cf072bc3c2d79e9b5bb7f49d4013b96427be55933250da7e20c1a375531e42d208b6445b2e7c163db349d96f0467dc91cfd8bdc7020e34569b73c51dd7edaad9eecab93be996645cc9ba334cebff30aef76e13a737142a26aea8889b3f837c3a20c14dafe423cac311ac1b2f8aa3ff120dac332ec6cd5d896f78961bb328bc1f793690f00732179b4d8722bf14d5eefc0d611107bcf02d068529f6857e8ad3bed0894742bb72d899fd46f5d1ec8c15a98e8f27459a659ac8e25b9c7aebb3916ff643e63d0439836dbd1e09a162a57234d4bbd33753112831a7fac201c3525aa7389908ee13d6cae3f1f1bbdd4b4af6e087bce80c98e546d4f82d73b0ea46a540defa13e5f0ab521d61352f2555685f9f901a1ab8cc1e4b5c48772fff8ea953aeee968d2516b5242d2145d8f17c3c405b5dbbb800f930c0b4d5c49d1c6387e5774a06f718177cf0f5c6c42932831f826fc69d2e2d79f99e3a5f863659d5f9894982bf91ed64beafe9a6045874f0e4937e6fabfdda700fb5d1ffbd8de538ec54f037278f1feb2ff606f00001b5f9ecfa38bda1604502bfa9c9fe9c010891a01ae08f6188971f914e50fe980a52e54e6b5240986c460a9709ed7db06700f035072368fd84fe0fbf5b7594969a4aeb0496a2f4db2f6517e937ce7bdae04169f558cad59160ebdd03b6696329ca184d9642437f339ceef13bdc6ba9a2f2234ff72b0e31197156f0e59a7b4dc40cf9e19e0b3e1e83d7fdf9bce01e23db1eeb73354394cb79d8c30b2fb56be3ebf9c870348617dfa187be29f356759b9f7fb8bd9283fd7fabc294af6668f9a04cd8bf3231551b431801199a5f29d08e17cae432613e948b6408e43bd2633d60f3b93ac292817f9ee8faf9a6d62d62521a5596f389fc7d161d4b24a6cbe9822f9a2f17cf99c0bb9b5860bf057775068c27baf839974b1f5371fb280c8b49b64487c260f44754402519797d70fb249bfbec8be296a7083273b085379a053e507b884fdf38a678abd6d7e3b55e88c19d4fe44774e4f3fc85adc990d414df259b0c9dee85fa1db17289e96844c004f4d7c700fd5bb040cc60d9fff3fc08c0b2f02801e84a638a442e86604cbfd98723e311233e6978fae7d5aa3bbc17be2e19471d29f0b7b27a3ba8008fc1c3b1114035d3cb29d952d4d2e21ba084cdce96661b48ae37bd6567ddf006a6f27f78af22060cfed79cd686b1252b1f28800a2e9dcbf0b6dd138d8dcb8682b523bef7e0aba984c7eb466915929aaf004cde305d61febff66c8a46ade9d31ddaacd0da1ab06e2f48281bab001114f2fcde9bc6975370c1084d67fb4f0168ccee6c7a2a603067561b7d1b7667606aad9811c662423e036eaed31a6b2308858f73eb9fcf87c31a9d95d29c9eeddafa2e7e135b7a9a365f521638a1249588cb8f1e44620ffe13562bc55bbdf733870c9a2e0e91b98a32c64bc5e5a8204f782ec2349e20da22886caa62329bc20afd8408a9d65fe44677cf4f1fcd84c43b524d62ee3b6364ca5af5f3a4731dce2816411d16b310653bd668d94c9548ecce363050ebf295d06de5d7919639d1957b17d1df6cc024ac9a48dd803a2a320039fa34d4f365d458e1e52fa5343372c3419de620b4dc86015fc6ced0bd324c8f43bc57f139545bbb5a0e4844891e5c0f2c2ad128752bdba4fc87fac3982fef35a1106f80a6b5b46e5cb987918f0d4a20e2bd9efebb3915903548f8521e90f017ac58f64e9cefcdbcb6ac91019827d2cb51045186e2a89acc7549651231a277b5a1cd5d386b12559ba40277d7a38c1a10acffab8f4e117573605ab7dc434712775ce3758f7d1efccc6836c732df57704434a39413e02b2aabf3856d14cd7aad22b55d10e28b47a5eba1ad030a898c03f3a9ef9c9a2dbe7354e863ad86f83a70dd455cefd7d1f2d603f48ce44ebb8246f47540b62cd6fbe0fa71f14cc5d7e1ca45f4b52431e218f6df02f1e326b688fe6d478c1fcd93eaa382c540c5e59fefd89ccde719e9dd7fae5d400b4e19164bafe29136f6e790ac2500e0585cc7eef06f358fc09d85cf22d4c5339f6425efab4f95740405c08d9e21d698fb2da66e0d9c2878e43a5e5cd92f8685cfb69e96908fbf32400b1608e5f697b74bdb15eb2d6d581cda9e64a99b4e7c929dd8be92cf2cf715297e5033f87551210aff196871ccf05a18798dcc34710cd05a5e639d19eba65d0a1eb431a3ff07c8bb3bbb95fb6b083078269373623143636a8c1473ea138a3f6ff088918dfff80ae6f3973fd7ef8646918d27a7de596577dbd88f79f7d8583271840e02730027ba1144593b9321f4b6d983debe54fb3ddada80fe5f051a7c97f18b81a0084a38c4d4ab50ca52d4335ef0282a774e1336e26b334eadfdba4daf0314a3a026dae56c9a971374fdbec1b6c371beb83460635da3ae978d370ec7e1a8974b76e02a0946b05188a3f847037dbc8a1b6c3022c367db1986f969751b7841bc5d1e08de6914451b0b88ed49f1f5f448629344fa73e5a7d63419f2d4629238180331ef8c90729b16b9735fdb45fe370388d3b57805449d3e0100ba631dc3cebcbef7c28b21149bfd22622609893f371ff5c15c60f2946e6e57250de2f59fc7b0b3c49e82b9dde4e29d53b13e2f10a5dfff83b05c1182634ff5a581135e94fae422127383b5a69a915072e93a59c8e931689c725e1284ca260b1d04c6040eb412f30c44801985a928b56dcfc65166677da1a12aa0515452850c6ced4847b31537313552cd792572a00bcf7582c157ac6704fcf79671d2f3f6bfa4898acb78be0ac958c1962d0a2047756f32ef7eee1920d4894aa57337bf27ef9e9762e2b6a0b01e8362fcc79daf9b40b89fcc42d4b47bc107b0fec180bc164ca0ac5bad6592295c5fcad908abeb737177063192fc710f6f1110422b3dd0c137dc8f8142d41a6df475710f326ad1c0e3839a965f31cc980cc967d698e86788662cf4dcd549a8dc976067adee911c625f15df08f044a2e55647712166265fb01f5e40b8f5f5af3a6efe437621058a32f37d258414c288adcea04c0c53a53b37918f663ec137834378bb7ae3482044c9884e019eaf9f8b9b0f8e7926ef5800d4a1180150b2c73d62566005fd5c4b74abb3cb9b1f94b19038b094557d2353d1179ca0aa865ed3a2399e11863e4c96905670c5d9f9f12c0a13bb6633239e1fc088cc21415bbc3677db14a3b9ed78fb6499d4719a279ddc367a600467e949e8c404aeb094549049395c04b0af8ae00d5e57df06ce466dec17fcbb129109d0be21583529045eb98145da9f102bac4f8004115da69e483cd765c13a8ab13526dc4b2f976f164a433b26629801c0bcddb62b13e6bfed98adbf88453c883501db4289fdda132d8af80691732b61f57b4a8b7fa578a8831f25db10db0fb74bcefbcc256632c87b7eb1137a4541fb6cb719ab5fc98d04630da863ea720e47c9b530a5902a5f2bb175968f9412506b5e7a5f0328db23231a75b2da418616af2a4205bfeed4d689b76fa6b56125100ead8b2d171e544c411872a195f9638d255ea0735b21246d92d264ef4a01c414b997ece77f7b83b7a3582609c2861dda29f49b6f691df811c6a7bd0191a6f88eb52b385002b1f251ffcb0ebc2fce6abe3ab674d2aed472de4ad672defe8e9dfa72111eb6d2e52e76def68a3c9dde4c75027fe988e7ba2acae266ff28bdeb5293f3cf6731172397cf85b57ff7fbc412c01394f3c16de7d875b5b0f7790c621920a615a7e17f3a995241cc47ae15c5d94ba5b361f56f3d27c839efb246a49030d45154c5774a44e6355cdf4f0adbfc280ad63a2dec93282646f92c0c6c0585f995de4e742ff9419f3b16ad77cb2da5d7fa26a0e27a5fc0d7c38644c54f0ac76d051840b3897d3bec7e82809339b7398ccd13f5d3bdf117ad05a0ead636dc450b657832b945dbc5990f063fef304aabf1bed60bd1012ff9626fec9d50f9aa978c564a436143be755e8b7d869f2ef3b49220bcf947fab8a1eeb29c999f091fc3e1b55b67b019c6b1b81a34aab4766fdc0bfc241991788f886d05142d1e41a13a0218d94887ce47464376926fe7eb3dd0abff2d8ae82e4f28f6885b50f4171cc50c1fd17b3f7380adff862a9c204dfd6fbd9d6d665c152f38c5c55aaac41f57b5f352a9fa3765d3154fa4b5d34b925c4ba34078baf6f33a1e9f744624329f491a146b01a064a2ddce3f43790318f45b8c48eca0c19c02bea093665f7c1d7f66d0ad2d1d3e21b5b70b2f8c22e783b25ef800f0e8947e7a5ef7c500db95ddabd60a0e38d773256344d8d4f7dff6e983a4c1b6ef39dad7f2e9768a23000a384425445e4402325a27fb2733469e48a3111db794424f64aa49f9be75ce79e6b2b7ab32f7dc9773a40f52f955dd5c74931d170f27454af37f531630b3f178fecc5e08cebbc1f7d7d33eb1895281250e28a017a2d167abf6761b665913ab978a3a54d0bd219313bc41fa69c82a3225f035f0982a5f5bb9948c7b8afaa1b8dcbe12a32b17bd4213fc42e5d387b6e8a21d0c2e5c28f90446b5437c937df1bcc61a63735a6c56fce80c445472c14afbf89e01e941f47b7151978633dca6b95c14ab2c5a69303bb1a182f173282bcfd72734582ca90f8c88ee8481f78869f09b7a16a9974c94153276f6d81f0b97c0e081af387bf4d920b3dda9e54f45aaca7f287c87a5fc6bda405083b44ecc43ae662010b01390499b87222f4f8f1a113955a3008c75cfecf932b5749b2e222062807ecece04a89af7cf677cb1b5f7974af88c19a4fac2fdfffc209db04db515b60b4c75122270466a76653fbbc5322ac3475b21e500f9dd14def06c28ae4acf202e34ea307c9631f94ac155d71fc338ca153d450fffeb7014926984323e1293013393afd013b8ec20ae390b135cc33236c6d1d44cb3b616ff9dad2046fa71d46f3576701d592ffa1d62d442069beeea0e87c1bdcab497105048dba4ffa1401b9d44a99794e4feb1f32d51f0917c1ddc9ef89ebfb0f3ee4157cdbbbccda0be23bcad09ecde61af616391cb70000c4c3af7b3689b634f26d61f40af88478dc1b454b81cf49377eea85aaa0ca405845425ef90cf5e5530b215d33ec4ff89bd255ceb0aab40e3f177e9fee903f062a3d4689962c517988c296b25abdb44eb8b4d0117109f41ef5984bfc2b785ddf3d8c58c36cda5a2b317d5e304903810c18d26b62e9c9d9395a9b72b0fb93e683047bc337c4764fdeeedb5cb31425976458cf7d747acd71105848ded9d6856bba3f651fc7193551d681dccb7f23fde83eb167b66af6f21a8671044163bdc9f4705b7445b790e45252bf8a2683fe0625cc833d7a80f064e299bdd38d8230a5bda1bd7c9a2b4488fef0209d3e665d92ab1402a4f7aa1a5f099a097f9c302f71272de78e8f9d0cfe39c6fa233d04ae6ae16bd2c054312621749a838f89c8ae6a9e83f43716f5e23493db53b2ba7c24fc30d15d1e3d51d2c48e41b517e938101582259225a93e0a993960b21c4717d613e17c9af4a0bf7a071223a26b29e89c0ac67e12253b2ae46e1c5a421f21d4bf54fec733f5b34e3fc386acdf890b96d6e5353ef1697ef5250ea944aad4b27806a863b887d9c38a1403db6959d2c2d374e46dedf593f57761d4c0477d25bf9933120b0d2d06e04f689a203fd7a32930257b44f22611aab36aa3f9c221f757508711058338bdeaddadb225904b8f08c0fb1ff44496827741f6c4847f9c2ad6929d38e7bcb3c0cc49ab47b4d557ad5bfd2efa8ddc3a21c4bee5821d1ad0d672ec795ccaa6cd43e12fb112e4624c5057b1cc006816b2ee59ec5fe04675dd2c4364a7e4bcaee881b4ad0b8b9e309f6bbb0127ee4df491a4071a2c9a8fdd8a788ac54e7385ea3bfa0f8e27d2d22ca8272e75b8123a447a5c4a1bc50e8d5882c751c68c6a328c5a91760ab775284238933d9205846267dab64686089a214da90c106b75403f19a19704828089d1d840e74e28350f92864cd1b5926de68ea4bb633d924623c58b6e3bfaefe86605b1a6909439939e1f5d45025a89177a60c3bbf75a56e1f752da8eae827d983f2d3f1f81e9098c3bb15a6c824bbc8b65ff798d124a117197cd37550f89e0c2d10c887160bc5adb381919601beedcbfa61418dd41b9b41c311e21278e86e75a8d60806d629f268d58cf79c43b64736e72ee3e6db984508f064e053747b7bd86115edc1d95adce1770f520708913ea399dfc393c7dcb2189fca1601330ae4630b0a91d376278b509ff42f5a3227d224ade6937eac8d3053e02cccc65c133da426e6de914efff1f45a6a65c7a5284740ae3f25a4a92fd42a00e8b38e885c00011873c84ce27d996e0860623d9c88a88d58e1e08f9751dd2f2791e94bb634507fd856bd80507207b44427977c11defa865ce508f8674e1e87abd4833541f34a9ddb43981d12331a0a5f32c15b2168f55f9b50817b50db79972cd410f08271632c36b5c462e2b6c3bedb60bdf56850891f782b1a2da9813554508771108bfa05bf7bf8c6ecb424b014d585f62890f29b0b4094d40fb5a7455223e97b375ced5b392344ea30f10a0e5ce095016e26940fadde744b1aecd1451ee29a905f5153d1aa264582b40a369b86102dd3da62e86f5d99a991e563a18be1a1be41327f01720b66c189e8fbe3a2b7fe47a50868667fa421fbe6f4ec670b52a9c237e4728e26791c07ae28b259841379bdf9890db2c5073541de7a7bf956b6dab223cb924b061da73d297d03087c082a188a4455f395ecd483d096d6fcdf1f5d53fd07cf2636e41b9c42a856a8a9c9c6861c352358ab1997c03bed9fdcc1b2d8203a194bdda9719c83c19c2f7c76701605915fa9c397c6ad2317b3b2b6437557637fcf648e17d05ac059a97844159e8635704792162e9835f9a43d2fdea5328aef8fdc974796456482b88ee8ab705fdc1f1b746b06c62669ff6365e482c0134e19af0446429e6898ed54d82591813d205aa0407c83d0e13d6e4057edc516f5b118a1e0885c83fd72a397a38afc715077166ba7485dcf5557f6f1cfa30626cb41417599ee00d5ebc60562d9648b973c9ed754cbc288bb888ce319cda69c5580af66c6a45947d3decbfad9c34aabf639fa5f46c97c31fa2921844e73c756c03d961606a29ee952cb8ccb5bcb2863fa2a2919711206432bcf168b5c7b1a3ed1b7651f011d54616fef949d7cf3b378e7869a4dc89df863f2f56139cf912ccbd14c37759dd63f39d886d43b1c75b3914db546f3b601999844607f673a413f782cf0e77ab39aee312691e2f418d644efe9d2f3cb6eb7bfbd1885785c7154f8c6c34e5676c01e1ed7e6e3060ffb873c0ff9ed6977ba89f20bf7d56d7f83393f2b1e33ffa7bdd32043f7a6f0b813faddfca49d80746844eb0836e37cfc5cc3dbdcf2cb86178b976507fe2aabdec989fc53c8b4eb2d252c3e42e4c218e26cabad92eb6adc7ecbc125a8b8599b6d6ff28f66418827615081f0a40ad266931419ee28910cd67f6cdefd3bb826c418644c57a97801ce18a8e3d3b32408de41c8a9f225a35c722bb1ebc4850b6557f90f6fc7b20a6b088cde7de34a4823fefbf0839aef9594b2c96a2311e1fbbfa310c39d7656b825d96efe8204c339c26eec4fcdf8bdebada6dc11525484866ce4782245ed86c219e0b68cec85ed335c34bef21c8b04f5a4edc46d99f9df9d0d8915ed8232b35ff627aea63e0378271edbf2b5a36a42d33b0543eb864aa9b77b6ff648a5da944436edaa3017879fc2594ca46c8d0f8909c8bad59bf9709ba117ec0b39356b132d33634ddd8112f2bc5e0de96db367ac6a6c974e7c6105e99a6c75ee53f59dacbc762e67a13ec1f464a1334e1106a9ca747511748789cbb02b798b1b9b9ff333ef01611845a7ac9b5a1e3de8b73432596ccb4a1da3685f33a581684fae937952bee6e3b74e45c3c2720e36e047be817c4ceb58004ad47c19c72a76812e496d6be6e09a4c74efc58aa9eb657a97f37e964f03ddb7b172c78fa0de08d8421cac6eead833a1953c64b0c5b2c18576fbbd123ac06eb936c7c4a1f940101ad9de4c0f3d45d375a064c7f04e8db8cbebf2583f5bf87a8b397c30fa57d418c7ae2d820ef28eb2569bb0495f34761a020d257420ded1dfe5405041187ea6a8aa5df6e18be066b4025bc75a49f29be8b2882eafb2b696a96d43fd247973ae8df230111a5afea9291276e67eca4b27af8ef66f41c5feb7a15278259e532a57cdbb806929f195ed0fde7272cbcdf2e0280a01997ba95b1c0a4e5783f541877889a95f87ad16c63a4bcb92e82093a30b5f8665624a76f2d789aacb12f4697dd160adf6ad2c14e0a4cea1bb151bd3da2adc12eca0cb2bd52a5c9b9207cecf4769a1c9e0610d8433a28196189b9372b2ef5d40f4acaee5ccd55ad1448e34b921b7bc68f49e1d2442b223f7555ec8d3a28c0863e2a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
