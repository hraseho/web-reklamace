<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2255697e49488f7060842db32160097c6c3922cd14416c43f33a17ad1c7c9cc2b3e9a2e09d0945fe78c28175cd26aeaf9f70312008896cbbdfff4a5067ada787f8c68d462402819c0e1d1fcdad4fe441bbe71a99a40447c7e3da6d2d5b6ede26416263baffed2063ecbd549b71acf1bcaa8171de800809361902204c80148de8ceb0c38471eb945037a54e01eb460c16e69f68731f126eb8c20c648b42a9df55cb7336571c343b0ed0a828213cca3f4d71f16a3d0d656bfb77b1e6869c5000e5b8dd244138320f16dd2d4a99345a3a4ea7a33f96feeb8a99a1cbdd0bee0b2231faddfa959a8d860d6a87b333dd397938dbd25c6226c3431f1fa8d90888ad1f2f2779c050705c6da4578e95f2396e30f987755ed896cbee9e3141c536f32bb51fa60994b5cabab4f278789cb1f5584e4022d3408fafd644bedac59c74df2b392cadccf6a19252b85b6e0eb89d533a6661ef0851a5acf2edb368b6c8430d567986fedc3fb8835ac5cd0ef6c7deed0d8cb8859e999f8fd629af00ff5090e708fcc351695434854b30eec7e6b8c938756b81b3c1153e6136f7303b2b74a4232db400b2c606ee0487b29fd4600cf26549514cdb2ca54c2f668109eaeee649b32c74aa170a526bedd1338f06c8067d8faf1ec0ede7f52cd33bdd74a870045d2727d22c4b7dc0198821af20b3916f8f971edfc6c7863e204126178b1293cbbc09d1134136761473d07dada88e0b280b1424192eece6be1f3853335a672e88c4c204992f0804e3b2c7f06bfa38cb84d5b55887d2221a70bf497083ebda77e71aa2c64d9cf38fb92a819ca5c2c2352018bee4e35a892cb33a3acc5ee16ac41cc447025c7399d62000759d89561fc073feac1145265885c598178f022e3bceb1e051962ac8e0729e82556f74a05e8bea4f44e6e9357dd7b77285769f976c286566a3dc2a0347b38d33d578ab5962d15ec2ef4d3e8a7f73acb6000b5ffa334e0f69ee15009c10c7470181480ec42ae131061331399992cebb2d512c0b95953e3f30b1174779062d821c7f0bd7b3f65322028a1082fe5ae021657784023e17355499c0d54bd360abf812b2281f12eb1f577202d7ad541a5db844d7ed962e4a80e464b389a2e00c19f8e108ffe98c4c4453870e8b884d30c27959084cdcd03b345c9ba9ce6da786709185af00c5973680075f98dfdb512b181771bba6e2c344eb274b16b7f935ad07e00b48a6b204ad9ad1ee718bf478b174b48135476508a578f37e790076f9b3205afdbed1cbe4c0d5584b18ebe701c69596a0e0f968ae269667d128ad1f12e59dcc5379b4c2e3c6a9a904c79ccc391e4d9dd249fb7506176ee8b578c7779f4223d888a85d8f890670d6c75f417e0b33deb311a5d520a3f15cda01f5e741851931fa7a253a8a2d524bcbf8f286375b990a4e5c1bfa25d4d07569a94694e801fa6b59863b61781d702cdf87eca9ea9a7d4fef3d26cd82ffe2a027ff6347584ff3a2f15bf5395a0fcbee0d7281009c93debbeeacd5ed69c606ddff85ce557e9ee60a9c0cc6fa6e7dc19e2f6d44a731983eb3e6db6c53140f495006eb7fca4325111590da54f6ffc6d237c77ddb4c4a0a6cdaaecc82827d740279332066a26c5517bd49ccb72a23f7994ebaa02cfccf6ecea67f4e650f11e11a827b0d3aa249e12b2c53e856ca25ce8ca121feb1b752228152dc9722f8a630883a6b5a037d13b9b989bc74388ab01a48f429a4ec624fa1877402c0b8ddeafb8be28ac158ff004e6506df21eee847ed275b4524d6ae85cd5afd4bcaa8a89bbfe710048c8da92cc551b6f4324d7830e8f89b691b8a86e3fdf22d7be4a105af1557a405b6cc5d30c5e9c0c28e98c28786581e47dac1a6767e10da42460635ad40b1d5cbb822a7cac365c315740227be8f74a79f3afa8731b2f133b8ca0fb88da85db8a80f215ef159850dfab48d52db4be729ed60a68912c4b39418cd5bfe96fcd51c9d5c9f7c3d361f5599f29bb00b990aa5c67d20fb852abb529b080c11aecfd399fca113fcd5b859c87990ff09eb41a7290bf7bf9ceb106d37eb5cde3b1c64dc0dfe385afe7f71847c2a071223fda4a2a9d147fd11d89c256fb8654417ae215b8e624baf960cc6318a57a5e8752d87daad6d6f7e4f6f487b183c86a2ac730ab3e97661378fafb9d3e499681d66266bf9dd4a9bbcc7732b5d7549980b50006a36b594b1cd0283aff6ac94c9e2d8183370dcb06a42c564ecf5bab256b704ab6ef2a66638c82673134f2d81250f93dbf47cd810a7ad415bedbd6faca12115e51dfe89d7480eea82fd9e5ac2a4809b96779c833671f4f1995383ce2dcbaf10315b663ae18f9f862f096c51d6b1a60d68e4f2e1c9ec2f2c1b76f9715f255c0d97c0e991e0d767bba7491a19b54b75f235aa6aff196522677cc6ebe717bb7183586108fceb3c2da18a82216245d314647738e4e4344076559dbcb3920931e29a1a5ea16f201aecacbae49bdf862a149e6adba92f5242850457b0802605af1133c8ca1410c808123eb291ae66b4a6c6ca43867baab0efa944bd320e71135b2f3061bb0ecb46b8e850c3850a1ff3d15479fc3113de417425bf2dd909825b7cf13aca9bbed1d4179d0151de2d3febe101bf0cfc61209d53a9d88939b02307a315f11e6c09230b9a4d0984d9d02b8e7d73e9382cbecfd3745769113d3d79951b2f2e872631882224ced4ea93c8d81607dc8531e1da1f4fb5a7a28df7ffc0eb603cfe730793354665368952d1d1f838ef9dee1959a168f798e67f3ee412fa6661373e6c1e8d4ef2dee8b6bd501cd7ef76ea1854b1eac07b82beadd67b6fcf90396fff6bed6a0086f6c7897eb9becf5532c4b15b69ab5612989aa1064f2779b1ed95a416dcd0030fd5d3212ea573b9f690302763a5754a1e9b8d0f573e5d86e909b1d29d2063883e57e81aa405007c9584677a3b2c108574c00b56743d92ef02b44f3709699d6e6a8fa95f4b8fff1ce0438e0b93b72d55a6bad132381bbb562e69e837788773991daa04ac6c8bdfe54437425d253987b41dcdff49fd7584299d9bcc3c80baa7f1c4ef4181f88d315e9e973bd81c8f6c2b12b7e2a169f7fa564548ded63a4c65753fa338b046af0a7c937ab2fa738d7c244a78e550f290780ac7d1d683c8e54a014cddd20b1471c1ce3218814e75e7a09dc8f8319dc4f38525b1bc0f302d7d475a67ebd1e337c1c6379e508f8280624e6ed0085ccc0e9bb5a03b4756b4bad428c1d8e66012f53f680d8b00d4c4d097f1b2f00289e89e3f9bf2e546d530aa6c72704b06ae793dac3a3f3d12d96a7564fdf834e936b96b1040d71b76a154317b00cbc328ba9b3156c0ca30b1fd654fa0594c0982e1e8e29e45f5973ce10c079dd13e3113cfb285d743d9a1983e5532b369a29855b5e571df92655a2b92098ec4abdc6e583f892ca533af0f58860533291866b35bf314b92e4a9fc774a19ee8f4c8d29fe0c1ecf7a7d9bad35720d2ad0fcbd64656504dc852610fec7f3d517f4c1fe06962254f6c4cef9f078630924f1620f30c2f088b65fa5512c0e5f2e51f9dd89dd08dc17a3537a43c443b0fb3799b18c9bfd281bc87b1e93a7e16354501c9869285dfb265dfdaa1817244008e1337aab09950ee3df101108de7da674f42b87282180ee1a19b4178b28d9d3db8f7804618ca4bdc567cd5410f5e9c3c4746cc2fd94f368f0b52dcd47c7349f8aedcaff20d6aaceb7c15db470215039b51e5b30a669fe69cbf31aebc56424e554ccb7674994563dbea9557fa599b95c31ebaac8b82a899fc1274e295caee241b654d4589ff7af3976b8b9338ee42c8674907070c6dbbddc134d51d55ed940f676db4f281eda217c21ee4f33eb5f5e0666b6fd0dddb2c569212ca9a4ee3768c7494ecd6427bc2214d41a5cacb68f547033e9b1a4f8787bfc7ccefa23699ca65f366397c562e5b6c81abcfaa6fb700c7e475bc583464b90dc786722365a291e98a5ae2f29fabf3c0aa78f2ad967c92398c5a5a9d80ac70017f799a0c9d798e4ed2d12724aa9cf7074f4e2563913e5a1f5def2988b14871dd03d2bf07e4c8e835686c65cb276cd7cd98feed26e0c577f17b75d111b31e6672e07a1bcbdb63e17f5c69e0d2b4bdd15e8c2ac35260645dd95af5f85bb2886017b67621252e6fd676e2ed73d6ed0e44e12dbcf9fe68bb1f874adff09c1fe5030e264cb8baaacb4f86ba5f636451af8879c51e449cb1082c15c8d726869fda84fed49f455e3179ab99acddde607e938e71eec69fbc6ac90e16034cfe623ffcb56ea9cb42f33cd9e4bf21a0680751aae28c551820023da7b1461ec245dc679f51b9ce714773764c433d17c9959e163cd1927cf4db346c74d12a6209ea9cb116edfaea1b1228de4b55f258467479d03e002f5603bb87db39fd92e5c53e5596adca11da87d9092976874dbe108e6782774a62671c9998071ff173f6f92d184fa02e14228e8dbd9d565f905a6fb87a3da5c7440c1136d7a54b5b7bd0c6531e24d0ab56e2d1536c5a528e89d6cb892606d160e6372384bccf62d17b8780af97612beaaa324a40728a21f3178f3c9354a75dcc2a722b4952d12c2236b43f5089222caf4221734bab79c9a6a4effa85ecafb22dce30b7b8e60d1a7bd5ba85d608bd84f7c68319e759d75e3ce41c84b601e567bb58c34d76a9b029de1e30ee6adf327afd860c3ce444dee00a288ed2b62c6d6646d364eddc234b9ac396f8ffc94489082e43ff002321bbdb992c6e737c1feb6ce56643097691a2a69511e2e0c48570d58c0fff50db194380844c0286632a2ce4de5e2a81ab443c894b6b87127f0bc4a33291271fe3470be7ac59a87229a5ac3996d6ca8e0d8b9b8c7573f8377862314d75d87e322c343747ced127b1d7575b18921d2f848e486c568ce7398c4ff724baa903d32f0aa6935ae71101cb395ad84e2f0b459fa979ca7616ddbfd729d5afddeacfeb3b4b9abae1cb77416ee9910e0762161a0746ca9b40fdb90fedf3d0ca448d2bb58c9c7dab98039b98e8117fd23a5bb40af302a614b86f0e010d0754e6fcd6848984f9be76ca36cea33c9438c32747e1d2b0f3785dbc13eb11436da4d9608192bc44964cd1aa9629e41716f5b4aee023aedd4262a4e5db434659e456734e7a5f5efb6a0dd450fea4fed349c411901465dfe1b45f641a46dab54a987d8350da94663347681a0f2d3cdc3f0d97109c7f8f8f435ced1877630b185c4f04ccdc316ea483a68df4a90c018e2b69079804fc3084c73bb9bcfdba3e4b97d0dedc30474c593ec6def903e97479ce2f83dcf504561eeeac04f21fe38ca859822e48e7948c041479f715a0e42457216560c90fee7c9e659061206b20876ec9dbb6efae0f7a8c4adf3838a69bd3dc778a8f5790d888301d2f5f9f2b8178a1240864eef9a12ef5890b89e4234e29a5e1b27a5a3ea5712ec7cb68edeadd439bfe0ad6dc2e1b97a5d334b04769300a6640096b5e6e8d2a3ce829f1cd7399243827cb83ea298f2910cd1a373fad89de4ab51985e8b8ae3b92e12cb8a285bf820e51a3b2a9dd489d0ab4b3ea5596f17bb140098a5f62a26c86d8ced17b33cda31042cd261dd9e1e3c27db5b3d5643994e672e718026c0056cb60efd6ed8fc7f3488afae0aa28da009114f46110ee8ae83cedff9248003fcb5ee27866a85f0ce5b574f921a67c80e63dd4b68d5c310aba5e28bf9f3b9b6f915bca66fc7ce1bde5306e09ca8e85acb0a2373e9875d85562a7d2f5bfa54b94b1ba187d0b115fc808ef2141646da7d8e4ca60ba880f98e1fc76ed2b2f50647a9adcfd5a39a9cda1a702b419505139e53b54ff78f5846a269defaf0681e8cb92c9aacab3497d1bc1ae393f5bb124a6ec8d3f4795a7664b6060b0aa3935cb708b137243d6a34d083febce98d05b6a61c3ea82948de2c57c17cf607baf47601da560a4ab59fbdf94472e8fd484686fda571847b54cc8aec2dc32b979e5775e035981fe2c7306b00db2b1d57a58cd121d86471a8458a73654d031bd0a9eee0ce772666b10c1169cf32c90134c18fdc42cebf34734d373c11583e5c1f3202c48cd46306fdc0e33de6faa2580ae715cf6ab81cc4d1a86490560058219f94f6641b0fb80557fb6d7e78321b5173ce69339b92018e20b9eff15890a67d9bc0eceb500f77876d8dfd6d69c76948f10c86e1c1b1663fe52c2ca138ff2c5a50c2bccb1ecac5b319dc3a44e14a513ee8d7e9a4a3be04b6cfde2e43709abc421f9794c689384caca65757686b55759cab326942493bbacceb451086d2b5eacd3a3d5403ea03ee2f67211e883fdc1ca4a53187cc08e9f5757a74aedb06a97553e6e49bb2b29b664b5c19ab8d8872324d44adc974573a4c29b7ba8753eeddbc8b1fe0991bc2aa672f2e3f54f8197c954425a38b505d13411341bde7a9e088c04702d76bd53b216efc5c98b3cd4c0cde2e1f87040c9f2cbb2fafae88231148805334955e3a385a76d9b7163a90dd99fcdfaa5d5c4c7e9ffb1582501cca35f8bacd3c2a7b8a2386fd76227391b919472a3e45e89f78d42b0130e6b9c947fc547ef2d71e33fa9bb8f5986b1d0807e6e700ee512a65470ad02eb60060e1213c543c00c9f1c3e50cb2dc64719a4ce2c4c605eecb0411c3dceb0d9f60f16bc3045c1ddeab3265e8af1ea53e4712d1f44e77fababd8018fc3442acfb785f367ded482a80a3d894a7b7c794ab7d909d9e0ca7e708d53c3f87174ab0de2a5e12ca0787ae97e96ed96220d540d9f69fd49bbb4bf86c7e6b6ab44e22108a8d00f5ede7c2a22ea6436e27c95fc800cff0ab6a235f591145a2c97e7e51d276d8dea0b9c1e7013497e8b6ec785db7d7ba3b9bd55c5e8500a60ecad2c895ce81c9c1f470dd4251fb8d4f971f86b7ad6c54e0687c30455d2c6c4caac2fba85801e885bce5b26df79286c71733b1456d1abf8d07e810fdcb13f186b1797740d881599e73327cd87ec94349b28a8790bf7c76a0579d48366d98ebe8da80e12c64f973421fcace7bb122fecf56b375177042aecffba480612c6719a164a8785b274268043b6bbfe766a05c2e0cc0b1aa9aca720be72157d38bfe577d37c86a184e1f7c331dbe271bda1bd33d3caabd35aa191c9022b0a40b70a26d5fd9d83eba1ad32bbc3214d0641bfa60d552608eddb20e0f073b8be025961abbf752faff978dc939c15db190d4a9d8a569054f46574e027492e215b71195d7f030d14c587988c12de178d24284c9114674ef85b2fe6ecb3cb21d28f95e6bf0e95aefb297f3e59a5be358553e47731c357c0534644a68e5f6ccaa04ca6abae80f7326837cf45f29f2bbebd9a61c385070b41445dc7065a2fc1f6a7363dffd43e6045c9dc5ae56fdd7a1d61eb30348f3972f352d2c1835730b0c573e3dfd0f62218d44550eebc7b9b5843a22ff21c6ca042c93379fa00e2f9f979d4cff511c745cc27f5c8feccdd0dc20f0d7afbd4fe7176c471c1e6ca79fc53cd22edfb3d391ac496d2b601ec987ad3fe5b620006ce2810e15bc6fff4f6cdbc5e0701f601a400120a155b4e4f5fc5759b19e5abf4f9ac9f674ecadaf63182eb59cd6e9a6ddd86e539b2340230e9ba8d9de5fdac3ae89f321da61e0d34e225027166d702772a027a0d813d088afe0cd471f18b23765f9e1a19089c531c8e267604bae3c9bb462a0ac4a632545c09cf20741362fbbd585b287637a6c76362c1e27d5f80b93665971a68394482cbd8f3a24710f09c313bd1959220dcf2efd75f7c60f3a0b54b7b1719fd3eadaa4af525e6895afa3a67af8356ab4e55d3f34519433ce57c70cde80522981401d4bcd0451d3b7721d6ba0e09b232e712ed7fe5327c1ae4941d32969119cd3af99cf0819fe2f3ba9c7babd8c9aa9a4a594d21ba6513eb870f42962ef9b9575ad6da307d19596993e0c85738807fcb1493f7c04cf772f16f4ee5df5d721de395c369d1b9c10cbb7087bb11d617df605e54dc470739bc615231b37b180dd6c52b284d12ecf982d5874b63af6eeff1a7aefc27f7e8971d1701c41e1371b0aa4ad2c9aaf8d431b15d9278f972a685ba480ba2f07d527033006cf50091db56d76024750cd3db57321c715a2d1387e55268b24fb29700ee56c7019c3f9d127bb9c0b54f6ac86b0fd3515a7afddcebc73419c265eff3d0aeeb24ebc9e9defdc5aa5dfc40156e793c53a4a65805af002127b018d554255e92b1027c683108ec725a75121a482333cd67f84cdbc97c045ccff2f75d566fd2ea84faf0770a5601a0351946da878c0e18e3e6e010d5836fd5d80bb1121e9e5ba4c0fff63ea67cb9bc721d6d85d792e2695269240bd15b37347c2c08dd36db641835dc17a51afcdefffca3fc63333f2323917828fe26e2f0fd5256bc562fd1c9d75ec6151048a7f73e4eae1125e07b350e1e2c3f5f43c76359bf4767d9b2dd037f76d22713a3a46b642cc97cfe6da3b4dffdec4d807747605fc3ba0d5b56d9dd01fe1bc9b149fa75f6a583d5349ec9c5b7b33b2ab009d6cf7413fbf3b87fa5400e7b58a699239685c11b15f2884e21e08cfbadd2f0945a712ab9b064b7db52abaa5880883fb661671651828e384bde01201cc862dcf700009f623257e44a95b3b787fff2f30f8cd4bf42d48a942d55d137e4e2c556266570f534f135ad06a19d041fe9b6057fe9d13fd8a653b595e940b0169cead212d92c348808838242ddeb132ca7991714bd8c24539e2296d545641a0cecc22eda1af3b0ace8bdfaa14476512d120da3e3aadafcbf56550e3e50caf7b674e8e3d10b55dcec43f1351b6bb8c8a31c28f98856a89f29a43683392594a6278678107eae1f0a8ca201fdfda05092f421c64d64126b0497ca6466ff6aa0317e0d23e7445138f4e49541d803a5648f6aa53fc97fa71c2847cc896ed1f70c27ead7ba5c7031cccbfd712909c4d3ebb1e1cf05dd7256406ce43ea6cca0f097b381b8fc28ba9a40e94e562b19241ea2f44edcf1ad6381dd1a842ac628ce5c5422a8c22398c2d8944ef62c9ef3e5b7fb08dbf7ea5140ea0057ce093003e566dac1cf95782e10c91b621cbd7ae5eab521ccc353783f7dae2fddd2bc5c0a0d5deffdeb526e00a0a9493bc609f88a016adf9af4b5767b515b6bda1b7f95f817c77aef073262b3bc91694e778f16d599c6c25210ae2d23eba525395e2b3b77b5f8ff6c0c2b6610616832368997f89c19bb2632b40d5fa60716f4bb07c67a9e49e0e5d97a15a46b5e42bde859381b206141aae543f1ff75194413d320ddb4883de63aef577a9464f661496503d83f5c0d7296e72498a345dae4578590136621fc528356eaba2321d9e48c4a4c249ccb433ea2e08c86aa4de312721ea4562f8564b2ad4538676b77682ee511574894e389da60c69f42096b9f08ce4c67f1f5c5b184c280b20f689e28a1572c528e6d04da62b2b185f60b06627c24047de0c77d6df72dfab47b6e424571043bedb5900e2ac63c0d0e2efa8b4054cf52055d10c8c523aaaf357a7f9ebd4f391625fb861c13b788f82f760540d36393b074e1803d19b3c586f3e0334e452e1967f5509ab4801fd1fc634a2947367542abf2194e448b7aa0be62c62f0234d72fc7587a64912b5e93ed0c0d2f09b4e0fc18ffc70250813d20700a040788adcbb942a7bfb938b65273959e48a3124121b39b8d83bb24e8fd6cf652cb9175321a7da816722eb45c3f3269e0d11a4db45412600765ef2bb8ed92a90dc96d2c826295561b42a1c31216021aa4ab66dc4d6a5b53ad251d20043cfe9d5a3190d1e532971c46e2ba3bd9cf1c70e37674e7cfd7d777ad8e82927c1b63e7a36792f34381eddbcff008e85caf2baba38bdbf30ed09fcc21e1c6f9b5508b6e96a8bc036f0f92101b012983d35510ff33492a8d4153826eb81ed1359f465cdfc85e085f6f60d2476317f956b06b256c2b82378a2bccf1cfad03bbab5843530bfe6e21d147d71b5c80b62b9cafd7b6c283cd5c3978281cb13530880d8cdace0996dae487c0f983da053859272061d8d54f1a1af1d8432ba952cd382629aeb6f38b6a20099fb5d2bcdeb5f4798cd0ab6d0d4ff856f1ba02ae09aed652690da855604d8afef8df63dd5d1c228f1dd230300ba4969f7f80b55a54f965c3853e6852e0a06c3784e4ed49b21ca9e2702099f5bcbcfa1bfc7ac40f3477865fb8caf7c2b8712f571c9ed261ce330b1985acd95dac60715f7029110ce661101d263c2a5bb34b01dad117149d9d2faaff39d490eb066473e2714a4502bd555fe15cfcdee9127005976ce5d035fa0844d2e2bb042edb2114df8e8a32a4ce03f170e08af827f5cd1a6dfe814d4c806ffbee24b4970fe219cf855e9472cab123ab3d6895d60624862e533ee55dfd3a65093dd0f5964931fd40242ae0c639a6386f80a9d1422d7b9aff590257a0e568b3f514f792c5bce06a307acd40e4fa75781eb245d450bf6e92213c3b34a3127cc33e1fb2e6ebb412473943b2418151a66739f00ae7e7ecbade79ebd5c2e7bf7d18bb56d526ef6d56a4029659655de2798c236829547525f74d6f032452f4b520ceafdd7c10f2b2e294ce4e3fde8e165a04c2def3d5880a730eb88674c5957308756cea8c4e4dda29b5c5d1e509dcb0f19b259844bfa9be7e90c48124f01c0d2099b07755f243d089d966f19a1b10aa93cea325b47c365031f64afd71538dd2f5c820dcdf87b26591d0e716daaed129cb43556d68245276d8e3c9a87688404a84d387e732d4f0f1b83a615a956bdb139e5495a78e7a10ff4fa4e227f9987eaa66f09e6cd01c0008b4c71c02e7767058be5308d50bafd8082057dff4a548a24614c7a04ec8944547fb8f07d99725edd92a3de11d1459a86ba8c977646294cee0b2fdf4e71e9c9bdf261e5307da4b074e03fb563cb6874dd21af5f50209d2573732371d4cbfffbbf6271dfad3d49f22535efc4965d936e9dd6eef8cac61621bf2019c94d17e5aa8869d20ccbf2ead9e16f7a642bd2df3dba07135e9947120f5ade7b7e03172a9fdd9e0942a6b2100af91ddd5daf7220ff9b3101e49512a8b86518617d27eeec04b190a245ff1ecc435fd04711dd0d98afc1821cef829927d1b46daaaf4e0451408265c5d6a615f55547b9875e1e35d26f4e094b0a8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
