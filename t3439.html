<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77f36f69f959adfe8ec23b945ae335c9e170bc143a2f0ed0ada2264707100cff9db8919db475ce193fae2016929bbbd40075cf85385a058c1bc640fdeb9fe5c72e43c200458338fd654dd3b04ed1e5868a04bbab9c4210d231b7ca098a1596eb8d906836d66010d2aa6ad78120e9138819c4b698c8d98c251c7e1dffdf7296c28dbf539d81a27884f2cc3c624da413af5981860c235f8c19f1d1c319de04b17de24757ab00b07f744f84ce829c9be0c8c3f144aa2ed06a98f2463fa94edfbaad2d6a0f013c9a923c973879600bc4ce1675592a0a65f49c3e87778e9e314195029f9374cadf1fe6533f615c91a2174d59509129a739d77a47e760e0ca42f286951e2a97a9f2c2965bf009abba16170d83ce0be9edf6265ce01a310a0872e282f2e8d5055b1db05bf01be595c60fd2e1e4c25b49e3ee9b79ba2d0a22dbed6caca97c852ba0eb8742576b76109864da827328f55b2b5f0b971e527579f97e4096395fd48ac2dd5420041df403e3f9e9c95e47d7f6cd4bce27800774f271fa6fda8564a34d094c957f85ee890b0a88c2506c084a1fb7f0cc09f37da6a5fc7bd9674b975f8e09ebeb75acfd0d90326050b2669da70d1dd325c7710ea77999960ca0f56330aae5a689711c4040fc35695f6c9af13a38422f3313b59055043fe57769b45964688bf2e4291999ab1a6bcf5ea850fa3879adbd99331ce2510d6046127a320162b9f2fbe5e2d625ad4dc42107ee11211384045f50196c07cbd1c0d7919f314f56216dcca4721c0366d10e55c181bb1fee24d6f848096715242db3ad25565a6cdadeebe90a91f47aa24b8b4433f44ce0693512850f59cfc2bf562dc89e48dd61c5bd5f0d84e90d11e69525061922b1db4ecda16bb0dd463502b6155de7c49a9c3dce9998ca5c19b2c2750e7100c6a84e55bb061f915b2e7ffe00f88376231b8c8f23c27071d70d3b9084106ea178903f665e873422ff9cf1aab5401785a48d549de2a8284fed4e26629c19d08ea1e7e2bc47ea42e4322e22456fe81aa068e893c4bf3349bfb926d25d6b699da6a1a3a1cfc2e3001a8d40ea4503d0d45c8fa0b1727b631ef63bc7f7d49d69adc08799a132d6ebf7e736422a6c229ad440b7b51f4ccd6a50b0794f8646533c129da969c70a268918561f783c7cd89bf089ba9919d24f914dd76e5723cd074b12d2666bd96da425df71d8a18618bc6c8c313b52cf3b84a453fef3366ca7cba1c6ae0c45c098dcea164d0c578fe16778b0ba213efd9453dc08e7016ca28dcf72eff7ce5aac290fa2e8f01a092726e9dfe6e823401cf492f57afc1f3b04004f50e09f5c28346ff06284715b0b0ea528cd7cbad66c9b0fd73c823a0fa2920377ea41d7aa559977be8b84a38303046aca7d7e9ba735e0640a295df0e9dd5acc2f2d5c01928ebe27250f92e395149fa19de09c7d5c55bc11d79b7d9df6b33bdbcabf8c9c04a8df1ac5cddf69108e7abe541f22fc29c1d14ef4e89f00967962f386f3d01f9ddf9461179b653cb3ed1fcb46e6d981d135ea02e9b4ac0d1dca6d9e692d8161bc143c56dee6da39ca802e8b25fac7b769575cade83423237282adbfd57cbf64b9bf368c0b72598a42464670325968aeebecb830694d7cae4727be6c7083e4fb6a8adde4a9958ebfdc59bd854b84e554d1c2d1cb9c64c950b8386d8ca0c6b4deee1c0af8f994bab8ac0f66b78d99d92983c6b5ce02e4fdc0a5a9f39c0b33e741ace084c9442598b50247aa08c6565d186c4778bcaeeb31a56f9457f451eebb6615dd489652a87b2bbe0961b06a0fbf40fdc47753735439813ee4412ef77479f77059e4d301632e5b26a151d2680df588c8bd683d25b62b9beaec6861b29afc261c163b82a1ee6ab23daf72e07e475f3e8f919af95fabf63e698e250a932f9c6e67771deebf64fb55b0b5e205ec02ce6d8d0c8e4f71f0a920c1fa58c8bb75cd8878d4e17ece0beae1d019b453c0d5e154b157fab37a5d19584f68bcaac89ae284ee0224fe0061a7a386cd7c7c14816497da3bc7c7aafa62ff9ef259c61c6dbf9f24b76efe7ad6d5d41760a02368c260fdd7044e5953d652f6ec6d98c6be673ae15e3ba1ca9a4e9d19cc533dac2ef5b602ee2f9f66b6226ab29afdcde8b0db3fc5a765fee2cb884b23fb375c0f60176c310786a98cc52ba75664ce4b0ca5a4fcdef93113c639d956eced2c6b661484ea44c34d714cff56880094dc29ea45dd44df62806486cc4590f8be765a114eb94ace0297cde8c3d5174645f284e223619afe68c1d0e88393b0e67d51e19a531197b06569958f28da9d0629886dddb80044bd2b37b4f7d7b9f1d2f5084af974e2a10ec1b582a62829f2776facde9d0da2ccfb3fd875b6c99203b4f3aba17795600c33bfd48435810932e1ec0115835950172e5fe624f93da4c0cde64af10eb94e8c201d190be31c47704946613c855640cd84586bf523fd5203b5927bb8532e905f635973b447f9788dec07766b878f9e7fead84939b4835a5b5e4b14a405de0eb1e7f47a16362d052f0f6e190de1bae33db35c8495bea69873129cdc59baa0c298119e7ba1e27dec6b8994eac1d93ee8402e08133fb3ff68199a8254656e1819c4e46bb757ef2209a09569e6891ff8fb2ba0ec04f8bd68734b8ac31418e3182fa26e926a877eac1216d8a3b229e5b27f31912e959a99c5964338b41d720a3f9d73fcae8ec9822c3294b80304e9e452eb473fb06012f5255441e2b047c3f52df9d5f987d29478d1e6ceb456cc670063f2a037865cb203e3ef11dc6678fa6c461815d0f8b61133d5157c45a2893ad6ad9b6a7b0bace76c102b1d3ecdb7bfb3d93f8a930319480ade4661be63a9d8901c53289fedfff069e5a687b012c40122b2c5dc63f92547d7d325b1d4e68744b6d97453b6cacc2b34e27a1f0bd4dc362f17476f035f54d6d07ba4e59d29349177496f0b25a87cf241983314895cd1171ba70b9bf784931b1880b33437f7fa492e77a8815c815646e549f685b487d69674d5432ea46b32110a08024ccfc0b22e4f683cfee01207e2de375e3a0063ed4527cd88ca768a4022a629f30ed053815fd6d79ae9e16ecb753b69a4dabbd9128a81729703ebeb4306f78519f6c65037e8e8f3ea4f2d401b086ce41e20776ec07bf32365827b62cd6dfa11570d985d7dcdf176bd0bbac6435a83c73a3dd2702fe9b295841edbcd6d1162c626daacf7240426f921c884fc6daa8a7e4e9c75f521540774137f7599a43cc1532b2f22be91b014df7336d7facd16097d99349a7a2f839389f7444303a32f39b2eb6da74006e58e405381a6279387b6f655d03c71cafb7a62cbba433337a976db5142a35acc7a8db673a8867e151d5083dce3e7c312dda874409f49d31975f3d0f24b9eb1993e2a5ba19c3d1e17a4c5817fcfe900bf776ad9ad754fba47b284a0caede10a524c331191985fcf71af6860ba8840cfa8d99d120b6963231d927fd6452d4de011e53591b5f3ce01834b0b00b7fd0aaa4e6b58d5ef4c68a722e7d2d997ea50d37fba7bdc0d2713645f490ae2eef51fb35722fe9dfd0697d81325c5ccfc6e01a7d44a1b179aa01ce16ec3902dc180ac0957049502695d3f4496e01e8af895b2196c068e6925b07ea8acefbe925fc0ac95912d8dbd510dbb91bd38a94eebf143836190d6c2992217556f72cfb90080d67aedb94008212de52e4699363478563a4f25e52a542941c814856c4cca7c889c5491c66c66d5b8cbe335ae9a2560dd1a44d2a05760b74b3623b135367529c67af41647af9475275effc3fdd6f3607aae0728016b3f7de6cbc0378bb76422dc016d4ec4d0238d4778025f047942885b76e4ce470ab8bb1ad2fe4c5314da033a64d08522e984a73bea1259cd910e8daef7ff7139c9fd51bf05caa5f87dc36d853c61d1bd91b5f6c0b80c61e1d07dba018baa4e08a8434f75d4c764748337f9cb8f5ba43157483999dc9689783a9c907e3c9a2075f0861651fddc02d0a9cb0c405d1a9ed6d68eeba6f841e0743f2c8e9959c02e57ea2b1ad609682a877d1afb6e6193d4955952f43c110e01e83a271e809ca8479f436c60e6a5a09384629a0c2f9381af65b39355543577c91ae5c0bdad6465d5f7c59de4436db9c99ad99b923e869d1682622f2fac4f9117cc2a56ae7e32c26b3e411c74b7c3e0425c275686e204b8fde30645b4d8c56a896929414ab9f1aebaa20c1723780e4abe7a3d3bd64e72b32b5bf0a1c9474feaa5e52bc11f408835d442447a34ad049d2e53d4b5eef51696b5c9360a68bd5890d06de330e2fd4335b2c868912b16c9114e5a33a65dd38575c8c921ecf5e4baa5750e680dfb845c4178067112d996d838dbb3088d9ece244d10d5588f0cc0f36a560d5802ec15765778052889037ab3be3266c6bdb281e9b6a20452a159c7baade89c714ed81c22dbc21a92116593c6ed0a0a97187c75b291bcd13259899acfddc8a07618a19465d41d2644dce5e2e817b70d9263954f14b701cebe307ea29bf0622995314bd4912a4c32f5344742bdb10239573c8de12e54dc9fd895276f4d87f1833c7fc9c26a7aa444b02efd75d0499c67073bb1c6d90ab64d9ecc5443fc5154cc18c1e52f6d807eb0979710940f94f12d81a290cca6bf37f8f7be563fc19522bb5d719d2d8b9b09f30ef96056b13e86d6626fb8f6b94e6610e6e233b6ceb0fabbfddb8e897d875729f8674162f0390c36ddcb5f7cedbf91bb0aa70c739965b856993427e0d2ffa5d3c2fd8153a3f76e0f5d953595bc71f63ac22fce2d1e1fbed6e107b46d9dade10ad0fe8bb78c4a5899c1ae721d916d55d5bc158581c20515979e9a2da503167f8770701eff880f3583d05324a96142fd82dc6110e8bda89be4753d171bb78eeae821076683cc9902d9daedca38a4a049764f3d8f1a2b8d1eaefc105180050454d7f1b18c539bcd8230cf343f1c414ef593f066c8ade26b41053f8d8229c52aa6564b09d57960c4f16e96ba1a363f14902b8cfc688b2a09518948a885cbe4437e7eba3d4f6e85a03058f93c5b5ab7c3f3282aa1588fa8ece1e2e07967d5e1d49c506dcd016a2174da50a10500e62d9253a1d36c005efb2bc2b39ee17845db3fc4b54bbe9dd2a62f89551eb4e53be32ad1f5e5ea08ddc863c6bd48b26b54ae435b1625fd2c148e315ff3e405eb1278e54564a32d53c3915d05ea78979a01b4f1f3ec2787c135abc9ab8aca1ce465d2a458043765d9bd23ba6be04a784e018d64fb326577c7e6cd07c5bb8717c0d97dcf34cfa26fe4a60302d033690043685b7ac02ca568e24cd256ddbe6ebeb1f120a338ed6ef7d884ee7242a2d556564532134407a6b106055fdc104477e6e5c87cca8181a6ef169784d396f2299a0c4cdece5effcaf3641af99412f6dc9caa7164cf1ea0d418f62b3a7c9ae21f051c5a6b8971f71e062d5c935cf98947017127097aea0aad5b53f9d7f12a475eb9c11d29d118e7a6396807fa31e77746b8b7d3768a681fc1258caa0829c21014e7e8bbb1a9884f1bdef21c64b4a6368349ebd90f5dcf34dc320fb60fda6b548ccda1ba15d51ec9a30f91bf66a2792071824478b4f676c47bb79dc8aad628f2717285726e849dc36c5b75a4670d90f54566e8f77cb44b7c19b8be49521fd6c02f172f53af2685c4b9e7d99cbd31fb2043f141fa594d420825c8b5a77a75bc0dd5a5261221d53d729392ec0948016d0ff6d010f51a3e21fc79cbb622a1f845546d528328201f83544d77d0865cf525fe916c7aba3f75d2636807e3c77e50376033abc563d3be9f5d2a1fefda436d3118049c5aff689f13ef15911679e1e33b9e70fd45ce60f2be374f573b3a85a435275a1315592f1ff3ef73df6c34e2ac0bb31684f894cd7e1e10fc7153a8da044f4d0817070b429d82d74399d278ec726fa152447512fd1bca4b56b1e1c953d60e8c7d559624656796021bdfa6db55e737ad8940e19a5632da68aca453038c0333cc29003d0f81a02bdae8ad7a7032ca938de4014c3f5b0e0f56018e73a8bcc03b0c28572af39873285e1849b4aa202befb13d1da6f0c51408bab8ea3fc968077e856fb8dfb24d20c2cb897823b7701f0818a141dea5d1b1a20951b38bf94624350b142b20f070fa09d8717f3bc7ad6827a6f539511089549205652321e0de4f1cb964516753f74185a11d9237eb25a2c8e248a6c7dd7427aad708c2669db257fedff1b230c587c843f8023e7ab5946a8532e419f2a231020773d292492b26b123001d4d94a57b244c5a4b91b75e47bd4f6c7fe1d5047d624f73540b666b06c605323ec2bacc93dfb53f7117be6f884ded925dc52c195133370ec63e8fa580cd7ed47c0d44ac2ce19e01b962363b8fbb6c469f84056e6b20ef22f359cd5a516b5d231778a2541e67aee236d177e4895f428d461c1e0afcc28f68e8f7be7d7ad31c2b60aea55255fc0b20bbfb6a8e888d1f13783f3e1e15d379dac70f153fa4a960eece814b7484fa1d9a44c4481e9bc582d3fffe8601230ef7536289f1003d5934b0b2e1c09709ef06cf7f8bc59d0feff082f895fc8caca93d3c21406f1cbec591ec5e3fbedbe5d9d29ca224b2b72cee0d430ababc2db29c2c04561298e5c6f841e2398a321783e90a0f2da36896d1ddf36370d0928de46718a165364dda6e44781c73c56a475e2be87ffc302891309327b10ac65d75214922559461644fe7949a45a8b6abc685cba108beae0507c8ff986ebed7289b2e979b0b0045d53cadefe8cc12e8aeede8b9990ff9df70e96dbc33fe1219b4d8f7d04c55852add657e4129cff440149b68a8ced96ddb48c8ac37f3752b95aaa5c6b222bf7d3ec1dcccdb2392724dc4cebe591e95ec032f10182e813cebeb82743d623ba7767f2527e340f6e60cea7be17806a5e098b6d553ff52340c67a27745a0e1b077adb3b7822ac4247a9b6bae5014724d0fb9eb827ed5ee061459fe08883e30e8797a4507db5af51e4e6b87dae3b37f972cf2c4932292060cc9b0ff1ddef82aaa9719d9097788423e61407e4225b37adf3b476dcfe28404c4f0837c856c84c0cc5cb0494be3894b891b00a01f634011ae4b10504dfad98f61fc37484f41c311a7ef5c1417bc680a8a2b15a46d4eedfde9149c8d65a755e853c4c2699519a7cd3ef2f3a1801b676cb4b37853c74280959e72b445d1ea58c096c21cb8cc9483777c725426845d5a69fb3bd3ea06475f59ecd859404507cf01e142720f7d213206453b7506a24894787efdee5b2e60957213c719152bd8525767f37e746eedbd804e080174f5f8d955a2aa955fd9cc6b593a98cb7674b22cda0535a37885a9c097d0d995661f0853ba884337d2305626569f9cd341fadfc67fec4f84f77961c2b60a536f696d825d7e0da50faa31001d5d3df3cdc7254a6bb60aae1a830a26b6c5ac59498e0bf4c6a75130405f3695f512f03e13c5eb921429ea8d1449b5761b2f08cedd2a612c04076462500a1153dd8ecc8008c1870455e76441f251b8a8431844b2fdf79d3ba995afb74eb489ee4427e73fd5cfbedafdfa6a69a0290d5fcf4d674acf3f46ada9d1c56e364eecc59738c9d51f104ceaf778af6055638c81fddccf77148bd40e04f6a54f5420a73861332adf959929b3ae9c7779bb2a99597e6f6220024aede64487794cc6ab310e13a25f2a8aba7658409ed17a552eced3e49ef4d3f181742f6e4d39f30704d4f36f371401f933edc4f2af3401caf71a33f8b48e43c38acce8af228afaa0f8d0288a9761a4496e78dd3bf02bb832586e436a5454184fa554bb34326adb5dab190405ebfa0d804e23bff4d09317c6bcf7d8daf25cbd5f60f4a361e31677d32c9c16f035d7fbabfe8504856f97bf77fbbe909548e968350cc0035cc0c8a2db6b0223473ae4877f5581a1e27304129ed6b98e180566fa3be0fe9b584aeb7931c82fb449796f5d796e0c697195bda405d87b244b6ffb9cdc6979c06daa1023f5d5fafc90b28dcb5272c126decaf6eb0efe17515c817939003a7811475ba7b5749109d7f3ee95dc60d984d117a4224e2f0b17783b534a7d312abce8e12a8548a765b63d1409f2b33cef60af4d152043f498f1998eac0c72b99e593cd585a9ec1086ff863ccdeb6c505c8ff0dadaaec4ee8038eca8baedef6609ec02bd294c1cc1da02171217520da8a71e0d4d711abec4cca19bd423f19c7fab8f9eb951ebce2fd8ff5c9c7e7c433da70bc0e2a6988b54999fb0e016667cebb12279c9c30002eccc57cddd4b605a5fb4479498f4bfb78975bc167d6b3723846cc7ad2cbdb28fd4ffcecc7364dd757148be64906adb21b3f44d61b46218a2a931a1776d99344ae6f6c89066f79d94f3b574b36b8b0b4a5b82bb6d629c644bc585a92070ce278eee5636cb73fe25181f0c248066379cc85082fd7badcc9a180e37222e231931cb7c933f8f8b40ad24963cb76f2f4f14efbb8b1886a6e607938ae1440212f773ac9a7307ff21efbd3c261cf38fe15706f8d7d9e6f4a266c28c706e6b8c3de8ad5154266edcd4bf63ba29ef53fc85c889333b9097620abbd3929ea28c355bd2c24b09e682dff180b4c28bd9f854622c2b11ff42c7251a0b3800c54d4279e158d2ba1b2c1eb96744db2452ce9f96ceaa1dd7eec7d3702c0c7f9781d11caf4b3225b5037fc3b0ebbb5c30e591e17c383bdf889dbd35698efc197d8c044b8815fb3ff32fcee5f6a83b348d948b9c3919c1b3cd5c972e5f293436567fb3db681d237ea321f545a8e4891ae82a1d6dca0e19817051e7f29fb27a0c713029d24654de19c7cb06326f8723950a098f8587e65b6bc549e1df938539c3840a63d2a7006eda5513deec9e2be73c346343114fd70c99e963ec312c9a6a7f542fdbc47427eeba79502b1950489761078d1d487e2f1965661e68451877baa0f9e0a8519d6306ad423e998c9a1919e4ed1e4f1b3537168f5c60a00c90873f47242761bccef88cd84db0e0d87efb97e7862a210d8d2106c1baa47b14ed95c74e76b31840727ecaf4f0d6a7c31d7d37fb5cc408b42377ed281726de3cae30bf15411e30060e3fce99ced2e052406129dd907662b58628f2e0b72c81964cd2cfab92184846b6c431731e13e25b6e45605b4af30793691ba0dc0d3606ea2aaff8dc2a670f14b5b3c00a4929beaeb0c72304bb643380c76f74a37b77ea211033259f97d96d947b84bb69aaa3a99bea4ce8c6ee3802cf2525ebe358813a4d805e954a371b10a8115ad224a1bbc44a65a40cd06753871c3e1dc664e4fc008129dd1952a3965c06726ca218aeb884af8b75a00cb0cc57452c7545c3e2bbbc2799c52e9b5bfc7cc45917f523c3a2fe60da38f064a32e8f066c161b5c9695faea4b08c86f1fa3086654e1f036fb84bba4234d899ee892a0f23723e738c4f7d921bf5bc141e933a2612a2b69ec10970bec496c0e764297d4f32876fd3a8d6287acd89f92f7a03b0addc9772dbf2c58dc0e7c0b704e4874916087bd19febc2ed6c82c83ee39b9e8ffc9b7c06f0537575f955e806617e6f50f3ce0d677b9cf78a176ef927d019f4b463ed6e5d7473288014297647b0c83a3f432232753a9d999a9491b3be126dc886882e0b57de94f2f3e5c1c1fc6a06f9ccebda29ad666222bdc3340490e6e1dab4d117820a537412567b1e9d7b7379a18b11368568996231ad3f35f5c205aa3ab7ac1029f37fcc291d3380f5898ee98eb67feb0b8e4de7c82619598fe4a1aafc72c64c14ee4d124325ff379b0e6892f782736fb3d48667eb3222d816e269fb52d219745f283b978c22345b436cae44f3a17731ef647aea904714419549605b290eea31bba85b378bd020ffa873a8b25db6289a8547a6d5235066000817b4d5ffbdf01e60abb66752465e93c7160b3604305daffd480f0c803497bc1931be28d4e3bd0fd5df5f1d3e38bf7883b356cd00472808122eac7a2f4b68b284b1e20ae2dd715a08eb92b983165fdcb5fb57d52adeb4269db4693548c4281a060f5a0ef664f99cc5b95fb2bdc39ad3737aad7f465b443b32fde97b2c3da553d1d1b54b81807d5adf5d7336abdb8eee773b1528423c737da471b96feb3757bc9526103895db45d66cc6960cb348f4801c37fe5df2c0df4d21d72222f477d484da41bbcddbb7f7946c79ae44759e66bdf7859a2951f47c554693bdd48375671c111168f183aef882dd712678df2ccac9d3c7ef15872d543a3040e07c650e1ace4d7dcf22f201d37187c02417c47eea53f23d90bbccb1b13525acd872a9b62cab901e2ff78b0414e87fdc783fa6ce6ba3b938035bad0735f80e8915f3dd9a932da1c3edc8bd870be6b97b2810d646bd4bb9016bccf44edc088528f12deeefa949bd3b942f765b4721bda1b55662df32e7504af61815a1788c1d19fd1febf628fa1f5c7d2e792deeacb769fa25397b0ce196d54fe0729a303240a8460c86a03f68993563d16ee6cdcca649399d07c7684761f516a2893e3f65de9bcd62492055a2d65a5bb361dc765ce8aa4cd43dbfa0a5640f3846965d913c8823414093399e8680bc78425709eb6954cedf56a7978dccbef2324bc0c789a67f7d3b39f9509814d39e97aef6c106d5cfd2e2bf5d5b1437752c824616bba60f46e8c466471db3c844f64b7676833ba6ad9d22a88e90a66c8e84fb7114302fbf3d289bafa2b91f637bff919fb4e3abbedfda2e78c74ec0809478769b0c222446fe7e763d1eff401fbca473523f2f82aea14628f9d1ab01150655e1384916614eb7f35e7b629e97ebaab2823994fede08aa9d6b6e0f0aeb205ba000de23351a4cf14d1a47b89f486f14b668d9a3ca8d76959724ab9e34b0150025dd1a0b0bd117cb7c33878c6b8ae53285a2606be3f4199b5cb1fb59281f98b9e36a3f112611b8ab8c97b098e31d910b6c372f594bad69bcbff0f31772d8a150e28b279b60f76d03aafb0083eda9e34d5e0e4f1354129292169ac5ad4e6f9e422e9789568ea423099b329c33956ff0e0be1d99c90382634e93f4fa2a6dc91e0895b2d5983d0fcefa39bd046415de33129d28a006491fa63de99c95e2f79411f71a5419708f6775aca99ac64f09f84aceb09003339f3c2bee8525849113cc23399f79a80f28454b0a8a8e12e5cb4a0c6ce6a7d0d614b7657a892212bb3bffe73807ef83d6a8792374be0240ca1a25e9fc411702886245412d4e220189cdba62ccfa087d001df95b37b0d8243874a7ef074e64f93a3982b913cff63af943a812e5168b7553eb1a04cec376b0b8aca7e60475433b458f57b44c184ed89cda10a22e9147e49580289f055aa81a73e07337a4943e9ed9d8e7cde6788f077259f0268849288f294968b43c7d745fc9cc2eadb7de23d896c98573c3c3a9444ffab575f4bd2134b116bc717d0c8b303f4d72b08aa25a57b8319688aa478b4c654ead8fe36db6ec0d4d3d7fe73c3847a7239636462289067cefab49e0c6d3cce175b351f95535ecf6d19b13558b4400d7523896e4d9a686126a2dcdd5424fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
