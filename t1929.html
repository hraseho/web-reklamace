<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54e1d1add935e46fe9670d73bff22c60b33a8a9318ef33b93e6845dc3d24e826358aba0bc0848834f285a9239ca611f9469799639a71dc98b68adc7c9dcee14ba8307abe34372ba12efd3a919d97a9785bc32ff5c9545083c7ea857cfe6bee0db319061e6bf05bec167c900ea82a02de4845620f941c88ca75ac11a4d318ae6596f23e64f7d5fbbddf8e8d9175f93f21109da63277a8aea510402eba3a13a7a1e8a804e051a3565a43a91ad137489db12036ca3248eeca207ba39dfa852f701edfa059143d1bc2eedd354cc1243109f239fea7cba50d101b9ef5c407f94602e4da8f0abc97e0c16ad02e5c97a814ca881580e28febc53c1bc54a004744640df011cd0a0c9eaead0dd894eec38b5b2ff6db6a73ad9ca339009541cb866a0cff0e7fe3ec977d78ccc49d0eb9e2627de305ada6f9e4d4f75b11f480a31841062b72530f7941ba1bb5de8bfd3ec5fea1a7b4d91b4db883dfc3cd3df81ee63e3328b13fd59858d4b4d7947afb7efd7b023e9a52a26f55d8562d2c632dadb4a91dd9b02e73920798d57ddc8f82dcf7254a927b76f134db50f6e97a9d3ac5c3bbfadfc2a241aeafb238336b1c0262b3b1dba70d7b30c0576c4b5254a6e08554b67c691312c7e8827c8f37be7899d6b43872b7fd718f5ad661f8e85f5e366dd1859fad9e9f60795c6c1c8a7cefdaeb662971db3d32c50058195c9fa50bf1085fb579c65b8bf21dfed5672604d59b3721fcbaece7645433a9a1ac8ac12d46774e7b23445b7b8af7bf1ee46ad7cb492f45f5623abe15e579441c3dddb04ab079cf92365d99f47e4a5bc0e1b6e25b82137ec11bc16a2431f615b2c1399222a8847d37f85e419ba675292fe255ef89f772db275ccd1995283399e734142f4da601708f8610d17e9bba977a96293018df2e94c205cd616dd42e009c1821deff9d4856e4cafcefaa982329e4d6dbb67625cb4f67b0593207d15ebf343203b54baa495d6ccd4635f5252a17f6471ccf84cd908ae84c66353dc4bb7ec84fd238e9f8c8fc2e600836e2d5d16a1ebed17aaa55b0ad733d6b937d0b66e99005130bfc0501a7f3b185ee9bf2cd0385c0ab57dc76e7ffcc3b4d4a87b0d492bba63d067bd6380b658c9eeb55945d4ca2d56df0fb27802ea5d87fac0fb3896e36b5f4f34bb2edbccb3b8400de4fbdd03f5cc71af844f09641355c2194d4fae89fc175df97b557646b1bee693ff8fe44a6db103b4da3d7b0f7523a79d9731ef4d2de1e7c10d095c11a53b6ea96ae4c4ae2ceecb6e0fd6818f941bed5dfd422fbdb137e3bbf972b210fc4491cba1fd9783540f1c193808ef4d2080b2f96499f111df4b6635d9100e0f76ec263fcb3243999f37c6b01da2476a051911fea6342b4c109882410135c5bf8cd370b43ff54194448edc60bee3d0a79b9b6d35f391e126ec6cacbd998f6ede4cb20a1c83c1d34ca0dd56c26fc2821c904049118ae91cc621c674a943daade10b8ae8f55264eb7c2f7fd13bf71b2791571898ddb0d805e1712f94fc4aa5a45484ef8e3f5be5e3e2052bc4ca0b691ae33536ed095397a81c3b91e8dbab0dba8054330e2aefdaa9b00fcbec0307272621a2afa212c307c9dc1ba26e651ec4e885babc503d4506bf9b9975e6426b9dd2b240897336311cc721e2ec60e842557e3612c46dfc0cc7f42246e5db6ac8d5cb3872392a331c9b91dc32d1364564b0fe25b9ba6603866a0a29ef623f89d0a58fd8149eb6a115bad74ba7912029aa99f70e76006d884d9fd82cd8ab1333c01e450f2c48ed6ef385ffefc7a5ff303d8e360c8602ca0422010ab402d16a69caa424ca6e450560fe862be1faee8c1951638fe70fd08a973ea99e1bda80b080697c08c5cf23b21524a892fe682c0c2032ce4f9d0df699ea521200f16fc7045ae1fe2d027e1728358bd8d2205d14e081d890f2a44ee30b517137763212ab41af22638213ca591f3c8ba95b01fa8c8823a2fce172ea6da9dbce190af2906668fdfec7a9a3c905da69c8c29828373326e8f57a11610527334451fb7bda98a9d083f2b0acc69fcccd398f8ee93e54103564866a56e847e02095f80f57c30987adafe1211af6cfceaf22921c93448973b01f7cfd4a68868f93cd1a4fbf0ddad8b53870c7b105a1a9b83cf3fccae33ce5e0ef5fed715f0037100c9602786d8b742fcba4e7aa7162b9b3a70e7f233176b3a926bae50739e13e80b577de260345b2621d7e6f180f8298259946d2b5728eb1d6407a4b503949af25d7ec05b9cc24befa28c143c058be9c8be5695ed026bf4c2aefe516e8f26b6a1fbd7ebb903f9374434a16cd05015d5bd7c0266421ee309d203c8ff0e0686ae8c34782ee98101f8f42811b6c7ddbf948e4518741393d00ac45332e080fb376c404e569de4b002686776244fa3590991ad3b4ca864f9fcd03ebf2f80bd3657ce288462524b486251e14fba956a654390ef0b35012eafe889c98da9df376f879e524bb84288d5711148af2fab73453523c45254c13e02747aba35c5eae6a58e28ac0bc204a59993dd4d20167c6acdbdbf3d730021fe92db28c7ae25da35f86d24072a87cbae1791a0cb083d91ee6bd215ce359e6fc8d2c89d59ee365f9b78fd826c1044d2386cc5b0cfad94f5edaeea3bb68e49b88540bfc9dc66d436ac06ad56ea82f7629000c44fb9cedec5712663a3f35f27084e69cfde2b4a1239b2566af2f07641f67856d37abdac33de506913f0d6b211b553470972bd3764e3922e54613845cb81174d6da265c2a246cd67de78a2761cd76fcaa2fe312ae0d6e137d718138cbe0698423dfd6d0808fcecfb5e392c257913505cc36aa36abc25aba006e7d273b140234616a9e55cf19bb036aa5e6f698cceba8d6feebbd76c8c503de053cad3bb4574091d74e371f993f6d151dc0370b7e0354720e4db63af87d6bc14b46aafd735cbfa225f18636642b14ec19fb2dd6b1261bb0666a7622274a8f6ca871df0c82cc5b5c1c1657c485d41a100bddbe91a5ff24bc0b7147cc7b6f2eae338a446145a6b7305dbcd1c9a6da40bf0dea8ac825b279fb44b972bda73e1d32253dba17f020270c39f38e04647c4179034e467f5b398c5df651492a1e0db8720b2ddb89efb31f8c277bd29ab07ca44e808acf9a7877465dcff56436c6d48d256b2667cd0c7773e5c45fc8f8a3667938af0865ff8fd97c239759e3bbfe246c2822c11e84547f570203ba1b29f3673cc8ad1f17e6ccd1d466c52f64ceba53f03262be96f7e04a3582be53110fd94888b23b68fd22ef5fe8a720fe887cb937bb2fc39bc8773e215c2cd0260a38650fa9c19059065ef3156a776541ebf756aef1a5f4b926cb616f6eb1ba32b5e4b2bb7071dd853e3054a7e0d481423f391c8d38f09a90737dbcee2ba5a2c629de5746dee4c5c8c712cac390179bb4d2411a692b54b9b28b3d5c39b1c56bdab5d9e88693da8ff4044833cf913f2af0c7b00d06aff2f7d1d4d79e7429e02824a54c44d573da4c7efba934dec70a5d1589f512679990696c00e4691b863636720c68fc25aefb365fb3af828c89ac7f953e168fcd5ed8705b8b60d46ce6964db38d1c46826a96e44d7c150699b1988fa456045bf7fe092b5ec26014a1cb4cccdc0cb9bf89596fca9c1eec015bebfea071507f5dd85493d6a4ba5af387f7ead8731db582aa87230f5a9dc1b3566c4b9ed60803a9c252c95e8d3dfe1cd50d664a4bdb61032c044b59697653381c8923b137715bceb48d8c42ff45c25eed4f90c1223c0922b9e3ed668f428a28b842bd649e212b92b65178a1e58e4965e87ad1f01945de016bf451499fd0b921c9fd108d8403797b4f2333c24f2792fc6522d037c62b10458cdbeb52989c6da065ebd20ca5c45ebbff61dc71d2efd34cc99e4ed452cdbc204ef358f95cc3d3547e71e70f4f1de089e7f4456b81dd9310fa291c05b23bed41c184d193d73cf232e8a9ee37be8f75bd85d7790fb779e2ee226e6f9503294d0d730e9b000b0226aa02c2b807f7af67330e049b411d81a61cd61735481af7b9a0bcc43a72d1215eae71bb08313efc7b989cd88e840a6b9f6e520b875ce9ba06e1a188431d5a64b91a032d96435559130e7dbd25e744b7360f8ff80b5d9a4981dfedca069c697ea81d842c7c71e5a2bfe6c88daff69ffb1de49e709ca27c347f0ba18a21cb290f67b34898256903fdf103ed108bacbdc921f540e73cb771a8b84944cbddc0f1800dc26b956619b2ab40ae8cd36d6b5320d4d7a06dd8ae223e7e5024a9f84dfdb1cad375217bd78464e5408595bfb733945438e8b0822fe6ee60f5600bd4132a6ab17d8eb507407a2f087cd776ed504bbd356a8c2b6fee50290125fd701989b3ee46ac473c84c7a3bf47a30d706abf5a13fee2d508b8786d79c5378bbf3364a12fdb87470eae4256461f4033629b9d313619d88d409520086a875ab88ba9924ff609244abdc3d6d9d253406b4a6075080e99dd6f8025676b589715e209e811e724633d0e42e0b24169f512f297a0bc076227555b3accedfe441bb526c0203b2f53e4a0406d4c2b9744defcdd2255332220bf3d2c7c7b1b48200c349ebe3e9b7d4a0fa84a8f6d15e1cd5b5b34de7681e99df89bc652b6e117b0a2854350484c11d64a45893903ba0f14a13c8e0e0df2a0c40c8ea13b7c47150e2af8b13856ef6ed1369e4c0f43c11c891f2ed704050d5497fda435545a5e8d3e379d229d5f23450b610889f0a31dec0aaa68b5649d949b783ea23a30ed9108bf42cf03cc0fc990f80e9290eff76124272740e5f246f20aabff48b293850a5b9784c05067f366f0e2a3f8be89080989b53f9e4a24f06d4046083f96da03ee267dbf74a4a790ae1846cd2b19fb9fe7f9c8a7276a0337ea6417f7a1339605c786148654d73172a0da553432c3e473763b58ad4839719d0928af5b8969aa413fd1c7f266ca14b58f848fdd3460d4d21fad2293b965b62d77526dbc8fbf7e6372364e15236a4b312397c6b18c80ca9bca4751e47fb8d39a9236f94cdef0f9fb09aea99f85afa5e1eeb72c6ddeb559a303dabbc0f5dac3268b8b30e475c1e069abe38d685900246873cac54634ae0da0fd19fb71c4c2f3dd859bdf6c663d8f42ac0203022890d1b70922400911e3f50de4e77d12f1d597af467bd0ad6d3560acca00471722c4de60d9c0f7c05a901918d6b41d361e4a7046f5ca512d8578e5c56d3ed7056940608660a1819196c63f1021d5463eecfc0532f8715f022d8a2baa7847d0f02b41b68f4170259ad06dc18ddb033cce2b90b05f59982c69353c347a5634e910f5b6aeb926914b817588f80ae59903da410b88b9513f0a6f0f8cdbc582bf8e33e37fd1131fa700fe9008939dcb3b8f2739d3bf0bb1604a303d362fabc34ac01d75e25e817398b228bc2d62a78dff3081aac41ad0e4b1d978bb8509d298c0ccef2082b01df877075d66e3dbcf8b2253f266923367f3c9f400a51a331c27a5b7808757bbb68addb36177e6857e4d3dfbab5fed556613d473157d98a6b56f545e03cc4baf21eb900315515f7ca0e9298258f19fbdb52fe63984eac307949cdcd420b2d61d39888cbf7e2ec3c24a0a47025a577b07818c187d67e23f9b337dc3ccf663827358bf8f1ad08de6400e38db7157b70185f2440ac1690599fcaa4503f967e17d826fc7be357e72d58b3715486934864a17a2f5436a73dba1a5902518a0c8a774de2d42c1f250faf693bca66604cc291375444eeaaec64bcb207793f520d6ad5951f3d69c0a4a86fbac0cc13d722e3beaf21ca5454ce53d0e576d20c37a665afa86c6b28741d311d92b5505bbdc17edc71f1bcce28794518c92c86455b017bc4c18fd171206eca12629cb37945b6d4e7d420637c6f4694508ec97ec9f0e1960cfcedf2c6d79a99d4d7b83c9886bcb0cf875b583cd0147a6b56725813262e9d8de1f90a08f51ea4eb9be89390fd0e446c4bf7491292fb553a257c97579e5dc7bfc9fb91216bcfe656d8baa5232b180ab56c62b5f1be231cd260f9af6c8bf16b552ff2e9a586a1019ca70928ea07e3cf6a09943483d6d7bb38e5253f2f354f57952964e0c1aae513056fadba6209a7c207231ea5db9c2accd7efd0d984b0b11f08a6a76349f4b4cf278808727399665b7d411bdc5743c5297c15d87fdd77cfad5a94410468db82eb41351594ebbb8dde2b5e7949d490cf88c597ca5cf884a2ecf8015fa3872242da4acfd2c94357bd3a77923f4364ca4e37dfe1b51d816f667d7ebb8f64c48935676ad76beec805f37153a49a2bdcb57d39a6ee4f39afa120eb12c1c3601cae08f9bdea5852ec1e9c4c209a0bcd444db809be1d0054becf49b9cb9a67db1a1d46479d3fc6b033499904e03b9794b526b3cd517b22318f2f4a2bd83b0d5e7e7ae19b7b412523f6b712e42eebd04704e28663d9a89131fb01b2504bc3d80018e0f05f71d33d681b27a4457f7d78a03c6f1ae96def7c58800a7e08a4ed34b089ee077411af2c84279b566a45c60e8f638c8ccfd8f00bcdc798a704462d897533dcde742308255b5a16d2468ec47afb9b31159c8b976abf88cd2b7f5d56bdd683af92ad74580064a9d7205568bb8cdb93e4c78ec54c4ffcb12a1729545b017eb6cf6332ea59f19965dca0ba33fd25a3dc202d9428642880a6fad2dfd074dd240cb0d6330295e63a2d5cb0815b9bd612e1ab0e565ee4c8c5b4ef540e23a8995f7fe6c6b9ffa10b4cf920443d26b8e0ea9fa8b405dfdef39437f758d246f85e5ad0bd9060e81934ecc8cb10eecafad4823772deccb7f7991ab0e335b37f378d011e25a96563fc17a41f7515b4f0dae613aa45a91550bb239f3e392a264cf06c2b73744b43f00c30e79e19ef1bee2fe8200771a3850847fa804f8ba348b8feaae323ce8cf4e2e2503f562a2ecb2b47d21743d634de7e7982ef498b1c4641ded09c2c5ebc7e7e58bbadc2f47b62ceb38ceeb802417fbaf052b4d56b7b4b21ed519e39a75c711df524d64f1eea6e41b9f01a395bb5ddd19871670ab7a60103ee2710157932f229d7a229039a5f2e1b7a02b52416a532cd1368bdde27f5e0c32fcc323d3149a4e9aa2bd5d73fd374cf165ee606813bcbcbc1899768e15be4a73f54021874d2ccd64bd27112a57d8ba36249d2bdcdc461b5f98d72842f2fb8f701e6894b30ba09310d55a3f8186cb07cf9fdf47da4b0d6ae3b7cfbf9f8f0b95bdf168737735f5b02524d90f3c5f618a6c6f9ae30698d1ecee1820e3434beb01508dbf27fd55573fc3c2a534c1b8906550f5befe8d49e88302796cd7461ac4667ea3386990444c96a07ea74c4ea1ab9d0c45c2103a7e850b699aac06afbd1bceb1270448c441d9a9d7c199d1103c8d010edad1c0f7cd2a5ed7aa9834dbd5aeca6846e538bd862f813bb7f5a23006c8451a5f86bd683dace5c4a83bbd24f0a47d5d8212017937d959d879de03a5cb9bf70520009ff416e4b6630b875a2c282713d22f547d858aabfeea22b91e786e668a506daa2fc86204a6d2a281d78128d59fde47f0d3d1974118ab09b601cdc57dacdcd1b5e0ef2a93bf4a2d02fdb39f94b1d8b6192e5fcab8547041536832ef9b3557baecd9616f148c9a4ae5773cecd6e9fd3b2b80ebd10d571cccfd90aa782534407d918df1b721eb5b22a7c2f643391eb4ab5f6badaa1c7c72c6e7b36d6bc322ed91d8c152de7ae6e8463a733e011a2179fcd8139abb14c4e0854efc52031f8eeef6b14f25193b5a366f30ca0d9aec02869ddbcdac61647dd74bd2d6cc7a1fbe3c7029743f85536acbea24107beef9e6b0012e723be0ba1e754b72ca149e285eca6d7894233f7e467af23364bd1f54092d106d44bc70ae6774881a3c1012f481c0c5ccd84a872cef96b8b8e23adfd3e4ec57eeeac115a8e685548e542b49d6c3f7bda1240d8afbe047dbd94b17593e6b32859b7c4f769c46d09ba2dd9f10f5ad9e6a1714266fa70b8a2598b4396009b6788082b699eaaed93f6303ed108917bb688525b4856b116f5b26f7ce483c5eba82236aff4823ba5060068ecdb7c3689fb7fa31f43c4dcf45512a7610508e62a406990138f81fe4902ff4117dee2bebd02b6fd2aef543a0ef953bfc8fd6afe55eabb83fed3abf795a69902ef1c0be2709f1a6d804abac024055d756bc915075011f81fc455fa0b8c019053b38a8a3869f3088e1e4a9bc902d44f5eb9153acb64e8b3387f34c344cec9c65aeff443d5e044a98a8fa85d0b51225bd2871d235964974d22262a7d3313f89ff16bb9adea26ccdb5f984f085609149067e6ddfe6041be6f04b838c2c5f1700311f8c1d4ebdd92ddb314bf83e72fdd2661e7b879bc299d2f897a3bf2372831682acf95b724d047f712a0e091a0c47b472f6d93b514eb3df069002bc5074514181ec788f071c2f7b55744b7db3b1f27eed4c5f12984a87f5dba4a96f4851c4972ee58732c20954da514ccf95e81f618c5c8e4aee1558485e3dd15aa01b94379543e35194fd62423aafb46fcfcd906406a80d87251b478e4fd3d0c34c3d8185b5acf06e606bcc43cac2b495900d48f52cb9336ae6431e8028eba493ca419c54ba962ba3ba4571638d7e615c42f55b0900d7a60f266d283c129c5606147f4ea745a34cce35c7730b1c1a6647e7dccdf4b67a757a5d6b2fdc9d8b8aa8a7295bba4c93fb776a9eeab8781b5a7b783426206e48dd3ceb8742831035393353f8f00c26a9e80144497f79cc8c31c714078b1b29973741d30c19d3a67609db36a5daba53d32705284c9d7a99f0158b3481bad775e9026c6a9bfbd68963b94b62c1aa4e8c1d851fd03dce866f512fe8bd47e21df604189e80b18c89ddb331aafa8484a3c4a0943b036bbbec01ef428e15463c77f0b13ad4a4b8de6e4beeb0fee8b7326c944f354580a48d180b78c011b59ba0ea7908939cc0b97d0ed07d7cae19e7d07495a59c702eb4ce19ad35db03617f6c0265fd91c6ad1fd398982fe3dfa1ac674c91c67ff39082e4d42d782df0817b5263c21852d55460487599585f0e6db873b76add17e36062970322353020d238f47843010f8182ce0cefa9fca928fc9a3feab81ebbf73daab4221e1d4f4af6c22e40c8493dd76f5c5ff5f48d7050c61f698a2cb41eccb4054e2175c05b342f18849559fcdd4e23fe72cb70f5c9913309aa01d8d54d6e39787823b9347f90a80d8c8540168693aa01b3087d81354ebc5216172d9013b017027bdf25ef617db030975fcd80413b8cb08caccfffef2150a50fda3949d913f416e6f73f4073cd1af579136fa18317a24bae66c132a3a954a4321cf127718d284c7a2babbb0a029976b481c160fbceae2aaa2c4152ef1084a103d0d6be187940485ad0fc0f45586b1c75f8599f4aa31f731521d8543889823d5688a98103eba8a8554d13a5f34d8524ce101cc3f7c62ef9034706c5aa253b9e5f70412f3de40aa01dd00f7d3a182683e2db9e7db26dfb23e8bacf85f8665b2809f446849106a0e108c479596d508e1600a5a0568580a5f6581c62a7aec955abe6532863ce93602064856e0d551d97da5234a76dda1b7c13ca37b338864d4a7637cdb97416a5d7fc7c804afc20dde33887cc991492223b97efb8fe211c763ceede0b5c084baad69d64c1d8297db431a9dd7f12818f6d0df4b8ce946958d4f71eb0a6f472516dbfbd865936213e4a5a2a2daf42d65427342eb14e86729ac7783e10ae55300a1666313c7f7c634e63e5c74eb3c9908c1bccf28140cddcdd58858626e1b113300b30e7ba61825acd5b2a1016267d0196850be3ed5c78e0e315b3ef377a0be29c42f1e36fb323f182ae9bd6d6bcb28eb1745a04e3ebc6886713a36cc092e245450ac0556f0bd9d493c25d7d6a76e4f8b9d01bbe14b7726b079017e2d413936371919b58dba597b3137f451084055ff001e7786a4bb355016a575fc606b3bdb4fc6453c08b3822095972865290c2c2fb09e272cec378892794feca7c05f2368310b1cc4c5fcaf23c06d146ec2e351664dda7e932d0458094fd4b936a2223d50c6f9f0a7fd765b998adcd6c186932cc1175884a00858aa38ce23d2718015bbe66fb76be08b5250006a452291f826e1964a4ddafb6efd151f1fcd0cbb9dd5ce7d6c9173a45ec0cf1735285f44d0221a1fc20140895ef8d6a0e850b0c14d5f48702a9b42bb0d9af6ad70187e8929397d65ec101da2d6c6baea7ae099267b5f9d06f2bab2047d0be801000979fbf675ad88c27d827fbbaf39ce29d066733a9fc7aa6d1cccf393bfbd97b77297da55645d8bbc38fe75db140ed62b180d545bd33e9e9bbe4d30c11ea3b7b31d1561a8eb3d66594e1a51d61318739a69ab60ba1d421357c918a8e0cf617226c2601292715e8be59a63403ca5a5926708f176606efafb1c50139ab69a5b25f7424e3a4e1b679a9f5bdd974e4cf731bc10e476917949f9e1fa193b1412529c2af388f1a661ecfce9096ab6f029b372403179094aff72975a3b36602d11741bf909ce4deea189732b8f7bcf3d41275e632447d2becd731c42d92c5029e959b9681e1217ce6a0d9c2f76f3d3b365c797589a816f7ac5c11c050aec6e59ce8f8f3d4215d1b4db9a11bfe366634ab0d8be7ad72b44eaa01a62fd3b5ff3f5b6ecd5bad8eeca17245b7771aaa7f292b96b271f326fba73e62896cd0e134b298cb78ef003106a92cd5e851aeec4ab621a24328e505da3b1fa10e1afcf96def7992e30598fcf0c77cea21afb03f58fe7d1d1c8f5eb7ac02b3e605bdaf0313ec37fd16b8412766aca51efc47a61cd6246d53bfe1bb73622db2898619e011c8158b8b4b8c377835ba4089efb1f8ca93fe318bf6407bf6b5c91c3cea7044fa96d3e05decd93ffd52e3eddd67267d14d3cb7567a5f53e9dd540fc0448a5d14cadf273f36bfbca8294bd3c1b2d3c75188ceb7ceab593d4e5b0a8a1af236052e05c71ec72e61c2ce7a3cd55b1dca2533f5c382edde11b3900b8c0665a030a22a45850ee48b9ddb11f5af939289564299dbd077faac365597fb58f3c29bcd25757895df990a3103fe2a7a17a37beecc8758ad2474b49a4d23a225647576e5f23ef2ba502e3bce8588a3ceba2e29ed8a79a6aa4d964f17098873e418a9bf2fc53eed6c3b738375c9d862166058a81ed2a0ce960122541ab4352a2b77c8d1581a031e6ab2c6c98144f4f0063e9f9fbcabf640707401dc76575836a5d26b27e9398ca026d05fc1a89e5486f1b3f30777f97529dade4b4051ad768f050122b9ab51293d1da63b14b9ff93e8d1954e9cf03e47f177ee6d4fd10800a9b18a0707bcc14c9692e40b094b33678be8225d084f8e20b2531b17d00dd99c8fff6bc274eb85e118945395a343fc129a4de452ede8c1090f89117e8044cdcc71566c3e72b687a694c545b13f706045fe5c1884bbebddb6e592218ac52907ce755aa14603a2fb4b73a2ddd9eaa97874228857d94b877131671ab799233d5901239df68d4716129dd35c67632dea262d516ed62589d11187110a13722ce11cc78ebfd3a9d9453fea931a690637fbefb62d23aa8153fe9b7d4250dd463ca97447ce682cb615feae0b92c973dfc6a3fbfa5e64b6e76cc41dc54e4dc8bdb55a4d816a00a0a167037959ec579afb1fd6430868dc48cb04f6eda64207c124732a6cedb40a3fd107ab6eb549d935cfe80ac214d90e42c95251123a2a1224a22ec45a9d05325b72d748a510029d891cf41696c075dbf89ff4389a86fb53caaef2f4a36cc7172fad1491f7885cb614b1618d2e2022a708db5ddd957e962e473bab0eee7ab93ccc0f5817c9ff4a554eba789f676be863617431d01e3d288c1fa678d195a054eecd560fa31b2de398ffdee06c464b327ea5142bfffb2dc734f4dca198f69789a8b4a4436b8226d065ecc007136593b78a848acb5d34f2f517f1c43e8821f829270d3e52f1f3dbfdbc9520625a64034c2e65de8a96740469b760eded68be1d972b47237819f16f1c8386ba44dded0af64001221e87d33b8c0c85fe76f3b6ab927125ab127873f69cc2bc6242c69cb310b322f3fcfd6c887a80db0f0fb5ead7e9ab33b6782c16dee8514166a04e81065dcbbb0c423b6a1be187e9c038b8056f544c70e242bd74f7a33d1684fefaf8dd76ec0e75cde0a8adb21e564ea4b080c98bde32ed96a58388c40e7c932ed45e9b8eccc4d7aaf587ad723a8238e4a4e1160942f21316cf248ef5e641b61b45af530918457910f7c45ab2037ba6a33212b06e5e66c7f2e8139086c0201546b92dd7e3c2192c5e65e18f8999e8040ac51edfefb13f83012d0d0c68895905739bd2c742f9e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
