<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"776573adbdd722cd9bf21f15af9f02067696bcb8e69c1546ff09fb4c6d0e9b9d229e8171548eff30494610859650ffbacd9b12bdf660bd91c6e1277ad407f7bef60bb250664557511e39355181ee20a77c249f5041c705b22d26229191afb93e05c0c0bfec67e40613fbb4812b717e13cefbbbbfb25b603fa408b182943f8b3adb996f6cb81f450e22d44e97b0145d6921432ccb40b42a0cc961d006cc48d15a05601a340e3769542e7c6f76a8bdb3549977c7fcd5ecd96d6f526a9c4b7b7dd388f599eb4d132099475f84df175d88e7b2ba5a9c6f9e010c47e53ee56fe42b5ec2ef75bc51028534e62c84cfeebf6a374800d57dbcef92fc84e754f7fb3f1d0d74a5ed4fc21573c9ef465cc4af1f393b0eed10d11d89a9a83593101e6070fc4cbab366dc420da8d38b5a8bf20d9cb03cac0551830eeab1d034195f50ac61128ee45348e4068f9598e487f5efea4f78ccdb8a36a75b0c055169e6a28d225f58070e5e9472d7bf321c24d7a0ab7b6b259c0c6535e650e82b4b26a284938c4e518fcd0ad7c293e08d425b4820306814085327d4ed59c05be197ac9c813bfc59eae5691c2c0b927b30ace2ececd4cb741b3748e4328209b459a70912af2a9933405470d0712791763312e516ce64f03118569cf26e30974a359ce391c1d283d01ddf24740c32f979741d34141374eaf295165f16a6c5d957672e8ad5a29f3d3b4ccf181304eb6dab23587776876fd45394e85b8168013ef019b23780f334a5e29877e9878ecdf47d3d974b8b69d2e00c6bd81d59c90d66da4ceca0b09f17b585ff86c6814a199c77ff96322e927dff2cf7c6c87c11ee841ab8184b611039cd1ca6c9dd84c6d66a3093cbb81452e5a93e4d5dafce60a9af80df9d3f24edc6bc4b956efd6768790f7a45179d52f971ce7dbe1eccced93282570ee4a44726b7ff52bd1581caaa8ae7174271a3dc93e1b161dc695cbf94970c037a7732a4a63d6f9b4669b9e40073d81357261ad9f008a49cf3425029bf6b92a04d5f015ff8bf7419ab89bdc5f37656a2fc0ce374795f4d3207192c139375c0eca55036c28570786dcb42242effde047b308c192230d6bd68bc420fa7cd922892e39d88adb0bde11f8eb0aec0068927ae441ccef8f3838ec590191ffd3636c205f298ed3270ef63ddec269b605dcc9855866131e20b58a493fb22ade73ddf547d48d057d2c719caafd86daeff595b1c4453eb1990b851c4b51610edc12b046cc67151d5c230917ad91c2881ad0f4e4c86a0d986604c43239d48079bd09c961c92db0b87b1eb3464fe4ee3b1fe4842999f459fd0f1cdf941b2b4664d962f961aeeecacf968854255dc29c2c9f404f97551916293f131cb5bd979d2279857c412cb446cc1787f3fee973db01ae923af36d333c758514258e8050b2503bff7d12dd8a7d79246938b5f39bcbb0d144cc96fa79dc520c096e1a877b139475b935f86d5722b9212ae497ffab157a08ebc56066085a8dd303d461de9cadbf8817ef68c020156c6204651c9df084f594373a073cd85eac9398cf941b4a3edd0d1c141b46497809b1f9cc8abf7c4066a657459e95f88efd288c1899d8b0a1e7c9e1cac210ef815d2d7e9c0407b39f602e8f9b6bb2b9d984dd1fa8b34d379ad417f1b5fc3f9f70d821a12552355bad20f621b1e2c8a738d3fd179eeecf8891af0ce6bf805bd63a1f1b8eb2f9aeeceb0bfe8fb99be895a83881a2b88f265dadf63048b99eaad3bddd8e2e86266af0e33f0cbe291bc9b1784f2ee76e0f05a3d1bc07c4108bfb1a9fde5232ab61685302a08424eb07d02f32beeec65b61262c50ecc697c457b965a2b388b4f8be0c2ed573745f40c83d5f7f86ba1f6cc592ad99c9b9fb0278221511bee3202b619e0eb7aba9238d2234872bb9fe8623abc1cbda1ac5d1385048a948ea6e1148266eaebeac877d3eb4e691bf58725a1c2753652a15ab127a06a057e0616ae405fe0056e6d2ed6715d29dd4b10ca42cccec0e71451926bcfd73b96d80282ce0ef74318d7f8d3189781d929c69a3bdc0632dab16563d9b48d835353f945f6096383bdcd6cee686621cd2bba8cc7474d3f321770188e47e80596c63dc91b8fe825bcbd7aa0c4d82e5d6a3b5e567a93583f005e471014e67ddf1a662e1628cf7dd99c0b2c182eb4cf4319d0084adeac1824092646a89e2b5374915024ccb714bab19801e69678626f06c1b54e09181ade135be5b72716b54ac0087bb5573384266563c43ac948e789b6d0a3b839901ccb85bdb6602b33adeedeed035a1f7f6546650f5ff08853ae07de0880254a139e348821a7286cf287f198bacbb5c0119b281560f332586498a859f4a39a773daf3eed398fb931ceeb652979f9f28b93d16d9f47ac3ef32aa487321aa74a3af9e04b3f7faf9c589f63c3c3aea29d6c87cd5b88d9d41980b7e89a1048b9a825f56a04ece178ef81e5177a081c7475c19f166d9f698c73ce021489b8bebe9ae4f3ad996be52bf9d6c11e9035d66df51806cd68c88c5c902b6c727b8859ba13e325d5c371a15fe8d03e68f8c081dcbd17d33c32b3859506d13f743998af0aec635ae26f3fb248174af1050a056618bbe662a14f2de79f674bf670f3523ee33c0d0d6e7d097aa88aba7a647899be3c7298cc44a0377c9aefa6134f6b8a83185feec6dac3591e400a5ecf91a067c91a986fc8df63e99d8b8caa37f28e5187290bf7002fa51be0553117281d976bc4a6730eeccffac996ab8e41cecfde0d9704692bbb29a25b58fa654c31acf47d92ae1d59fbdc5908979420faaefc462e6e1c87917e455ef75315e8381faa28fa7beefb261372d6f24679dc496d9513c7bc27f7c6e6e6de2b245d9e0055a7428c20d473b531d4706e3d1035c5798624f6b0914aa023f546aa8665c2a0d8ef4fab1478734eacfda65551a5e8ee2ee8222af777287abaa71896e1ef5b07199518dfd731580dd1953a67c97ba35aaea6bc539d91a25cbae89a20cd3f9036846567966ebc5fb23d8b5e4ec7a3f44e20d72fd6c99393e56c5eec845412639cf451500de4af1f200bc9f6f3ce8f4da77209daada13de738e680c0e6b668cabbb90881d74b877856ebd2b3af0bb570906a575a72511d8179e75794f9eadbc299f0d37ecfd4f2a46d4d5367171125136a26b3fcb0fd16f69cac99160fcad16e02ec4dd852ec1c1e783c8529d059be9c74816d93260a4b5e5479489c5a33e6edb709cc16b7f8a1ec6ceb936b4f4d31529a1c7170bbb38907f37efba82c641077fc2347daf59b4fc4e2043d92b8c6d9379c70226a8316e7d6ccd510100aa61ab71dae0f77bf6a3fb0493dc9c45205c0df8a85d15681ba0977a7282485e88bf5b6ac2549b470bbc14a49674bfb635a27f0afdae0caf508b4a32c6273fb5c1a62ae063ec1317cfc1a15608cdcbc86bbe0d9b1a0fd1a76d7ee9cc503a196776dea0d15af2620b8027bd4e7c3001428a99bdf0320202b2a065b9e6347b0605ae31203e94f4adc6c63133b60a5f0c864fd119a428628221ce3c0aeb552d6d818995c552eb57c8e6f9b22f4407f665da64523d2e6955afd51581c1092d38d068efd906b5cdd93b8456f530135f5af8efd58be7fa5cea1e7b92ed3f0f3bdf3454a18c30d26cf296d70cc8639192f724e4ec29f29a90c7179d2b8d136318f744716ef9fa8a9be69fdafdcbee95a06c0cb3baea88ea28b54ad001c4b0c61327f4aab8fde48960948cdc57d3559e07a6c608a66fc343b4ba0bd40be158e8819deb6eaf2e869da735bcd1bfeee32725794b5633fd1d3a5ba76e1096b754110dcb8378eb61f250ee1fbc725b17ceb45369b926fbd22c0fd96f30fffc78536c719a72683a2794caca45a450b5af0cea5a7507765869d0fc52140820f271f3cadb9f0e3ca2d9fc9c7fcbff24374fab443fef3c9a3f3773523faf0bdc71c641dc7091e3a3f445cc66bce0f0daa9060d076b2579ad8ad33fc667012316f44e409c34661803d2a8da487af7a990dd387e85588a21d558e00d057456f2942d09ed11fa4aefa49b774c6ca0f91419c0fdd7d922801b0ac5e5c87be4a2982dc1764550f7fdb95eb8a242957132aefe16041a30cd69b776036d5851cfdd9f6ad03b54db860ba45e513beec8fd17f8bf54b4bf8778d81f54109864249f1ea0d67dd9ffabd09a8b1cdc668363479e3ebf5cf830795aa3419180abb2119676ba2fbd95393fdd40e102c8d492f168b909ca2bb8cde182b20b53ddfa286c5934eec1e193b7e82c2b58d22724e9d6887a78dda21b28da6c8851578bee9b2668f9bd23d98b87192544cd9c1e13655a1efb99bff2a8cb8379b61bf1da4f25ae30e6e8774e6fa10f700768461175a5d6dc18e2611b536a5fcc318082e96ee36961335bf9202e76f59fcc42174e77b50a9e499b5b2d1bd5462015dded22a587d3cb46f94a7c4ee7cd842f7e970438cb1ab3dc9fedef31c89febc53fde053b02a9f3cd5bc35582dce773cea096d18fcdad35fa6bf91917a475e850250395f641d907fd7e974aba7465e260ef36306a97c2fe50279eb67692e1fa0f97abc21fc14bf6d25e4d83d5ef39274db6edb84896e05dbb9b35fd102b876f6d73df19c288b3101775a9f444829085b113b52cc79c9d1390c1e37950e0e23ff02a2a7c45ba827cdd4ca8ad4477706073812ba14e8503e8fc7300baeec5dff7ee10278f0daaae9351b9c6ca0ce2c20eaaa280e845a09903b8457d536f4d7f374e69dadb41411dd97d32f4db937c32aa0549a178a60a60912539b4fde17061a312e2f4e4d3f4b454389e944f6ac55cc20fa50ded89b21e863eb3c876ca21109633a20fd4b32d9feacadb8c42070843c12d515c3bb44f67f711c71ada74d1b9f8385ebccaf2b3a44de6e766c837adebf608bf84b1b7c7ca4855e2ae19da879d9a9fe92f244223d3ffc209a0c3171f2a3eceb04b9b5ffc311287628db8b385056a8822e539f9a549db281cf8f21fa70c5602b8bb101565b7875d7d68dcb61f7a4ccf3446db31ef9c20bb25d253f2c6ebbdeddf7fb8d2bea033299c1982163a4fe121662a5bd802e193a73703ab8400aa044bc1fc7c6796cc011595a642c9ff95bf5de4847d83ad116d8a81c221278a4e4921416fde06d94d98320dc843d15254386cc509f7bba2d9ff9c177980dadbbd0650c3a6984c6069d3c9ad276086ebaad159ef2235d78d9a31ab749f4fee686ea2f8844e341df965ba97d29ef68d23e7e0fc674d474ba50f307279d89023276f4aa48444816fdd3331f5d89dc74a19353ab34df86740074e73b049532873e61bd38ac46cd5a6b78d943862a759a0456fe4d20f9113db10ffac26231c6614add79a44c8d23f82a9149df48f80229185abc07d818deb8d9c13990642c30e9e06424f61a6dded1d5167fa06f3cd8664ddfaaaa89798600a6f54dd24adf2310df621a8e090ebd5aee4a08f0e4a307d86ef888be376c7adbac04979ceb5ea2261766e1878d578d90f13376a6e7ee3f8cc6ccfe49f8e6da9e8b75496fa2127c50f06dc67ff381470f981072c968442c5ebaece8a70f6df108778aa2fd272b06b4056fdf58bebeaed3fff4bbd48a38a75a3ff80a38e038e70288436e81eb149dc2bb0ebc3de3ecd83cd30af41b47ab4fc3d36c74108b9589554e1d8b1289a4e8dcd7933784a3ee46fa85171ee2f26dac50158e84c12fd79f4016506d17d82ecb5fda66afa2c66f82abf7df306dd1d217e8cf1f79063e742861fddd30100f8b74ff13246269f9445ee4b76067a59cdad84a22d0a6a1d15980b33a2c49ef8efd1f79ea0bb71a9dab437552e0f3e40c799910a9e46ade1cc48b240b401873ec56a8eeec3e956001d62b410b9ecf8e9f444d5d9e451a48380ca7979eb4d5c55506d0add28ecdf14d713d82f35424b10bb221175edd5a4949dc12be7bac7a303796be5c921cdb89f7364a977174ee2096265b574bb7f00594192decf29828768a0d03eb15ca3f2244c2284bff2544a2a93abc0049401a4482232a720afde301a957781df4f8b48a05acc5e80cf80f2931e00d891004b99e8d8a48bb0dc1cff7f239ef7a069e39b4eb975e585ec08ee202215b3f4e69a84725cee84f3ffdb97d0e6c626ce0c4e4fc15a7e12c22dd70966db8edf5893f1a4ca9ea466c93ef7ef0b173953cf0a83bee184da01a4d298eee3d967a19d011adb827e1f62abf9f8e68bc79ae8cf7ed7a328f9c8503add95e975a1365a0d7aa4f9b8d2216fb7418ee5dee464d591192db39772b8514cad1873669513aab53e836e3186480f8a714c8dfe548194e64af6e0d7d85b615585242a9363923635dc64841939a28891c597c52c1186298979af997fb86eb78db18884ebae7cbd2caa734741701bb83f7a331e20814e543fce974f271c05208577f0b6397c5293418c8b414f95726b32f732d84eac90477cbb1ac3670b2118adad86f14aa49eaa53ecb717d1425f4ffcd147ff655e19db79b4558ee5a0620d762cace1659748a7897460576803d9a834a5cdc00742db28b17f65c2b59413c7cc0aafda26e74d2ea8c183b63d65866b4543c2b669aa19f2ccbef8aed69742d0077b5c160e162c1e43cd88874f0c23ff05ce290bbc8463e8db302ff8aea19da08f48c3c028d0655e7a4ecc192b5d8922ae9a3cc0f052640c9ddc711db90b9949b0b7de57aa4ab8b1b14b04f66aa92052ef4ffd32cd07fe0b0c3ea9645e3e563bf0bdeb572e670babe48dca6c847f723bb5651a54add01f03f40882358db2ba9b5a077b2a62fd2f056f33ddc55570a2ca6fd4b1006a57f17df810884dc1fbd6688d0e37051ea88960d4d1cc42ca3386aa27c2a694c55896e9f792c9eaca5f14217f7ec4905640e4bcfa24a10335e2c137273785667197cb0ccfa7e1d45a64ce3af4a479cde738bf4dafe77a01c9651cd5a6254f40b580e7d9e3137730e60877e4170e4f3e5cb672b77cdb9a6ab21f4c8df82fcb3c623d828855bc51e1353f64215b701af0f9cf85dcca3afb6d6268e582b393804b88b811137fad5686fd3e51eef8992d86d0fd7709eae4cc2c43f69a1ef8c159d0fd5359abbc23e91a7b72a6aabf93ae005565e5ea6b3b5d26469fa5ee8f13c1702e49168d6c51b4daf8781ffde3b92587bde8f6e5665a8846d997942b26c3eb8ed4bcfa55e73f2a653338fb2103f8e1b1a8322bc6734aa476b64fb0de2ba2a306d4794835801430f9040a26c9f3388f38595910b0a51ee064ee8eee2fd9d739b285d0300d080c9d1550976cb4b4f345336e94a8d28ad5cf1d429a6bca33fd5a8df3384974b2e3295cc781e6d9d97c55e6f68adda77231d49bec56322c95497e0768354876b65756b3aaa32c4ca45705a4f6933a731aa390858eeb6ab9ad64180e18258b0fb951e401852d9a8998d65645a5a5bf959068dc413715d339f5b965e1f8964c51202faf753e6e4c0f085019a6db684c031ddf4869bc58d181fcb7d8292e59b5fb56588329f0efeda7c23915befa9b8940b7790b12901ee89e60d7d10fc1ce4cafa0deae058f748c05a13aceccb9789994f36dc3aafa8c5f1230a94ee131fcaa4827cdf38a3bc3320bb2ed436a4a26b44c16a06604ca615596f17fcf0814102e9cca692dcf7af17cf4cc04198f502ef01f717a39ac755957c13bc01e89ca10de6b54b5452f721c85f926e1136cfd68b26b73baf7ba8ca667ee2f0d097c1f87fcda8404190e048ee57f0063cd22b64092a44ccba409ffc1430d4c2a9c9392e7f5a3539f29da3a22950a6c1043dce840a15f2022df7b09830a68e8e1bca9b66c4bc5b21a25cd5f3d830f68bdbd73e6286dd7aded2d731cdeb3d105bf8a81688267d816526ec2d9d8f70ed013907eab7370993350d5e2d0f865da94ef6f14e8cfa6b792dcbdfb248eb99c032432763398ec529c1c31603e81d3a92cb7977fc4448b042c9114cf82c474bc19c6527b1777633789eb6af4c7db604f8d8a87cc3fdf48935fd7038d944e0c3cfec026c28ca242a7236b75dbcf1ac9ec940d19100e8a695cf7f23a473ea7057a0507c44cdb6b379aa6dffa697a9dd163b9ab002a8a91614a7b0e8db8f8efc5b719b38bfbbdea1c5ef1f0c3e1dd5b547c23693cfd1bb72c5c393cfa959be39abdc581ec9e515911471a5cc0926616fb5cad24f2d493a3c6cbc700e006ad233dc3e69c498fbc303724025d61818d1edea7ea526dd35fcac58379d82811f826b59d57cf1c8a72fefbdea696448567568809ad7bf39155334db325e2a6000d76410b76e985b066d476f88e636cf3fc0992bcd2849e89e6cbef40e3c30dc408310e2c608701e9cc03942efbd10caa0423469e8d65e7e3f2907b6fdf20390c44757cad82031b99c8d775f706363c54c1e4833714961d1b4576e1e8745a255fee3c6a80be7e4714f74457f01b53046c2e5073dd3835114554d9860885a1aa7902a1baad687f805458cf65c5d247e1618bddead65b0eddbb4fd1f35a6834ae3aca84b7848980520e11eb3709bc75b4d49858e64aaf94838d45e10d96dcc4bb4e3dc6686ba3e91e2463f54144a9589a26b24efb040f160fc12254cda17eb6a30b92666107b45ceff0200f6700a63631f26f52f9c949e8eb4cc64483a4e53458cd15f923f0a63dbeb5ea2cc36116f6b597721b0e8a7609715411b6072590f91d409354fc40343cdfb1d6873098d05ba07a57307348409ea48d1127b0cc7856a5bd8a8d00e1598037d4fe40246f6598b3c639ebbb1162aadd1a64fabbe4961f96eb63f825061d2b34b69a70e5c770a01262f34f55d4866d40705aac07915d44e939f684991b919df93944a56f79fa51634787fda32693e9f8af3f1ee72eb8b8b837af1002c4ff1d544c68e6c9d130b91d58c39f38b06f3e4a75b6c7bb0a211efa2a8c6bdd039d35245d468a83609db387ee713de24da2e080d9b0e5f9d77159a6e0091410c78c2cd4c5e863c0f1b732339958ff953b95dad6a61d8f36771d927579a21384c0ddb3f08ba4f54ca03b55d6ae74fb61d685386c8d0816340e5f541608d936fe1c1bae570fd9c4e33bc2a3f95ffd4905b8c288ba253fb59309293c0900edf168d9f48d49c2e25829cf21fb16d4b902d4346c3bf68916bf4fcb24ebefd9ec1d2e09ce6f255c7bc1a32cc48c704054edafaf06d93f85b2cb8f9dbe4bf8934997df480317e6afd159e95694d831410f06dd3573264350434dc7edb613d35bd83fcef24ebdf09a0acb5f62d53c232477258a43012885f94469b14b57443bea30302146bd2c339a4cbfdbb373c59a0a86b9c1a46169a48bf7ad59140f239e783cb9f0f0cdf8b31c56630cfedb11f5c27f08a250735975e665e8f12e22ab8b012041c9c4ed27d8dbf5f31c506781c016af0a1e8fadfd5968fdfa3df006ab0e51f2c7683a9af1d74b23bff310f624abad8561bfeb31a8b2f117995d8f1521b516db28279e718487c491e4e366943d58e02b97b5e249efd971dc609a8515710cf06fb4eb8546cf18afd4c25484808d468510b98f422b6c3aab6916b3bf135104f9d9aa52b4ed34d0ebcd82e91d49e769ca99476b5161552cf7f5704552eadb7baa40e97ce4dcc969ca6b29d17b87e56f447653f30d933e97e9ddeeb60fb1568b156c06f23b93e1f255d47d984f1cfed4e5c35cf3e78862fcb2d643b50cd8d3bf18c0f556ff2a427cf5ac05b655cfd647f1dfe804fd7376db63068fe71df6d8a546eec56421e1050599b7ed666061e348d901a462c24ce7ad793dd101569b3b2db9595f67732c441f133c50acaa83d30d87fe49a4580609ccb1092765ca32ca90e0da2df0c4c6369bdae51962101d7f8f5180c108a67f023025d2cdbbdeb1f069f0d0bdc1e5cbcdfb01ba9bd0459280860e3c83f8059b81cc31fdb10e328ebdbaebaf70c7292e0869336b9d10c15f0b8c47ef7f564e7f8f710fa287774bd3d42d6084b66f429c3b020d199d6cd25c920dba18931bc75e521e39dfef8731bd509c19936e0febc0722cb92245a45d53a13dc30ea9528e66226a99be39a00f720a7422199902241f2663bda526ed1459b0f361741ad7f128a1c48a7c3fc89856756cf1695a473e95b69a7da48036efcde3808216cb50d0b00f7e3b19a0aa7513b0eda1a1931dfc12e5be64872e9cead06e536ea36d73f039e938969524a0aec794c01b2402cff1d23346e9760acdd196e572f23e475fb0e4fdb720206662ce4a7b5e8271c35d62a342cef990ee24dc7383fd65ee3e1d7e91242b0da2e4af13a4010b2a444c5f0670951eb2dae3fa2bc72f05b16fe7fc58eca81433c593285f804f93823686ace69bbe6610e823adf7ed86d3062028363ef50134b404cbbd9d19395b784d8bfe7ea78106c067c4322d1083c1a178ac3959fb539503101dca7db26e9c6216d0113c79e71d953737e643c0003cba23dc7a8587a60dc4414e930abfd918c0f86a56ebbded7bc5ce0171ff200b4f3d47700d66bdb516f8174d5a7b174726f0ec8a3c1687a4da6fadaf99d6013b8f3302cec448ab72ee2d27c1c3448691c12a077efce6bab67fe50d71d8b9732d3bfdac9cbe70d238f77ab4863754bce1eb7d18862ffc2c928f072095c011e0353442acab3c528cadf8f35a3937dab32aa77f61102bb5225cbbc926a58a484c0308eef01f82584e060b9bdb5fa4b9b86e117f2fd8eb7f52d81fefa056148c7eaa0aac2f0b6ed5c0e461d09d88478515f8567b2d0d43e716207419066cdd4f0f1aa86ac077d88c0e12b9d58ce367723bde75112271ad23867defdfb7da06f860fcd0feabc62ebee09370376dfdb30986e5837cabf9af5368549ec5c4ae1c8d7f812584122fc63d076bdd5ef111ffd2deb9f3230014434f9f7eb24a9f461013b6864861954f27c3a597578dee5921a6a6715d58ed4c36936ca869af9ff73e157414baaea82bffacc4dba36d92a433608d7ec18a72fd44ffd82407b75ddc9eb456eae4a1070ca2a23a9c0a41aac0beffbc294a16e9e11069ea9e1f10b5102a1c276a072f534768982f3677d6346ff148e8becf6a4e71b9a69ab419ea94ef06dcf93d694de86865e581178a65b8983be38b39bdbef998fc5efef37d5f89501e833a94c62638ca99ceb8bbcf88e9392ddf3d87cf62623fe42639cbaadeecbd0950b67efd6d5fc3fd7f0cfd40a4ca0a5c3220fe846b01b352049ea55498215fde7e494c5cbbbf94fcc55d232777cb623c1374741115c1be3bacad357ad363368bb617382a53272eec11baea102a6c21738217bf7fe84767714893e3617fe34758f8f614ab61728b25efda430e3ea849bfd4777f977131502d9550fd808c0f4dbc2a4ef4bfa92d21681e77d740576b64b9e9c6448235f3fc5e2bcf9ea42685a62c52c68ab5bcb64e4ba1b81240905ed3f2176925f2ca6dd539b66512072a034a60fb9264bbf8e34dc23148c5382f4214c991740075a4b89a7f746154b2e3b6d8031546a87f3c725761b4e1df629ccbf154733cc499dc9eb7395489e91463961c15b5b714d4b58d98aa1dc067a42057fcda803570e0a12f1174048d0aae9324f339bc72e51ed12b0432f9026b86c9966c5ab1e5922cbc8008a0d08ea1670994ac7867c03888f59af9711b4408901d9da12181562f709af0cb38beb13d9b30dcd6788f91ab8d66e5bb2c1b0e179988f1fb9f2f86996573e5a36208c9acbd0a0370d40901e3a3a19b9d62c047c9b10b56097a27f65b1f644a7c53ba5a35c2ddd714ee8047f393a8418d7a011fa904547a8cf642a7dd6c6ab150d3dec815f3095d1d655c981f8f0a0ae36c94ba6962c8d0b45a7b78ada75ec1211279ae9eefe9952b7d92c8169d3cdd8ca780f09a839d8112d9c0b642bd828093535cf36272b2a65f98219f92565e1b781d4e6e071b1af26fc01c00798246cce3e75d9744e0384134320933938971c3a5819391e57d92a7175b3260f09fd45b04849ba17bbbfd1a1b5f5bbf2c33951807bef4b44f0dfe5a9f3b757ec7e7f367caa7a85bba3c64158353955a824903b7e6f024d6322ab731331835c432c995d569ebd6d33e30c697e4e71aac2b6bc426e803f1256bf37198cc252278c65f1df15a95dcb594cce8b4c399b5018011900bb715cff84afa48c7b70048df5a4aae67d5dacc2dfc0405e400b6e741d147a400b90e663392a4633d3b58b168f411e175ce2ce5d00d1454bb399803f1e1d39c02a26b7110869facb1b63727d3ca4e1c296f90030e05c6e202015f0667a93c0cf242fd1036beb215cf878f9c6a683e64a8a8531d4edaae548796d7f5078bc0c10b39b4481c2a259df13e6e37a0142831c83b180fb5cc7b4109a35f5e12171c191a0c5cf9e5cd8da350f3d26783cc1fc8baca33f3c328fdaeba69a8c9c00a624a21df1ff583acd84654216e14150a2c262c6238ba8ece3904e45a220e21e922523bc413d499f9996c1fc4d05eb6bc728798276885ebbd78b3dc5674ccbde5e68c0ec0253700d37159af779581ae11643db2ec48c3850dbf8fa36f0c015b7c21d7f8e8ff705e332385a06bf3c4f337a7ec403b2a5f7351a43c520feb41aa86d1afbd4f9bb718fe5a76d63a10c29e633d0ce4f257918c455dad139381351d728430789b71f61f80b7125ac3b0088f943a7298638b02ebd2d4d7e02b5856f12d3e5a7878b23e36d9c34aa0641289b6824cef4590436923c92f34f7df224b4997b82b451c069ee9f1b356a20695657ec7e628ab6b9fa599a8d7972070a3bd3d40eea3abbbdbbdde6064e2956c3d5107fb56ddb8a4926568be6a9c82da7e87ac2ee802f703c18e252105726b016d3e64d41f9ca03c9029d464891cc6f0cd944f5f88a0d0e6398c023f946900e5cd4ceb6cb67fe0a6b8863dcb66950514280e00857b1f64caa0fbc550c7a29fee8722a70d89038aa50b19bdf832a1bb986751815e9cfb96117f24a98782e563eb7b24e64191b8bc3cfcd1dfe2dc42c09a395ea39964c82ab79d4f608536527b73def98376ceda674169bd255cadbfed58fc0cf4b76197d3e4a75602ab7a29d54e66b1223abe61a27da94f51790b1ef78ac0fa6f472c9a97fb60faed56ca459b0d87ea7522870b7be229f01d9a2bf475a27c538b6698272856ff81f78a24d9e8ac0b71dda163b884ae9fa2685b80f40d3d2cf122753a05d5c3809f73b5f4de8261500da7c9c882b9dbb6578b4ed382062f13ea4e773d5229701a5a5f205da6f6f034998b5d93d246b953013b3a04d341ef216bc1f5ad88be7d6a24e1d4b5e3f64ca063828a44f84a589cc3e511ef7275085b5cbcbaf18a1046aaae7c5b89c61b3a56da3f0a9fe61d4cea6cd827a5e9e9f8c9cb10668090fc7b311eaf76d0ad1a694a9c7e418792ed1205e2e3b8273e51c66657b32177f91e42e563ade837e8601b97af62e25c86305129fdf2e60ba5e008611fe0f6f9389479e4d897c25ce32489d5b2b38e7f08ff6b5f4aa82723500f8c93316d5e86523adc027eef738fb9214513e28cdbf8fd6fbbcc7f476ea211f88bdea3078ba6f379f949e63be91891ebcab6c7575b661b058fc759fc04d702261a0d819d6a7ab1f510dace1087374417e7684c827ade4c06f17605a279a4d7e485c55846346d6edbe4dc78a9f0315700b2452f6dd0f3f651f917b900731d9bf69ace22183639d92dea260a2db863ddb9d60d24fe9f46a38e59e01dadf7fcaff23f3a0ea26fa98ab3d688cf09df3bf1880eca100e47cda2f91069aa7bdc0a986f0f6800b5a9f0e7a60d1b89b2c4f33a663ae21ac477c7a0b5ea3cf1eae8e7e852d0a21bc2f70564242c26050ea4c8c96fd38ce560542ca5d7b75f5fe7ddacb2273a495dfa346f75e787123159b98a1f27dce6ac393f7096fce5d191757da59c950873ad182b78bda82d66f638ebb4fa767daa18a48f76163bee4bbb29f7ec8ab0c67f706a0fe522de9bb380e1e9d01c10ae295146e4ac6423617c52cba9705079c4a19dae3fc83e581091e07c04697f63f808bbf8cc357531a4109499550bd1d828bbac033eb353a9e5a48fded8d098f4f8ac9ec915190a1feedc83cdad053c0e1befac08cd372d2af317166d6c757564769eaae6e3e71fec37faa52cf5a009e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
