<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b462b6d0f415ad3653db053a09b41b1e84e70edcd3f1a093030740fb24ac5975270d87f6b2f76c23115e9f8241697d618934934e779a5ae6c4324dcb496802e4960058744075ddd5979528467efac77ee941c03e722f96dcd95d2d01c4ee196ad83905f28d21f29452a9aff5bf16870bfbbbd8fb25872b5878cd7805e5a0045b4d8188b1a1782e1643d6548b0cb95388128f127ce90c5eaa1918c9db8760cb78fa0b56f7c4835129a313f77336dcdf38ef5dfbede29824e280017462f3a14eddaff94503f1c6f498e56e5fb416dc24203344d40e4ec6e047b1bcd1706afae537c9bc018652c99051c694a8d90febea8ec87ab45c3196ba88935989bf36516cc00240df1779e6baea6dff19571f8c6f5029038e12488eda6146e8e974b07795fee289285fe489bedc6c1b4f737a05d4c7fc462df3beeb73ec665d80222f5b6d56082aae3131bc719e06cd23d8466e0f156f807f554774badd0962251f297138d6994547b2b3c312fa3635dac8ae7126cd94a2cb88efe6b659ea0feb58f6624f4bee38a5481164af758e08d9ace24c59476bec676b66792c6a62149c8bb681418ed2f46a5f165a92fb709e3e1554aaf3a04f960c86a09481c7a466aafae9bd5c20065c0ec2560068f203356d580042b67394b2cdf5f18e04ffceb5ddbec2ca29e8fe8d79386e370e75654697530c7d530117695c24d5a4431d1fb76f1f2b41b8faa6aed527106f576a7fee8ae739caba1fcefc967cb1ea71ce3a2904bcf26606bd92dec4fe386498a5723e8881c0cedaafd5733a33e2ed2b5303bdf37aa04878dbf73bfe7c42296f95691434cfb2c37742952bef928b1a24ef738e08e39333c50d5a2ba1a256f0f1c7590e73ee99d433f539f718ba84e27a6afe9f2afc5e33d327f46add951be2cf0212f2436f6425f4f64ccceaab7fdb165480927cefa50ad4b05442a54869c29a278f7495e79431cb6044a7ca9244756eea13beedd8ec62a0d3022ac057ca9a39c918bd2c640207cdfc94d0d05bb7253fa91fc9374e9a329aa74b0f349de61fa49e832890c743a45900b0bf2d60f621e5413efdf6d227c71eb71421e95d6fb76297eece3f1e9fb3b54985a27fdc74a0fc5703c49155ead9126c62bc07d0a33506d5215e4241ca3f86a916ce17c2d9bd8ed425f5637ea83dae612fa3006eb0817e5b662bca90cf584e0b3a6e3bead2ed631b44b2ae66fa0943e9c87966ee18965e53d8acb6594f59c951130ee8dea2080b59479adb7f29232f696de3371019413d56f04deb1aa51c8dea88b090b3a038d0bf8be9235a24a0c34deb078915835c97f7da377ae65a6358b7c18921a310c0ca2cf8b96da8c5c673b011372b134b4b1ff7a783b9f739563feb7b3703aab7e76519c899d60781c91484c71c53a53c15c5932fe41e9da53d547d186ce73991ca8bbdd29cd70cdd2027efb3ae7ab44946a1f18ea13aebaf2301b426664ae7208b6ce4d48da437e4130d312dc881e3c6150993586ac3dc7cf4cc9ceaabedcc911f6b385508f53d895530ba7a4354a02b724aa9c0c7b5c9c26fc225b5f9c3427d96b6304744c0b03b45e38dcfbe292c5ed15714775268dfd5f549b5d3ab7eb2003415c8bf69186c0c3dd62a399e2a22ec7b20becaf6269e7c99bd906758781d6f39af63b14c0b2055d52c4a2afb61b61b4752f8a9798b6984ada13ebfbf8806f1fdc7872a3a5271369b241fa11f91fd3d87aa289157889db69cd2f47ec32f8bf427ceec9585f2383f8877db2ec7b940a41eb1674b2bf78c175a38de354f5c7f62704d7f90f134c2bcf882d909717505e7af9269863e8dd55c37820610eb1b07fc452ade0e4d0644fe9bb0b8f5d74acf781e46d3a4801d20109317370444cf67c416c01fb60f6abcae1ed8c15596cd939461c276c5289220f3e76670d8f3d30664b224a1e1689eae2f7127ea6854876a776612b3191ab5f1a4b0d9c10e146992ae52c271f5e664d8410fed087263d3cb3d7611a68d746ee8dad779cdbff369627db28d97808ba049b715eed9869b233e12fca2532937893e45fc9c07bc196b0efaef06b893b45dfdb46d077d3e91bcc3425c8890c87bb450502872a828a82b80d96763ef72dc933e6e71ed2d41b42335b139b0bd6192dfdb1d993ad9f9b01d7c220bebe8d487b3a623b32a35625c580a225046f1888151bdbf550bcd05ca67894d57c11f7448599cc65bcf888b6ab8ad1c788091f8bd52cc21d7fc8656bf5a498decc7d7b83882174f7965f715911106fc7efeb24472aacd89de7b908b5f5fa2fe4dda09238825b16ecd0d578733e688d57ea15c5008ce3a05fe45d64b9100738e9fdd2c77f38eb7f16dde7dec75f2d9d5fa4bc095b808d013e357c5fc4cfe08bc42b32a5c754d38cda3a0bb9f76332fbabc5ec3eec7e5914f0c634c8d1c5fcc2fc07695267554635d5c751e43785103877ae206e6a360fc736874f6d85c76ced2ed66e330a8594f63296e3a724782990b8c2e7ab633b018588caf47235d68a94010320dcd2df6a599e509adb8f6ee2e06f02e4b6aedf4d08420cb3ba60737407f2d39e91cd674779e03f123333299c45c0e3aa9b3a5e8001184f46995817fee5083f35f23514b9e0abc20da730d3222125b5110caab4030dd1f21a9919abc5b1fd027de543a77617e596ed8f06da4ad406331a2a2cd922469170e4203584cc2eef75542fb22daffbf3be9e99d8142ed80ba5207e4c58e038f9cb7c7bc82acf8a5649d216d8dafe04ee559eb90020b6ada6a34832752a74a751e060d465aed4bff23bc9622a96393f3a0d274e4eaf230caf468380287a52d99af30e3db985dac08a245e0966c05232fd37a402c3abaedf1d7b5f5c6c4ce068a24a00da3ba293ec1375ddfc742e0acaf2a98d5c587810d7cc02cf678a6367262e1dccf59eff2e96f2a2b112a45d052236909214571f220d5200b29165c0386cb738e1178083a9f174a0a6322e37d23edc71b7cf2b777e984b11a826499f60220300eb8f328da32051327b3fe368fc5c71a1914ea67511a35167f3bdb57ecd980c6917fd14332d55deb4660169da808f11060eca93690cfd6ee6bd959f9f86742fa2fffdcffa4164665effa718e86f404c88521b58a939d4b87b8780abc6b753cdafaae9d75e66de27500a4e9101a3d105867c3f64862827ceafa74d881891642cd47ec10cdbcf3d1886f8db742bc29160de7ec317aa73d2e1af6fd5c6405c9e072d3c8ebbae4d7abd56fa03a299abdd59bd9f1a1f9e78d6111ecf425e8425cdff6d8c21ea70a6524e214316d00ec8eb00d9276c345c4dccef273a4265d9e8c348b40a19831d47bf94dde88f0e927fdaabeae2c7eb506e873989c3a1f1d128fa96699f7638a0e7d8385821f4b70cbcd9f51b7e125ea4edc3cbd747c77f317c74c2b381cc91310c4f8332e6531b26e3725430ba18d737d67f4ebb17977c64f34a6ce8dcacea7a71c5326c85ef4d654522c7815e473a04d00489eb5347d15cf6e54b14ff61aa117d6960e98d4a6bed6d856b02575743df70dae52697895e1f6730e6431645088c51560099a587b29ad95a56db183bb1e235b8ca2586eeb1606ea40ef21a1bfc7380e611b56317d8ad0051da411b1a54e3d87f7fe3a7f0d7c68e17ca1309446c0ee1fdc153968f7530c1c8da82a94d144a4ac640b00fb6387ba96a865c5e67b4555b2611ed510dddc4704605c1f3afbd2d7091808619450c53a4829ca2491af9a11f0d8c2f49fadfa58edd663c3a32d6a34bd3b00764c88077be0ea80f6936ac1719ab33f3753183c6eb018490fd2615b293dc5edfc9cb716fd5bc88b2b27277e4a80224d777e09f3c6f73553f86c807de84b53def27f82288ada63ae8803d4284d9a08468170defce65152d3ec3f5909b64b7f8fb226c6cf72cc40dabdb00f37d1ff884ecd4be778a70c6b6bb0582dfcf846416e715efeff5dc732ef4d13e3c36039ea39ceb6b6f06e06173e5f6a02c59cc25244debb8775cf2697108e03e7d2a4b4682caf75f49d6374216adc90159f934faf95f7778cf451b07d971c33c9199d511684723fb719bf4baa1bc6604b40dbcfdcc3bcb77fdccdda88c2294b9c5d0b4a4b1b6d514a63a142ca08be10126ff366e83dcb263cee83ff9b98ccd18f2b2b9d4601b3dcb399edcff1ae07b609af81e9f607e9e97e6bc178b7090c5f7023629d4aa4f9b0e7ef6e7a014d0cd6a837e98d0eb745f179943bb3252bc7dee2dd961d07a8f4f02b84b54d4d0fe3f0be351c48ebd2a566a7dc1f10893ca9a6c8ec67507884e9cf13cdfec3e2fe3786af7e167734d2f768217afed13a65be5217dea6c6535b905520d110d57c76d37933dbdd5bf20d0cbe755911a8f8b34f7188704ed188eacfe80309babc3faa9949468416d562e73653402f092022c5a8a7c21d51203679c54412cdcb00ef076d7fef5d9b75c871747c00c3bf6a0f501a79c2684ceaa16c7f16febd4f4847f028957c8adacaa875a942575c64407c472b07fbe5bc86bc03c59ecb7829e85bc8ffb5b30b54319d61f19c0f0d50116196328d72131b1b6658c6b4efb70fa6c7a944b5f44a687cc5b071da42352defdd08d763bc2f04b6298ac5c0f7c9b2a190656b9197fa91966817405b7c194bb8c22bc40f7d61bcae5f4ab1738d1a1a7f1783f27a19be516e034545a50b4e3541e47143ee246e82f439a2864c89867af596c607ce7ea2cbaf6cba5b93cc29cb3f60ab232f645952fb8daf7c4347443823f33ed692b73dc48c5e845e7e2e2c751e11a2a86801984b443c1b02d3f7edf84062e7e3bd815b3a18195a9969b1824434ce47a673a4779120f5dfb122a1a2aa71ea5daa864d2c446740726e6940208176b0eb0c1305bc117ed2fa04355ba6031665bcca7e3bfc7486d28b4c676bac9310a18de4553cfd5738d3a3d5fe44567e1dd453db92a5eb39daf6d26b5e2c05b42c4971885f9eb1caad538bd5d53aefd1757656f09924e050c3d543d08814d73ff4d91084e68567e654c866e7c147e1a933fa33e78164d8afe9c4727844da6b95b32cfab9d6b57fcba62dedafc7f91071fd7cd3f59e5065de74bae9e29df160b7ff7dd61f3dc44a46d30df27ff912c8dcfdcbae6c95386ec31faee30aad96f70af8c7d86ce5bfd969afde53bfe465cad4bc626f78a34522128b5b6c16128e164fec09ac17beb7989b9af4fc7bd2f95a7ff38dfc61909b144040fd452410782be507eee8d0958fe4b723ca16c0590bfe0f6dadc2df68bfec13a543f6ed1acc60200dafa60ba3746454be559f869f0f956cf54e08bccf058d30697542777aadab49a102da66c86058d99b70eec83aa11f55b73893f834f4cd9370cbad3522ea31051da06f45487616cd91816dc16147e5dd6a998a47b59f9270297a2aea09f9d64a1da138cab5a8e99f798d6868a71a8a83c99dfd16f5a9735836cb376eefc09533632e4a2490e18e874b184c4bad9512f5e88c5208b18243032228df7325a6601975caf05e932e0a5e4c68a99c83da87132edaa7f0af98817fbe03d10b767e2f229449793dd74380fdf8f0afc088fe3d10d3a5d7742fcd41a2140322b96188cafd90738a75cd5877ad658678bb671f2a5a02af9171a4178cd670ebfd69b4ad04f6d30f224c7bc0cc89ad8e4bac3f9454532d1c1d45344bfecc95c7864e375b9696d2593830d46890498a37eafb4705832404f6ef6504ce852ca908c2348da08b3c295c8d39135f4e02fde6e387d2229b0af25516f14284ba2bdcdac3204593f738ff7458414b185821431872bf2bfb55aa33009d40a5b6b2b94d9bc86d1bdb5f513de5ddda98b91bb364272adfd957249b75090c82a782248261a3208b1a4beaf86dbfbb92196173ba13b88c2b29b1338b1acad80eebe96a80e11512b7265d29ba10dce20b83e6c086919ae510d5e65d8705a5564d1dda384ca45bbda7176976e9c40c3f306cc32672072232b84d550efefa71be485200532aed214aeb6ad7958f2b66dd689efc728d3c5c76293f0e89d762c7f0e279b6b259907cdea6c63aa6d3564a2f8ce258ad3a81a6a769c14fa20dcadde78a3a7ca61ae9d5f9ef15d4e81693aa948f4aea7b08e04842e1c6b4694c270ca457b1687eaf30b36e5bf0a6e462c0818a3d3444d486adfc509864e63a96392b26c30183906fe4e271bb53218643f219077e81ecfd031b39f5c80fb56af849fa5b06796fb08bc3ad38845748bb7f50f9f4bb2907dda29b4ec29d0f881811409022ecc15239a4984e27547163e19e2c2aa3fdf09b302a8c333228548a1f0f7de83554a0d423bc71b20511216a672e4614dce861f3f0eb656a52d617f0b78bd3b56bd0cc9c32e8d1097de8eb2b96e0fc5a5322d858c4ff79619f69f31c77ae1392a47c38c3d539fe6b27e4c07857613898332b668c31ad5ac6d8195b37ba083927f53e2a25db4b469d5952ca22e48d30b88ef6262e54437e6f6ce9c07fa8737bd266cb7abf3f98123ed267cf943f23dd8e97d699946182440f162f67e03f22d96b43eafcc16f69e09fc13942a970bedd401ecc2f7fe3401313dfcf307cc9f8cc7729ad0e3fe7220899ff9dd545555e4a8b4d0d5a2069628ee1572fa1f3759f29c7851bec3bf2d9a2124d4a467b865509890db34511781a500234563330b65e40e44f949900f8c2658d4c5909fac7ac644948bb5e5c3726d495bf9b15db12161cbe9aee1b9bc08244df2b1fc1f728c413b86c27655892ac876576a2319a44c4b6bbaa0b57e6bf5c87d704cd5aba8c35534136b6aabb35bb76f238758411e882912a449ccadce65089a3d217a0ebf405b7865ce4adaff130c30cfc03daf5d9fea1b271727c46bfc26f7826949b19b9c043d970f9d1d81bace800131cc716962f2ec00793e186fa286a795d608a39fb0a42e4c5bb510d6637cf49ce14241e29fc8eb0ef2f6e75ea64fc1deac1a79dc38e67e74da6825522dcd0eb959881acfed8b4dd2079dfb6eb9d55290df4551fd265c210789a2c7d00cb0622827766e6b05f88d6fb54249460b2643d59ea514ed5376dad21ad207955e33992e05b3b01b1063504bac019b05d45e839a43daf8915175227128b8788e72a91ef0034a51f98790569f1ac4a8fb6bcebe7225171c25b19ea295b2ae5b2ce487b3c0cd60374799af2e8b42671c8c97f4dde072a18850b4ec08e979d44726988e95592f106d5993a0ad1165b27044356ad9171e4b9ea7820cd246221a53f5ef1a5a52b91f08686af93591f85be8429f56f84917cf82c453d2518706f1426d6110da81039854eb451b85f9cf5be5f4f4a3c056a41f7b0113afa56e0806018ade8d563a89a354c3cf066bbedd13fa7d3eefd937db69dbb1df1f2e22d7fbf07ddabf2ffba0f9fd2c67a4b997ac602cbc0abf9e223f620685751011beb163ac2c5b5a5d4f79671784b8a77143456064192d6b6179825bcd4fa93988b8cef74a255cf1fff98159e330d2a0f6ade3bb86862ca739f39f2e210793c14cbeef4f56804347f56d0476b4a0c7b3596018f8ad243212c99b4771bcb29943ddb0c7a92764f3d8caac1a68d10653ff3899e74ee0889f768d27d2e304ee1be2af59bd0b0654fc9f18fd6f689a05d9aad9129e680a0e0d3b2191dda5a0ed85cf3386e42bea04de48e9190595ca1049b3532d45b124ec649789381978b839ee9fe6cb3b1a9687b96bab394495da5b860e67b31a0e59be74df00d1ff1a8713578fc8663d55531ffd3fb8291a7625706565fdf1c9970cf21eb55dd96b2cf5b85fd22ab12a935b23dbdfac43712c9f1e7b54d2a5c3f0f8e68ad464bb5e4b1a9e0a0d68e4a7c6727ea8900ded97b47cf470c5e702f815181706192f2c083ff4d81d350cc8b47e7113b61c49c36f761cb2bfd46ceddfcfcad5bde32efd668be3b2fb0cf433b68f379431a77bc1fc6b89efa1b928b7d44ca30e962dbd4916150a526fe6f5e838fd1a16d6d5a1a980da312cba3eb25a652027d26457c66ea68b94e869797363ddf751858aa1729eee9bac59660594a3fac1703e3e36999e92b2fdc502ebd70c956c42251879ba08931d3d6cdc41cb384729b23b9d18f965004c03963ed6f46cfd91add1cc410ceb260f05cfc4da305ef816cbb05db107d500a52d9570d0ce78a73ff762aaefc22c4d8940d9ce8fe16f97c56f23f1e0a1ab28d68b6ffb7afd80528f151e0035ee6840fdcc2ce61073371e2c85456d2968e773ee54a53b7ec3fffbea8037adb23d91f3d7f81a868319d117aa4856aecf581cfa657a871f987390706348ba1dfa7f9b3ab1e452ff93f9cd54d139d83639bde6b5d025ab0d4f44c09ed1d63376d5c1bcb1280468c0ffaae24238cc42bad162d1c28b6c79952e32c135ca0dbf97747f48cdf8d8e39f63836b8bcfaf850716ce40cd26be636f10361c2e46a26459c4cb23cbf604cb42ce21334c59d119668ea505088d99f2f0279a6940bc031102824341562d7409ba5185d2322582058b3d4caed47a9a67912825e2377d51f6294adee800e65a47b5ef7abd66fdc044fb499ce113a2977a9c74563555bb577db8ce213935ffdef59b2cbeef031af8a1455eaa03809b93f81f99f3b2d2aef4cf93a1158d0c6515e36346c00f0d0e2cf420dd9dfe73414ceabe9b8c63e0ad0cde29822ea7ec8f222864b3c1e9bbc4795bd5eb7220e40538a74f6d9472f88fdaf2cebe3adba6f47d0a8c07093c81169e716ee6a850a0b15df549a4e5e4490d96f2687ce2d68bcc6b1ae8c3a2084d208776f609493048f378109b1536ea284142de063ca395a8ae3605570bd523ab47bd4569943f6552dc535f6b8ed2426902fd3dfc3c5f708b1895be87a18f679c11afcd1f09a7aabeb0e76ea70921313c45d4224d1a456ff2b905e6ea778813fdae6134bf4a83e22a26e6dc37a3df73e8927cb6ef7ff8edab996b8abd5eacefb22702bf245f524747cac505263d698a600af0b8d91bdcae0378b209ae5321f6b65f188162b89e291b58aeeaeb0161e3b9f643e98ead65132eeebb2cf52ba3f12edbc4cf881b89ea46f85ddae5e1bfd8900aab374937f088015f4f789e6d8c0eebfda3c116fc26515fd35f9c92fd8adfeba85b2cfe6bfa55af95080a10fbf3ea08e02338531010ce5843912b8d0ef167d62db8a1fc284e64ed62740779cf50425b7933249cb7e2b26239f0aa6ed8c4478618300e74a144c1800432ee60955af2311a77c8a11acddc69c39c5796586721d0a215d1eedfc5fa84180e620742f28ac9d7cd006826b63143308e9b10b25c1ae7590602776767ade61ea90e864635f2c955cfcadea0facdb74ff882af5ab258b878808fe675af9d128a11b18297aecc556f83462b270810e3c5ecc1845074293e1378519ff1293c51711c9c60ab2e8264d1bac1752ad064c9e336e629e8bcfcf335e9e6bc8333f1f54ba12f45e82baf1999173eae9046e9c2e30ecdc9ef0e442082d9f32f1c65ac015df88764449a275b02cf7c2b76ef287b204a24dee4df2ce2a601306f5fd6bcbee3f5478881a83c012afaf33d5bb1fd43361c19986be7333b5e1158b15705d89e08bdda749072df43e7a834f123a76ccb9e3b00937488fe232d203733f7b93f27206ddc681d3a2e645f96bbd94bc807f70065d6335575945dd8a32cfb9d8772b324a39c517de3d239d76a6f5bf27774c1bfc627830fb0b6266ade141f2537f0a6cd6c3f329c468e255c222de8ffbfff12fa263c1e4f555db0856f5e7cd6dd5d669af4e1da29c3771dcf93bd5bd5c82fb6d90cee2ebf936ca1a206b89b23a4f4e884b0c3cc54b6257008439939767a2223b2d170d828b4d06ebab2e7563d4de06465f6c38322ec38ad129d731ea7a31e69dd313e03535b0918d70560d782659a98c3dfdf85e635b1cbb67bef99d462ba968eca445e4626b87041efedcf2c212bd20fecc45db2d9d003a11cf01d3973ce874f7bb03db77c2fc12b75013dfe679a68462600c3b25b71cd228e27367f3d2c5845c9b27ebf16f70a13436df173ad0943d12de2bd841a76492d0635a5bba9d1b81daec0a106a1551b4cc8bb0b859fdcc97aed56d54fc8de4f73479bfd96baa19e5960d6a3b72adbc64f21f617fc31a197065d5dbeb060cfed5bff00adcfa4938a8b09231644d6e4fdad98823b84b3cb2e0c5581cdd5e318fa248ead264a5a99a69b1e9b728488fafceff0f80758dcd9b0599af719ab6dad4e77eea441801815b177ed824a6ed702581b09f0f3618d0238f061802e8583e7cf2b6121fd091680b653ea50104dece4c940fd00aa1860d9194403c555a56378d3a176823291c71d17d0480888af5c4ccc2624be125c21bdd0d29a15569f1aedaa85a15b017698073589581823935a86750297ada1574d789ed416f18516b05997e193b43bea409b2304a7baf1f7d3a3f7c49a449e0da645fe5cc5654dee26b6a5e29100fcf8092b25b234942b6902df47ba66994e493711de42664e66bc2fad38379840e73084f267b3c2e4e4f53d8384c40c79308f87df1c7800d15e51f862ef0d3110f968e5265c87f564c47c13044b4c1c4cf2eaa11facc74e465ef256ab2bfbbb072b47d68b23b9b800e9e4e9f4d9848ead094b2561e1e607794646f85a706c1e3bffd920b93ac4a3e33b8a57f1d6f38c9a203785a20d88ace881b0d76e07f605fa5cecb9296f4c4da7693373c0c8adecf89d72b408d76ef71719a515b39775d7a8963610c0c74a438ce9a3f41e2cddddc40c9774297986f998a68869413f3a97115a23f005be4f9e8a9861119c168912828679cd164aeff03404b52a28f70cd722572a751d8cbccc0740aeb52aad6cbdd1d32293e2c3edec963b89c119dea514715f26d02cf1f3182e7ba99f893a6aab0d0b69e23ef8d8749bf2fcc50b2ca2d5b052e1e2b0aa008a323533543112fc41a1f022494a1b7b09077cef59a40c0d1c085ec4dcd68d1dc2232728dfe11c026f8cc5a45e8b51d09326d8932549d8f3f7097d4690066ceedefbd38e79850348c3d6ffe71375e80ccdde1683c8b2314f372dc9563c4a553a8de55dac50d3ddb4f89ed1994b28ae3f725cdecbaa5eacd1c3595d0f8cd7bf2ad20774d494a67c1240e43213f42d135d434e9a0c9f821e91dda594f27626bf093861a418090c0530ec713afc4ce35c136e8349aba6d8c0da8dfe80cb12d0eaeccefaec98fde525c4e5ba61a7d657200f06d51a44d5746ed558bd94d58ecf05d03b6c3137c2d647f8b3b32fa22e7c2ef912361112186b8391587cb4e6249242378285024d8f006814ada34554579a1dc9259027414a3ea39a45c6f10ebebced7819c949e4121baaf6ae1ab42e53a6c41f1c28375e85520f41635070726a567691fa475b289aa6262a897bbf0c9ad95e16e4a050033f873cb3effce7b1b8811a8634d076d437c9020f46ebc1f3df03719dc2c847fda4b4c1be05300dd4c17f47a6f60642a90a6d7907667e648dcb72b431aa74ae2275b18e093cf9c56a97115844523da45b80d7be362ecb867b225980da69fab99f7d78c7eb04a5f5a2912063aa77cfdfbc29b19a695d8d7d61b1a0cedda40cd594e814e6fd4478341fee8a5be3bf62d85dc53773079713c275140e7a312cd3324c3af3fae4260b77ca2e4c16bbdb2f885973d5cd9611baa5279fc7db364d0511592e4846ddd31ef6229a07816449bc1b15d4cf4e61899cb7f2c49e92293b88e26824bfbed9b370d423a3e0550eb3111d8cac73437807758cd3dae05abb5fca0aff56338c70be8d2b60e15dd17441ac956b788c908b2761f06b753f69ea89c3111b312e28e544bbe3553287bf01a782e86e44857b38fe814be3f8d155fe3c57c14c1d87d4c132046669a455f67c5db5e0cdcb03c0a7c02e4dafbefe41ae51d238a2c55bb4a2395e9c7a1818eadce8223495f6bcd1ed045d6ce57215cdef43a7208ba62c3835ecdee8f92115e8e8fdf11669c359ea8c198b2fa5d42b8a1f890f4fbb3691f1d588ec544ec57afd421b577fb917303bb1dd16b84195e589c208aac20779b3ec35aa506a36ded0163a25616a2a7477d6d14bdfd6aabda039e83ac10cf56f64d32e33afa5e0d3fa0cf4e5f1a5aa39149dd73e71a5310fdc5d8a6718f22036b7751b2faa5cd6ebd083387b3c9ac55cddb6849083bea3a6f472107940f66561436a190798b97d005bef046ddde88867c8ef7cf540c89eea2053d025293692645f261fc990f27f68cbbc7cd020703bf03f756d315fb6233ddbbebfa3f4098a1caac478ccaa05a88994ecd30542666e662f1123435c18c559c147e56fd2a219c3066e5434d9cd4680a05e6d756609f3f6c0a750d23c8a05179ec8de44e9ceb87ad0b88354c802be010153f5526bddb13ba95dc447ed18d051d95c965e6f341dd630797aa187771be42e64dac25c2fb01baf194e9359e78ce5e89bcc3ac5dd81580fa1d6567b2cb6d66265996a9a33928251776bb67399f8e6f79f0f6c59b9f2a3699e57a3b5864904c3fb7a3e044ead28cafaac9a5f60601be7cda62696a6c45e0625ca25098a1c08802909d23c758eca3c8a7055be80e105f1572a85956e627571f4abb934f8d659a4a64d7ffc013c2ff198faf11d47498d9ba422d71044625d560f11d3da5b3d83efdc43ee2331b277b908ad630320d177e7a397ccb05770206c69e8a5c63fe6cb8f48bb54dd2790708511117f5456cc1af59669abb397b509ad23969848f87dd702d779c2ea3e0369fab369a232e4f1a8b4e851869eea762b2b129d1b7495bec865df8d28ab663b9ed16060623d8ff7506f9de153bf02e9c58abf9aa7f4e05568a6c61b7e9718a579af6b1a859d7b69e18e5c5d30da61f2b216d4c7ded1fa435fa2e18381715799c932c723537dcfbd7bea7d7413fb3a5f088ff064f5fb4ceac9726f79140c251c31e4848430a22a1c45f28dab231ca61034cb3a643e6cb3e0f29680cdc19ff6a62bc97a28671096f300f5027a053242d3e6c130cf32cbdb22eb66b3e9a782b0a21740e79fc18a49a7f7761ff6b9cc52067ad7248b6b0a056a597737c72eec362a08c82f29aa3a887dbbc296865002325ccf6a5d75ce106e98fa201fd1042e6615b08b154f00149fd8d5b01ff99398343201058d4650238464f7c68246fc86d33f1285d3708b7de91b4e8b0a4067f0cc7756dc95f2c2836a98a4b735558a9f0b9cd79ffe476badb422665d3bfd96efe98ec774a09c04600b563f180cafad1eea056d2bd7901b4a6d901d5ea04078baa9a202e18c74a32577632fa02d6ae3005c5894c15d8a6ff5ae1e22843c274adaa491e2b791718a362457475a5bea03de45bc9d946662ff25c0a27ee2657a15a0ba78500f0e1791f6490d7ef0e34a672fafa3e4ebe5502e4e6eb5a0a9e1b03d3708ec48264422955ae03213f4805f48b63a3b865a9794f66ca8999a97c457ed674276167cba954d940c7c1ca3d9c82828473b65c03d19ed0774d6de325a82bdc05ce633ef30eddbcb4e7f9c5e8c57690cb869682031de093e52e2bfb0afdf554e5ceb4f4a94551524ca71e9bfd3ddab8326ccbed2a84b1eccdd14b8522b1e6d0f1ed53f811eeae66dbd4179dde47fc99bd204f1aaee1e766567d3fa9661f5a966789ec3cdacd225acd439de85e72b0741f95bd08bca8257032a4b45e630dcd8063446feec5171d063cd7425763284bcc5c9f36b6610a5aa63c884e3211b0ca2adbb5e919801f771f52fbc50ad9bfd0a17bdae53697589360d77d497bc552eb4696ab6990c3c6ff5442ad6dc359e9fcd831e8b7580f204c8745cb2a9615c77a0603e6906e1c5ff4fce99c3dc8cd26f1b1e0db85f8bb96d8c4378ea654dc265c6ccaf7ffcd5b3a717d42b564c6f375d33ab9f003dd9db4b05187498840908d5aef885fb14b39edbb72179d509f6ce14bfa3064f890414b14582523db7ef7c299a9b32e971bcfb05a95743de98436a5a2e6e629bdcb44909983e41f6710c219fc5d3a3e924a67b3402716f9f73617324a064644d5e9d07bbc98b46f84e1a3ae94cb5b70e905ed9f2996e47cb11eae28f656228e2eb1b5227a0b9258b3d98997da8a94f24c915b49a8973d70fc4f830463b82046120dbb03b97d477da847e80ae0b19d5358ea4e13ce84060cf4228797fb018bc9aba1effd5792676384fbf60a39282276004d87ba79a44e0d852c402288a5b21d5b617eae0c2a205ed2ec1f4012aa8b538afeee3e405b282d985cec6ce4374f88e2ffbfdca5119f63df5d2292ba6b6f0356c53c8d1c80dc641dbbd226b3db96f7507cdefd8a76427f27d850da4899bd6f5ebe1c967266055337622bcea1e5381607511ee2b4730d45886c3af8d7626baf0d1a109ba6498874c0131e393194e16e39977b609bf81a7424fb6b36657b1b68c79515a0fd5af3ab1da9a314e37dccd3e92353fbff1c2935c44c97feba0ba9edf3869157258b7d557dd3263336f07d449e3fc58e025b2284d85fab70fd8fd3f98461591cef86a5b0be90d3fd81cbc344b3ab3a1cc46605239433a868b73aa6620fc7b8b58292e4b55c1f9aebb78120d888ccc707dfd78f07a4d24ddff7c34039650171c50fcc904506208ad0065c46f2c912a84efd06deb8112c91fcb939814e33631d11aba879625e3f034bfb00202c366f5e39aac17644a874b42ae8c3c72e8ce0e4ab26f0e38470a4748f389ceaa68280bdf827a2da16bbd2ed7bd5e1f2ba8075c0789f9ace12c1a276a46f80329771f78058962dbcd5a34658a0ef7a7a1dc237eecfcba6c82c4209fbfc9bd556ed7a965eb424a6f8f1f3694e5cc49b6d2960772dd683d4608d6462366f2f591435ce3d076b515e35642579211ec4e128b82fc1bae1823afe6019c702b5bb5aa6e19dff316036b21ecc66f040936af9551506cac37f55ec27b8a8381da704f67cf3f841e896346b8c62e9fe1d49c189c0603fd81cee7f7a2b4444562c0bb49e6f5580453dc145a16909369dbc8c1405da5cb54fc52e062d02ce3e4b0c408f59e053035ab2a8a5c9105dca92ea1df6cf57dd121a306db4ad82a3cbd923ea3cd22d208b4b21d22ee4dcc3093e2d1b18c40314f6c949b3d4c25e95a09cb74c1160388567af9ca45e3eb4033d5afb700fb2991688385c98f3db015f6f59b7dbd42ce2534f271516637f7b8278d681e66f591de8fc1627c883a4e6b4760de5393e27c7ea2c58ce2c7457b730a02ba325d9e37ecd2f63ae8cef3bdeffb2944dd610116f7c3066cc0e0c5b4a4008c081071150623816971c8ad370e8a446bdcf07f74bb633fe8f82137a15a09a23712dd35338252aa219cec28016a3273f0109c506d5bb69331f73d3bf124e0242fad8037ae21dc624728a16b93415376c5135483ff8e30867b7bf56bb95bc6b1206e6b7d0d62ab69463ca7f8357e0dcf80c19b477b1759d2fa4429a3a1609c09c24e3e3c615cceceff2b273b79cfd8d9bf488eca567330e104ac9469e72f71b0e689961bad93e892f0a214a078d2e92fb201ff8c693f6f66fa1f6f5102433bc57a01280773db71d8d5ac32dff698b2196ceeb34ea37bb43935e9ba4121004086fd8a2e8f172f0253785fcffa3a40a0c014fc4a996f8451330e1e6d5b69f5e9fc92d4428c2dbfdd96791834c931b87c0aef09e086a51795f4d1c7634ecaf2259a9a8fac60656f3b27dd239c680e57563d2ac2e2fb4b149f8a4d2cbd9e486576ee91b3b0f41f785ddda256a329cd5c24ed3b76bd9c857f3640f8ca9033ec27762bd9bf5621ac533fa46a4815564e1a8089dfd7e353a0db57e40b5cbb14767da44baaa6000d1c5172506fb0b99b83984d717561ca42a03048a51ffdb8441212117182d8b39e4686547d36a9e16891b2dfc66763127d31d56927ea21043fb083e0de10dd112ef1d2af668f6a5259326fe496080dba052b2353f96053a0c9c4c6c5ffd462082accb7f7ebfaaba003e975a267f37f9fb964c2e33afe6f67d38264565be4c312e4279ff7499eb41b6a768707a4df97b8cab7ccbec7c7639eafa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
