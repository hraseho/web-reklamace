<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bff9a223584af391d7d7cd78cde766f9c3f09e2dfbdd579fa399b91f4b2135a05de146e522d370b29b3f3d723951f038f34d65d2dea4c385919e75ad38844bc9020e88c00419b7fb6e3aecf8a48080fb454d30dd3b6a4bf3ff001aab0a89bfc19e23ab0228dbd1cd64cd6be7a1ebb25053f06d1e69d8d3e1d024e6f6cb7257e14affc47e6dd0055848949554ca7b66d0816b064f5300479629ab1f590241a18e98638c91b4e575787ec07a0114134651da9f35ed357942c502139240be1f244248b6cf657bd7d0e8673592a4acb1d44593083f1255058e2f1685d13fe25316c440a2b2698a8acd93c94365e24b6f0be663e232b7432600991bd78c5329cff5ac982925efd2735511c0405f833873e45969839e10701bb2bb38df61e8c5a4593266aea3823fe60e6282c6df6fc2b790d1ad4b6162d1c2eba61b51bcfec243391951d138429d048315c0a68d00b308725bef03587d35d77af32ac4cf407be9a200839cfea1a3f8cb88b10f0e759be1f06b90abfebf636154914a7da0e28f337a2f237f9fa216c9a862842c9a095c63d0d9d9f3c5179975a7db3be4ee871640b94143fbddde1ee3f9796dd87a2620813172a504ffce9be5a37f0fcbdb7a805ac2c3726fe50a5f5ed926662b455bcfa25c6e0727ea13e90dac95e1c2dc1e8ef64a741cffcfdeb10687c107e1406699e62233ad1dcca5e53399189aa0630688f697d83593ecba4a7d99d9b15d5b32f9cd55334443d17c9cab6d0a8ee14524f9f6994a65fa0fb66da6fd2cc3e8e6795c235bcd6f32b30b5d490ca2a743f62d87ebad00717933a1cff573c18cb98261bb38b2b17ca774edd99c45f39063a8d06caa4f6c631d83440257a660cd7370c4fbd4ac27eb836b09713b050a8bdde378358be94e5bc4c452e2885d86f0761143b07de195a86728a10cefd1cfe1ffc03fb14bfb249c17349880e037a6605a97ec048c2e7efadbe543c008265e3de40e8ecb4b07f4103b3cfeaeba64d3636deadd52f06b0cff2bfee38e66d1b3440ea505cdd55777ddc131dd8d2a7c5e880161f94729df98a371bb244c5721a906a799c598a361391d2916f44a144f0efc003e8b3c9194265007208f1b05e2e6bda800e1a8c71047050cca55e35a83891c967751e394c6bd14fe059a993eac0dbc7efd434f37fa69f63ae80af08b64b1ae566e0db63bbf5093c3994f78d825a3b13e046a82502ec52fb0f9318d7a22ee27c19b56eca33f40eb1317c46ccdb2df96b5bff4470bbdd2dccda916da86bce6af3375291dfc2a4853abced6d188d1a73869f8b6117159a13ad4e7eb589fc136ba590b5290d2c9ea5dc97dba0daf8b73a56f9d2f411d903d92d6fb0994dd9bddecabbc71efcef81b14e2dabda2b0d3cee02fa9de9a3ab3f9e7f8eba9f77d1eb64954c6529aecd1646e3c26c761299bfc4e2f59ca16cfe8511aec7282b2f641edab8b2176177305fb68bae223cd851b4fde678a1da103d0500ca02e647e47c5926ac5c10c57a43e1a92cc7624c29470515d35279a1017bf152a4d778b83c45dcaf82545216bfe9e81dbda2220d090598207eb6885844403231c637b3cbf3ca93d3aea0b2084a757b171b3afa38709d5c82a96cc8ac450c84ec6611a74d5f3f047b4023fa1c56a2691a52d70162879bd39666a94f0506a9c2182ad1b567339065ce568636bd352b85d13451ef2590b6fb9781fa69b31a6fcd1598621fecff9cfea4b3864e0be326a991e2fe94de43779f524e49f75e4194e388aa284abc281988ead52b65132430460cbb14df1d0687a14fb4746e5dccda6bcc2b60d6400c7521bea6a9ad22de29f63c44cbf2bf6fcd9ad96ec5e2b6fd2f6201a4cc31393b909bb666decfeadbccc212596815cb10c292bbe697f48d9b0cb394bde91a0a6bb9f9d09087d018e6c55c43840c69f09cefd47aad79625c268ff0caf1cddf8e0716e792f113b4df04bc7d3e778844b29ec225a3ac74d22d034642662076aa6388fc9608135cfeaed7823b114efdcef6283b55c9cd8bea2f4ea9aa5b24c01756979e19e873ec62f40bcedd67cb1047d0cfbdf0bff10a21de2d699847421463d4fd25d697d37c8e59853fc96208f0321d02518fd93027aa6e2a9b8344c51c1371feb1f2624da86e2d95117542317521d2c1638937cdf13d9ef55e597f9b5c0f1604d5d6aeb0b4058a233ed18ee22aee5aa8cc3fea2824479c5ae328d5617f04ec12f6114f2195844803c4277dac22cbe6820d323ac103dd8344095367002b7d0c915aa352e4b30301d26270c27078879ff6f0f9e50718b4848ce322c2c4ed5a276ac5c96a1dd886f8fc40854036fe4a58eff27ffaacd48e49c473a59ff4c42322412fd07106f0e6752e427dd5a91c591661eaddfb37398b473743ddafd0618edf891ce84a0c6685174cc340bb8952d2308b9baef8f4db1e1b8fec874f6621963d5819db650549a528c643d7b822bcda03cfb356d48b13091a5d5148620298aad464e5987875c8df56f0d93fedf6ddb2fa7584edb4ebe2e159fb57a38f12cfff5fe76e669d6a00955e4a732a2f1370f6619f36d9b27abbf63477536ba2dfd924b0c28b34b93b4f2d7747fec66f60e49347b5e395afaa87519099f939f8c54bd8db4e2bfdfd419941720b05f640698f61a632b2cc563e8d7e40b255b1da43acc5ce360ab1d87d6c421db2075076e81d6911a3ab92a62ca6665aadd3c5aaf039b09bf9dac5b62c2d09d709175433632125e590389471e5322187582793eb22fba841a5fbc43e52aab62f4fb4e5ca3f112dece85c32b61bff159e45d6b6f1b9319a730505fe1edf1f01b65e29f2768b67e00bf584ec0d551f3fb67a1c8aa2bcfffe499fd0243f6140f6462d356fa97578b42f2c9c9a763c9b0a59fc798db6a8a4a57031a016fda4a087e0ed43d4f5b7c30b720c5bb6994ee83177f1f7cc4295a64ad94347157ce7cb9ecdf42b98076f8f0bbd1502658ecc15e1f97972122326e637c62ab2b2f4e315db74d27184714e7861fb075ecf8491af52db8157c166f61c23e899bda1633b98a744ba27700717066b98457687fc8353693a5467c95e4755a93556dec426c7208077fca38932c4ddafbae3c172504a4d6938cdd8b4220a4654712e87f4990c23dfcf2f323acf8a01548dbcad8c45f5b12a34b386ca9ed4b1d18a10105d13e75cdd06bc7d006ab035cee69e426cedcfc2db0666162b2d78eca9fae5610e29f2ef5ff8fb3d6e23bb2abbfdb93953335e2520d63eb72dfbc65ef51b0f7ceadb4b341e9d286d07aa11de6304564dbe023edc1351d3c2562766c35bbf209ef28a8b55c4d8b2622be77742a566581de551b0d33bea77567077e14af85e2d3c20f055a5d4c7123fcff5580c2031b2fe02547fc87f2d8d431b42fe2ed90d865af66de80c04ebfc03ae90276a1a2d0d8f78d7fd9d01e1d19890a5d822287019f5526c9b97378a8189d44c77f63acfa7a09a4c00db2cb15679e2b53f1d3df7f0f957a3f61f22ca7df23ec98feee48f99e5e0586b09737455415ed1c5bc74b54ad2d56dd2c74cb7989a92f7efc4b19f8db44f2c848182c9680f012c8179b5f2983dc0955447a1ba83282b9b8c4a181ab2ff48dace181ed13e04dd77345d41d608c26c2ebc2606a19e1957c89ac7c0a57e426dabe8c8107cbf7342e766096c04516f93fca9ec527c814d946879cd4679ee04fb3e903f73329159aa32d4b6907ab7bcc54e8b4f6b42f4f8e667496a768e344ed491fcaf191dc7a7dbc7e040486fd9ddc5636676739d11f4c6239911d2cde2589fa90ce152f2b98b54ef642376389aef43aabb1dbf87a38b425cddc981355befc6dfeb6c6da7b334fd457ad7b7e775b9f8378e0bf259c830595b91fe371954bbbb14ea214bc374ba41309a5527f9e81e1f31fe5d67e749aaa25d838a7f368f157d0f123fb5bc4555712f32eccbc7780c944a6a50ff7ebdf54b79ff15105800b8e0e4dabcefbf696b0db239f1786aa2147e74471aef6f814592422d24c7690af26721741e1714e23f98c70d7cd1b765ce80e4fbe05310870e560200ce5976bc74d884a2d049e81c7b07163f4d6c355b00fab73465560acabdaf9c03be3f818e3e4871c9b9181dfc1fd30771b1e5a6c746975771d018c7b13faaa15a4114573cea105edd1167ec721e455069084823d0c04116867657f162c8ac277033789280c8f7685aac9af7fb7bc89ff7fe24fb76aa9bf7795fd2e9b17bd049410a33af0e5da87140deeaf9574d7af8baf011e8e8739a12d7bdf48fc525e26bc301d74da582524ef3884417b9b5d0042ea033228dc68267c7f1eb150fc269cc45feab568d10f6342d7231592e3605cd3b185ce3f290dce618c29cd223ffb7c84f08bea33a827e9b89c82000e0dcb48438eea57967ecd2f7ecb641d4581f940f6ed4c555a070d43d1d2fdfd9439459b8d26b645da996ebfee38e959b8fc5b05b28a357b62315840feb68e22fece6f345af65f8fe6ac8c288615cdfb0f5a3480704a2e7ec68fee6b88a02e931d29c919b20f6c5eddfe941ae7b51aca7199d687583ec83c58c58ff2f39113a539bda6b348f058ee56280f30e5f37a79901abf43465ecf8ea1a522aa8175cb77384f9d06467cb2c95a0d218dd12cb5b13ffc4160c916dc39128d01b3987a9dec60b82a191c51b92d1f187d2a6489cc056c39b076f597f9d46fd0bd07e679fe96d189c3ac10ff9d79d12180243b48e92bb251c70e47463fc25a9319a5b84cb71c8954245f7d2f3d7e149dff85fb624606d533a6910d1bf53cb805366e9da64049b5f4755bbb68586464bd27a6043ccffda96c304ab5d0f3c080511c17f76171a5598783fc40c0eb2f2504192034c4d1fb20a879240651df5825f52244f003d63b6f739914a80b953d108ea8d293dae17861c991dee25702d1324d1f2ec45c23caebfabc3bb5f8887de6da536e229ae12460e433f440e1194e5825a09045cdb5eeb3312d6cac7a9714d0474cc530674027471afd0743ca487f4b2e1fedabd82e084e704fb4a29b0b4b557e4b97c74dbdf015b9ca7456e6906ddb66205fec668d3c8da719bcd103b5dabdd42b0a20dc47fe5eae5d33742a3ba4fda7248724f894a783b4d33e3932725310cda99d5d0b847c50198e96a245a676561c17a5ee0f5cc8d3b6307d22e790a1293574990ffb0180400f6e6dedf0b24148ad4ea674591b2e0e8150995445972026fbbff78bd15b3d26591be57af146fae02404b5dd96e42d77fe5b28a7f60475060763bd7877589080073d0bccb5f3836d21436b4dd52fce3cee176418cbe0407c0d6188679ad2a1775b0391c56fef249d34b5605951b2a46290a37d3c15d4004547459d0c0075d5fde059019ef79a52b1e64ec9ed9020f452556f7f4cb6b2d95bc8568bb45fd2bc895cba953097629d90b140263b4375b18cb773aacf4ad05ead4e85158f2a66eba96898ef8135634b5f4b907047bbb6dcd433da86fdb684d0e7c60ae3ce7cddee4bbba0ffb3a257341e112af22903bb4370a3cf85c7c9ae4015f6dd9ea248443c493fc06fdff86ad7e8b278362dd1e45a14cb1f14e6fb93f4929091bc92c7e90c73188a9686537e12fcc391069ea330f47a1104e016090088d0d681d65e546bf5017b76b557a3f2eae8fae744deb554a00ede9aec2534a2aea0da5d3b0c5321c13b56fe018ecb6d141231a986a4724f46ecfe7eb500724d90b26341a246b132549b9110527a89187e252c67258743372ca808d104a76c4c171df52c1ff6870ce00b37ceee37dede0ce6c702e67d765fb46e920f99e73f8b2d8f8d91cfaa9934904dc7211a85666665648810d53c17a5ca2187311fb0c5fe4f5857da4a9be36924f0691e164bbd4bacebfd2d50e23dcd67eb8a4f33c522009600482d0e0835c6126b27d32f8046b95b66505f2df166f4d1fbabffd47d2b9afd9cf5de553b2180ea34b753042259321b00964d2ac0e60af1b8bea64aff583bf34ff4f639cff1353bfe07e1ce282bfb3887cfaca3d1ce4dc26c9cb40b469f0fd732da35c0cb88a367d58e17f52df30ba418c009c0e11e3044b9acf37e049242ea2db6327a44af69cfddb332666f6105ab6b4e931d9426f52079e2fbe28e248736589ae3819d76621c02719bcfd8c6fb21fc5058ab0b49cc7d9610834dcb6205b6a21a355c2b911d562274ba28316cc16b93e34dd1126fc4e9f621289ced369918bbd5c871934e81b9da9ccc688747e043da58ca7091320a9944a5b0814c0af6f3e8216ac7c1174df2b1d1ed754ebf00ef1d8f8581fe3366ce18d4151d23bf58ffa9a6a27d8b40bc170d3d37d18ce90749c3b8c1cebe2b2b5eb2fd08d4364b986212a3f20700cb52e65ebd630ca68f08ab8e661a3e8aad42611e39c947af4b4d2985b6d2a29f658ff05755c3d1abd8e29a041c91514304d1190a117f936fcd6d78e26b5f5afb9e060eb94ccdf192e89d866640d1b39c64b98602d63b80ef6b34c67fa749abc1f0d7ec7f736149f19adc6791c3b382c4910adb2ef9d58fcc62ba59554336bbebb9a10a3d056d51f46006c4c0e4e4b3e820f03fb2ed9f13871fe73ff1aecb328dcde8a377e9dcceb686c85b1e5f3c4c58428a33398217d4adacf5fa71a07038a671617c820ef33dad9bd2d46a110b41ac02140c3511056d260de43f6e8667b11cde3b94033ed824238aa338b65d1456ae964f226fb07f7cd65d1869b52a842952b001a4323884fb1fcc783cbec9128a79abd9841fd9acc6ff712329813c367b6c0c68af548ad984ccd71603f6927971426a8988bebeab3a77bf284c363c9ad54ed2f81e08f736fe21acfd4c067809dae735fa97064754c41105993d3a1921c25f48abbc76dddd2a52e3eabe4f3d7dcaa5dfe85e4d2a6273985e6ddc73b8c0edec744927fc94567f6e91105e0bdf6e76def38a0ef9cbf2c140d27f648cc9a4a1c516af3454ddb4a84dbfb8690d6e6a1468c649cd38e64a6c6cb5dce7980cf258a0afa60e13128de2b13ea967073c9586075378bf71e1807d908d5c68c679741f3d433e0a626d4954507c84b199393e80e45d51b611ccc9073f9f4eb293b81a441182c353e4c4c809008e90fbabf033a367ca336940051336eff141a63e964d211c0e422fb27712fb97b24f866da010c0d81039dba235c3a86cdf6ad91cd5ad6286bc4b34a09c5317f18a5c685242669eaab0024d6a37c0176c96c528264ebdc32da7848fc2c5d7e79fbd2f1e858f44930cc79380f441afadb5de479a4bab317f06abb1a91a0442cbca248c077647240a606bc1266a18bcb7e6bcc4c4b08a612f99814119439e6c48b15224a8531d546c86d5e949a01df8ccdcf6a91b6c969bd23984832e5f220545820307e45d05e616e8d635041d45c4c41c92e49924bca03faa71000a015c161dfd3c1819202a6dd46a4d75fa2ce4cc0e83e49e2fc52b69c5b9cddce26f08e8bfb3c467369e06118e2db8121017e1d5a753ea061f0988cce309d0fc07f8da76f4247b172c22142cb148706d8c5479c8bc4a0cf91173a3d9c769957a23008fcef38dadf77ae49017bb455c0dd21584844b1321949167e2285b16ce091fed1db544a2c9f45fc290a45a16f2b13c4373f39b9792164b8e8748a4350b16bdfe58cc39af4988ea7afe574f6a123eea87bc360a574d37180dc8768677c5c08b5b37685999ba2305b77c3f5e0e01987da97f9e5c2e4a1b8519c64801402421a07fe7b11a6b614778b4fa9bf68711bcedc35c16b29b6cac3d287f2214606e51f3b51089768e0344c93fcb449e8b8215c4cba6a5d18a67e8e80cf42d39df3c76e75a4c12af6e68add8d1143f1850b32193856961eff6405dd769ae2ba4eb2552b35ad717a288ed5022bb3db3dbb62770bed7c8d703c1599ab4b1ec58d4f8d63d198b9ee5cb9c340b4dad4bb5f9886090cb49b0039a275bb6c0a7101772d269154bdad64957b5e0f32624b4743108c69402310c40ff857bc0668d9d8bd791beed637c9cbcd7f4db80a19481838be9363c7215121177dfd149173c20e4355381fa14dd446477aebac6d3e4583d7750bcbf64b82e6ad57f3c47ceb6e3dbb8342e64c0d6e8e685a75d2f4d01d32766a720c5407666eb5e45e00d858e878b707069f134df7755a2e01f7957870c15a44218b56d37059b48bec1afdb1a41a9c8a91808de4c5675f7c04fbf27f4093a63002759fded985b7772e370e894986093b5490115008abbe9c07a64086d34beb9cb38f4a8efcc7ccdbbae4a772c32ef9380dd6f66dbc8751baee4a2b239748fc0d528c0e8a2c7c3360fd4b28bd86dda8025ce154504443de718ff3b81bc80e625a774f190700107c21b1477c52e9a387524b592634fefc28ea193144ef5519ae091a91fdd83a155b4f4d4d621ac24b3099a0b103d19a40509ad31b0e9f720fe08795bef0722ef2e0ebe89800dffad6dc541b71039f24223105bd07e94d9f2f03538bbf7dc9f72843b990e1f70d42aa706579f589e1443178d9ff718a6887f722bb4c41eea2d7a673ef4b767e432280f3a92afdff38a95226be227ae20e2c154b55be31b23222c82c2d6dfd380a3302a39687623be7939321dff2c86e1fa0c0d5cdf003f5ba75b346f5175a6e734dc5198900cd95b6b5a1a417f1902d2ac5903d06dd5d940cf376ee1e64be958f68795629d9fc73df1e68c4fbbf8d1fc391b7378da4152b8a70ac9c622bb750a63acf59af617ba5533a6e04036319e851b5fc5d37320f64ac3161e6789032eb0aea08c54ee164053192452134f22a01ada4208128e77886c86352c06b6c79627e89edbe4a6153638f49dd6bc4c541222f3d9280c16fadef97e3ab2cb0862b3c52a038ffdd0d33653c602a2bf81aec5495c09cbe6e0b30c1878042b09f399ddf63587ae585659b9fdde820c40530c57741ea7d17d02cf9d53cab74e43beabde8524dd3f224394da26e2aecd1ad24b0f548b8f7ed71192a523e39aa746ad1415bcb5e78005f8835ff74d41b9363f920291474aaf581793b11e4e77030737e719e9b77ea2100f337619636d81bd0d157b336e723c7f78425228796517bde8ea5aab1cb6e14357f15736cabc85af39fb19f01b7eb35e85050f5402e7e17aefd4044c6a0f0ae5c8da54aebfde473ad3a9876407dc40cb683a6019a24137be130aa4c89c7882c1a1f42db47b4058a8e9fe101b118c98a7a33895ae607913d6a63b8101250d23ee7db61558b4cd6c9602d8ec5842982a8121875166f632add038f6a5cd8250846261999025a8e5a75cdc843806e957d5864b15440790f59d34f4bc5d5feee4b1815eccd79b83450688fd79aa19ae96441264f356de516e9bcd6ea9cf34dd984dd9568839c2380aac7ec657bda52c054df98ed5ff22c167e18328e75b78858cdde788ff79dca50b5034596e0fa908678ddce9c2310892738cb1f739f515fb39ff9f434e41b52cdb3feff60f0c9c52541e11c67e4a65ae9f5e6fe5276b9077011ecce0b3ff0dd2db7f244759067abe8a6db5b866cc97a6918450d356005d3619681d7b7ffa08893d78db6bcac4c19a72c5deb93026fdfc0a4354a7380ba2e1fec7dbbf351351fc13364caa02d49cbaa97f55cbb38d5edbfa4a9537f152de7d2233d596415807dd9d0309790ad7f10938936d6f35277c506b6fe34d85e974c3bd73875bf5fca9f40d61c4cdc33ca2526e368e52831c71bb19177fc5bba31f10fd60c3f8cc2d092d111025603425aa7cbeb05cf550e878a62f8835dc8e20835c3815fdf197a5ad0e5131210c6723b431783b95446291dd2016a9e617efc2cea6be2e27ff4c0a9779fea36d389e217f1fb686e95b9baa84886b7d0f3250f14b8eaf1c5166d6f50b312b9081f1582cfecaba6ab1a8130b02a395222b162b97154cfe7d7d9ab5d46887c17892c28af26c4e3a95b531f1bfbe83a2fb15a5b39992f7e7a7662578725e66d7827f5c5f22f77f1534eb35ab5916ecefb40212c4543cbf3df532227974d82ea025124eaf3fde6f6de9cd1e7d9daf3d23cec9f7d3d7e8ba702c263258f1481ba5d8358e899eff6f37286cc711b15f8c9b8b71df3f9a60a8e04f5167572c9fb7c855b5eefc9a897f951fbaa9bf73775455584a7c474f3666b1e9c5017253a2253d2b7402d7b0db8f2b5951b69a88ea8edcc62110f3617f76754c3351abb926982f061cb0ed36cc89a742b1244957b3ca04cc30d8f23eeb4ece9a30b8e962e821828a933475b6ff774ba948d87cdc4e6de365bd30c36774a000431eae7d881d23e7484f48adc193199311ba02f09de7e1a9d09f0bd5cd8dde9893be6dfd54a0c01627169d042cb67e04d3876dd1900ad39a2dcdd796bb407660115774fb181484b973d03a6f60d0ce207999cc0b53c3138a2df90f290780c8597ab0abf61320916178988d8de21ad24121850b9136d22f08a26","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
