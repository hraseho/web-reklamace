<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4825844f4990f45029b22113543cc810a727f423617230388b25b31379d9825cfdb474b3ffbd98c1228440f3b708f35bcb6730667e2c208e79ddc7ac9637f74017f35726b9373ae596723c1d60219dbfc74f99a9c0fa4a7c8679e0db9aeb8b8e701e1936ab85348311b5899401504e894288b2244c7f34dd33714b2887fc03444cb9b0d92cf931b9d22218b4b2cc6fcf3aa12bb483e76dba87555c1d7a1b21a05b1db72db58ea0ca65fd6ab776187af17ee2ade1006c31ca28bec43fac93e3558e78107f0044a6f3df78fdd98050c568efd52291f6eab431b65bd56a5c0ba598720788dd4760e847bedd617ec0ee2ad849f46325d0068649bb13229a12bfd800caf015af255f3b66e05440e84e72cfe28a2bd538fb425df92c4c0ce8528f5cb8e87854910470dc42fcc7adf0dbcc82ff4acddaf6bd9b8e1adbbddc3519092f82c154740e3bc0667619e609474bdaf5f7638a2bba32ce9032810290a52abaafd45526d21995fb0c0276e891098087c5754c8e90eebfcb6dda3e15a75e99cd64b8681c80a695260865defb8d1b4c63a5531caf77ee041e47220e8c90dc8ecf30605dc9ab042c193c45173e3e2ae6debb0056d69de8b18926ed60bbe261efc99d522298cb982e3c069c9ff8840eef681e53e7487e8839d71bb2a968f080dd7583476e4c0ae6c3602ea7b72068c70f6216580c6721925ae4a339214e234906b5dbcfed2899eb016f560c802ad86b6c55c7db7bd64e23e1f8e74fc4b9735ec52887bdc81f0f902a995bc6e3a7c68b672e02d47b0c864d5235637a8f08d13be1c2b9c5ae86e4a6cd7ddb295af1987297909577709665cb123ab3fca96077a192adab8346fe14839b20b51072dd3d1cead6e1e7d5a112ae75d2e6274a95ac5092ec842a70ce6fbfa4cadd163d10b2ac17967eeb77d4af7b600ee36e5e1ce93113ef29ca1141750757e9748484ec8ba8a9eac76a6776ddc8cd5b6ade541b0fa67377c1901f4001541efbb00da5131e1b4e1e6904fa1c12ca36633280349b92bec3388400743b4ee1f9e8e575f118628ada5a3d05531578cdbe206b14164175132c6ceaf120a7d53e0a60cc0a7e329668a8f1a1165000826fafec155b07ef9fb56dd3c5adae379fdbd5419ccacd4c74e75be03cf81b5f30b1a5c5f78665ddfdc789d920c28e629cafdc8101ff1699a27ea0ebd593e5a7023cf6b1f4dbb03f87b7966fe2a5c8a4f0a5fc9540dc171b6c5e8d04ea35a6bd66a3b3f4b33823327b5d9edae6de7e1100717892978d94e8fc948ba26e557b2bcb21ce9d30de0c89bbf5befd8bde1a6a7686718c4513ae8fbbbd58095bc21164ed3cdebd19e59ba68923a9d08cf7c3e5a74e1bf489533f26a22f7b3052482b71b6649fa05f92035bde7ed47d4133e01825f48163c5d2aad10c53a858ea9948111eee0396a6350de44fc4aaeb32a39db13a201e748504823a340ec90679e285edd0c2069c2a301e4575ca93966149053bb0b82722fb05a6cd3f7eaca760f3039fcd8652d4eece0adc663a896cdaf83450e713e4aa7acdaa1c25c7a161dad47786f7080a0a525e03d82273ada1b1c4637de7d73964d579e37aa29006e302ef8dddba0411d22f978fc41cef0283fccd1487472742dd8404a6b4e97a81e95b2387b9ec7087e737cdaebda4e8b5f5ab647e2f38c6cd0e6d3ebfe5c18c4ce8eb1e6c13f70c5bf4ea3e9f5c1c1bda56c3d47aa8ec3653d2e70aadd29e34726c5a5861dc004e9f63e0a1109d7bfeb44b25253a6795f572e221e5164dedba3043cc8b48e7b2eb7aca0a84b698a2447c0653a7d974c1a2513e136fb210b260f1e69a062df85d28c7033dedf7c0506d9b65eab6a4ba49eba1141b531c8b74b50850a4c838aa51bc1b969027cf41a8e137bb927aba8f9001e55af68ba1826e7531a55b28e317547da6019b40fe7f4cd64296d7c412a8c5703646db54711154b3b021ccd22a49bc8b4db915894b250fc8017e666d1c2fd4a9b8283e9c4a2de1e7c9f8ffea0f55bc1afb0f75d5069f33effbabe6f9b90e5f7a7e8e74390210c632109e8ca16a4532ee0fc432220fd1acd6ce7e95f57a964a420fca36d09bb42e83d4d2a43d666ac13451d3c46c7c9433ded4d04eb98a59c1f370fa5bd787e26d59f07acc956a1dac82bea4db58747cff43a89c25db3013a1793de8bb79bf878c9c86a47e451e0bf297a97711280b099a5563a9bc00ff11d95ccb71dfce56b8997f93f73a129c58d7f6d12bbdd6709058f943d7b1911c3bb763ad1fa2adc6c662bf36a3cea12ea3f85d9856f4ca9750a9f0703d82f60bf22db6a4292e59eeef719b9037b24fa19ccaec66512d4e231401f8e68ed7a948bad526eb671cbe49d2b779cd298cc116e7952e3264418719da0072467bf7727190d0fa015ff0cafd05cd447fd27b75d20087e5cc27423c54d9d95b7de156c1884b171c04a955ba9260a15ba7e4d353ecbc2e8ba1b566e38beef6c3adb0dcb7426cd704b5a3f45a29c3a19f31887deb04a82a2ad00ba9f9ad59e2e7c39d0bcfa187bcfe59b22bb0478a6d315ce9e3095105d56f716884f2d7b772a846b05c69e6acc5f8de133775a4e782d22c3460265e22fa7480b85eeec66cb08d947985bc88154da6220829a3cf2235cb13c5ba2f017cbb96d80726aae971961fc662063c3371d65b982e83057137cdc05d718dfc40552a09a875cae9e9df4188b0b654280fff3179b01faf337feb76901017c1798d1ac8256aa7175e89dd00d1c6615ffd91b09ebbcfa87df4e906e243fc00fe4c54e7bd3b2290ce0cf46eca136a09ffef79263cc14a3128e510e25d1add84a970be25996a732d24368047545fde45be1bd26eaeed8924ffd00f0d0c4319115647fad1bba935dca300a13f53dff24629d96d2dc96ff7a929a552106bc305efbfd86efe91386bfc8152a5061996b02af3465a5d146cfaa574242a5f07a8d24415274cfc69148b2fe8e8ceb1a08d9acb1054a0854c97bcbd5e99d7e72023820816b860158b2c3c1a38926153aa140ab44c7d8ef33ad8cb693991af0b414344bb30fd29d9cd18a0f452e1910e6f95e0d7099c5b69ef53e5e05120e5e70c8c007fb3ab27098cb8b02d2e1ee3a238474cb49c4cfa1303dae71e2464b8168b7de448ebe16dc545465b391f1a294646bb37b12cf6cd74df4ceaff132633474dd55d2ea69fed48ce08aa4c2b576d15af46591a23747529aa007d637811dd25fe9c1051253a8994e122e58d72e2ee1f09d94833f1caa91044c53f12a46c1076e447bf5dbade5c859e161a77b8749bbd21d3a25e1c5f30fa895df18a0a588f75b9b3641df142687839fd96a8aba8ff6ef7755bfc4b7d11ab6239b72a05c60866e485fee3594a461f78634a6aa1d81aa6cefd6a1d001c9e48a99e49281bed68b7ebf9556271a2d0f6639058e947555e9c659a03727a9afc8116711d3ba31eee7d4fe1d868f0ab2701ab29971b99b066eea67efe16dfbec497d4732c54ab7ac232c6eb6923c5016d26d7d7c5a4c192e16f52c35b41bb4f96f0d2cea28fdb58aabc4bccebb5229861b4015f90a78ff6d0fabae6d2be01b5a4cdc3718fc277f1836041423d87ead6676c94aa55b85033669225c473a60ea8cf2ce0da169570f3d31a4027bcb5ffe40f881d76186e44c21bf1bbc9761e53bfc8cea31b94794c483a133459de4cfb4c2dc1460a971b835410c6061dbfdcb0f1505105d197625857a63450be4136cd85c8fa7e8eab5646cf903ab391cb791253a05eea4ae9fab3633786ff33206cf58bc9d8394e50d6ab08ba4fb4e7878d3a1db9323120655020f16b8f1ec94686b864515f8aa36ee515c86b9226f8f4c1c7fbc6283ab83a5a6ca472d689c902257c1a3ce4a7fe4f49d9da809d47218a98d8ae2ff8b8dd175a7914ed1fc689f47667d7a218d395f3705ded7cbf40ab15171c8a002bf83b2b7b2c2f80b3ab3518444ec458f8656310b4a7733e2dae48bf7964e3f312a8aae70367deedbbbed4af82f72f87a24dd4d29cae3ab1afd9315dbc191f14ae96ccbb3d437ef735702bc6a8cd1d48f5802030b552c183a3fc9288b7fedd56810744c4db9bb83a05135630b4d534339aa16f136616780860d947ce2b51257e831528f6d215bf3440b7c36124ab8f08095cc6bdf419cdfb7c687a03d749b6a1224206ce42c16ae2a3f2c10b5cd9170978f5687c508b2a5df42cb23abd2fd12f1f9493049fa841418b87e8fe35d43198e6bd587f68e002eec52c71017e647701ac3cab142e5fea11f55770a0bb6f59e50296f4c41de80eebb148a1d543d46ada33c666f8e4b193401e864afb9c7f4f15c682b5325c8996108cba5bbdb15968d8b7e794bb6e0d54ff0518778a90456118f627a78552ecd5c355da1bccc427429bcd24c7532e139676b264158b556002e531a4575e830470130aef8aec434004dc9974ca9a0611d21021a64942f43f472420ce6e43a07674ae88e15ef1d109929d7000a682cca54ea22a28dfa9fc036c8cfdaeb13f7e59024eb03257423ccd97c0cdb6758b59b1a881eadb32ef5302b460cd61949ae04bc49e0d5c0914ab317bfe79b531bb00facb54fdc8575b660631d862e0c6c4a52957e07e4ec1119b8985abc6bf24f88bca680b6ccffb805e6563486ff69d9c809503ca6430285f529360a88a9e5ba2aaccf38265f8a7039490bcab85d8857ce948bfa87e593dcc934288e54b6e21ec962d5d4fa71106409a432a3232bb3597d2a43c5e34c23f6ea06b67aa00b4ee5388c5de2797ecc1102e8ed7ef64e8a15a5d9c08a7718d06e82ff995a5a031c36216f6f522984bd6cb51e2244ae2d0429c89361836703897a1f9787d9d6db0eeda34cdec773d78f0dbfc6d75f6d85b39ecb5012f9976397e6536c2b823524ce4ae457d5760789b21419dd0ff41f6fa0c184e6514ccaea84d2fc2813da3440ffdcab1388d08b031291a2ec41b284eb124d63394034b84261521d895d5387a4db1eca2aae036fab0a24ead7592de6fd76476e69afe27eb85dd048b4198424ec8abcf2c9045566d1287ea449eb79eaff155c9dc9acaa624cffb99056ee056e6f8e341014e531d180b8ecf7558672b57b72df964465fa988fbb7c48e4f9473e2be10bfbd089972d279b255401b696e5d97d447b3780eeb82d0f92bfcfdff6f035b5642e132eaa35cbece2c202e38c36dcbfd21807ddbb7a13010bfca4a63fffd2b90869663ed7e80ef9396d9c54429880b7864fde4642ae6b164f46b38ae00be631f6dab2f52716735e8cde942a3b58a7bd0d034569e847825e0cebfc8da093da0fe7ecab7c0b95c985f550c3f257baa4aa2927f4591acbad3b5419622e61bc328c26f822c67229d84849f870bae60aa5898f86db95da5c10aab4b74ab93ddb53375ae46a45ee355ffb42e5d07d83be518c87d026f2dfb3c4640997d1f92a83489a887398de57e340e90345dc7eb91e18172249998181997a26071826ebfe2643acbc1003aac3bd200706959c15f4e2747a714d785bfbaeb1295bdd3c5a7129dd430884b6f01565badb91d11bda69d1bcd66aaf8d3be4fd2dca9292b3eba43207341d08508710a1dd438a8de1fb4e8841a4aa6eb2dc2b6248c5dd38c03089dd48ef20512581091bc50514948a549967d7072cc8a2c184c03b132504dc65779999d62c6295e43a499222dfa33ae3dd85b5279ad96b37f3130694d217cbad5013d7b12f065ee4744d4143b4594f7fc645876ad279866d5f3980873da9a11ae2f876ace9ed1a9d2a25e5acbcb0b3c25730dfaab0bf486b6f67380ef36fc406d84cddbf6e0134fb0475fe5e1196264213b94b1f7787245506ea56687c01e2cc2d7e20891ec6b8dc7b9de10953d56f068f9cd85793f7dcd11ff2727131a775ff9e50ec1127010a84a71db9a1330932135a2325aba6615e8f485a01193e1f7de06e8c1b333f1d0921dc87d11e60984264cec4949d1473afb196a22157c0c3ecb7f95d6f537d01eaf35155178d550838e14ab5cbfcbb1ce906d870908ba04a57c88c16416336f476d4b298e8ca3cacfce15f7421177949f7c37b27c50365f6ddd33cdaca9bd7e4effc60a723ea9059b3417c5ed05b9065411357af2ff0105e6872b0c896f8917fbc6a123a9d470a912617bb2f8cd175d91f29c8576fc441a9876e837b214344621e37030e44d4a09cdc5ec63b499c974fde306ab72761f0107e290bc297a01dcc3653688a2032c3936a9a6afb77aa3c9a8132b27732ed0dc00a3cdef5c6c81054c53fab27da57034f84255f96bebb79873c493f602fc9760139cea1831a2d5292ad23b76be3a686309df37f527b3233ea7637d8d8b40c7bd9a3d0b445bea0af6b27a9d4151e4f2e584ff61e3d9e3abd1ed38267ec03c2844eec2588bab8ffac2f100ea2c0d98a09765eab5fdd0377c0b427adce6c2544b58e06ac0c1df980c4cb8bfaab29ab1a466282a159731ad0d28a8a1e2cecd909428dfad3b0dfef342e5c0b67b0e7e8e7284a7db17b678888bfb670e5f747b9fddf62b7721c6c4bfcab749dd312fa35591c155dca5176d0273ebb57747b96d4540d1dd774082e5ab7726a4ffc39b663da8ed036b55d962b37ac68586028991bf0e378db748223f6425a3a5d8111cda16b40a88b3e99468d2ab7f29e74f0ad66c6aaa8fe35f096af39b082064dc4e05cb1c0b54818c703fe89c5ecd871ffeba8b09c5c28b6b8c9290525b9e4f6cabeb4272b216d8ee16053d8d2f6de12b4ef95374c818832139c3e1e596b3fda78448a6c0a02296f1a6e9bbc6e668b30777f4d243bee0f84f13cdc85ac26548a687906dffc702b6260164d08f5d2f48eb049527edb5978733fc632239f682c0998ed1f443f88433c6d7129fc126bbaaeabb2fc009ca548423958b2080973599cba97505d988403afa298fc28241c8e8d6b7a7c691e14e7f0579a8447713be5bb71fe4b83d4d09bf03059afdc390e02831e2c0dae33145df694399e1e7ddea90f9f74b4b7974c20d1827c68c34f8ee16d75a6eca88ed281704910ad527af9370fca7a0c88aee028e312e7e05e842ad5a9b5622e719749a524c1bd7347c50558d1d292b9d8e2fc6b048a4dd0854073968fed85035decb78f4d186ea15b011f0d69baca4825f53d849472e2feac193eab0ee20ebdf302ac8f29e3e99b6af61e289f141ebd9965a9393945b624c661ffe1fa93e1613cb574f282168a19bf8b1356effd9bc627556e32f0aed9c4b703d49ab0ca1a57704099b7ae7084c2181157e45c43aeb8ac4d11c7e39686e7b60639c5dbb8a71985eb57e2388a4d94693454418a942a63d97647c146fc5f5c54c2c3139bf2be839a90b7053451b4ecabfa333aeb14e0d4b731d04bbb811058b7417695f1f8d212ca93e9066af408b6218192a715a28ef0144f8004f21ef8a823112aac5d9d0f986db49f13d94988ee300b21c605c711c218cc57fe87815175549f9588f00d64a0f17425d25923e644bc58bee69e5f64bef3002b6e2c9f8e1bec66c5e6717f487c4f2ee07b3ebd79c3fc716f53eb2cc57df79985785d40c2a0f73bdbb2cb3c8b2548d88b8d3a87acd692559ad74df5433efc8b850272eb9a23b492e768b85be4ec4e3b9a45949f210ef2d78f983b1236d72afc03ed625b0c60539232f3b2be7e15c7c27f781f0d21f82db6b729132a4886b912a54692179c3e615f68a4ae7f5b4fb71217c560bfa03859bd31681e25b50af96b03d72c45daebf37b58af724348a072ff443e668f2d7bf336636b78659a58f77af14e0e938e2c7f2c9d97e9ac434da1f013c8ae6fcc75df09bd6e7941c70e2208dab882da6148c4ddf66d43de76707cc58fc2bb359cdf6d45b0f356a19586a96d3e716f610e7913b4c28ee54bc7a2bb4740a838212712a1637ac92fcef9ca2ac195acc910991cbf223c5c8c20347b416ed36eeb502f48c49795fae1623d841102e3102c5567c2d34db6c4ed59f0e3ae3e78c139c14570e8a9530e1bbc34008f7b77f6db8053a3f7e4f2e43e80f38f153dcf7fee2d3774aadd8b0bdd95c28f9f4cdfa79b916a6b3905550f3c87c4ca4fd8fb2368bc5062281b122344db4c153689c4016675b8e938f5863754c6ae8a23af16f5187c2c41f21be545156be7056ee1bf653a3795dc19d719c753d4d23b7c295b532560bc7cf041c35bc4cb67f8ce7b759c694f85e0cea04ee7aaa649b3eb3f473dbbc0b45b80421b4183bf865b0cee409c7a630edb424e07b50a8325d9e2c9dc2068787901d38659ba8a4a2e31a8c3e1148f9059fcc013a42c43be02f638e069e85f287efecfa717e405d9aff0ca255a448949eca75fb88170cf1abb11e84e25b01eec0624ec33c726d5a2e32a86f62f25ecdf493e6f49fb192777b062b88a72ccc1b1161ce7a8ce5ad0a02f381bd40c34893629b8656cfc2a664d658e5520176ff9457f1abad5ff555a3c61533ae8ba6faf4bdc2fe0229cb3cfdfb3b250307b6558bb0512cf7587479224753d7a0a8241f89aeb69c4df143cf4936c4ae53aee54e6e23d3efac0ac5283741b70acc37492e1608456fa5a6ea102b8343dc194d46e3303f349c47c089c0dd3a1a9e6bb6a6454a64287e84082d6379418443ba3414e1459b2953a6fe32c920a45fe5afd5044e25ee1c78590988ca1a9f1caa2f094aa96efd7eddba47ba7b9a23c79dcaedff274a45334a589f4f69db13df7772998ed6b363b69a03c6f3b40f8df569bc2e60787ada68d3763a485ed06b973ca5a7a4f2574c640c5a950383c3e925a6e10732a24928cde9976d0c8da7b6bb7e900346478b119f5e2da7dd528ecceb1a2e28b652eb3d31111f3c4147896b866f200aa9654c319a958e91aa5bed10237e91f6c6931471dcdb9d624c19e5fde5fbc063c0eb0d177615d022df49a6a5adc309a3325bc242885df65c9bd103265c431c0f5ab59d35b702049a480ebaf6995bcbbc1bfa3a661de060d64e25ea9cb365e2c3e860b454edff9d34f054e95b06b9b947dc83877c9dc8b8f1c79f5ccf4dfc69fdcd7721c886e11023a9fce98399c2cbc90ae0aa79f25719b690aed9e800a016483112daf57b11398dcb1a896d03f0ff340c105341c71dcb60699ce646ec604e16a8b4b35f9472c750bf6b0718700de94f525d473216308d3f9dd060cf7debe849602b2c68c6789b24f7ee4c5446f4124be332caebd2b9395434e586531bf8ee6a2ccfc46eca7012eb64ae0509a81493a286eaf237e9cbbf29b617f6e7d63350f6ea3f8161b60c3a7cbf4321cd694f2c65906612d86e2aa60d132ebe5a7ba461b216f738a2b9bded021656e2aa6d1f9ccd69ed8d3294172337da08cddd2fcda60f120b74c07e424640078b9e4e5eadf54561350445b56e104bb1e43c16cf622edfe7ffb3622f61d02de09e87eb64cdfb17820a57fac51bbc14b537014b88b642be1d40b66d65e6d16b21e74e3b3f58c0cd7a597ec58c3c9afda2f5dcfa38b4dc1d67aeb871b7da6b827d531745405d0f742780f2059fdff11a83fb6d885dbc2c06c9bc83bffd5afddd277ab78553ddf8a16c9cf153fee99baab7c2ad040549d78fffe2af1ea312f906f2e01340ef061073b25503d0a1a42b976ec1e1a626ed5961c9cce445df0677cb039f53888d780917ec075dd30ee637eb5ca289e5dd6a80d85e1961a2e2769ab7f85a5c022d85902111a98b043d8e0bdd9a15c2be7ff06382bcf7da8e256d77372bd0120dade600f21f9480b0f27380d608122aea6f45fb0050d3456e7dc5f642ca5c953be037e7f4fcb9406e78878533b2275a07ac6dad052c8b5f6379e1429ad3b47cafdd4b0b073520848b1be4f517e6fb4d95b072df185e79d4e6ee652c4e2e952e748482ec35927c70082f694bfd0763866eddf5ac575992c4a0301bc4d92ce4e771c09d7f5f003b40f74e839feff5b3bff946a8e169f7fa3bf5e8ecb629ee4ff062e47469f1f1ad6f9845bb840299926132a1336a1fa85bd8071807b1f4de9acc7cf8e9142873e4ad89f1158aaaf93c5336fdd546e574fcf23f5546d908d2431bcd1305ccdc6149edce60b3d0d38fed592fa6f66199237e4472e797cbff8ff13901cb68011eb7a46eb884287ff308017c833c9fed399ec8750fc86f4f5f0885d9f3b620a6fc9b17cbce0d48d6ba7c666e770960505583f83eb6e5ee92e93c0a415ca4ddd150519f872009bc239a55f115cf06a00253199f75df55e5e539302021af5728d01b372e7c91d3af069d09b1f5b283b83ae93352d6eed12cfcff5216f2a16646a043afd87f9d049ce70d22803977467e8dd34bfb3005b501fda0d1891764117e8235dccc38b72bc2ee382237c8535c9af7d16837accfb09ac955911ab8b57e2fa086b45e5c67e547f925af1ef31ad4e634cb668341cfb519ac705259013570467397b5046d521cb8f2fbc3a8aca7ab292a0a6933e3ccc13403614f44d6a776ce2a875bc32b12489e20c940a2b37d16bced1af5807d5b170b78120631dd043227641667cbf3e816eb51d7f9103970cf81b535533df824f0648f7af6331a7cea3419af23b655cb84a0aab6ac010bef5c8a1f95524f5fc0a486c07856398993285c4ab67dc3da0c0acb5e3a0f350e613bb6da793d8d33eeae4e3edf382eda67d0eb5403c179da1cfc05e2891edaa2947552870550338fae6225357b292ddfe8979c7ca83d4afddf02e19339c03facbd03e71058796c4b8f85a0143f1236cb66ca02a1940bc2ae0886bfb9f582d8ce3ff61090da1f8f74f1bfddf44b7ffcf3d5db990eb68b9a058134fdf02cb53aef7dcdcb7a1034198128cdfb208d01b9db72b77d7e8d5b35b6e82e7ac0300a955df0fe0ce31a5621e614f61c83f97bf329668f6f0a7d0ae2261aba4835ac113f3cdb8cdeb5c047a1b1f003765498911770beb7f5de307eaaba466f29f1f7cc3a009fcfe684569c877873349abe4031037cfd617a344a66b192157955fbaf917809713cba51f70c76774363c1ff2d818dc74a6a7e01079e5c6451bc49c6d2650c570759dc096169d51d7ccb19068cf3f0209bb62d2049d072a73bf8646c022c304d80f3e9abe0931260af4f7f85c335679751d73042d33190f6cd1ff97e1b0c05942e8fc227cf525961ff5ab5c4e65aa3a750166e490f0d7502935e976a83a8f2b5c01e334735492b0e6c9f3e5a7d4c5bf8e8da6e09f354696b1af7e8c5f8a56f1407a3da2a9da7ebd99120b430eb9e3a25d88e5429b3ae339810e9f4868bfaa15606c5adada579aabf531bd081205489fb3564027ca6b34e8213fe8583f5dc90f18096e658e8f9235a5a6c8cfbc5fbbf0e9fb46a15d244459bfbab779fca0382b1a2e39102af5ec541758c08ecbb47e546b412198cbf0de0e7cd02d34e96c9a5e0ffd474f25e7e598fb8d8a8054130c183efbfc0ed1828293c686ae2a0f24765821e1f3eb38dad753e1a42822ed92e4dbfdab9882209e4e370cd94337da6c96a4b7a2eb0d68c6e83ea95891c3e8c5866d9ef372077a7016df5298d1f0fb426f00b13a8f6ac2c70d507da90e0b0783331144f2a951baef7c363ee59699e9ffd496794179903c47e3c3c64686d16df18a1c88a5b5f8aacdaeaed235155010370cc59a5328d27ae7e70590638e35fa4b2be2278d0e47c4135b0492d6e0ec97b032377eb788cb29dfeabdff251455153346101544d26b6a1370db6b060a489f93b149ca76b9be0bf2eed73a36b7cbf3da17de6238caf44e100c5c12ac62f9c594388c7c4744e0ae405c26e2e6be3fe88bc8b87e9c6a745f9ff0200465cb0d7c48f6ef48e6bb925e09a38eb384f94008f119f65c0e3b5c872e9645c8dd18135fa665f048dbc4851c11168a7a88ec782b7ea61069c8c4a27bda9cc620471beda6f2c360f0b104176a5699f19e581cfcf89b7eaae5c9bd8222d9cdf26169fda456f553e8d8d1125e4d0ec35fefaa7dc188767a9c42e39d613d78857175f21bf2b1906156ed5cc6f6af6c47241cc696eebfd068a13bc01e4bd3608fcf5eab53f3ce9365743ce9e9c81f22990227718939d08fe53dd4f2a04b6730c6de6c674980e9df02bc9dda7ab43115be7a8805f4a9d027c58568a4c82043fcd04e52c1bd8018236b1b93f35b320a7c4533389aec5ad13fb1bc99fc81dadbfb057634171a34a48f09c426514eadd005477bd571a562f64d762b1bc8958f5b0fadd92db7ef5bffeac1662ba463f4fa2b89cf697674131705f9288eafbae520f244c99dff143aa0fe61d1a05f2b618895bbf31113eced33e4d2f8402d80cefffd09daf48cbe0c460fc700272a75e6f347a15b5eb98c1d130bad6363e6b7ba3976a3b3e14665ccd31de7626ddf864862e5bf5f93e2a75592041d001fa3d85cc31d50fce852b945339d9aa6ad6d173880724dc4a8880c234091265a594ec71a56ca778ce25a4f7a4c0bc1b1725729bc337209cf9c1a0797b5b668657e32f360294422fffc30232c51054fbed8363317386e2a6844913dc18a50f36405545336814eb6392dac91e3d22e7634ee98b3910ee1a6ccede043cbf237f3d69fb40aadd2b309a61bd86d2ef88b6cfc98007f0928cd2ee63f6fc6e73d5decd0d94e3357817882288a846f070080fe52ec9758a6f8a7e702c912364477d898e3b20e71930bbdf29b4c1e8a30a97c544c75d2762de83696a8df55822d27f37f01dddb65472f907d7d834f27a4db17452a5a625eeb8655f4997a05361c032eaf63962c0f34f30499aaee855c736afb3f77413acc75fbaaef440","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
