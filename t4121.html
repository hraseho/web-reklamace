<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2cf79950d8979372383b31b8197ca3c89545400378d2e76dbf088e1b0133205597f460fd32acc032798bdb85dc68c6a46917dfdf55e8586d4a7da2ae333578fd570984850131d3de4ab4048a34b38d6a3f84c3d6863ade2490128d7ffe7f37a1057de662100aa503e8066678a47883e48bbdf7e6b6ac4dbb6ad8a912ab709043f847643a375f8524532307ecde4721d65626feb49d1391bd498422aeacc02613af818cb08334c332ca95bdf743c9dedf26666b87044dd7aabb72f81d6f6d058ab8606a095e28dc3d26a9925aec2053b6f6aee08440e9e7cf069dbceeb183b9e8afdf9735e3e8f0055ec574716d8a88b92529c3ee4126ba293f2d1cddde203262250ae788aa0f36a2c31d59ec442498020d81ea357b87d8ea64b96d4965d31b2cba83f3a9a1c636a57b78249b171d0db49d3e121247b49991bd62575b6da135944409f9ccf3e11e7cf465e35143766b71d8a3aea50fd65ca23554795200179efd1b43f5312f21d3a726e4c636959ff593b7d003ee5a6e15cc5dab68b54787320985aa7facf19c2c63009ea180b9738a5bb6883842451e323cbe1bb0230c38fb29d80d827e0f4b232ca5b571b2e5646102508769dea5598accbb57a068707a9b9c3325c9273352f55d66c060a45b5c6e7919c564f490ad21cf0dd314a0ea5a6409cf194f5ca8f39ec1d0a762366702660d265837eb366dc36eef3814f2485e4764382e8f956662b6afce066a8cd9bd7635144befb3d0e345ab1579a5a20b655df76d91efe10f87d764ddb7222f1292fc8d0bd58a17c1769b23902907b571649b0cde5315d9dc9480fd0eb5a7ba47c4efdff78a2244e43c19a22456748af0eb20f4935035c1d41eb92caffac171cfa52f32a2f19a7c96f1a1233c59a9198ae43e38eb2c2f7ce6c43452c3531c2fb1290a4a130605adfc2fb150e7aca79e6c55dfae11de7ac07098fd50a20a7b5d3fc795ab67f161e19f1f84114650a93214988df30f2c10c6fc63c5db887ea963aa6223f7d7c791284f17c5091e8d2d4671027ddb6b80c4d5f6b561d9924101fba26cc107f5ded437cf4405596c89113037ccba37ae1a6dc3d1e33f666fbfb92c689b3e9826da8d6f980305a03073f9174b10c5b188c8dabeb9820f39ff87cc4252ade8a3520cbda9456416e1267f363cb691131031ea99fe369c012620976e8040c59ecac6ee9da8287d2a2081366bf58720df275e9f28b52d4c58b75881affeda0d060f80a7ef415268b328e737a1e472380da9d4a9c691f00020e1a2f58eabcf57bc65f74612af01d5fea11ab3c81e358c2fabc968296e10737ba5af5a62d125b8988775d60ddf4dfc954f4bbe42de089b9ea24db878568f837b41fc398a7f0341487c1e988181dc4fa38631c410f5989830b7ec8ce3ba7e761a71a4ebb72a83b7e723cb9d1417098d2374a6e94ab253ae1cfa6f12ba24448a11549c5c3a9019c6adf712e895f162ad956d61b5da1b284dbc75714b0f468fece6f09939411564674e9fb4102d43c32c3eaf33a41d53bad4453290b4086292636fcf27eb07823646288584fc9797dcca1a4a9fa248ea4d7a165b2eb2ddc9bdac9f9c58b13bfc3a2af89242172e451c08cd0e69bd74c0f8af7fc572cc7a651954cbf5a4b5db215576e01b1cb10013fbf4d45d58e02a67140ace2cd9ba9c018b212e0f4251312811de1f6c7b2a063b50e25c1b669c4c3200793777b6b2284050f12a0b8ceedd80abe73a9697b343a85bc26eec221000c75a4edb9211ac843892bcbef97802c7d819bfe1fd1b1cc36a22efcf6d18a096a88189ea77b97bf5b462d459f02e730ca483953b32d1cfc915ab49967985df46c473cc363cd754f0644923bbdf9bfa8d1e9a1b3af70d7a2ba3d2465844f372197bce072ee0b8d4dbb0a11c62bc8556219c3e69032776254236ac4e71a35c290aba2937e929a18133e4a07ad838365b193a6ba81d404c2f1e61ebd6cc7fbb28d986dca1a5640e44291374516742ceae192ddb15f8060ce938ca57b782fbd09d34786b3d9c2fd0e97e312145c9a81742447c4b10c1bea90839f0a015d5c1f9cba31d0b1de9156249635c218db9c368a3c8940286cad2755c5a21a08413bdd578f1cf75336525978e5fb819a7681d8bb30d025da9a4227df98a1e3a0335b10a477fc374fd4715642d35c0d4e604cbb85a581d45749f3ed8ca67bf60ea3a34db32442e27396350394e3e48c2aead5f186046396453b31b4ec6654115ab43688a66e99bab90e2a1f0fbf20b81ce230f204ef9237009495e1dd07202bc61dc2a67920eb8495ccdbd6ec763c9b542b6fa1925a9f6ca1e82bc8a34a0abfba0b6048ecc302ab8a6c0f156c2ff229ee008325827868fa412691e3ff133db1783430f5319dad09a1fa953d545e288d4d1eed459d416c0fa66c244d65338a759e5fdd34f3e9d4e16fdecefde12c7cdbae2ce178bec978bafd4614234ea775cf3993ca240730eb3f1c8b6243a9afde5acc5395ed607d77cec9acd292c805af9609be570af74b20420a09829dab04ec85254d785744bfcac9b6e90b600ca194c2e555f4c204f7cc2a16d91e7034c94eacabef7865db4eda62487d8a34f7c2a86a1007bbfc3895b4939e812a1a18cc024273d0bba0e15a3d2a6d8821124c87449243056eec7b210404613a1d00308b35d3e606c578af4a14ecd5fa4c5434d19fece2d708785450ab2c963cb9f84190261026dedefa298b56f73d73d7019a6579b38c18900f133504e14819390839b8889632d2c786d303033304fb4acae03fa3edc9eb1878c25178c9525976030da6ee7f9df69516876a384a68ddeb4f8846cd0acdfeeb3d56587b9e97c379dc6f4474836141210a37d0dbcae90986f7f43d18a24322b5a4be068f159ecca17010abf90fe59d6b64ec19c86cb2af8b6eac097e59a76891f1678ed0e8f48fec4991af426e7664d867d95729c101a8af412c0b547ac020030ed32f4c850831da18ef06aa936737decd396c9a9a9eb5ee84495aed767d89051fcdd3f84088058dc8b4ca96846de8351fa2b8be8c6d9d058b90619cae78fe7e69b68600ae78914f11094c0e6e2cc56c1a2aa6dd11f45f9e1ebe4cd74da2804421e867c7eefade4067888986f063e44c1e64eada9faa53d736692a07b5e6610a5c242d72241a3f39c3710629d23ce3ca3472c9b16fcacfee4e79ec1a8c9d4fa251cba1dbd2132f9f27eecbad2d0fb0ba97cc24a54f5fa306d21c0cab93ff7c864c93f728be494306792158be56ab5d33dba94265fa372d113b5f9aa4985432632dc5a747bc556db23d7c726bcc8404eda2ae849b490490a682add9f98ac22f0c5b7fff874470580c4add610361a0203789c81c99c193da7a27f25dfa094fff6b110440ad8522daee4b5ec9f7e4bac24d9e505120183f87bf7899c83777baa051d6a4a3e464d0c5bae65d7e0989f778e819b39f4f678703f01ce11bc8fcc030bf47feeb7668be3a0eb510dba51af9e1de451b955b33c2955c242383b1108e5fda50106f5a542eb6976a39408ff69dbaa965cf37c432e26cdf48035a549fc6daa9a7b11bebc84430d27b04470721231061439ccca39c5c784faa918aca31eb07831a6df60c3c9325876b66bcb5afbd4405276ccaed7a8be16729abdcaf1e8d421a12bea0c0b90e0c046e08b2bbe4c38f59bbef93bc66ce3b3c30b4ee8b92e6b59b1fa999678ecacc11b7cb57e252c3235dbf6d333d695387ab6cc7d34c727e3edf27837d034ebc000d9ed2a994f448c721d9f4bb5bde7b7c8944a28cc595d0d7c6ddaa99ade4fdd2e4301fe41982de114c83090060e649d2eeaef79302a730d355f54f4cc0374e2ee4019f6dd03c1a31fc77273f7987806d363ef39e059de97c603737d765920c86cd84e5b47f9d9a26e29ba314f0ccf89b3db380701d853a9228cde7271489b1a08361005c29bb0441d25481a9b941e72063a4a5a7042aee15b54f0d412ccfcce6d92e36ab541cfd9651d6f9527d9b13e8950edf9c5696437dc77e61f344d5b50a9109e4227ef39c6e5f3397821f59bb9ae3aa8adce1e0e7d28e52cf1bfc6bb5b95d0db94a62b061ef69f50966220664f964aef7eefad51cd8dd91aef08d648f25118df2a2c366ca6bfba480c6f2e0d207d4c73aa91224a09292781655a728424071092480590791a1bedf6ab6cf0bb6c332ac63a595f4178f84610c2d247121d5f58699c9e66c6d64a84f326101804d760df8d2f442019079c80a16a5fd1dca0b0aa0900aba6df81dfadd68b02cbc37c8cb81d622399e673805abb1246ac9168fbd0fc9f12535e8b94b90f23dbcbbbf3c7d048d376af6a029f910cb6a1eefd7df9b0a2edb18b0efe6b2deae96885deee1bd49c8339c37ae3518c8efd06afdeb6156fc57c7d6867726e7a7daaf81745f89eb6a9f6fc9827990219cce4b9bff3b86f2e937b7281358530f367cd20e2d667788cbe1c62e47c0576d430be35be65e26242b34d7356f40672e8052dd3eb3b7cd32404b89870c1dc542970f3cd63ae1327e438b5a98c8ec66acd9f0d06cee4d2d025eb8ae2502eb630766c89ce417ab9c17fafb308cc01c55b6df19b8ea1df50f0cac04da8cbf91debbc91044f06c4404502e6a67f15ed5fe4de8b2985b2a62d9cd99ab548b06044baec25d83f8ae8b7e74cd861e5b5053809764b089c8d9d8a3889f9e34bda704918902cd1bcf4b4fa6d3728892e62707f9379f57f7d7ad82645fa99a9778dd63a41d53b2bf60b8d91724a50ce5a83eb259617aeec6ecc4caa5661d4b54487d47dcac7985c516300abf070aba72274510205dd1015ba3c57b5b63fd13de400f8caf821404f5a887ac91d45970a201822a51df6e45d20589be5ce0ca79831e6f89d82e0bda83b18f5707fcd4ac31bf12a72c0c0dff84d3378c1faaf31f9ebeb18a1526d46529a76dd2937c3535062f030fbc9da39f64a571fc7a96c966c53f09e2737fffd4cea5eb71dfe49816157a33b88384e212d477ea2ecbd100e5e63d4af16483401ad983493185389708dbb7c1334de8474e547fc01861443f47b75ee00703771939efddfb00888f12b953cb2943c23037ce390dea18ce2f6af718aea39f1bc7050a90cd08d3cd319e1653b40b7a59fc4edc08029712302e5a9db7585cf8ccd7674370de8c73360a7ef64f12e0c8d4f6ed4953741f8ce89ac8317bfbc369557a012c97face1721573ec7697afd0e1789f4e1ae8d8b13d5cf7605e13b17d29489a4cc6f15b45fa67b9a4dd9813348a6628a324724291098001401b546b364766d8e9d7cd1b3b09e95425ec2f710cc722ef2f2d3f56ec3c6d3dd3eaa70ed7559cfeda3f29ff44687cec8beb89b69e6fe45ce09551b58e6167f9b81f588a4e7f3dd6c0983878a9f10358a0d1c5075e328a17c613ead90f21343219d7e3f45f1cc2fb68e332557ef26075c72a653e9e1c955e3870491f2af496b39d42b9f7ae84fee0ebec40b084de96f943096a0e9b21941af68a23726d7c6ee97df47b8828852daf37227134487acaef32f56178ac641356a415fb35ac56229761814aef4a8b46acd2a7b9eb67cb21b3522d1fbb92922c11f2625e14b712d9f1401624728036d77f6e5aeb1bb689e3d349116aa715c7c9a0f60f97bd7ebed20f67ad5c50512fc14652b4f675a5da2358b84deaa085a3571a1da566e2d68a8c06a958e1e1773e52be4c615083cf4eddd11bef5b640c6f6784453cfa1cd5c375b7e22b50456fd09e86c95eb803db15469bf7aa01ab04449aa176af5a43b3ef623898cb8440e180dddde13a22cee2a11e039083daaa9cc1864f464220251a778647634c2257cad2a74c8563bfa3594d00bdedce77dad18ea6ad008238d3f433cc3c5c328d8bc7dde5ed08cb0202ab02df73a08fbc51984cfe050e7595de1c5e7f96de0e8ac261999bf14f6a32e59d99723d26cf439b0de4bc22d5bd63be7fc63a22439964c275321004324c039138f9a9234f3063c0c3fac2a3a3d8095d4f8e73da023bf19e617eb3e068f8e602c1c7209106be3172ea4f7fef659e737a1ceee072c4f38226f2d9836ca20baa6f8c8e2851cd0fbf594941fed9926f483ed30b30031c8761333ecee2f4c6520b649130d003b4f76538502902f58bea081bbbe2aa788c362c8d4e0efa899ee6cf11937f56642c612f478710c268db9c5f1b4037779954178d11ffed2cf35d6878ecc1343a7cf201e6976ed06088b51ff340279c59d25eec3534414cca2c24015067da8e60a9685b07c4f9d996e62ee34b0c5da7d5a79c8b15fcaa97e2710d7ad08d0dc0d6681acf32877ced28876fb6a22e037b88ca9309fffa10d4e9f51d16517983f233c3283935b5f041a37dfb62bd877cfb4c3185e0aefbd13e943134f58c3713bfeb3b0acfc9efdf51608d076a6e28679ad5f86e82276ac4b5f788504b8ab84d41fdd868a04985d58211787bb9836d564336213bdd72ee15b19d7715c6776b28481a3c58f602646d2a17472decc1531b0f65d8a623ea7a13262c4d9df877a41776a92ef348b59e8f58343688b8798735a4427e1684f3be3233eb05ffc2eee1cc71d88ddaa63babe8d8f7eb57bb2035781d59e564e7e92f5833c75611a458b78292604faebb24c889e970539550c86c72d2d0bc533870e8b0e32ad03f3ac847f506c8f6328acbaeaf41e5b6576b6e1b83af50dfd5ff8bcb74bd0485aefb660ddefa5e244b6ad7d27d89922f198e27dfe9e49996bcbb4184241ada3262bb21e070f4e3d5cfb4c7f64157acfd85c366780cb7cbfe6781635029d49251343822689d2f7e19985607fe082334828c5fe613ca99f896f1e8d24f51f5575a36e777a458ff3fece44021b72bb7f5c76ecb6567f86f5bea76a959b1be4710f053ee372e738ec261ce4ebc42bee539b835b024ccc57a33d7a431cf613f8ef7f5bbdcbecfe495dc50c2134243ae784b64554b3298d67b312d984f0185a502037f265c554e549ae6a8b17f8e03371c52903b8281923e4833735986da7169b5c1645df01bcf02905a6ab9c294ace5791a3d6c66a3437fee8b43a6b0a64cd00d6205918b1e9cf91ae2c46cfcb64caefb6ed654ed834e147fdb9d57e1ae03a9e48183e6e37fb72dd5221605ca15f665de1287463abae14a9ccec566d8655cd78cb10215ebbe9017c7a5b6d513a1cd4cf553893a0167a58dac4f73a1064ed07f66e95d2663932dcbb033d270d99fd1a7824030903f466045538227199e7f983566750db1c3d90f2337654c72e7a054789f4c2109ce368884f9eab4bc8684b19f5858bd3bea45601c44dfdc1ffe13120bee1806544c8bcaae83f5dfb51a997de99f6cc552983e2387d7f6dfd50c8a18f0cab0174df60bb2f7a4b940176e23ff24a2b7482385ef329fe6898a42b41609659db417a5ebe09e4e480eab98273d197080eb1516dfadda42a9f01af7499339bd5b30e688f15e86215d98ed5f0a120dfb540363186679099e1db02fa767f19578e96d4540214de2e8c610b6ab3518fae26138a0405d543683f8a1ba0a66e1d0b1c568fadffec220b96805b0c03e386a2392ca5b9270cfe5854d07f0a799efcdd928f7f21ccd128e7a656360938055fdd676386f09406a35e294482836a3ad2af76539a536356d38f3150a59303d4bb4f5312327b0dab069eff909aae6b8603ef9d27732021ef8a8835afaa98a7768727f9b32407008e1286eb2883e46ec10ffbc2970ccc2e58759ffb64cfb540fadaac91f382f8be4077f5cdd4c97321be312b2958a4f7d8e006216e32f3e24b7cedd6b9cd2ebccdb173a5f1d2a1c9ab510794dbd61f80e69e5757fd54346a4e352434b64005f019eea35333a145dfa2c438c51a4a5088edd833e1c709f8b7c89f89ed5ecf98a3f96d756082098f93d835c35d1732e3725443c8cb28c206f82ce73fdf532e3a1e76abb811a0fb17072786c9627893988f9176af73d4b27de45ea2d8af11262912c9b80ad7ffe0fce07ec942ad156ecadf59f3205f5625732d0d6f7b63a5a401fe1ea164752ac3d511165f177ea50dad22fc90f6cb7faaf803c4fc852e04c3f637a272ce5d33959da403016dce52a3bde9d1367d99268aab6d5be2cc2bc704fe17ed5c8beff1767427220edf872b5ce59fbb464057f162b99e548d5ec975eb8cd75588eadfbbfb28400143dffd72db7ef3bf8338b7b32423e0c434f3610567e7ac5e14d1d267770cfeb880bcfb861f5da1c33ae202c6abb3f99ddf07721bf5727c682b34cbfee226fdec64d6a9d3455f709d4f7638eb3309a248cd125036ec4db0e4c2cec712dfe3a98d9ca07f8146063cf9ec6091abc651284448bbae6d8036de13c6439b9cd76a65c8d59d21c8490480b8b48355cdf247b0c4ae0798414eb8c4bded91ee2f7869225c1c7ddde882900d9d8c197f4acbdf4130a78d874b615a8c98a06735d96085908814e989f66fdc72757ec3bc79ac5897f47ea5658c74817ff0e6e64cc3aa160fc0b6676536fd76dacb4268d0fc32111768362931b9064118c6c9f88bb9e8c25e146f62b61312dbfa2ea0eb340c7b7f942776318b5c5607028da06fa13470ddd6022c78312a42902988b918222ca5a1e460f88a6b212ae48271e9c6ac304f3a95f6ee253ab9cccc563d82b237c80b2b4864445be8c6267814e54051622eaebfb7fb41d3e07efdbe2fcc62ee5b6ae46fed4f23b74de038ad710d1c8fed40ea4d688bbcc6a0dbdef10e692b2f70f30ac0cec3833e6980efd3b3bf9f10df374c64c3e5f0203db59cf8edcbef979c15cc01f5ef7aa89cdee619b0e744dc1f1a8938b3ee0f4055a8b1a2031ff1d427fb41daa373ade197067ecf33b47b49b57543b129773931e817be6ab57971cb1a9949f51b617307455a00cd54439a393b448d8a992a1e56ef4957d5583b4a3a04445e81d8422b69c87471a460203ee19d0d98278475f7b4fa14c9ed479d5a433d0ef3a4d0a2f5dd94389a05c4013bfa382add9ef2fa030786cfe87de9f4c9b081081f874be4211f560d678c1a7d1737c39eefe900d3834b445433cdbc90ded70b9024e8def48c8a2da68a7077bef5ab280ce1967a2154d0b6495a9cb8c7a07c06930175390e4a3c603cf411a839056bf6b203d47ded5ae1abce2d0845e23f6493751b253d1c689cedbf3a7c1044f163cb84582d4f4eb336d688d4eb2ec17c84d04e665e8371edbef56e213a8b8ce44ce593406428d1ada3a1c49dea61285886b03f4951877555c7397c6bcdd6aa553cf181fb5c005bf55c53d05708a97e5b96c7f9cb9cae905387f8b07776d1c46a7b19eebcf5f9c6c5410c316a86e8259df178477e3bee3a4332f4112a232dbe2483785233848d7fbc1528b30e206f894fe2bb6dd0c82b105855bc7d6a6d13e3d30c4a6fc399564fee05b1e0e67c670bf2ff2cd327818ab8ab3d27d4f04472791dd72c4a7de5176f5d44ef5e93abd76f3cde26b3ad40fee224c979d528653607e5efd534b9f4285f72b72abac586d4aa4d0c453a79175bd1cb44e00dd319b79078baf25e84a5622674fc7e162cfcaa2e6cd394c9b1e6add87ed823487510df5e80563b8b37d467d6b010b9162e043f6beef19c220aec53cea339056f9aa6bf4728fce7cbac20102dc90ca31f5dc065b466581c3bf61de03446f30906b064226ac80f6e153c61e4142e3d822956b36a34f7c4e9c36d855e7e552453bf7b441cf08ebfea90d22a28e825aed709148f1f35c7ba37e2812e0b97b7016a1844a18c030fcf564f168a6bec980e6b3680223ac71d9623bfd920a78cc3512da62231f1d2132aa478478159657d33e25b54edd5293015df3eb3c575246aac3afc605fbe7bdfea21dc8310075df39df00ef71c853a9366f6521e276ee632d8aa6313b72a0cac0d9a7cfb952f71305cce5c3dd9e6187d8c30630e7b7346655c2d2ee1c482f28856b75f8fd2935f72da7d1a6d4202fbd4377365ff094c204af43cb56bfe92cc47c656859344ada61f9c78e15db0ca6d6b5a39f229760","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
