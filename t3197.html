<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"842add945c41d1316767b710bab0d0853bbb84127e5ca4c9f00f3fc73b0ef27bbd95411e9abc2e94a979c366c7aa3fdd8a851e7f4edab7b4ae7fe45415859c6b6ae0907da129b426f2cfbfad6635e25103749557439d61b863449cacd7d5d707f97cdecbb5fe0701e8efc2c6a5972a049d30883cd71b426ab8c75a89b53f7a6a8919549b417aa26c957470ccec02af4a6ce1f581b376de96e13979fa2b3c05d2b1ef7eb04885c88a8a030deba47356f476f5d7cdf74a9f3f3ec1d69a8fd41a03dacfa7475cdaf44c0caf926d93281468d4d164e5e2e37da8328cf016b1736760751fc994d6179eec16fea289691dc58a71659484f1072c2578526f499be3a33ad08f18793813b5cf8c0137b28796ad8501f42368b3f3432e9a35d71d1052d9994acfbad922deee9edef50295facee2189fcd5b2db6104ddbce1b1aea3258d60f019c069263cd14f82b0db72f3a774ca23b7b6ac796ad844d207d3fd1e1a6bd97d6c92a77dfdc58e313b2030fdfbf9970064669e8c5b5da22ee17a11c30dde5dabdd5e24ba3b3579909db0a2fd449031188ebe53059ba727641beb4e995f1b168dfbcfdf0055e2e098d474a0d9a774e67ab6784c40bbebdc401cbdde958942007feb00b658b9b8a6bdff01ce2830ecfc4303a589a4a3762c7b744465c722d3203cd6e4c976e3fa9476925af907ed903e64a7de3241b2ac67edc78a4b92deada7eebe00fadb2671fedba5173fe2d5c6ed5a8d6da9d758688751c2f4e7fd1202d8965336a8810e6afeb0eea8cd6095162f953fbe723e50f26845fb5a938847b57906ff6946271d8d93b089c4e69349cca8410363656e7b546e02f15cc32347b4007e33d838a20044fef1a03e31387c5e1326746dd07f895e4f2d350d9321b8ceaf2454c1fd7a9a7adbe890ca57a6f422f524dac29176d23568acd93643e37e3abb2ac726473104cc9b24d69079071b64893de285e04f3d1fcaee2a8cbdb47278f6abdb092e7791da40255102d629f0514774058ace8b9aaa0225750fbed442b7702d0ade6fab73aa30f9b0cadff08096c2e90054ee381b73e7d0e52cf60365e2c7b51b597bb9de0bdd2c3b253fc43300dc0b0f5070204cabad7c1199563f3c7387f3921a84e8e83b4e39cb87528a4b3db1fdfdbf0ee4fc57e37b24487998829c27458242f9ac123e3c9c555cf4ccb85ceb94e73f91e55b15f57002e217d3b8cd0b19c73e0350d4de5ce003eb65afcf19186873e0c43cedd89f616b1aff8d6c94b9d120188cf5d9a93507f17c8e2567410030f1226087550cca5782c3122ec163820c0bdc7c365b9caf901e787af0c680822b41efd4ff9a94da4f9ca62abf1df3d222e352c8538b798168b999b23cc7f14b85eccf81c58ad85a9e1f3992c8ae11d80601dec0bb0c01969b7ba34df5e39f04d032fefe5738c8532d23440f4a5390b78420cb84970b2511c2928d96b9a39f53d330667b339886390be89add94d68e05a814dfb50ba84600a990e69a7fe3233f7c7997dcc67b88afea730169bf6b1c58d75c06a7a907b1fb7aaf73d22a716eb059a4573567abdfc448fc518442fed1833a2fd97a5ca6a3061d8e7e951e70a474458d05ff19f4f207c8a455afed669b59cfc7b2180a375a043410a078b14fc537eb727b7468345e19760b82efec2585aa76e5f85a61931e1716332cc649fa4eb868f083c2b034626f91af7a84c0b28a97a668f822f10a571944c4b0d1312eba4a20738d97b0f310a4450a43935ed1eea12d783fea190ccd07e40fd75680961090324c2440a454b59e0ab4830ce13929b01cf89a352ab96c880ba30eea11d2c1c15e087c90067f65135c04fa8eaddded215abc432d7dc85a348a94e85a478c4a50e1d6c61bbf843c1171c189eb53f2645fd24759a6158d6e0db191a3b9b13600fdf6dbfee0679e734a9d89fa9f450da5b6ddeca58c10262dd51f74a9ca24b400ecf767d5ebc0fcd8670a63e51d10974398bc079076d77c76eae0366083bd7707708757069170bbcf3e0b6a732fbb6850ab04453a6618cbbef56e78761e395e4b819a3005c1e127f30c303a55e9d182b1b2fb3383eb265f542bbbec4d65074408a8bd9db7e1a89e217de3e2c7dd26af358f0520f7fdad90639b4fc953ec79e7d16e58cf323ee893e798b8f373c4ed6b5cde640202411e2ac94997d89d24d92b09f1b8988d95f6683bcbafe5a9e4cd00554288322bd120f25ecbb8991c620d5b0ddac2a0794be973ed697a02e80901a5a0978448fba5372aa8edd3551a38b64e5e9304fe141526f3ef14928bd8cf86c6af9f493f177a2b2ef4dc1155b991bb7986d28f3b9d4058aadb7d1ad83f70b2c85232a47c779bdf6480508a0c8d49b67515450837ded2a18dce1bb4534fe588ddfc16411ab96a37e9a57938bf86afbf3cf1947ea859e2b1ad7bb48ce3a623a847d3f9edbc588d92177426b635f4775a2b2b4a19b33707cfd09ae045a6dfc5a859f3e804317eb4651786e1ffed8e4e9a3baf80bd6fa0575d2a6a414a0a3bc53a3ff2f92290726f6754035a3d3f35aecfc59ecd35de200eecaf71e63f5a97e1a6a0b7f67bd9db35dd50eaee214f08e0c83831cf5e3628ee3145143295db8c91bce9e2c3f3ef83847ad1ed8dfc2cfe48525941f2f2e768e01d24eba4275c3333d761930c3eeb1d9af3f7436e5120bbad96fe6abe110f74465caf5ab4b1b00b9ef61ebbbb11ad8bd543a3945172bbaf9c579822b13cb8753e6eb1a2f92d6f40c3b3652b27423ae26743b61b4e338d6718c810242fb55b0dd222e5323dda61fb696e926b76317f9cbe45fea8c9f15f61ac3f45980efbb70194ac0c87a184e69efd0c00c98188478a0fade605e07576303def65c5a33d5dd37d1feb95cbd5c4c63155b0d67c229689914f9ab2837bf078579ca0c62abece734bddcd059361638db93cfe0d786a8dda073608fb132811bba03a8a361980101d3251319bb7e4dcbf1c8f48cf6424626f1f0d2620024a61962701e5672e3c64397c9557c65a1bef21ebff091ec86857d08d55b096397502e337452f15a843012f1e78a8f18c644b0933042e5075d54ae4a87b8d59b79cd7c6fd39249d79caa9260c5673fa44a2599512ea6e305e94dfe364d4ece9afb09a6abacadd105fffe0f1bffe72ee31a1bb0673f5d8e4b6bf30edce53b01fa63e0e8a12ff15d0f6300a549008de371a5bc96f26649ced05cdb058bdd3f6ddabd6fae8d7330400a54b8e36642ed4bf2cddfb660928fd01c537f9d3a43fe66c6c3d44041116054b9a1e3625ba2078e5c25a32632346e28a1682ebd7cef5041880042306b1ebafb6cdcc40ca064e3aef1f54cf9174a9b00d791b1a58fe251aba289243d821d27e6a41a04171c4e25f35d952954ca0f612a056c45f1c69244c83e4c07a294fffe700aa0410d12be39b6cfef5245f9e4e9aa8da153d3b35d3f2798c18c845f53d3cc6ce94ebf35ae6c590fe9f67aa8b19a239b6bdb679b10113fd399698d0f232d434ad53033f99873000b7865154ec3582f6de753f33a70a8f21c9db7c74d44382cbf928ad01b7350d098f04c32caa1b083c3a73860bb94c4520be2ea8e6e9ace0d6cce9f988bbc4e55b58b6d5c4cf32bd033bb635195e0ffa9d0837001ba8fec8ceb2273a6322884d90d9908f98cd7fd031aa65ab820d12e6a430296824e250e152e801e5ccfbb2cfbdbc86ed8cee1eac7f54a77eda2b28b239b50a88071d91e36e08901fb03380cd26398aca24a6b2dc845c4b136d3151c108b48d99fdc7967bebca28abbec2d6b85e0125380c628901cd3a8bf38f88d29789113b91b78d9848a94f56515a8e54848ef67c2b95b58069463124115682a560481a2125e7dff4b1cf63538c69c936ab6daa48ee451f8a5f2e1cdb32977bd0baff472b76f4a694713197a44c1ba303f93bc37a9ec30a483fb5bab91589597b99dbc3df11d6481e3a8cde24450844a036761cf7c8724b35f1dc0bf6d49739980e2cb6cc2a5a7c067c5f342539cb768802fe3fb17dd27cf4bbe8cea404cbe9df7083d6ee61d0792729991e80b8f62f7a01357c5bb58d2a5715b690ab1bf512d2a81403c577adb1070e8afa64535d167890079d6c4f332f6ed01a1f88b46bad8affaab990e40f4b20c3f98b7c80eb31d5110e93bdbf486e7fcc61a94fc30113f0c903a24b38d721e9b1472d69db80292184432193ec2ed5362d2cf9d7c79aa58a20e76be748d4d3679d74d052e1a03ce5de9ab44eaf15c7ab7bcb03a4f349a252f01ca55faa58ecf3de7ebe025b20b831a721cc90996ce4d62bc05fb6c66e03d4f2e09dbf8988f162443ec1b0e9e4fd5588a92b9b5d7600e81ba5e6bcf8bd7c5865fbcd0b6b9217746219efbcdedb2b2c0c2722a5543d0d376105384ec61bdc7ba5e61edbe214bba669cdfa7d1614a12e26f272b708e4633bcc2d74b4db1126b744f4da5c0684998bb79989bb39ab16512e2b76067ab30c2258d78b11bf00173f5ec12cce9d76572da54ffc93ac9280d23851d6075a6604956c552c6e19b382ebc5f473bd59d063e8cdc3f752fba473971ade3d36200547ffc0a41f8a7ad46e71330b00a2dd3496751bdca9e8c16df849c323cfba883d755dbb7f3183e6bcf11ab86fa923376d6c7a305b423d985e6020a0eacb3831b041127a36196ec7753faa40a433a610fa021801e1816108ad92540c034a5c66f6e9bcfe5d754a23d791effe320835f1a500cfbb0741983de33a8fb83af9b46d5a41f47463e4063db898874f1f585b1f5d74442d1c0033f7a0c34a7fe5b7b0f900d985093642b1cfaf9904e8eb4d8a0f4390c413bb808caf70381b78b54b27e6e1bcfec9b684a0b55f658e721b003e2fa64b62fd2ebd2c72699125d25a10586b603ab3ecb8f36ad1ce7eb706cd5604d4a3ac37f335ba68bd47ae31572fdfd26f4cce852114a629bc7ceefd78a806e99fb3053a93159f0a2bac3fd1bb8a256509b233407b01ba1c8b1a18464bbf2d8a4c3ebbfc509abe1eda7656c6fb6a8a46f7b61e3b900cc719a0d7b7407db12dfb79595f747e50ee5a66ed6a2bf29fa85e68174fd952b69c42acf1c83ff271e90c93f77239bbfedf2b24733d265a6b71b636f0e6243a2062cf0df22e7997084996f9358300435cce21f59010c631cb1f0f6684d9d435317e66d9c0c6be91ddc3206fd08fac0f891077f8c984a51b98adf2cd3f99ff393756dd9068fd7395433b52b6129be220582170c8822a625b2da71b969a84f4ab0c72ac9e8f9c1cc2f89d62ab50bebad70258498a20f7864b77e875ad0c9af3a471a0d71e1218a697ef61f6fc73b7c2fff9f4c3fd81f8a13786346acecb3386300beda64b41575523939d741e6d4f165c8821dfca2a55d2b64835b11de00bae8a91592bad731ef17a728a5912d4eed45a90e16ddb1029d724ef9366d68c470c69b4bdd2dd364f3cc68049fe1c389d633b30b4a2c6ffee757fd8173b88c08243e9f03cf3f78ad5f5e841f02256029a3e5f769b01b9f4746c1afca66e901cf77dd8e40d9b36b1d0a77504b220cc8db7b0d95577c704b34eeece967bcf0d7ed8329c37b92cfba6def60d0294b9d7bc314fa94e1447fba22263d638cdca19bc0a7588dddf77767ab85e13d312948e8adf547b43142b305c021bb8870169f50f6bdfb468488d067fd74788e5e5f2cab6371dac03cc226a04c9274024f6b6cd1f9b85fa8e84417d291f05315ad68b112819ea28a527f3751a2f09436d29c7a3352c00a866703cd2fb2f40d415fc5388a77e9cfb2dd4777ca379126a78b810953738b261cd0d393760af0ef93001d4077ce56a5960a79cbca1de8469cbd361d4da951d937ddcc54307e7f2e3749a2cfb8ad73b55cb21de0836b1049227094464e7611564500f1aeb211712699eeeeea1cd58fb4d6d1a311348551e56ea95e8a1844fd1dfa25ba23d8e5e2164960a8ba1b612026ff88cdacd8676133921684659b02a02077a3fcf05756c31667998cccd7f97a761fe5ed5d471e43daafb07d85ea783135409b2b1797ea95107399e9d54d9e7c798caab7006cc0a0ef2ff66cf9998b3f25a61484e3aa8d59261b18cc40b9f6714d5a17e97bc81bfc21899e6a5b09b2a9c462bed6d0603f9c16928d5159e26f9be11220a063c8607ec643143dca768e216aedf54f01db8b47f5d189994c777386f3423f948b13ab5761cdbd1a42de6518b629582af4c8742b31b9728eb978d56d67840fd49466f2f5677030cb36c2c0d7c8266c41f4074be26bf12eef7593fb82025d81062443f6a8b4c23557e2c36ce844a3f3c2ee19d89f0258f2ae24a4aac26ea14c107cdd9ed8cc6c5b8a7ab87d4cfa7a20af361b60d43be4a3fcae3f3a2da2964990acc79dbcd5be8de204ee01102a9eddd9eedb0dc477da431332e14139ba2af6905cd28e638f1a72a24a6850357db42679fbc32f68682cb708cc9ab17f4db5ac0a41b0d9220ec7d87f7640423103a14263d7d24eb1a7b8d9d774d4e9fcdd3f16354e9712010efd67cd271ed0add5970eee37f9ddc079408ffeafbf5238292e96f7d465362ed083cb40fc46e35408f5e414426e272a8ce8dbcd3a262a5cff5bce38d34a4ba83be7772ebcca2fd05004d7def0ac47bfc09ea52bddc49ad8af93134f8361636317f5c5bfe7e693f07b6627647c16d3b650b7d842c9632c21cf93e5eae4af2f61a7f5680e019f1cdcb96541ed5ee0d72a630066f8380eabb637b99a0bd244440732bcaf23c867eb775e826657aed810a1054d55e16ea752e88988a0474e9fa7a550c2b83418c56e5733175f7f4e1956c12f017a363e0d9a8f951bc2a1b4225b059e839d196a2b1141c54bad4820eff602661aabeef27d4f00e92b5f0b8a3d0421f4a589846b69ea5666ae5ef2d84072a0365569d663320ad5cb82aa88c9b88575ac2467fb30d6e1fc3dbfdd5b2dc0063787bc8ccb149871f7ed3c55ae1b38340f521ede2bbdf704de45a7a811a42163bad7d30fd813a24767867273e217fa748737227fbae0a5f776624fe8a0c41632e575ba174be5287d3392c5627d6e9eb7c60a15723b30a11cb02416924cd25c9010b52443dd0a9b751d4e154126036d796ec8c73760e227297a30a469784d29e54f9086d5915419ce556f23e9f22c82093e883c7cfc0c13393a98bd63090c05459890cf7d49245dc9dff9cca7d3612afd0f53eee01d98be857d7b42d18b08bbf2542ff23fb94dad30c6d0614496ca7c85e1bc0b036620ab11896f5127ba5b9d60078503c92a969a7530d7d6658bf6ad76eb1187ca89a36246a914fef73945a5d49801ef1a0d7b31dbd79342f42056dd45c4be9eb6e2401056407cc5323ae1bdcf6cde3c586992e25d4230ca0471d4ccd5b76ae485060c17682aa05e3eb27fe262b3548906f2d674a9aece1ada1aa3919d4ea55cc1eeec1181a3aa15b4cd38ae1b8d5875940600d4a5a2a97ddc5d7e72e7626e3dc48d65064414d481eba40ee9eb957c4f7d5a4eea9d3618213c41a690ccd40daa75b2b2cd00849b82167c793c7b16cb2c6f904973f72be935ce23435f2a2b1a3bbe866c12d78bad432732bd06376b8a5da4b8b131db6823a9d23d6a766bfb6eb98a0ec307aef5d42a27b63be943e13768f730430b659197a65dd4e8b0b1f35842bd3091052882132edc2d79a2e2c0f82d555ca703ad98ae778a53bad3609fc2e4ce88637f74a57e9ed483ccfced8ad8e459a5779173dd9441e3aab91a720cc930148b7333bbdaf7fbceedd28c98a2e808438f093a1d172717c8a58fa9f4efde0ab8f8ea342bc3f2e14ccaab1528534408a830f752c2dc971734922441861bf3501b1d6be3d245868dcfa3ebbc0ce375961ed9ccf312aae731a5cf14440a8999c9c1673ae4994efda8918dd326158c23e5558ab01a3e3c50fba1b9d8b9a4e5224f89c25700ab026c2cece75c065c558381a1a64170f784eed2a3c80c3942706c04367dcd911cdd916c0df4c5e667caf7094f4bf759607eba927d3f70ee19ea9e653972d91dc9e1362dedb19b13bdced2081ee3c8dc83050e2d1ada5afb8e5ee9f264461f77689dde3cca714723708c37aed8bb0fc6b9fe5cf8081c330ee78951a3d1ec591addc77dea6bbb3984a45701846836ab98302dd3eed6908445ed8ef4ba4e650ec18fc97cfc2835554473e36c955184ec67c5d05ed659c337f4a2dbd504d79d3a519911b6f1b2bc091c89ffbe3bba5a668c982d4c7b1ad489fecceb9806b70cc009df29559c7ad9d2634a319d3d48e96fb527480dd7fea88a7b90a65215b36297ee39706f6cdc17207999ad05dc26ac33614b2fa3bbc171f854ff7333c4e064162620a665e060eb3f50ac0a8d7385136d27aeb0695d71a42d52d9a008d3b06214ca2f593ed77d2df8c984e806c0b5ecff057369af231e3fa0dd91c6c59918ffe0d799cc5eb0f00771884b8e1079f8da1f786214489d95c63928f0bc58762ea62cbb34d8f89a06421d58c1ca2179ada3b269440fc86bf1f54f9d60d7057082b4ddf90330a36e22f06ec904bb4809fdf60198f1e5be3879f46666ea82f30c059c9d6e1630b078161d49d63ba9d175adc60c5f6ee591ea63653d19356387f36a5ebfca4d98379ae2ef1209a1fa7093898dc58b594a3a4b39364342ef7b1da6a0174b199d00d5387ceaa99419f7aad10f5f374e918bd5c30b7bf340f9276d65aefdd318c81c21cf8ccc80002c08e900ab209a16baee56adfa8d56e0748f0c5974613d1d7c228bf0ddbc4e63384003e112eabb5ba6851aaf802bb37fddb1c413984438231e71e41c6a8acaa798ebc148a1ce995b76516e94bf6a5b3359baeb721f0a69bc260f8437271271f9b7ac0f1a3f06422dd2e147cd1653f256d7248bd8b4162eaff69e2f000d4898b9fdf5328b048492ea84143e5890125b6a59c113f9f5cb719a826dc94827deb8ebdd1737af62cde3a5cdbcfa74d9242db53bde6c33fb16a4dbce938052b75b224252a3c30f1f93894a05ee5cc3caee76fcf62c29f6931c4e0f48a0175b0cbbbffc7e42cb3d982c3e1b1394e2d9ecb9ed4713e4718843a8f593cd1e72cd2ad02da97369756fce9cfaa53e80a24e06ea734bbcf37c3e7082a35bed9b8316399353ebf31bf1b6c4488a22669ac6cbee058db1d1727c186797f154e3477b8def5fc455404a1007b44841e94a438166e44cadd2cb99c7b5219365902b48d17ec6f175467a1055526f20a4aa22713607f5b8e6519f6d5047655cc796a3b9b961953df9cbeaa4d10622ab999368962f43caab17866d78acbc03f34df590aeebdfd9a7be6ec72523c831f5d02331cb08e392d3db52bf01afd53df6e4250f7261ce1c8c9fe799fe07ea53d5bbf0bc118c894ab55d901f7324b315a6f062b0c8a8b201e7931575448fd61fc07fd862ee4befabaee9f1043dea1bbd4e979758539a1d6c365ad482b42373393f46112640946fcea3285665ba3df11b63a6ac8e8b669e6d4f4d2090358d3d6e547925490cebbf585027194212caef91f99cd6706dbf8f70bfd089ffe23cdd89bd167e63da87d6a529d765cb46fa394555a318f7e5fb4b82af2a200dcb7c194bc1f51e5e07602d88ad8405376be67e64e44fbaa8b61d87f7416d9fc07880fc40cd1de47307924c5fa90b5cee01bdbeeb8ea3870ed0de26e83e5a717b9816ca3693fd01e7c742c33439fd9610d2d8f322b2a2bd30ac83eb4dd33a582c82c07c9140cb97f3c59c4f6e3b11496526639e2a3282e398dc3cdb3317454e08fe6d0f6290b7220cc17b948e1fb15f058482f1ed819f8630dafd4c1f744d9822b25805ff0988456a607721deb11c7c8d3699a429c948a27dfe82e4f79737a145f1c1eea1569268ad6d73535580207d49ea40e92a698a5587618a7921786c109ac20e295c2929f0b300002ffdfbf68598741ddd554dc5b4a31419551f544c3d0dcfff9c634f577d535f692210cec23dd7b5e1b3ff2610200df61d86ce6b7b3c7781496cd4b32b998bb37d1128623d9b4565c0cef8811f2b156c3ada5e99d00d4ebae43a266ab19789d89b2efda39a882beb2757480ab8919730fd841795cba4e7ebb3b19299039f5a4850d752b5b668f54875853179834ea1c4ff4cc32304e9828e83fb0a43151ec485d7ab0d722c4584e2db3da53901576d70017b3f2132704d2fcda0c92d1eb464a60fbbdadf46f42639910eecf3899744957be675adc2de9770ad215544c6c346f59b3b8f7afe979498b022a9ca4ed773a22e2f0c491cd62b5359ac0b69eefbb6dea87b9acba006737212e3aa261c8dcfd6a774ee964ce161e3812ea7996dca47a3dfc20621127af566d1258641888311dc14102fa52841f8f9afb1b73e78dee68ba672525097187b44d2e04b0a21432c275688b1e04722b06bc2588b72ad0b5b9ed43633484055c7f408fd75c3bde71343c19ba8da6ca7910d4d7ade5cc020397f7fd601a56b4b914570a259dc3155775f00d63403dc027169631be41ce789eb87779aa923097bfeb1887afa56901c35221c22f9713fe2376769981bcd9148ab507aec9fc8d678abc77db4b7b5f29890b84159d077ff5f46ef7390e6bc9d84be2de02ae7267e89a5e06a9fe63de8352da4cf312bc154f1d0991b0deee33c48db524a5627b27297c910f41e79573136c109d1e18ce01e661336d2042c94062fff439c77e43b5522710ddd054a7c1efcffa1adcdd907da04fe5d4416261854e1f9761db7fa380ce68084ad5ffcfca21e8e75a6a3efc8efb61b27c3f5cac55b3d13c54a13493cd25d07256f383c717edb720cd53ade0baf488b699f5255dcaf3d881c319e4eab888716fd40f66da823219ff39f4506c90c9d605aa40161d3aca2296e838bec97abb29ad6312c12ed694d6e03456c8a7bccf2f81df7728a934b370eb1d37c56886b29e132c8986949f03310d5625fef4dfb8f6e2bbaf84b09bf5f2964102db75a397e1d4e238dc21d2f7207452048cbf692f2fb153d7f216f04609be55010f78d9cc55b601b2ad05eb9f549e8290f02e86d593a30c25279ab28f0e3eaec77e0d312da0e7640cfbf064746cc71bcb7ffc54bcabcecb85daf97adf747e4a82963820115a1fa437c5a89460da387fb020c8e2bc687ec9d661dcb729241f2617083dd0321d630f0910024f5bc05338dce56782b3bc066334ceb3403fa928d2ace97fd7f88737475173b8c5179cd613fd05226077d09cc4566c0707f49e07ecc42dfff58efe55e185afa5cf923d9e688b1f93d889d3283d264f1ab2e70cb1d32b176b9747672b154505136ff442aecde594a71f9bd4e5effd12eaef8bf8cc4bd30c546b1d4fdab2d64f999b119e009fd75b8bfbe35c3840b229a51508b978b500411ed7ae0e5f86e8e92563ca09dec19224795c0252ca6fe799f40ae0848a403404911bbe0442ce5ebc2080c7a0771db9ae4d1b2e05983b9c83dc15e1ac5efe54f98dcab250b549ce3211e4f78b63fa626b2dffcf61d16c73fd66b4745974819f9f9f10387d99c0691c6627c2d18f9e75ec8795996fd064345b16e0fb6649220457ff4905a8a196c390ee209e19f81aa2b343f54bfdf86160e74aa33e8b8884a3cfb36a1a09a75473f2d0a8add306ec12fd1c16e1e7820740807c2a2e478140c2b3605d5bd6c3a5c8efc202dfbf438ea8bd0dabc29af11afce744320e5cf0b57a5139322276049e1240f10b19dc15b1db05fc0c506640b40eb4d55acc3f5db5d51a992","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
