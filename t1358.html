<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23bb97eb9d8f8fb643b2cc143d2488951446c2f8e0c88fc3fc6820d35fd7ef6eeca5c49d33f09024207ea4d2fd9e77a4a901bae3be61bd1d4bb0e0ec9896a6fbbaa1ae2f5792ec4c4033c87966d87e513e8ccc694f4164ae7d218ba7ed145d1085a9e258aaed0bd14c112bd79a1e6785e2c0e7d098ff82ae99a5ece33dc52ffac1f2ae7f572a14c4629e090c0796134ae2fe0ec239fe45c07746cfba1ca6fd43f55c49bd039f2834bbdb526e4f49af83c48446b29e73f34fff193b713720815d39e672f1ccebbb82917824dc9967e97c0170670aac87080e0fde2ea950e0d01cb2430338cacc4cbfccae6aa25ec8c97a4716a3c0c0d9ae1c9f8b0305cf367805858ce4e7eb9a19335b06be351b852206b2ef5e236f2d2fa9000591f76286affcb6294107ab871a5b8e67ea32c902146968b2162a4d0cbd370ceef61140a12c75b36d2116c013920ee92dedb8c41b9d8fec5f082770e6dc981c4208eb8ddb068456ac59dd13c5d4afdd8e557fcf6ce6f8e4c9dcc8241e081c26ecfa202353fe3bc25cfb7ea7816dbaa07dc048e7b522f518f041520b8b4b5914621992747726eba1a33c5bb0663ad0523311aab0af6a9179c7b81aa5ba6bb457e08513dc70d606c9e286e12d941ca33035db0eac8007e190ce568189fccc562cfe42b17686637d5426b9321504e7df7f780ad1c885a1da0383905a8037d047ae1b3cdc48e1be17aac4574557a3b5865f7396a388bec52a3646121b1b746a9a5c69eb95be2875a4951e21d9b98634dd8146dc1432dc7f47d069c0519f89ab742265925e6b9294d58a8ba9de355f9054ab85a5857f1cf51c32ceeb04d329a6105f8b5dcb0d8cf41d9550711bb3838400e8ab554870222a41fa4689b060d52df4c841f867274e7957c656c2f73fcd1cca14048d4ff67027b1af2c6e1b0b9a9fd349f9b8b44811f61693c1b7b2f3b45cf2c7ce9d8781878a8636074897c44e811e4979dd263f6a252d3d988ddbc6d0efd1917dd288f230cef5060639389416f270f4b074c2549bfe3c144298f0945bb17d247f43a200728f84903da04910102fffa18101ee4e1bf058858816f3e940a4c69747048fa392c0cd517f5cb1f4476bec7f464bcaad930ee8d2237db02ec04bef9ab7c0b30bce838404236113119a40301dc7524831731f6c82486c86f3ec30753b694097804698a70dc062a618f2aca7a927f914c3d324d70fa14de414ff3b7b9cdc983bb779affd03e1b78e2bf5cb501688709dcb92544b8b87a74c92300957ce9c76ccece9e5f42da4c6ecb4b41b23b483fbd3417075637d63a69d5eab1a2813cd51be37d509b82113447dce64ea5c5be7fd8fed4d7c0da02d99e090c8cac6580ab7c925246bc3262c719f3334a4d31bac4141a3d41ac21a86c54a594b25280ccf4639329c7d84325e21a501080ad751f2254e2ce429433501bf5f2291e01ea7f6dfcc74d862c28fdec8f8b5c1ae59b749a2febd2d0e54066910c3e5f57c58adadd805cce10c282a2d8d9474dc87eb4375a95dfaa12ea9934b8a3ff889b07b26bb234b2b04e99d6155e8ba909b9f6b2c5805f1248e85d8b350943234b9f7d377763909795d78cb5fc97f9f412a50550582bf39dd1d78ed5b9a42ed3df0a520be20ab87f2e7e6e9141c9cddc3eef154b4396c6e54802190cdc8c0c4af152b4073aa59e8493f81d6618bae954f37c3adba1089a90222d47ab594174f9691a54dc6a495c11104472330e03b8704517c9e94617a9b7caa8e57280c2bb8553c65949e80a47d5dd7b63af5df41b20fe6cfad5a39faf910e7b125b91fc468bd9bf81f7583b5d12663c895bf908f0034a5d8c2f8c5ca3c5bd2ade58ce8b9bc60cc16b5847c4ab0c9f07f28d054c7f5ce84912a899adcc2e6b849be37f503d68d10a17743d5b1e65be4c6c9f88d972755879ed74c5d2ba79eb124db8addbfc7d634075331140c24a9d6c165cd6a9b9e284772f0dc97dd003d998d93e686d52e3974456e7efbcc074416c89bae0175b4ac7ac3c56bbd92f35473819239467969b09a2d607024c1349311168e9ea5cc14b557eddc5af62d291f2a0a7cdfaa2f071b1701902669fc4ec4be51112dddcb63143c6b759920f5a6da398f4867a195f82b41d1fc0da6d4d7d5123bc960740dff56a36c9bd320d2ec397791b58a04c285b08f06869589f789d55b80d969a22ac132254060373ed15ca615bdc6ff50d33d3fb001fd200b09fde346417a25e029159223834eae4eaf5d971297096370ec741c3777662e0045c8531023a38a140c7e9e591a6f77f70e3312306fcd52e94a46879701adbf085825d133e47bdd077cdcd1b49e86cba72f6786f40a2c101d6245f47edbe185cc8c89408b4d8691bf00f0df40a5a4d7ac1559120b79975a6f25923581d079108dada5ae3c7c37f2c32df1b9bb0325470eac3a7d47d0c9fe616addf31d8821fa401e5ce01bcb4b6e1746c6e6781928c28e5bee9586f99d20bf6b4a5b0b30f7896e8d73c1042486af6362d98d04cc4bf79fcd0b46d8940072ac8721112904a99f95c296988f678e205b7f82a581914ce835a4c4f786a699f27dd2f7f489f97bee7549f683413149928164cd40e81502ed1f155ad5793438e538c0c94af6c08785ed00922857fb3a368747070e5c7e1d8f023a3b549a5809023d96ae038c5ade7c9576ca21c4709c6a243f6f4e1bfd1e65a4243cdfd743f8e39886ace88e7018d233e13a94c7e41dca07e07fc46b20e11d260dc19818d34539e64c7ebbc1a3e7acccf41349cb268e057928a72b01ce45595e617361da4cba9a0029d47807b85258a90267554b4e711607810f3cd14097d0d9d2df4c4235c961cc22ce39d538f5d9b7e57c6a813507f9962c39a44ba4f52ad7a5aed877b0b8672c42071cf9a63231a01871652f2f11f4207dcd3a872d7c945ad9a450e1297b962ec080e885e8870a9d8e4e7bff7f99cbe165b51dfdc0dd450833d2d95078680ad87b16e436e10d272152d284bcc9b342ac7fd35961883d93a426458e69cc411233ad2aeb4ece2ded4f88289e226c3e9cc5aae32922c5fd83be860184b070518e4d878e802b2817967e21b70da2cfa019239e7483de84a909ab712f3fbafcd8db062fe13531f7f393617b6bd7827939bf2ec25a50a6ce7437e7b9bec6ee95125c63069ac8e9117754988c9ac49e30fdb8e999de11c852d406aae03aa9d254ee4748ab34631b255dfc8b547a382f5014c21cda7ef53793f50e53e40369a6496a5793fbbe1ca6c38fa0eaf9627813d92860f03975f5957f33ddfc00e920cbd9a3e2bb4c8089aae6b2818e91cba2189ffb6bcf8275d89a83812cfbbf0b1d07a6676935087728530d3e67a5ce9745089bfdd6c31c9f28c44217c74dc8b3b1721b22918697227b0883f2d22a655e20c04c92c3b00985659dd23c69d914e2369c4f71132b2ba77d65298273eab5bfcfb0ab6503681edb0cd433fa12d852264ac7f47817b7bd43e29169a204f8cb4883af247eb3e9c259d925a5b892678037f808d8c49e2c07321d5f0831e57d5ba5afd2d4f50feb92ded81ea8f25f58857efb90647b063160d5d0a3ffe9be37598f37bc35aeab7f85cbaf4f12717b2f14c75a2d21c876d1436eedbb7000148ee442123e71e5706eb8de98ed90bb3217018816a815a7059046c84fa923d10a2fd6f11a5256dc2274f524907681159a91228cb80325da12898d63d858eb57d32849f70aa3d4baf558d8f4d7a722be713d39969ec997e42e086dbc2724d8a4cd5b0bbc10749073fdd489ad277b756e418a183761b185d53496a85cbffde2d6b7b2e8650aca5fe85060856e1bb126cc872c096a139e82af5a1a2c8fd24af6f5069c9ce8564a5b37e18d0158c771b3ae49ef44bff985749b42d4edb7d57ae12590a41a26e27fd13bcc1100644bec413066a83a4640b41575d70cd1df5912056cda9a911af60558a6b732d6cc9db6e12d463665078515eb6eedea0e299957841d5745987181a7cd6a3015baf63ab89dcc2997aead0b88acdc33c80a220cde8a3bcfacddaf5eabb00a26a382572428fc550205ffd58bfcd71fb0d06c62328b7d7b2d8a50714013586f4b0c24a1da3299242f837fa67d2009aa2401e0e625798a2aa5bd57be542b7436d2a6425902214409cbe551f2c7a750cbb0c63bcda52c0ad5df04730fc618f30bf2e2b5c3f7a038e20a24de3a40b43eeb4191dc495ef78bd45cc857166a2aecf247fb6c91d874109b2e323b5334818b7d6a2216b756e69d849e847abc46e741d5dcaa446a0541daeaac52a2c6b862a2ac6b7f2f97f9d45df4442f235866bf52865dfec36339c1bc6a5045219cb3c4ae72dd3cc8676020903c612e62e994778d7d0fbfb44bb2974a59650232da249abd20fee4be2549cd91d2e5674d2b15ffd61b6207a0f48829351377a3c5a56be553022edf8bd8de4dd9eb6788261b6238ea5e732e79396b1163f02964b1dd27f99701fc7ea7b9cac0b7b79830cf576dafbc33f77bdfd1c8b327bdbdf870672a4af00d79b21c16802254abef19480e4a4171ecc47cda39b58fdccf9158285e95aa66b41d3758e1f191c2d44355970ccc9127300bce3a00b7aa10e82493e6b231042585d11fcd55a490022b8b3decb906b307c53cec0906dcff111e3ff164d84777267f41f20f9724a57aec806c54464c76fc1f21b5c480a3158d05824abcb2902e5df99cd01b2b81d94b52279c5517c280aee813b0f061fd5eaa44cb33e103847473f278b0b82bc99272cfa673bd94d85310fd29527271841d56a8d5941bc0ba910e385e18585f54326786bee29949c167e5d983349025f22d4fa0295b04ee185e12f82190680e0e1ff6b66591d4fb4a691457398ceec1a227fc633f859892a4b95ad88ca0cd808737b6b2b9ffd2c02d9ac0ce37a339676077da384722925c153f42cb443bbd2c179932d70102c2a856f85865ee2e844364e0a8e39df72547277243b4f2161d0f3bff1f14eca561f4cc895b636e91bc9f583d1c3afd89de7a65befaf201f10f5f420ba3797964408ba6d65638b37206f0beb548bdc4ca6d2d43e56ff85821a80db044a0685ca1d2ec95011ae58be0653eddd16d0a36906aebd93da98e9cfd1a236e726e81dd2dab8e71b15b6ef39115249717c037332d8411fce87afe6c894eaf6d1ecd49e8c4a4d48e36ae790404ec5529879727356b640526e1b2f31a7c76988f2c07f1a2abb41a18bcc585c57e3ebd8f1ae8f1939d3925fc4a49e26c4828f503be042f5ba40d0dfcccb926962106d42a964100bc9b4f7ebc08aa73228133ded75f4c928994a5b15ec4e2c7e7f41b26b51aebe5739ee12d704e4953821fa734b9b6b9f2e3a653f5308f49627e084135e81b49e48187b0768710b1fc1bc591d8578874af4cf821f0c026b2357ddb4b7c40f3c1a0781b7a659b7632621cc69e80c8c45de926adc0ad2f47d43d93f5ccebf328031ced1dd73055ae20747641c0143a8a128de96ae6ecba58c51db6297ee6a87b8094cdbe2f655d81c8b50203d9d7e13e2eea27c60a14d07dcab8a4699cc5d4fa062a8eea3c97e935867f27fc59014c66bdcdd1dc891b13ce1246d0ad83a6fc9592599c9142e40d1384acd8ab36ab80a865a5790267de9b567c7bad1f41bb788102f5870e0ad00ccba17fd0593501b4d938e38611a39e4822e0d19b9b0e943596260606ca2f792e2b9c2dd169648c31b2eb78c8eb1af5ab6be25b84ace77ab4b74b2182f01afed9496ba8a05590433c16f1636cbb3d27b1e048c66c22c7ab4bdc80226c5dd1fae13f4e748c3501110f834f4208692702381c4854bf707a92c84166c1ef8e1fc763a6acf68c887023da0670d2f9484a22e7be2488f493077e05c122fe09096d7e785081bdb36a76db7f87c7ef6d6ab97d71792ef44b7cc7aef754f76bb318d2c0ef83cebfc6a981e96e53afaa21b7e6c2251649a199d2481c79366311345b0076c94d03a11adc28348034d675e513e9880f692333a8764d64ddc03e3a5709f70a0a341f6a9f7eb7932076ff5a9c31094970cdd6b63e351d0898cd94fc4cc42f1fc169b9dab9b14d009bfb2e252d3d7465a8ae021cf717f282bce6b629ba0e9ab92c89b7f41835e8fb0d88f3e395b9bc2276b044e3913351a8e9d6a271643cc9b85da7b0afa6dd323ace1ea7390662b575222513e0890d1e3ed5e785c8613483604c7e94b6e0e615fc4286ecb306518bb1a680911913e6320c3918714c7beb83650921531283bb55791e74ff13b29fa8e675f85711a213c4b3b5b0cfebe97b131d76a28e069667643d050a7543702053b464b4691665769984f9c740926afed6c944d39ed4a5f3d2a0755541b2b036b2cc6154800156101aa4b5018ab993a9198b606d92798a5b887477a432ac7604db4ba2d63003d0bd8df2e0c2e86eb70c3aa9f3e9db24d79ddb21a95af9e510983418dff2468ad2a70d3ff53c578e568a2c65b3d0d7f0983257ae565edb4d0b0a00b85a37b11c2f4b3f3f004b4a4c04eaf3ab570e5f8a9201d228779d3c0734b76b9e57f6dfcc7fefe661212cb1df493d178672524370d1cfad1696f1a244c02c5741e956d916018eccb62f5de8be966467cb341b772d223da986ab2070d9d14a7ceec1c89f9279c5d811c4acbb30556954da86dab19364e898b3a539c0dc5db9599d7ea207a53cf7a092553e31f259f37bc726e55a23f5222e4b39bcf060ebf4c169c7f22783cf1674449eac389704b661d90d79d4f2564d82a1b799dd74d2fd4d4c61973959dc4898046416c8e1d02b001705cf5a1798f344e1247a7d1ebb573b174e00d68b2ffc0296620532d30b5044a05e349dadcbc333bcf13beba64cf8234213983eba0337bfd0fcbae65f524978cc2bd616e80363e720fcf9e14642743c59e4e584fe5050dc7a205378bb69fa3075a3205444fcf04a09444f6880f217c2f217ea9b71d2d7a36b40ef129c4821866254c22313fcc4361da27f46375fbbf29c3caa4d97b5d4456d0052aaf927acb06c24e7aabf94db4e6be92b9a6c2fa78c8eb88cce20f0be33267db6be7f9872b156ccb4abc59eea74fb3678d2cc6511d60233f52e96b3f1c5d418d92d50941f9d07a26afb7a4d190c152dd5ba1378896718d4814ea291dff9ef46db979b863c1e71fa8ae543f6d97ae402521402069614d5f246b55db669a344a1bdf5d138216a0d3fd875c19ad9d6f4a216f74229ee1086a4582e9c452c8a58caf905749f5897e3712bcd3ba4f0bffae76e3cf68c55f15c2553e53a01a14b081e34c6dd69c00fd0a2e99f9ab5bafe7edb1e539a16b5c7b0ea2d0fdcf0a423a2d5c087bd9f9b03507acdd6c83b61047a8c251d20904238c41efba44648dc69ec79b45e85b5c14cbd318418255b940b925ce4a5ccdd3096f50501c3c4ab17eb46690b0d6348b9d772238f2630b991207c4fb138a4a2f4036995c92fbeea5b2b66481615771693884495907394930b2047685622cbb44ce235a904fa66dfd398d12157fab2116366cff1afebf51b60d4e1238641848fd065733e40a4ddd798037f5fe4c4aec48b80423f22ca6d8412e3c7700f13c8c3fdd25aee90252db5e74e13847ca1f332873701d56fe16f454572142ab5062a565da714814116c9646387e7cc00adc67259029db797f11a25183ba6399a55e0f671543a20c351ad77810cdf8629d86e785ecd757d358121c832c10ddc6ca1d38f1d9cac8bd328e032798dfd74ed1ac371d00b74da37e53d88f6c50e894a3fca357bdea1a84ee6909d91c13ddd84d704cb46313059fe2f0636997718c8685680c949e3624ee9ab88521bece90be674a752e8d21f821ae756fc9fc4b138e9f2a0c7762501b623d6d61422fe8c6ed96f0232f7273b75b4e7b61a8c65eaf18b0e13592c7f3aba8a07692732ff09a17fb990a858381ac15ced2711d3e2ebdb0a4114469c9fe94f4b469f9779f5294c2493c5d67c53ef419c92568d780f0d3d2de545e6825d81099975b561a0af8772b8e193a78bfc0ba25bfaaef11e9df99e64d2c802f7374af0205b0127c71c7272f1665cea795a2b41a7d4ba0ba119f6c5e6d66a42734c117b96f59ea2c1ae1a90c606ea4980d09fa8720e6b208ac5b7e67362d6205047b61cab43d91048137e3dcf4194dc882335778f89b54a7561173a2e42b1b38331a60cc0ef6bf8d975ea803cc346bfadfa09d91aaaa4dd5000dd6a52ffa12e8b0d2f6d4f37c55635547b8bcfcce1b6e3a171b1867f32b41b10a692f3c2b268224e6a0a70c46866ea1ce3bc9ca2dea3919c13fdf8f2ef3f19110f254525389fbc81fc2c9c2ebd01a9f87251efcefe4b6d2c1acd7af5f5792c4e260052cd798a9ac882c080136fdbfa6f36331dbda5a122f8cb86e4ced2c4f74ca5924bbc741d072ba9edeb75e2e1933d10c7474b6f1d0d983cf4e22d5defea0007adaf032e9e296ba6b36ad72c287ff2023f4df08041616b4fba9bfdd562997301d99f2979113d7d554bdbfa8714d2c49c81825419e801852b0e78cc6f444396fe3c29e58492afd610d16ce0558b2df31b7be75abc1204f7e79b16af9c8e4fbcc790ce952eaa6467f0474988137b553ef6ddf4833c113ce8555aad97d5fb39d553a8cc020e6dd72dd43eb0b22f7e5091573397ce5ccfbb186b07e970fce6c1f50134cb6a076a830dadeeae3c87edc23127d553809bbacb7d3b6838dc6f0b704393f5b2d3a90395892f0c0f4802d1de633908de404ee82504f2a6e3f6cd1a760fa2c5919b7bfacc34c24f3aa7c04e3c0342518dd452725c3f6c06d66b8e69279a3891734a177831e0b9391f063ef8633843573cb897e4745c40607e0ed834269fe502ad652cf3492d8fd950637526eb45a17b3b90ad97b98bb7388f4923680a5d3ca7887df61db72e6367e3723e5bc0c6a34fe0bcda34135d6266d5b8199246ac5c778f834c3a54392fe91eff2b7cccbfa87cd17b3753ae091033e8506969d1969f97ca4c47264f6281ed839488d5cf5dbc81290dfe0c736a2e5601881763599f31ac46981d1accd2f8badd58e8777a57e15fe956dd467da7b8290d550598fafe431792529e9a6a8632d518dffea66b5d85944414028dab4e6d4d57c727123040d8054a10ad195c74282261e8df981157ffbfd946fa4bef11bb2ecda4545026b0b16b31542cc67821e46c2eaa9fd267095bdfd2d3018d08ce518829073b2aaed514f3a4d912853b962c35d5e9506cdf2ef33f282aaa6f3a845896d893153c39cbc06d471006c560c9064feaaed01d9aae221c21d697ef67b94be62395c71766a923a9f970a1823793f9957013b8321dcfa15fb088d0ad440f96801a2e90bed9e63eab41a92599571ffe87a17b5f2cfd220d4e113f6369d60de10ba619eb2ac2c0012eb65876972d5ced5b418e372a56500db5360695f6ea2f999805953bbf91fb5aa23f687b1765578f7bce6eb9698e9dba983676934d527a80de5e719802bbfbb551862fb5c11451cade3323f454edff94c75cb801d2d63f9df7352edc53db3e80b25b16f4577006033f956e2d44e4d88e53b6f47374342b8e4714c3b8406efddef1eaadf5dbc1173d8d58b28f78da737e53996222ad0748bcce684e80bb3f15b2df709a5afcd21afb0be41f42b3e300b72ff34bb2bd00ea5a3ac44510a752ab0bb56eea0e5965528e5e08fe32fba2e26b9a2031226049dcae585aa1d4fdaeb13f75855a5bf60351a72996e13be40a8ae2139574cf232dfba1259361efcf716ba7a69ede71df1492152716ea758d6742cc2eb72ede3606e87c616896394c7fb056c25f9c0cc5192ceee0773db7cf86f6314880b8b3293215b4e82c1c449e3274905a4db9288f0dc8c55594dab413c46a5aa23194e30970a5f3dceb6955bfe0da9540786dd44f631d1cbe341bd99ec73c7ae717d53c3ed37aab7439c107706b32c37b21ffd40355dcc4d62c4ef7581f6c17b267532ec0f0eb865774e9d56ea69a822d8107152b43c089e513c6ab935a433a51744d52d6bf801fe1e456916b22153d6bf549077af0c241cdc7d3fc47450929d2567b14c14b6366fff293bf4efbda8c6ee0253a65c32fba44e45f87bf266848158f1fdcf50fb78274961cab690ec6802fc2da89a256e4b37e199b83a27f3f59a55ba326e40dc7c7e4a5b4a846968728e38fbd3769e141ac4dc4affc1c2773dd4a0fdbc045ca10722caed13e928495db0c91e0f725b2bc8bf67728e82600bd8a41e627b7ed57b9d1f3f183cde3f04838781802365680a156693cf69cee46d8038561288fd7e1715de176fa2a23422ea525d25499a9dce1c52254dee00bde072bedca2931e3eb9c6fcfe8e860eaeec528a23cd242394f31d1bc33857d50fa1ee81dce4f60c1f7e8ec82e3f6ce44764a94992d2fbb103c70a6e23369f8486794813de4d1088134ae208512431d630ee47293427389d06034992da28c0df42c57db6e269fe72a79fb5e950b80511618dd29d3de13c09c46fc4d5cbe2d49c5e75521974733753f8d34f4859436129ebb84775f785572569da3e31a8cd1687b451022435861b2b896d3072dfddb8c77b095aee3fc87be2db21aee2dd33343cd4939bb448a3ce9b95e18d2ca88df2017f443f8385a94dd3b6d3337655d202158c28d4e1a930837ba1598f0f0ac4c7459d1ab4a71ba2c757a35f5b47647f32dee64aa2c734ba2b8e5cd64bd99f23282c2eb8b5f5afc99e61c49907d4f861b7f9b53a5e976e9fe18a0abf7f778b82f87ea08db1349380a98239a659aae2f8d39c9ae5f18f220183f237ae1847d0cd5a1e914ec6abfdacd6fd2957f26dac32f1dcca033b3be5d8f59fe961202388489234b3618b643117db90b7bb8860cd948c1bec1a430c2f1f9eb11e07863954ecc9bee3560b64178486da9e2a1f9cbeef8c0e657e7264d399133b26110c537cb37512c4654adc5a9ad7f2ec56e2bc4804a101175f02eaaacdf9d531830eb86959d221b220e07b2f9ca2192c9afee92f850bc0ebddb79eb0a130cae1f2a6162f3da57cea34107e17786f3b70c2fba3053727fb36476c996cb76d2cdc036b5e760826312bf34c082dbdb1e7746cfb665b5f492f7548368cf1e460309f58523ce9e48c329f7384d989f562aa60cdb0b7387a82a523fec05863d62b8228549f53d3c7196bcbaaddce151d3ae869cac3967714b249d55ac5a041fdf280478607424b16f3d32deba0f80b6e5de5c5b5c0a8988589be667a5c023d42713b459b91002954677ab934ef16ed453c8f85c84a71f3cba1c87a760618fa2367c256deb51c66b05086c8b14c0b587b3dfd14b9064f0d0fcdc7e0f588655cb9dffd61dda515d684c11c42c535a01289774e966bd3f3a32d77d2c785091069cb39fde62c33cf2bf3049f06c2bbd417467f04e25ee8b633ac7982175211c0e079922ab41e5c19b7c6efc72c84c5d290b176744354f74dc79e02fdb85fa2270f50cde8a2cbee06ffba5b40d00b671afc89447785ffc6eeb7ff9061f35b311f8de94cbfbb5fd34ce71ca3da56671cc75f01aaedf9af07638b2574ba344a7f4a6d46534e49c9e33e9fab0e2e297c80872281e3bb2b7cd7a270bc9cc11ff599d7558170418b32ee559ba621e1b1dc04a5e412e19fb94074584ad5edb37993442f4acc7b543063809b8d90a92ead577b285ceaa341912288cf1018195a11365fad912ea55c44574b631a58a8b0c92912258d2e8321e7094a575879d7423a57b2b8de9d0bb984a1141ca70e505718344a2e53996eff8c2cd1c63da56641ce5c77609f0fba222379b30733a68c58cb7a3d7b030bdf490c3920109556925981c19fa5f9689264d0f8659d8fc5f3dc0f79be518a204b426ad51808a72fa0ac302cf09d318844f91da5756f46f526ac2c2bb11b263ad73ccb29afe6dbb1f51c5d06447e71bc4cf0aa9f58f68bd5a9a2b8c3370c6029b0563f95f7153fa7768fd6f71377f8baad8519d4c222897d717669b9c5903a11b2e7937c6b277b2a3d2771d3f06f939749ed69cfff99cccd5aa6aa861a959c5aaf3c47571068d425de80ff24503c79586addbf494908911d3d7d50872812412eb83aabe9e7aa386023de11322c00c47f6da17045ea3fc3a36bbb54b3ef22c99e3f6089e0aff3e3172bff9406c8ab4cfe77bc53500a1aeba6bab6e93f48b57c3625935acdc5bbc6fbd76cf8d528867076fc271ca5e54b9073a8d292858f5e4fb20ff22edfaa8ca282a55cda6bb6bad34ae20e42171f5e709fabbf2ab2e455c45d66a2776917d3892e028c50918a59cffc60943fa19eb6cdc10202b48936effa5fb95a8c54da72ad296471a5c1fad482db175e86bca6ff77cd5b2f740605049fc418b354b7054fb95c4a9f72990d2d8f302656a880f2e006a29e17bbcc9e55e544c9b9ffccc9579334027a53d31e5cc11fbc0da1251ae54363a856d4c52a5c800a76c4c8b99d09337ba959ee6c90e55cdd5af2cf531a7296fac21290e6463195d188480964dc0498f8ae3a7e00f50c51843169635cab1e4fceb7332384d083438821a0d07fcba5c439abbb25140bb30b78211defc0d4714e245ad39b389751094dcedc173266d4c8cfd37b0512d638022259a3338183b36236fa5c43a521c70ec4b6ada9cbe7f36a5a2570a0daba23abd420cb968fcfa63d8cf95648aeb8ebdb86347ffeadf8a93ae60abac9102a0ba87a3d5152bea9c816dd19408fda5c6737c50c7b25de58d8b0f5185c1ce6cc7b692a578e8abf1dbb61b1c111c702e24a3a61977c77cb7aa44187a20765ef9f8bb3ff86286160c926c81fd2892b906ded424e1d1aecc35dd6e2641a1acc4cdc34ae1578850d1a96cbc1cb256","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
