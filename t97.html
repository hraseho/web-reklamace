<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5047c543d957f17d7a0ea8dfe229c1fe96a0a5527ebec947f6f6af1be2949ba02499a233aa83f2a3ada182ce0d8213441594f246a8e0f7e7f98a9739a75b6aa36fb0530b80ec1edfa619e935e383dd3fe4624eedc37c1289e462070fae9e3e8eb700224b01b49030ed03682bbfc7058fd1fef87bdec4a363708fbe8d377702b0b8b91a3250a1d5a8b2dd4285c496216835a5fadabf1cd18c8c071843f2fb018c2ad3dc98ae2fc07c931a14d6e6d94d9cc075b32dd307bbcfdce1d03f01f5f560bceea3760f561cb1d930c1fb6caf5dab1335c982c3b7c7e51505f509ca8c9f1ab194cf239a726bffae97b1a5d77625e15f61ab5d585bb6296b1baeff2a72ca33298c77d3452c04d1ebc114d92b08560cbfeffaf0c5f496061ba2a9eab20eef45ba00586dda3e23df005b8ba8fa9aa7da581b78ea344b7352df12148f211b91c656dd4032ef6963b3663c758b3d221536e4f46ea15adb610583882bc7a50daa400f1b2306b9ace1cfc6d24b616f3bbd8570c4b15b6c965d1ab20ed958a938aec910577ba61a20ffc614c10a066777254398b154b2ea1fca3f66117689efb0b0556d45ea063251bb61fee691d0abdfd07ec891ec33b944659285f4ff83ee645ce8474950c60bb1df81796ea07a7d0aaf57f945f60e13ea0d9eb6b5093344d8d6f045cb28968a38f7ceec8f97d4bc8baf0fabf054d1d0d3afd7564fc2aeba5cc18e456f8053d2912f370717fc5db7e42344e3c6358e1034140bd8dd7d03b3bdcc7d16f7959a25a752082032158d7388accad29b54ab7861bc8001cb31e1b934632095d56a38bc6dca57c8ef2cdd9f6e84045487c4be3efc92f9f43e65c8f1dab026542b27daef28f7efb29b7136ba1e2c98b6c0661a9f1e841dc1d91ce4d484cb69e0992f7ad350b0ae683b30ba03cedd7bb6d1fa6844bb9da8b09abebe06c64e89f0af15d2564c704b8c160b0dd3a15de8425fe28b9a1a11ff1a997867f40fdb201ec9c0d14b27253f067b9d574b861304e281eee33ba58a61eafbd38a689615c23c4aba48d356e74155c24bdb6252dc914386f64d02ad8efe7fab0fe87216207975f963bce414c69b2e7e9d34f93bce453b9e41b97ce3d7d362eec656bafc69d0ac42d65075526b0a35c1952be0fb11c6d970281866cecbd26d79fb691f55bba51af0be6f452d00ac7f67fcbfea33bb9ea92bc76f85ed7437925672c9a4515023b261356cf8db9a050dc61c6c55de91759e39e4bfbe913e710c2a041c46e236017026fac58757ced43dd63d4e2e2842d460af38a8665463ba70c23822df21fcc802a822950efd797a5ed0faaf1078794df0b33c314e099b1c90439372de17d33f57c51c22f603d8a84baa2e03cc0be3801d4b442e4d0b1fd7314241190313722a4c76d8e17f15b249b6f6c6eee8ab1a3a590e0c9f4e41ec45fbf4cd9df982186acbd1e6505c606293cbf4f53301278c1b84e9076e2b205fa3fb548feeb21783fab40495f0b7eac7a04e9e89a16de2e823a51342a153ec0b7f0caffb2a8d01e79fd1a57831521ce93f1c576d713d99a0670a26d3e6b718a4e3f8c79620420a348c147bd0e21c5b3242795cfe4877665f6429b1dc1849f272a9eea8839b0df4b960f20da73456aab1f8c71245ad44e925d0926595ebafc522bb506ec0ba3960635418a6093ae0dfcc54bb7088ed08ac1e5f3406d7cc2402dc0633f907d93bec83e85c3a50865f7bb496cb4e0a8cf00e04447b2037be83261fe19d7b043e2a6ff9f741345d39f71de83979df8eb59a0efc3c7f8ffebcc62e3212323fa54ef8b6d4dd53b38d79ff58325268eb8c50b9903e5ad186bf8efb8096157b21a56197991afb1044ed4bb652c9eb51cac48b2be9494d5371042539b68ac7b9e3bb9f4cfc4c7dba9f3c8b940d9d874608cc9e9f74661af9c07f1063375a93c5a3952b58b8b5c3c1525b90189149a318a8ec130be98979ffa7dcd279d93054a13ef4d42dba08c0ac1735047f794764bb5625e4c602ee6ef507f7f65f57e6035a824e3b722fc25f0fb1146ac945d1501edf19a2ebab7a8f690f4e1ac95de322bbb5250d6ecbe2bfb555e3a2774b7e765584ca91ddbe60d7ea9ba35e51bc50ff5bc9b3030e6bb13a634290fe71fb38fe56c18425e500f0caa898bbc72479ac8955538c5083c6b916fea9b8c5a20f3e8f0fd6bcca9c493a5e8828d29984381812e597b1b3f078e70a2cfdb28949a72888282265a3558418ad5c8f469f4d66b491f7648d303f473138d3cf28a614f165624174a34b50f0e4916c6b00473bfcf220f3be2ad5119b1a06ebf5c730016fa039849efb07c2652e86ee45e8e1694198a4cb8b25adeee8e103d4f8ae866054b16754998023625d986576f5f613879d225e30dc78cdf40c32e4417d8f1473f481ada0227df002eb09ab55a14d40c6debbff03f207784bd5cc1fdbbc96fd5af4d89ee5189e0eda2b37bcb987d0b678a20d44ac11ce93a7ca793e221031aaf9e6c1c1ca534567e2384aaa253b493ddb0482ace33dc287ccd48a555eacce75aa20c00c6c89582b718407a94b190bafdc1902cb5bce30d39083af1b20760002a9694f348339f45a4fc2a34ec7ba22081462cdc27625257b1c660937edfca4b514f6d2faaedc0e318f5bab111f247156ca1224fa86e0f3d83ac2f00ac68b34e89d27cd83a69ddad0542bf7dabfce8d168d1fc2b5530eabc45b5febcd57b11d72de40e7702b960a56eb1d5762768fea265403c6450986919b7507ca11f3c1887b00b40cb85c77c2935203875ca9260257ff66be5c9389f74d5035dadcae8a491c99173b4dabdc7c5cf6ea90296ae7cb8bf607895cb2bc18975d8196cd01c7ac610c453c00cc193ebd08d423ba47e9f9cc976083c6d5dba544069d97e0c80ade36502cec229110c958d863f69e21b2744361ddf43b338c4319363048f51a4dba6286ce01bd912b45a9093c10521e57d5ab1c3c064a682b730ef9e7707c8f8c57432bbb8db89604fde3b61811d84edded1b44a60ab9c281abfe6180a87cdefeb93a88cb1ef2771f34b15c04c2f647a2955ecaf61393cb85ebce7350160d12ba4459fff772963c6c1c1e8924f1c367a32c69b770fe6a455774bfa29cb3b3900150bfd2150db06e769e9591629427d5806ac2b9ebef28d42b796e88800f8973e602d8948008a267b3c1ab41dad0f071d6340d3e60b72b19ac18aeef4835619d8067b1fe47cb0cbc65b11701118454ab1b431ec1020add5b0d39968981166122967651ef9902c5cb01727a84d1383996d59cae484eb8a00be2bfc8b57ab990cd738d2bdf1038d088c68f67f0f8d39808aedd986e29859dd04406d9b400104f1c3fdc559ae6eef919855bb615762803d25fe4bb3a7afecff294ab6b21cad543df5b80bb52a37b48a15a24b973bcf154ace8ff0f0ec969cbc47c26e927dcdefda5b29769a007a46ea68451680adcbcce18b443232fa957df917da37cd10c7f38f1d6f30a6536b7f981a1ede207a163f6c6d165b64e1b51474ab57b92fda3d340e727908eec911da1ef782722a9d71dd32250772fe0a1440348b1ce81c703e9a0484ce94db4ae104217568c608123d7463b39b38e14564e0a500b3252b49e33efa69b7c4fc63b99a506aa815109265cd5ceff981d6191db88fbac8ee20e82176b1e8df15698bcd6cb313b61878ceb2bab897072d59a5a2c4dd2e6c215661e654f64b4fc28c8236c13166656a87049736bb1b50e82e51171dc621de10a6af37abbaa135df813f156b26d31da024dffffcabe2f9beaad1199403cbdbd416f4aefe6d618b9b9f7341b125551440989f163f97778d5be4fc267609d0d66178a8f125d738a159b20016a449b9daba281511d95c303142cc8f42e219cf3257a79abe4840edc8aeead39382fe108d82e4c26cdf4a614fd2196590aecfc9001e39698088f9de933eb5e40387be5cb829cba4e2be3f618676795f090eed1248711558dbcd635e34cc9734ffa52e67a0fff5ccb242e49a635a7aac2d29e8e98ad71c60eba1f728b73dbacc9959e6bf05bac9ea3671bc4e8237d3a0e564ab6252bdb44fdc254ef7feb6de72971f57023968a100cee5f3b6c43ced4e2c73dfc1c5ea30bed874d8074d6c79c83dd7805f027f44c430ad38bba88e25d6e9d1631e7e3d747590105430e80e73e8d84c841b81ada9c5758d722fc687ffba29168ff9d0788f480a52459896d5739fa68813ba61f1a3c39f0327de0bffe6340c5a8005b4e801700ce55896cf5257a36c7389971b2a977315c161e4a3c5c4748ecfb1a035e3e259c49129ff00b71421a5f41d0f4407ee1b0cc8da386f3a53cab643053c9bcd67e2bbbf53ad98c770515402ff6ac47e13c0435f83b396770e8c9714da2a9c4d5fed4caadf13b44eed815df5453d47bc621095a83dbeadc0ff2a9c3c6a5312a88d13c525d39cd49e14338de4d5690bb46c9c7406611637ff8097f05a8913293afbc99a05d074061761d3f4c2e2d811d8b83a0625e444ef3ba0a9a48223750d4196f57ac621a99523a454882b6d75be4e539641b3a37198600b4a0028d92f30d2cf29403f92500e38641512403df6c03fe978b7196cc0fcff80698b71053dc8dfb22f1ddf4ad95ea5fe9b40692086534e9d2b62a843a2aefc331f9a9f702817d97b061fa89ad022c903f90babeebb25fb4ea8cd3e1f297e4631bc536016d4196110c63bd10ee772b53c035e6baad74bf3784882d7fb3f72c1f14d2e848518f5c6e2e9976a5fd813f6c6b48474fb20a74c3ee5cd10cb71fef14dc57fdc759697e048d6b2d7c357357895f8cb567b98b54c48b71e1e2ba1e299bf2e07f0f0dedbbfb77218be10b318bf455e686000b69aee44b7ad66220a9033d46cac1322f05c82da9367aacce97f10f62737cf985a86bf568a4bee6db2608b1ba5d28a119684bd88dab8a504f142346cb5cc6afd21b664afd479578f561d733c2b9e1731b4591f81dec6379f80fd0017eb4002f55d11680b904ba87b476c77ecd339f6d11ca8d969854ed4f79e89edd072fc799ec61e02317933d89f74b32570930bc9725613a26f8e91bf1fb1b544a4b44386d8f351013d7d6a7203a441ffa98abe6c2c3a511eff7e2b704396abead9295975d6924c7b203a73035b90ad8a3d9ed6e28aa751dd850ce1e2e1fd1a1e2986282db1cd76d4970f77da784bbbcaf428ffd446fa64979d6cfbc07b6cfb1790a6ed1080fdbd0fce8d7df67c5267662c5e2e4d07d2a1f821af0d36c7a04c418d2a36a2668351fb7ab071041ab23eb204e0b072a0ff09420ad68a0b1429c852da4555e360dd13e7bf847344ccb10e4b5d0d624eaf2d295581716ce4f3140e5161624c6e8cd64ad25f395bfbe28d2586ad3edc6da15cc9bd4e6360be30becc7e2c6bc22ae3266be003ddb6289117a4159b4abf4ece00e95226d232fbe8cb6ad0defd9ba08701090889dd711a836af07fbffe50c5f80c8a7862e080f49d7dcad07d6047dec25e74f49047e96bdf2b2dd673b294072833a94b9f3008e5221d9433b0f23d919fef733ca4550ed707194db0ac0aeb4e1430926113db704081d1fd27f87b7867f9dd14718489e74b79b4c2bf464e61054ce00cd0953c052c6dbf9816b23b053f9163c406b39afb1c0aab6ee53b6b0a2ee6678d8d2882f42afa5ac59c7b4c5ed5fa0cddbd1615d8430ec011c3e13f81e2a624e550ba6538a8ea8dbf946141480dac7b5d904bfd1b81fd0fb3bea33668626a7f9b09a75373ab1928f18a09231295444f88fc0afb166e2b6946d0f9c2a69ddfa076460433bac09c77613942be0d557241f9afe017666d45317cb75fb2845bc5f1fc44c448ced04c6603325f4cfe82414a8e4bbe62002728dd3aa2e1461c5088df9c910089e58814df35057e069f67b67df42929d63217202e2b20329ceaef05d4d2af4dd90da9c8736dd4139f4f6ee9de0380621e918ed54e42b52bcf03b5797e311c1700eb488c6a724da70c061f8a0668466b884a37da58614652298abbc2a52aaa767fa03a8af4737bd39d8f090f74667aac689142bb6d4f0ce845d570869b05f06604bddc7a0074711993b0beb7a2379ff03e8b11269ae5e10021c04c25cecd2dcbe36acef68e0116dd2fa13edfca4068d27ffa817bafad2475dc4989b2ea477c9047d24d79a012b982c3b06039e975806b712eb5bb1a604f71354bcca8e3d578b51e569046e03170bdff11673e1bd1e934cd7cd070b2f4075a480c946c958cbc50094ebb531d14830574a8584b198aad969b0771d851138ab1ff3c90c154986a0ca13c16b9a5fff0f2f822b1eae73eb4e32b870c93e1b5188d9fd8b5d533b87b158cca9ae152e8bfac78a1795b0b364e6bf9413d939bdf84770a26700308ce3e425ead2b238b2f970568b98d658de89d744d9578402d1c08a0bd922627bad43c1a22c627fe43cc7264b489a4ad64abc4b91a0c11b810bf807f69c2f11ffaee71da9a775e511c4b4e713662a0d1c3d963069dd87e7691e5dee3a15278431af82bc9f48c3eb59208b205284472e770534a6ac924541d6fed44d60940ab2ce1144728a8fc386491b6dc5088414c3a6695a13c37586c97f215f358266414cdd68d3af052bb8b8b6be7714b0cb08fc7ef8d792d9325b23ae9710d8ebe7c016a56a589af7a37a89483b274f0b93cc89cce9b9c61772477b00da513528ec91e4f14084312deb9e3380b616473f3e1bb950146e6f20da35b326007fb6a121d4ffa5a9447f8d022fbc82c58b1c2726b2879464f5801ab2f99f27ba9ab0da743a75fd9c415adeb1ed2c4515559601a9ea3c0744d3d4e0c075cb7b49c4a4cf9c472c9c4f2d309e61fbcabe51196de54c3e8a58a8dd943761f8b57b3843e942cdde422e428f431d3255bd7b44593763f2b3602a1081ab879e5fd8c023feb735a58c956070bf7edb9c8ddd16216fb74c55064f2d7c3bc27e428642f7ba052c1c65d7a8e16ef02ff8f4150a310e48a8384fd72315e38b1daf0c8eb7a647532eec2891b0e279e9c9f590eda82b66219eb1c85d723a39d28bedcca061c09f542b48962319693b8766d603757ea3ac3850d570eabae881ec3e3d632d9c1f529a49d68db3095d2d1e0109a54a08e095763b9281902739389ae591e5939ad5c5296b79b3b4db5c51deb96b5ccf8a0adf870f9aa34723de0a5437adcf03c599a3fbd168389078532c97f1cb8bfd18ac3f09bf1ce81f30c55e3e4ca53dd0c9e1454890cda95147b2e40235e516c610a052210238249984e97b001fed6e3b0551c6945a5239ac6ddbb273009c614d16f9a8da21739e5e92490841420369ec46a4175697b762b6061d755582fa1cdd3227597c3ac83fc7de4dea61a1aa33e6af3234ca915bcaaa26a4fc091e8149c520256c6602ea6daea12a7aab30a65bff854cc9ee39dda4577fc87f351ac7cb69dd6e5750701aaf261104e75f73eeb829068b1bd2fc352a6053cbb9aa25b7c711454fa74b64f1257688f11a39f9b59e9989f2ff724d41c001ec29f733f84fca199692b7912132b8ee5b27dd78577d252f6fdf66b5798bb29cda0ab733f0a6c7393b71a7a0c8f3f1d0d70f3cf386fb1da5e05265044554f016aaa3c737dc5625aaaa6a60033323de730166a9d7c6366d8299587b5ca378fee6fa758ce68a872e82d3f3cf0a34629c3f62ba4a5c53c4aeb96b3601e9b933625e7e497b967e9a0102de8749bc8fc85fd0523a99b0316559a0e6d5deacaef79035765995fb99712f0ea04fd87954d7a0294ca0655e5da094cead1c37cee6fa87fdd8be72a72f9f7c3bf8a9ed65fdd71bbffcb321405946440dea845252ef85992deb3ba8887b9fd703d52a1defe6cf8ff091c5a3a0f2efeb23d4378b6a1c374a7987ad6d25053e32bd4c463ef02ba40497a0ef0ef95fab4c0b45a3409d4172a6b0a510ceade148b20ba6370698288336ed042430e8080d5bf272c344a820b97eb2c13d10366a41ee7248a08d1937b62d16328cf6e34c23711806e5521cea36b77c7ad3a3957c5a04ec69011faba1af6bd95157ed7ad5648a1edf56648b83e507572d6ad25c2651b9f61430ee46ad7b749617dfe14ed6713aada5e94c45315ff01a9894872b961fa3263291d852d2a1fa74d8a4b873639688ea5c33f4312e66753ff14123c4e12143a6930db7e642387ddc9139f70ccc762d5c531ef6e2be6de400e2ce003e2544647a3adf819f47c78bd3e1a994876a2fabc92213361290d3f5d95baf84ebd4b672255404941ddebe4939361bf504a41a0d1e5d610654427d8b899bbc863ddf666d6a444276519545df35e1bf33965ee6c2c61eeae6af2f174a6d984bed80a20221e005789f744a259510832104f72c70129e522af5fedaf1c6f97176a7d5d7070decfbf21cade24dcb792abc6a63b7c8c0d65a3562eefc1e5fcbe155e79b1f6d31624559f986671fe51bbc9e0cb6c261561bd27641741d3df58c34f4040195f8d1ee77ded1aad5c3e9c5b6e9467aee0515d9dc6872a7446a5de231884f75e1359e7212adafc7009c17560c3d2d17a6fb55f666f13b9690788499697e337a7225a2cd7e48b0d30a2fca192b690bc8411c11f668b80d26440913d6cbf877a395793651a5ce86ee7b35efb68ab907cfdd4441d256b520d0b03054e7fe48a672a47b42d91f4180d11b6d64f13797c7431af0aa8edf7126d7f3e6cd7d4ec0f21ba51040959e27e7127a35437655dc229517af95a39946df99a5fc029953095b12029878fd65ed1f5cec6c779e93b5df6756505f16d251133fa3e20cc5b484bef6d2c28a1b4ebff0ddfba22e6f390151e207e68fb88af5937f095fa88359877627d375ae6c7f68ca97bce6733d3d327ef00b6e6cb013733eef451950f5fdedf7fa024bf0838b091f9bde07e5af9881b41bc83150b292694c573c9f93e03d342d8b2535e12528d652e43d86b17bbe4a5b990df7ea55378c8036dfa6a2ec21b3ba8580f233d18e4352ed599f2713a7031572a5748cad4143bb2be7b61388042c07dccacc40f045529ccae5c2024c6fd0b5495e86f82ff649370ba6c228fc97667920dfd0d641603e592b193a2ed89097f26b4f30674e2cd494b4c7aa453b954dfa8201447b766c5d2613b39e01032d1cccf47ab03aad00cd77b0204bd4812cb5548f2a709e1320e9241fe0e1e1fed0242fc64723e2b25456230c6fffe7d04e9c964c90fb50a72c5295a4479d9dbabd7c63d24ab974cadc91eea8aca8db3530b6d81dfed96612672e2c176a84bfc3347a401de82eafd5387527cf42201968880deaacd94215e95480d66dcecaf0b4e5a86c054f6c16d81e12324436198c0ac67d5d4b48fe36161f56c02484b30456c6bb0c8e03dafe95f591df40f25fe0e72a73e63b6095f928ddd88b296d3a6989c77d51138a4e6e439a598ecad867b2dc9a065a8992bb87da8365cddfed2045ac8b7cfe7f803b70126c6c491315dd34e2e9e92cf39f58428526252c9feb7948e386b9a6827d20e58aba48f87d7bdd26c47539ba80fb215f9c76f9045f8c4c33928645593e4f7938968f62484b54cd7566687a66de1508e10acc836e269267e0adca6b6c5bed717303546aa84daa5b660085f7ef2d4270f1d3c26c6d81ff8b8d5505192dba258309b7d821dbdd168686b549bfa1899e47f16e2e79d4686ca9484c7a1bf2899361c4e5882627a4b44b9d362aeed06e769eae7dc6986eee31899bf88d405ab8d385afd6c503d706c459b8b137c0c0c549e1f3c65a6f0fe3657661be816f74b29f3f515eb142d18d047cf25d0a4333d31d28362c8dffebb3995613f036db450b5ca4b21c370db432c669eac9c0d0d074037d050a34901804db182001c1ae5aff233926af663259cfb9bd7ac9cc0f486f1e71efa5dfad1bf3a92154da948f6deec43fa644443f3d63bbc2b5a318be28f0fdfb7470111f0c170a461af939af3c59234380e0754ef72f7b0b91d75051b165d65dbc8ef28d14e347581bf1f4b8e0740e34009af1c636e8decbce8c5d3a2c1d2cf3ca5ad6974f417a44da76f64ee46ee1649a7c5e1715ce82de8b6c281d6870fbc359971b5fc05c8f17f92e89afb5ddfd93b454b796dcb1c14af5fdf76db525c41d5a2dd2177b7760d17409d1566ab218412a6ae3152ec174f8e08a5ad16a4dc2335ebbd8c3d4cf89a684ebad92f9aeae3ba43138038cb194738dc5023a668534ca2637bf77fcf51877b901fb83a57aeb69e97c135f6aac2e91a93b3ec2b197eaa1943bfa3e2dd25a341713f7595295f20fb28c80013101cdc16586454d72b201b050d69742f3f527b808923984eaac216f7035635d14defea6b3183433ee297bae111013c59a157ab771046bdea4ca115f9a9c5681e7b3a5c978663cf7600e41a606e7f277d4966102a12cb6580588d5f131acff88aa02a995ff7eab51c5601b81ed61210823f929808405a1aec487169e63bf99a3607587abf5ff2d3d1c77ea23e68ec13b577ff1c701e70e4afce58e4d65aea936f8083b4ea3ab1c7c38fc123b323030104185ff2e35f78fca8ded194599c576db840606c721a6ed871eb602f3166a3e93aa33f82cd99c00fc7fcadf4e82b845487cd16b6123ef65747afcbd89e0c4ffe2f9ee02ef4fee920194c60be9e317dde0ec70517b9bd90877d5c1a71a9d28fddc78b08ccf026d19a12d3d877b4349297d16033ddb10a3c0a6df99e020312b8583d8ccf4f190296455ab2bf664a5cb10ae8083b560dea38bd3d8faeb8b744d57c6988c3b2c626f4c427f5e46a48de2594a0d9f5cdf8a9863400d3515929ce4deff66985b97bc47ac563cac6b73d31db5fc9c199541678274f9428d9672235367843d6b32f5b1b8673cada33eb88b160f3963da20c48aa95d7a9b9d413b3b920502a3214935b5d296f016aa287f8851733cf55344e1856bd8032643220fa4f5773bd0bad56670d6f21e10896dddf52cf0e22781f32792f48b10c4d5497f556f2fba809deb092d478fa1a7114adf7db4966684c9ed24cf1692e3814eddf3edecb55ba6184ef2e68d7effcbc1c1f571a855af4b96b2de068584b77b4f209cc33cc7faac67ee3ac4658fff59b52df29b7ce9a37a4a1014f41cecafc96cbab15b5a536370351b61cef1941f73bb63f60001e19275aa595d0d1053de4296745729491e2ea8193e03e42213335e17d30df17de4c9670d7da1d1b4fa7fe60658375352b8bfcddd853db7139f920654b26890de510c61d087eed42264111762a2f4e9c18c681a9641963e20f175b33df107dfbcfebd9d391e634b9795c8b2b578154e8024480b3548c8cb2235bcec7af5d9d0e57b1d5b53106bbac7755473f058e138aa8c37e6d8b8143fbeb2aa778962098c21c551dd035344cdb18f46d0f8991826a89ae16f466e0d4bd136b5122c06b60cdbdd8ddbc56856e552ed6358cfc5298c50a1b3e0de811e98fac563ca6686ccd70f9b7f59110de0c3ca0e541e604d1c3da203d64860f16f46efa0ac8b2c4ed83b120109466cdf0726e3dff51e168e2f18326877f59745dfcbbdbcab44447e574779d8e3460e729a22a6dfd3684486ccb36f1ba57096b1d9b2fc4b955e5dabbbbdecf2c622df6de22a91f47ade827d253eec3f83e4185bbca229f2cf1fdb06ada9d030f52d388e1a339f25acbaf63f7dc374af9062814e199798313993259603e59bc3db18fad5a93ca2cd7aa0e95b6a9e47e2eb727f820664d64f10750b6b4ab9fb9b9b782cfdf162f1070b03f32d30a364f1156d88b18cebba0a2e34d46bc712a01784fb7c10c7b5488712bd13c676f3f34eda806aa056ec52c4c431fcae44ab9343","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
