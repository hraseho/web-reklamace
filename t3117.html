<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75306a5119803355270234746956de4a967360e1d64a55020542a32643ecaa19a791b7781c1f6e3de05b25d51e0ea5cd727782ad404fd63fcf61536e056928a72bb61852cc401ecf91ebe5d0b618c1901a2d7a9c35ce84b12db595d8c8293643fe4da30903739e477c871c8ccb44cde03e8f2829b3872700846d1ee1aa298db28d16462c28ebde4763c301c87d83ea4faa315673a3fa8d164ac1b7d4effe6ebb2a6fcfc9fca215c216497de5e34d21086579d306d2c821d72b5a599a4518475dc8ef310ad9e50a5f219290f5c33c60538d28e8968bbe6a30b2b3062b7728e59406309a58798a9736db507e182224dc96bceb2d9dc4e482d1ae7949ec7fd3ceba9cd362f738235bad04700a506bf5bf26ae9868b92e3260e38fc90ed2bf11e3848e52f65aa0a9d0d9fd0a2ef57dd29762d4e2cb86005e7405b24862f2887eb874023733f948843f61e6c50e4d8314f8032536cd63d527f203651bdade0a9f7f03b30689b86bb9bd2fc5e040e81e417d0aaf004005258b9e0b7c08d2fe998317a4b93f2423175684e2188bd9a9cec3c62363d8687df821637e1c74ac0cdde001b69450683325ec695151c57f93268a86dcee962b87c6be833825eac5ec8fb5240f0925c57fcfec56afd966089df144be78c407be23ecec22eb6a93813b83c3bfd34428ab9cc8e29ec31e3dbe3a651b83c262def8f814a2a65a95c8827c830538b4eacd186359abcfa343976bc71822301fa7bde2d0baa43462adf89816b71b0b14c410b6bd1253ad97d2cc3469ba5d5def213cc8d244e638daabfaa6add1f0b448134383f15955952bf8c0b912c57b7926b4f6ad2e653aa860a0e613cc802d87d404382751c1d78bf1346a35d4526548394225fefa77f536fbc01df397f3662b4d74fa9f244b16324c40da9f4025daf6fc7aaec4e14e35bee8c77e902f2a009bb56088240b17ce7541060fef7f8ed9d26fdadbcedc02d8137f057abad6b7981306184d4977bb6eff5d3dc291278cf567fbaf6a4ecd302dd67c8bec45134c3bbbc36b42fc1ed1da94459922a0c3b1f0812c2f4303187968f20d2db3b5c70b77c4a6f87bc8e97be009d1628fc2e6ef1dcfab1ae8ab5f8e348cf2c95739ca43808a7fcd19d967fa633ff1a961330a06203f08d405249a340af7c07b0cf7a3915b821ae2bd0b7250db3ece0b9d3267be77255f0fb47a8913229ed66ac3c970f6a29586223c9c88daba9bf3c0fc1db14feb39fb39c6440ef6d2e2e6fea11ad0e06056195c8e0854c4e4932fb9eb4d453247b214518f805291ab405a737a8700e2b0445d6b2fbebd7caa1b2de41e177a3c65d657da05d912f391d85b88a320913afb51c29326e5a788916512084ad6542c0e45f531f27d986fd831e5ea14a73c70c5729443760bc23ac0eeadf866f54ebd4a12f5b2d8bd2b0908d8ef0f54a59df77141bf09400c945af335a692e2cdfe5c60dde3d3e6d960787d78df01e6c306e456fd35467016f546cbde4d8cbaec3ce5567e54a80e15246f3c35dc8a5a599adda2cbc9c4b7faefac021f12e96a13dc42da2561fddbde98c3668bae298bc8eb0e7e53d25aaa0cfd1e1c8fb6a0009b07794165ab8bcfac0dcbded859b58da382775278f81b80191b6369836ddb6d3f6e5b1d66c49bb0ecedf83f6316526436b5cbb087d6e53e1b96e35b7246042921daa3f65f9053467b29838098b67311e1dfd111071b063c8fec807bec519e5d9cdc7cd9a4ae4bc20a5db0506a31483a750d825f7fc8702d441b9dd88a8d7f9cc7d147888662088e6aba2d352a079b071f8e533e6d40f8f9920eb204d7160d0dd482c9fa62180d087fe0744e02296fdcd2b80c0bf10497f72215a3ee968bed170cf09445aaf690861a6395fef710ef47285824b2a689f96bb08cd2b88a498b2b1811caa9b662b3018ed572e5d0a6ba0f983e5fed8cf33b5ffdac42177bee7147c4361a1d6b595a19e29bcfc41fe5fcdfcd49babe04beb9ffad3fa9ed308eeea7209c4c3995166b1797b66610936c87396f2db473ec710bc4d00a76404b22f278c7dbc4a5f5057c50bf2959f4abbeac756601f00fa96f3550bb314358c7e739fc09a61ed61f8f15df394fea9729cb5f6c8256115c0529acbc012719ab873df98f78bbb1a11bd6615c5adfafb5069abde87dd91151a88e2bf89ad13aef921cd7d381578d84766b2dd4afd0f96823559314150246fea2048df5f08965da818b276ad549bb79c85151384b77bb4b5146b8326ae0de2c7e85ab4d19f2ddefd0bc4182657bb70721d7edd6ec5fa36bfb5d110ecaefb9427f9df0eb1f2147fb0abc5619562ad082beda0cceb82561f7f97cec558d8b3d0d34dd190895118a88e36356fc57787e575d06e8ff5c9a356b38d6b88d35d84d8af4597eb44c10320e6c22aee76ba08272487bd456df895b31b34e6ccf5229d1a317a5919af82828f2c160183e871dec52ac43463f1ad9d733b1ad62fc14ea63e7d80d0925180828b81971a526b1ac52410c8afdb09594435086b6efb306ba438fa47b0df28fce61ec6d25a2a0428a556aa3a283be887678b283553e9370694c315da1559ec5ef6ea623f7f818ad799bb740b2a939af85796c24add8a601ecd84f301e0f4cc8a4268ba2113953e5c091c343e50b426f864903f1b6c80975dbf15af80b66c8fb2d39ba681b054bda3c496b379053ee574665aca34ba2cded0300a56dcd16bbe554856388fff0943e884617cf5bbc1424ebe33e7111983f53bf27ec495a699fab8b4d07757b2f88330df33081a410a7a715f0b272c9b35ee743fe58877ed24d53a202e5d1e0f80be81279003b69d0ed0c4d7aef8e992ebe021d8bbae00c7faf452ca2957ca5a767795aea7de927a8ffe7f9facb49d4cbc14b22c4e8b2357945b671682ba3923f155ccd8e65edb156e3e0a50b07d3a4bb9c3256f4db9b4d37b795438ae42656fb576cbc683c3eeee5ccd61d8c8386aaa6379550b1a02197ce0868a5d5803a783e557518ec8520360b7724cd089a29d352604ec5de622b14adbf6c961df7ba7b3737382caba38e3e7c8d6dc0660d9bbb6f031b3d84acb2d4d83a8fd0198a68931ab6a9c37bba4f0dc6969457831c033b15f1e37e621c7d0c09e54d2cbd242c95b01922e20f7847f93a3c45786f102fceeee1c3d27170f0f01d07d6f3f1d0ab172c390aba72b5be1170ed20a58f865f8dc602217e3b09e2dbb1be19dac71ae3f54b8ca25c5ab0d30fa75da775a6177d7939ecf66fa10005c010a2cf397f042c0615bab89fcd07217f4d19078b3ce201b3f1ad9826e58311c7177090507f007632fd1f184bc940447694c3edc9b451fc6ae7f257c63dcbdb0ae46eb72a5059c5a83ed39dd717258ece200d3eecd56c5b047c9c9b13349819fd768c21ae9905f0ffa165123d572bfdb2e0729dde6b65d849347dd8668a71abb3172fdab445d49d705c456c8181c76708d34534f774c6f156d2d7e73a653f4b506c5ac269779a646567b4d23812198a383ed1d7de605fad0e46ad20b10922f28835109c23eb066883a78d4a78e0c1162fd9ed5d4630567775a81ef88d8258af1b4adfe87f95445ba91122396d351fe6a82b1e9187ed1f69327bb30dfc30b52f4efed1ae1536ce473ff9ad57b1fbba0024cc85065ab0ce206fadd55d4d210a6592ebcee1851f4a484d84c69dc021c1860a29249e64b7f0f3b628be7df1ee236351bacd5665afa9ee47bb738fcc0babbfe1eaaa4a287f6204cc1c52b17c3d6943d234452aabbb87df525264d8c56122cbb4257865807fe6e73fc4aa2d59ae5dbbf01d76cfbab1821d8a5db510e639bb32d93af2c99849e25dfcd89869693bfe3f086cd74802269e3f70d89f3393193705fea5eeec3c1648df2bbe4c4eac8a255fec0edc7218d85e9cb3d77a0810ed6bff7f15470a28bda39b0f161c7f84c2dad141026cc2035032366a5866fe8e5458d7f99a233c43404fc356eafad608c555df501ba27ad5788a3fe1cbb89eb4c682dc00aa9957ab706f08f65b1ac36f4ba4c0edd7a066503c37ccfcbefebc0e140b72bd5c5224b887ac371b1f2dee217d497824b410d3fb41af3f733745936fc793872c884e54edfa9608347dba26b63e9b737aec060e5601f2ffb38e35a1a8bb709345352379c17576adbfe566135d53111005370aa69dc55c074777bef3d2c6d71df7d329617de93171f276848153869c003223b8ba988d8dad7388a8eb38f4769db35254947366883692036b1fc27184c2e3daf050810294759a745f575f33c7c86ec0488ea7c9f3b0041fbf9f21268ab36b01da8871fb2b1da49da780cd49bd8643525872f0a3fb3435030c6ac27ca86b9f2b7e904b72ae266f417202f2c59bd3adc9e9208ae1165d30765b2ec9b59007a729c8138a7a855600a15d7aa86e03646498da46e090d5603e36f7975db3e2ec4913b2be5d25f4ea2b189e2841b621a51d34f34fe295347ba581f2c95e82e6954037c292a6c970a08ea5ec43246a988b1dbff868f0dacd6ec2cc4850680a411545b492be0f445a5c94288fbf91c08b97d3fba0e9ae55511d9e8f537746c189d0ef36fd9abcbe6882fdcae79f4b895227434caaa633cdfd9cbe0b0d860b3999e0640c32a69f647bd6f1a0345f2cfd5ba9983e62490d600c69df8487b5d322dfa9fc21eee98c10fa93236b3fb640f817eac4951644bbae588251d7a37e6535d343fbf6ced5c7b4e39db214de60c91a4731ef8a375fbd4a79272eb3c160685cbc5fc62d6a6bda306f1bc59d8c6481db4e01369a1fc69fe966eccd4d139bb6bae0605daffef444ac1e704e052a1f815f8e4e7ef5b9c385b1de6e4dbe95ee656c0c6ba68666c05a8b5ca0a27213fd8efc41788af0d42c83bb83582a01d249b25241a985ff71fbd4f85e7e5a9f6f11259316dd1940542c124e79d589192c990ad250b638a7c4a3156e6b1018ee2e695dc75da698301d1e338d97820a131e2c428b39e494de86ea723421bba6452c6b94c29d7bf95364048f935de5e98f6a1f88a854b0a25413a67f0d440a9a5a6110c82b75596af1ca88f95e41e74c0fb9a3b1645894a25167362a18f22fd4c5bc9793b8ff52ce02f844343bf78f12c2bff831ee486b955562dbd65c9c3851b1bab21aced61c8d7ca8331cd9bd6bb579671d6cd88997c223e0c41dd7349673be2ea7f9f7bc3369bdf9f1f55ab7927b73f239d220c6139086533c87379affce94a04427c2804fa1a84fc244ccf1244b6b42ddf6bf7db3b1c9f2176cf363092b4b8474c040f829240e1a6e8e83f01ff9d11df01f5bf4a581ce8f56f3d02ffb28fec85d5e792bbfc0105a376375a098d73df68adb56d8c484f7ca9659dd63f36317ff17db38e7991cc856396a439a4daff157fe056c4545210a920e7091a817107179ab3279f6109ccb923e6e409882331811f0099e6258cef6ec683e9d5b9ceb1507ad99feb1c8fbf6e2a0ce2539e7ea6fb9a694f4afde843d8e3a518b3ac2f48a9869a8bc1fa36647fa94f36e931bcbb357872e7f7b898938a1b49bee123efdf3b43253d89c260f3860deae5feebf009212cc1a7330ae8f0ee5504bd451a8bcb4fde29f9136ba719e6066a52efa52592be2b1a5b36f9ce048afafa5cd711287693c34f820b9bcc01a8df07abed61718a8dd43d87c2f6e7fd6763d4ff0208a790026cc64e5e45b675a8ab599d0556f10546e552f7862e1e25aa7205d23b23b16b38f298925c9a345bf4ae85b6c748a9941bf2ab35109d7ea100e4ab38dc62a9db61c9d89f3a7308438bc0304d04705dfcf20f3af7e3bf16e0966c0f79c9007a8bc0f3fa0abfa276e7410536193276cbc218e7cf9b39d6af10d5e10fce4028c5e828927b1fee8255cb04840af590b479718e41dfa61c07e21d4828ec8e7e879e2c1cc0b76b3eb0b4134a3318b535f20106686ad4ea2f4638d208d449210aa0a08cb6dde3a5d07d5ec07fe2e556d5777ace428852fa6a312cc71108cc3584387a61151c77b26e551e129b2f6568ed71a9fad534654cbc5f0ce3f9bf4f528b05ff84805952bc879213cd84796ab278adf1711d8d1df5903ea98ffa4aecb59c59924ddd6205e3e45e0f82114db5f3eacb747ecdce33593d5327c175e32795c5b5f24d6bd15209829426ec4ec1eb016f29143ac7f3dbe158ec16d348df520fdcffc9759e82b5effe77c7775a03110c548dd4149a50294e38d6928b3c3b3cbc6576ed48eab267a2f004dcbf813c775d3e504e3798e0e34ead8ec14fff80e99c617f7a092b896cf368509d9dd459ef9843fa8afac80be5d0514ed0086a304eb9d1b3e01306f25de8441f2c543760b26dee004f8f1bb41c53cd6c187f738d59ae3c328b268fb7c29482190738139c3ac4599cdd3611115fa47987c23a848cd52b87037ce8490a46c8e2cc83c8fdf849fb37bdad5f2e8c1a6026e884add8dd72a2150713b11e9b9341c4afe4ef307e3ba54ab00f1eb8a27c5544088077ba243e39973d59efa52bd1aa01686a2ad3b6a9bd233471397dc08d30a3c5a4a28b33642bff11597df65bcb86a3b6c4dde0585d89ba72d258d4d548f5ac970ba845cee58adaa7f3b06e72aa7b402034f5e79ff11f8d216009c2d91750ed59b6a0e5651bff4b3b59e7e2c51b74697320e5723d2ef0a49bce9a4b74933f5c9a1b0944a1fa5ea6ff0d4aa101fd981bffe3d577039238d4ed8e9e445a014fe2c113ffa5db0a8fc27b8f64189b868a14bf8430619bbc141fe16b7f81042b3d865ca216e312f842f5fab4498d9bc35553fa25ccfc6fb1b29138e93f64c407c932edd92ee9562f91dcd02b15717ebc8323153d89d099df9fd8b4ad246681ba8a4595e2adabdd5e529d6bb029a01ab7fedadea7b223664202a8cc0a5e0115e3306663a6fd16986a4f9b4ab55e7227c01525525954b7a55f8fec8707b82872523ef799028e1fa58b361b88fb8048558ea2c6e14c067a733c321a6c70216d01bc4df5914c7450a1b53d8f1bb912cf4c2d0fcf840720c76f088e4c0b3ef1af7160ebe98eda89b5c2034862841dab425ddc3d6ac2f6b117e3fab3cf48de405761e3ca395bad675bea17389d083bbaf6b6b5480ffe32ed0b0cd56290432371326471ea2da1271e69fa02cd7ebcf805c4f2a9bbb880f39e253dd6968c44e3cc66fceb3dd8b941b1e29378c91078cd43d41bda2d7eff901e646dd9f8e6246306aeebecfc4a5a3c71f4d5274aef39a87ba4f4584cef8eee5edb886963473fc60422713550a94f994573a186b3d20bde3bec1c4285d4bb31df4c391a39a01f562e3c47fd3d2693af33ef30ed9a912dfbe7ac708324fffb14f499c910aba0375cbb537d34a9c0f82261de64fe3bff516502531270d2a9ca7e49aeaf2178db0c60dd93858a902ddbbf10788a404277db4796bb62745fb959ee12eca4ee631ca1a65818e754dd46fccfab16eb13c8a9c5d9fc2c92207f26762e7dbbe26a206674ab5ab7cbb310402fa7c1543e3b42437068020cf9e9b36544e4bd79079088b1ff71b66ae4f040a15313a562ec936d053487b5d5389f856ef29bf3054a1d5e8db5743b6b8fd90beeff421693a33b0adcbed2c703811c1aff332fc2203ba0c5328c0cf3338d8da043d18dd82807509e941dcdf2383ca58704e5b014e921c3cdc96eb74eeb93e4a5d27fb2eec225f93a811eabdc5ee968204a9e5c1494db620c0d588f2bdcafc780589c40bb34d130d240fd387db7953195fe6136289918282d2202cefa4a827d43ea52f8491fb56a5cb83f504ca0d3464ae315f39ff56acfd63c0265cfca5da6ed25bc04441ccccf968ad0f76cb69dc49e0eb850c7deddd8c8e8a0e32bc75fe890ab9f62880ab84703032241565f8d7ff8a10456bc8ee7ff6022b8c07b97ff01d9ae571387d1653f747cb4011569c0d1a80d23386570e1806c80a3897d5bbcac7c049b2069da18b6050b12c49efbb7c130cd829157cf6f0db070f69225f829d48e84de5aded0e42aab9090743213ebce1e32fc867c28e1f880811cf24a0edc7be11c399736c639156c479813dd0565992301cd9f952adc66d2195f54d231e46b71b2171bc5212c95b563d758f287e22f4f67305d58596f3553f79e5030537d42d182eb787282d9f384aaeaf1fd4950282c377559ed752160514cc212925f6ca683c2fdd49a32452154260c95a5b5da4ed9be8fb0f611a85fd23277e3746b45220f7c05c0f0e15ca14866e1f0230f26d296131113cc4bac357748348aa31146edd7d453217a67fa67db9e7dc545ceca04ddfffc259141ede2ee9b5b189cec1a6f40c5c67552c8e37ec3e7e0532182d4c26002983344d452c54d76a249ce79dd2331464c078374eb7698c7954aabeafc57c6e959b7be7c666884e3c7b1ca750b4b62d41138090915962c0b0ba1972c10228953eca185972312e9ccd38b654389f6bb5b1672f7926f2daebfd6f0df6e7f253a1d7772b8fc9627747e9d3eda407eca1f688db9523f92ad76da8a8107df8c1327d9e879688f6f456df45192861400a4fb50551c63c85f70d39da0f60de86f546ca12d50bbca3cb97aa1a1d75efa9963f8567e5a0c259ade19797f22bd74a96e73af139c83ff9c630f333c5d6e0839ece547f5869889d5019ec770413cee6379dccbc485134d2d1fab4c422c76e83b7b2e5a17e18cbd30973d41c02df22c51e6c91b0584886e1c9fa55dbe2f8743491b436b24e7e934340a5e825171beb28e43370ae2a46aff10464f76beeac5303c8fecca791cd195ca804dd99e2d332ac9bfd55589b898b4899b8e47ea79bb194aeedc6f4c8537893a115fde23439bf574cae7384a1328fdf889109e77a688ffb02f0f90ca663d33d1dda87b2db154c10eb4da5056677686f637e2a7872c29dde1b4a56b72e45a96e5e1a9d6b0cb79bc86be166644df602537197375bb886c544ec78dbd61e1b692ca55b902c7f619eb7ba25c08721b29a0aa37a9a70cd023feedac286c82054e38aa0114bef24d17a14e3116d9d73f1dbad80bab29c3a44d9cdcdc1a37af156ce0710fd48232c1849c2dacb2645a7891d0d132e8e45856178e8efe1261f708b07204f7555c96361442ea19e17020f58b46923c20148e472978a62cf55d12a0db681fdb27208b63afd5669e6428f009e765a7c74abec7a531f6717773d27408dbec5f961050d44dc1e9132917115679aa7de4913a26d57016b04505f451fd440572feae46f6d42908f0feee90698ca7b76056224cbba999bc94122c9c1943f77cc4c337e11e53e94b09d2b6e22834763789805f7c9586f1d745a7e7e3a0e5ecbb04a985e9cda780543861fd963bb9c0e5c7d0c394e8b043bd10adb25916700773feab731157f25ca041e409fe10edb6a493001620179d397b83036e2c907ebdb7761bf643f4d2fbb109d5fd8b33caf6a91ab9db903ba514b500005ce0f239c2e4fe05208d3a4da951307a8c5fae3b4a5c3e17f524e572db7cd5d069d3d10bef0f12934f5f242e26da8d81c14709494721dfb7dca7af447ceba0bfa561beecc69cdb4ceca6c0cbce99deeb42c5113af62ab929bd22a67a4ff036a19402d659a67a14b6658eb0704200483f048fcc618b33e93232ffbdf302ef82dd1c34a18cd551b53bf9f1fab1c6d2acbc0f2b4d2ad4614787fe39a8a78c3774a1bebc5cac440c2ef76b91ddbbbd8ff38017009e1b4472533739dc4753545f3933e115f20de7aff6c830d08e8d4e7cb86731032b108194f4eedfedc48d47f5748be81ca643cfcbfc54724c45c7814232ffa560b0321e3b69d2df5b5fabec8d768beb8d7e2ad7f116f5a8f9203a57704c8b7ad4d00a80b4cfb6e792e99bea811baccabcff9a6b50ce0b2a3e80856f6d4ab2ead6f84a1414c9c36488165ad9ffe2986ca9947a28690f6d5b08a2fbb942ac8beeee50a3530a87923d4876af9f192b2f3ec967c82001aff2847a25d278ba8ccf5266d6b56a317d9e548dc8fc0574970b4a02d3c31bda68d9cb89f5cd968189be53c5f83188a4e0f08a67b89d0faaf741f082128c86ea5dc06de2120ec161819d943c6d08e6c3865e130955dba056034904144e4d95c8f830a91691c78f634790fe1806a6cc721517905aaaec056815df51839b000f6293fac979a2e057c8e38a2ed31dc2acfd809e36454a787019f0c86704bafa4fcabccaebfdb9dc9a7f8ebcbddf4cc59c2129113a6bd6af18f2b774a01c49ba5e7aa20da21fded0b51c52fb03c57fcdbc37cca225081ec8cd80c454ab090a6411531a87776642f0929071c7e32d99a3743237e4363f245b1755c79f875f7e38dd05d7619e6b45f8e1517d5a7fcd41226ec18fe6090f3d386369f3e71da3e6cb01fb2e884d18ca8582c0d71f8cebe6f35a0e138708c6943ca0252142ef40af09fdda7e98155f92c40e599c7a872c5cce016cffe78ea78c53147b63e04e4e0a6c8ef5ade57b2ad381b9d05edadec784a63ee1c73591b571f257c7ec99c27be68337eeb39dde0903bc69883c563c41b34366f8be997c565f1ce0b4dc81e8cd8b2d29bd7664d72b2f26a8cbdbaa7bec32e790fe76ba1356b10edaa1be767d24c037102f6f5e358b052f2c4d6ad195a47a4bbfeb1f5b2d6802a6e44d9965cf470b9e84d781ed48b2f31c2940fa4ae5731270db05453df8f0027c595e757a0d10d02cb699a412dbd307d662a997bc4a2bcc75909e6577a337f303b3e6341883f8121276e8a596146af4172f0cd363b973d13c0b08791ac8a3e9e84b2580647644402322bbcea428457ebd0952dc047d1d957f9e0bc060d41f0570bb5c46bdaa1c2e755d8960d9d593c5b5b9f02522a80ab3d3958f1f8cd85ffb3c37a0b1a9364c3c59bdadfa3948e38575dad1e9ec27aa89919320bbeffc10ff7cbe09cc38534ecf7f5d5284641a85eb7971a0ebb8523f8cb50366da949493e24f5cd30ddbdc5c372bfe53b7d56ee3b4e6dbb96c6f0960be3b77040194194d4529e880b80c5365ec46e31570d136cbf10f2970790ff334ac6268fed7701ab1115088c11cb3504de703a96b6ae52792eb2dcf83a506a8b26c9d77d569e02a2d24b503e478b2578685a989c92a7ae8d6ddcae2fb338cddbb12e1c1498e33ee1f398b2b36181a01a1c2db2e30a98043f21f39ad682e861cc8b1e8267abaafefb9c13917f960d51da320bd7b64b5068ce68c884ac5c8815b8d9cf6a5d99dccb66d3fc07bca95a918800d01dd1527d0fd77ffc6f076f33ecfe2ab9ad630c01ae1fce0561cc91362f19f7a412179bea3f8cfb6ec64582ec823b50166b3cc3b4cbf3d0ab997771c42fc166f1834184993f38b559bff9b568c793a033db5ff0b489fbef0fc47dd9e5a982fc623dd5547d9341858cd70fd182c59c447fbbde11b553145ebd24e60b757513873bf9685a141aa8ce3fb42e66f819fbbefef786783a2e3332b8ecbbd7a4477143df498bd02462e8b6a91a1d220e3abbfb51a2111f8691f33337882877c5504b8efd9e213e5a5881bfc16619d7d078cbaac381c9500ead813008767f38bb2590d86d8c3f4b873988036f3e85e0ee780ddf5e4c2dcaf6e985641821f80ae6b1286e0a1b1cbe3000647d332603e634441e1eee12a1c2c3168d2dc7de310ec42c252772c06bf93347a33babd1563a002e1ece587d07fed10942d6c4c4fa181e6e6148b54db3226f27faa7735e548ccd22c9482faba4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
