<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cddeac1fab14dd5ba30ed740603e4014911e496066798aafac581d14b930ea2bd881eb1b571a6cf795d16295efb7cba3042bd0a40949e91e46a4beb59b28e4623f1e42a62dd145516ef3ba84c2025a8c453f77598c95ee304a887ae7b1599e45d93ff34c2c155316bcebab9dbb598985fea9b4f7f5560891f2829529f9bb3de291927e5b4b32125417807ee79f518d0e746e6ee03137a8c9bbb0e30c6cf1a625e3f75ac8bb724995ab1e13ee2a58b2214f892651325e5e17f0cb6a01a8d0bc1fb8376a9c09805c5a946f2d4497bc463857b9ffca26fc63fa88d413277dd01f8795013acb86e3df9e0e4443bea42688aabd647c474928a804e88860b546e81e04b447174d9ccc4edb3350a45762bcf8306c608fb2983cf61aa683ed7baad928156d8135bfa583cec41492e318e269a366c3489e207190597f60e30d57e889a4374b2fb2e5600e3dec51849869457f63e59583f96860dc460a59f7148670979d3c1ce15bab41140edad22926364c03b98226ab2bd60bb0a3af67c718a43b344da6b1fea65041ec3ddcea9701a9fbc6ba013a28d9a8f2049715616c922cc137e85d2ce6093fc26f7e6276a20334954828a0850502877cb30d3cf3f3c8ae4a92ff8a29243a580dacdd2286dcc6d6e7ebfb4f95c8773514a18cfc7971bad7ea1813709cc27e0d131e2c1a6140259b1cd95b026181dd10686212e392632eb493bf10d4ec391384882ffe998eb54de681e90ddb34f4561fc6758614d00a4fa63caa96da307bf9cb524003f0af548b3f791ff4f4c245971bbb5293a8e1c34693a7e87bbb4011b50070b6b1ad579d07d78dbd80b9fb061232801fb306bf234ab5dc798b516cf0f2c9d87a87a86ffce46b099b422e6e329818e9939126bf485e984fc2faccdacd37592da3cfffcd5bc60d5f6f83b594049622f4823def092de029716c822c127fc9ba634309a7b17ea2b3daa3d9fd2a6f62793d0dab963375a10fd78a915afb946b580c3123ed29622ce77436e9caa1bf7ded4a1dc4dd06be0f957123d3747e46c5e1a1c3fafe79be00e8c8aacbc4b2d5d1c2b6cdfb4f621ba26c0b8573e4a0ad1116c5f9895d18eefcdd6bccf78459b725f22c78f43d40913e499452de2e73a927ecdc95b9c4f4aac8a7d7a0baeca170237b930b94cca4be754d71bf3d161dc5b38ba534982d5ebf05d3773487df2f5209c0ad426546e860e325f2bbddfb9eb96a41f904fa92610f1b54c1a11a97e39b97282d3757035740a970edc72f97ea17bc79847efc95e3ef2ac8fbcb520be2bd533e79a8a3f608452a34b02c31e30b664618b3508f31678caf187d96d4760f5e95f8bb432e27f8c7b7bd6b7b3a496f1abec693345a6d00fd1f43dfe55f506816c2dcdae9653fe5cab3e8f38652a843e79c8b4c36d87b936b3f8353bea28bb6d3eccd363f3bf17712a9b674a89c5579368d15377ddbe72992a43a89c14bce36ca824e6a559f9c2ee5a1c25e4dcfd32eeb860d2ed91f69718368a592d9917d6ed97277b31e5cb2c712edb3c1f1459fbc912c89905a5b0c115a8f09e44a35cce8583d385fd1c8e0624262c216f75d5a3effcb755ce49cd2b38b69ba9fde260b97e334204207781b018b139174cfca30a7911ed0fcbeebc45302434adb28c2926defe26018f5c7b9ca7b00c33b031b12856de2f0c47dd58530860162d7b65cd238ed9ba0ef27b15b3c0b5020d18eae891087418da282206f282fa842db44e65c0bdcca61ba59e4467649fe8e82090db71280cc6d49f46d4a289582925523faaf4a4b1a81da1a5ee774a0e84c1bd5c34d80aa9403bc2777a2dcfb557cfae67943d894c12f5cabf20fc13297cb2cff606251ea7832c0be95c653adc3a8eeaea46bf0256203cf7cdb501bdb920dd23a1df694d59ac71f0b8408a416edf8a48df46b9ff15e36f217a92f3a913ceec370ac14d3df26d416ae90aa434bd6904a39e99d36bbb02ccd691d9c9acf247bc0df0164ff60cba56062541f6a21a80fdb70037ef7a1b43622c368a48516e9ec0e000fd876670d9e3dfb30950d6deb45f7f5c81e452be184957c66fdc3054d7792c6293caf5c4e2f0faa96af0c1ab98d8e14d7bdccad99aacb31a88ef4eaf52d288f29bca66ecbab0e69ffd485b8c0feb81ffa9510fb4463e43c7f03afe93f2ae9fa6947a9c15d6680eb798385c910e61717136861612da1e07c8448d31b261c099b269d2839462bb5848935c73ca2730e350ab52e1b5fe129d73935f329200ef09b4cdab912247b5990825c94cb3962d54d7fe92616ef55cf2e2d8f610cec8adfc50417a2bb92f3c05292a4e756164e1da6ea337cf6e177abfd0b2ce18f7585f98a7f956a6ec74c5d98a0c58c14e88747821e3942fae56bc1a8d7c119c7d06d19926e47c57539a1c7e77745323e6d3e81967c506a2b32c25373438d6b0fae1e3acb00fd151935273558fcfbddfe5aee7fbed5dea0017910627c5a7f978fc33258a39a589140e6abb666904d16b4f393034f1ae1f84ea199e6303eef7152a2c9909768f73c17b7efc10481175125b655fc810b22455d46bb14ab479578dfd6ce7affdedd2d5b5b55a67b31ce261ff63998288a9a330e1123b520b0893cfdc74ed60729eafce08e1bf45d1a18aac2cf13aa8748892fb7a0edbdd493124494d244a073bf7d426de67874f2d12334455ace961b1edadb0239a07c7a3ec81ed74002f0e161bec179aee12568a4bc5a68ab3637b26c465fa1a66ded472bb55fcb4bfc2c881833ce05d03d2aa2d05409e45f3989b91fa58ddd43ae5c68980f50d09ac1d9c040c94b1ab3410c5fbe1ac53902b85e2d5b12318fc9e380e3fce17c4e1a23d75c2dec2328fb6dd801b465ea439b3d614aa2fe229977d05f979d251728f2d7cdf5ed8f2866adb0b37a3f6b6da5766a370baa8fe6c3dd0b92281a7d17a60341a06f0da991f9ff4a6115f4d437b86c50abb23fe09dd8da1db610202cb8ad19575026d31687969ec863328ee7bc02166a11b506997e832e755db0bc7a371d236c0357d9cd5c79a7d0fd95a68b1ddc2adb228b95d8042ba2a49afe50abd83cb18ea37c32bd4efc338e77d84490696ccb269b1fea97f1b060576b02b99695ed106da2fffc4a5c9ef18e63db2e3ef123619ca96728707568dc7115eabdfda9ec129506940e796b687860c71f0f801320eff81d0263a3a232728e3215271582ef7d492410cb00f7b2a67d3a62bee56b9f32206ebc5ce0193bcb212b3a06f234b4fcb506d291707fa1b2997d0033eaa0f83ca1dd5b2aa5e7bf1cf03b722553af81ba789f34e443cd8217368c9a3e9b7a213e5e586b3d1c5b023c6a4e1fd3936ca330604a440d90e7fde81e0ffb368d3e25806f79b53535a60754a12a25ab2fb33001e8655109a2be38ce891a162fcfcf2de435de68fa0b8ee2cc729325c3fd695a70beceb15b2f3ecc46aceff49d001c2ae741a065bda78daebe49dc18bcbe84e07c7cee47c9595e614686306e634c1b3f9d36dac6386099c05728873ff17ef844dc5d1364f31eb9f1b15c1608d67c731ea12e4effb300f3553679c48556edcc443e2ff87da67532373b51a8cf7d1e95248194392842ca157640d86a2b98b9a35bf9d3cc361572c05b9a694a25541545b99968465062c4c30c8bf8e366af47a07d30f6e3d5b3204787fc9301d1d1b6e246f5bdf1e51d56b23eb8a90b6ece420303041ba026257198c3cb9517e5b369891051ac780b124f1189ee2b7a803684413e79f6ee86c39da3ab444905b6ab7836cb4e2e2c72d705df910fd4706dc6f99223376f93d78da00cebb932366b1b09b0fdffbb83765e001374d37aa5c791541f8c54f3e9cb3c47f8924a639185d308be9df33a26224c9e7c151051451349b3316dd3dc626c68987f9912b03fa1125bdfdd16492917f63087db60c218aa7d53e842d8b8c95405507b2c8b3369707adf50f09d231e696c635456d5781755dbcd17b60cd1058ab66c91dc1631e6658979f06ae7675f2d1b73e49cef5ef976095789c7e4b5724ccabc1afe924ff83ee2dc5c6dbdf8532ea947f2d0424e1107cb955e06659e6d775f38f58c62ae33483df14819b5669da84ca082880a023d6ef1caffa1f0b03a004522b8e300d57727648927f67e1643957c81e46a640225474d769ffa62a857c3391735e0a914cac3fe673b9ca3645ef29e67b20509d0ff2c1d77ecafb6c52c4fe3c8e5b23e3c6d0c24dfd210c8b3575b7ad448e48ec19c48a36116639e74ed4c47f20a372a44d29b916b28554c18d9858bf992411e6a148b1193ba9934322ff580d9e094ab4fbc78b9b6ec39d07b8248aed7fbe3f328ada692dd6fb7195cf530de53c2ae6e3a358582e71d16f29ef4e7afb228ac849f77fa46ad2c2ec7391d28bf2cebbc1384685120b3d92b0bd4a3f3e4fc202de416f16d465dd8313936c91b231e8eb320e6ee5864ef027aaf7f2acd2b1e95f7071f4322bcac2ca284c780308abc624f04e3bb4a14ee1078d6aaf02725c8a8aa515e5661249dd66b5af73f1ee21da9703c5a13c403ed20555862e298ed56d80b9a5eb7a1dd1428b3fd07428e550cf1e7972c3aec1a25e81142087a7b5fb50e0edb35909aa88a102a807614fcea490bd447f7db67152397053797bf543438b5a7957f1b11a45340686d2495662ef60465349e36cd611fe5f7d5bc294b381f4648009faa92b5f7a5f185de242cc33070fd8e59956ebcf241d40663a508863c7bf23e43424b87b903a23d1e219e4c85d9dc63997b8196d8ab18adadb5443b7d4c1fe7363e4581275aa8f77a6c485d667ba3cadfac795dadae9488a35763b5f73f6d1aedd64a8b4c4dbadcf6dcaa68752f89154d4d43dcfb054f3addd42ceb33b6a2284d2c537cc6fb11dd9d67002152211ff9abbebac4b36014e2b4a57769be385789b2fd90305c1443d7aca1cccf50d552595e5df4c4f3f24d65f01a036976f4dc3ac2cdac7ea31c5fb4ed5273b6b867e05ad003dcc7b4e56b41f911baa815b3000104181b6929b94f119447a6df10bb372dad128360de017ad9cf0bdc02da86549c7a3f299afee45473f1be8649b6c1c1646933cbe1062772c8a5877e3579e9f2e1b5b171cecf76059b7b6e095a42e06b248576d7aebf955a3770c7cd0dafe6464cc24c73b268f918a9f0220333d3b9acb0d09b7d9c03f93b899bc6b08f3912274e3c76ee3ccbe01d48fd7bb6bd9d9f263db17ad32cbbdecbf2a738f689c56e84dff621e86baecc568f4f6265ab9b4c7d729014debadd83494ef7f1a69c7c1d61af4109af585eb6318af2bc1a4ef914e00e682d190d7d746c9a7acee2880ec83c5248367e40e6a5f93211c200054b1aef4ee315966c44a563e3767cdb26aa17fb99bb2842281c7a9a1d4b4d6c9240173b93b0b31e4fc4f3671b3206e1ee08041510c1d858abb51083bfd240145d505fbd80fd022d2ec068d1035608a1aaebcbc57097a608fea28ff0da87ba2354a32c3f425c499954bf66f97458ad5d31c51cc3cc8c69bfaf7ddf20ec9b44d03d73fffe38ad3a537246fa67ae6f19e6585c5ee5a9250995d4fdea8e9442d5f9ec53dd2c80b334a0b78c44eab877dbf0ec65ebb012b28a251c77de5d959e7f873b97391de2616cd88257e3e2d57af7b3913176dd9e523b6bc7ab904d24354b08b6c6397744841e70989f8c1ef7e662b2feebb895677f3eee5658328dafc5e8ff0e45abb152606ad3bc7111ec3247c2d233d2a01bdf499818484e259d297e8b462eb5aa0bfef671cccd0300b580a1641018a8e5ed2e0402e55787a004b01199825dfb9de92355aa62f29649fa49e25c4b8948c1833bba6b5466444de5bf80a2b4b6bceebf3a2fe4ea326a1ab415af362edae60dc7ca1f91671d287a400302591d51b83c4ff9d1472261e9ad26ee6be4359129f0258f5a1eb42745015c827b9fb354349055166f3c9a73f57333ef33a473b7ce75e61e2fa0f5dbe54131e63a8f0edd94fd78a9ca83c33cfcc9376558b2289b72cad00397e03246efe694433d2c816c22dcfd3b6637b57e442a64464ee48b916ecf682727ce77121ea34e8d938ec9e94ce6c775ba666f295387f422fa39093c1cc0fa05990fbc3c2ecc1e083ae61fccdd26fba50159929fff48eb414122c67e4c427fa1d504814e432730ac99f40cd1a73047cbaa28d1a694f1ac18690247f13353f0ed092ebd7a321389df9246c6ca1329d531559b0eca06e8b2419106d601b3ebacf07caddb6312021f573ad48abf76bd96219238da2bf839aab886561c34d11e46bae5f8e916c969db074ad2c521ebd02ebb6c479e519e7c8edb5cdc341def340244f722b4b18be76044c4c193c65cfa00122bee11fbd7ac2efa916de4c8724d7f156e97bd6cf8994a144251b480f680355f02a2d60a9793811dc471ccf38ac1cc6c1f28eedfc2eca940ea1632b665e1ec8c2f8a47653955cfe9125d1a0399727b2635c44a22ef972acd04e2f6fd7ba178d480b09a018119495432d8b9a303d02adf292dbddaa3fa4fbd638ef39416bb7b3e793b90bf923df0c0bdd33acebf5c6676d37c4311c8b8bd8359be3e46c583d294f4dfdc16841027dbdb902a27f9510b5490243999d880cd435b2ece74b04a71484cfbabcd4a58c150bc8d8619a06967bd288bace4f190cb7f2098cf7fdd4b24599582a5662604b87eef802204286abedd846effcf08e9a3c689a742e30e2652a5406aafc07767e3ddc1575405717f760a023f2ec93cf59b24fbc37d9b5419d59a1ad18779d33ce3746d4f083396abff75d00c823ed96310e9c605e2bd3ff378e4d14a5ffc09eea7a2d98d759e654dee590f32ba5f1d7c94b57ff68a5fa22cfd61cfdd8b16f331edeac4c2c79d8dc3ca7a3d5e43e2c7e9095d5fe6663453ddb70410d9779d668d71df883e75288a0072adbfbaaa41e7830c93cbd567880c592957a1b3a0995a8386f8a50d83da156d01d2fb3b9f5f42d173f82975d6ad4e7b6d239dbd1b6db68268807bbe5754b47af6ccb442dd26158b150a83e73fb6816b756586b766f29e47fae0a3d7b3070d657c6e8fac4881e8f86bc4fac73b68b25c9d2c50801e5935223daefa273e9d6b6ea2a9cd7eece2d382a29958fbcc60e9f9a40aac4ef1bb08fb47221ef5153e8adfdb6373e9084713a39c0503b615216c743f07d5c61ee1b59d515bc0453619a4b4bf35850d55601323a3c9af16683cbfce56317a1897fdeb6922f42ac24745128fce5cb047203c8201a8047ca698406bc224e0c3be30b23d5eb8026550f4703035ef042414b7c1d4fccf0740eec53af03771fa73330b4f3ff45892a6357f36b7131f8562a60d30365d68461c7cda39a54ef1f67f5501e7855c8d509220b53798d2c9e38856aa271bf8e915bc503a5ffd75bbea6e43f2ba9dbdea370b3c8e4a7cd26d53fe0983dd0e9ec2dcdca66389ae79bd3ecea1149e978aebc186c804b55d66cf1d35efb3d5e3e35edd77e05f7e636f04ec8043315b51af59083b347bc540e73d1fff605568b56554f860f378e0f26f381a92cdb6df8378103ecff6e396323e452bbe13a766c23b5afbc070434b72d5b9f17458dbbc629822c6e1cc82da44c2b0b3f86d57a6e1aa28a52a11d0e8c0e4451c3cf83abc88af7d862460edf37b716563ac608257edb661fea4828e848ea6bf85fc86a5f001ac9feb7b304a1480e3db98fff38f6d56515cc56f76b4f12b5312a6e2e45da6a706ab2b4c5bc008dbb4e5986ae3e5980e14e9014498324ed553c778a6183959e0882cf339595204be54e50e4107070fb56fe50d27af58eceaa35d08f0c4b78693b783b44ba838600307fadebf36f27436272382d6a1928a9bfd3d497407235da267b6a29f6886241418b7d1c34c14231a4cccadfa406ae42ba5fe1623fb5c800c2b6fd4171c6bb665361714fdb6e1256fb5f1589523b25b4caa288398cc0339ba5921a8a12c2a42588d9b5750d79418ccbfd5fa17aaebf0a33d9f66e8058dece10f0e64f86e301b072e4f1d89baf1c5ebfd656a44b0c1d9f8ca89c27279dd5d0f0cb0bef06afd57bd6040f143a8cade64f37b07d57ac42fea51cf0ee67c3b18d7237bdffadf7a37f8d66e7757106905fd4249787521ccc589aa6378a4f863f8eb2eaec22d6c6c408a71da4c8ead39137b684ca8bc408fde36643fd2192e02cc113670562e6e9cfc811ba58748a36701cd1b5e250564ff5cc2cc36f55199f0fc7d508d2a955cc40434eea03240353c436ad011ace6e290ffc8c77ad0a498deb8e4fcbc1beb165235f3a9ad0149ba0467086447d8400d2bf789244b48b4c42d3ad136ebc7309b13cd8eafd49143ba6d2e50bc6f29cbf595339c740e8fac26c7ec875c9258e0f3328ffac2133837d97bbb52961793fcaa4d61fb35f8c3faeee5a05abf8ff338be5a080718cf2d3eb270f27d813af730673def5f86933a4ad8b97bde15b2daffa1edf35bac67bd1d9db0c1c9622e90b9c0459882675365a9d23fef51e26bbc4a9a0f18253eff1c51b116677a4baf56f1b8b2c223be9a055fd909116e47f9e12214b9ba7882c8ad52adbf06b50b4e32b9e1b996cb91a6dd67f83097b3de102d0c2058641a06bbdec7dace2f9735330895be0f56bb6b486e156627f4e239ba05b02aa5f2391037710102a872c43a9f646bac68a06adf8cd52022763d297bcde41a6b8585e489fd0fc00acf91ea9e600856d688a549862325392b110228230d21dd13b2b7374fb2b6e8ca6b3357091ea5d0b0086601408d30c1a86d7a85620c1dfdfbeea7b18ef50eda2db533762f64a62cad2f8b5f797a65db50bcfc54c4d0a70ae2e1094fe13e46d7053111f1cd137aec6a06a3bc44dced8bb683e704cd7c13bc54ea0f40319d6d8305c5b46248cd62a01077939991d04fb15ccbdfcb04762795179690e84003a09d81d271412d4863796547f4124ed622ed74eb09b5ee01f7ddf6455748817385f3dc6b75093b87642980a9db30b222fe843ee737b7e4814ff1ecaecdd0ff8c617a9f6aee8f46d303436bb5b89ed9c66a89cf6b4d99b55ba0a36d3265106af597116f0d338bbb714ba40ca8abb229446972c5fe9daabeafbe4dd2f252dc34a7ceae8ba6453dc702688a6a15b3e18656e01614beacd84eccfa2c010bac90d788e87f0db4bded1dfb5cb6f101bd1f8472a7abf04506b6129c2ca61e7f748a09b843b0747c7bdf3ffd3e18138a2518eda1ba11f5bf4955742d97731dd96ccd660710b3d56cbeae72e0689f77c325ff5fad949c048205ddfb33f2e2045772abc22ccd29bc2de5ae8b9d8c89a9ca9e411d7dd72b1edae0082077e67ad8db06841c273bf64167731c97673067e71a8484b818dd25d491d00c70c6cc318bc4ba1d2a2e6e3ecff54a6be77a97a5d55648a38e86fef9873efd428b8afff694c8ca7910094092155049a2473fbc2bc38651fa0f5cf46353f38d31f9ff84678df802062c19e14f3544ea1e1540ced4688ec32c9f032b8030e658544f391d50af2becd009d5fe313562a061dcbaf1526ed366e69ae0ed0a83c5e53d1ddab871734e8ef597cddf959d99eb3f5f2109852385b095e8406f55581bae0ff4a998618e480e2d12508bb870157f381f5fb5f82fb4262475173bc3cf4df366e8c01ce2475726628eb3d9ed25e1879abc96b9a0b8d81fccaeee702f7fa75bfa3fc4960c090934a79b160b76fa678b23d5b3842ae041d86c7d4b6c39179348b39e0c3ddcaeb9455d064f3f1899ed46ba9b5685761b45f216146fcda3cefc2d5e7ac2d284d888ffb30d48139313bb0e3e25d2cff14e1aa20ae9e0e7869d9034f22263b8254272cc5a3bee436dfbda265501f5e714b30f2bbac06163aa6ed234a99aac5fca0a672b4a0b5c63b3d425ebe5dd2972b3222f4a46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
