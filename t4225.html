<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cee24c435d41a73dcf0c232ac93b85f7f943899aca89370ea5316ce50a163475e21dad697eeca210abaaf4cc275aa8165868cbf514ed61e709e3dad5b1c1c78642b4cb334c0b7d1d66f2d1e61f33bb4f720b6f06d01db441334d8a9f63fb995873865729098a297664f282bc15cbe6d344f1515a3e60e96d7f7793683f4347ed417161140c46bfd5ec37c8f3d87103828be79e646cbcf11034a60a776b914a2eebff4322848e1300a65a9ce1fa704b903f28f409d1a4995a98e90a04efa4361dd73488dff6ee786dcc4ec060aaad37135e5c6178b4fdae7904de8e61609a1cd216a144d0e2e7a2d135761339614ab824d4879b65c5cf2a6e3142070af2bcd59c4d7960486736831181e55de4c1fb8c65389fdd8c9e4ced42a0cbe0711d86ed36995e04543c0d1f0929274cd11a9908818d0f6352eb9c097988761e7abd757caf177cd1a0e2993b9f86fe153e9e697aea91e28570381f57aa0c8378c9b88ea7a3c48b697f3f46dbb9a309c3c0e4e886be0931dbc805baabb332f573f8e2f48843fdf8784033d4bfad018b60d0987bcfd7005f8ef6c356036099e90d3768fcb78175a480c9bc1d20f4ca06c45a5345966c2c60ba8dcda0c130d60e3d8752b7020656ee9a4d1b4723a84369f2196ac19759a6da42f4e5caffb8d6fb451af95305e04588b9bacc80118151ac988ffdea2230213cb88dc18530374f1e1e6ba46b5f6edbf8ccc3acb3534befdda7660fba6b1bfab1bb1646c3ba1f9285673e0b2eb8f730b46507cf8e1a65e9bafc2b45275d72c23a4e7dab5c19d106aab4d6ee222ec56a5c8a2a3e6f11a841362d3080d03d6314c80dfe4b8bf5543dc497e73bf644c60a8da72abadddb0fa4e1fe05ecc7b54b7fdb8ae62123fa1736764925b21b21ed760d8121f66e6dd2497b35983860d701af3b1f7b3df7b2d6249ae979c9fa2c534299204b79b0703a0bae16d2ced9b63f38a86f41a87c165a9b051ef0e85c63dd62b2a07a88f1659a3cdfb727198f09df253195b33d10e0c287f3d93e826734ff147d0e2f68acc8fd4971835621d0008b1eb8f729ddd182ba1bb5ef098899f05f2437d0e9ee369e70826df2168a0553789439a30e23b8b67fbc21954a128d6e4cfc2b86becdf999d9ecb860592fccd995cfd9e17009e9081bd5ab89b5d8afa6e57eb58bd9f1bf198e110fd2601e0835b70b73cf76df6dae98a5068e13c8e6ea7975296aeed6d8bf46a3bab817fee57c5e4ca455962a0e4de53ce0e303bf3a77045082b144f541f6008c87d055e4eacbc6921d455d84b8ef9d28521d0d753c44e64d7fc861f6296177d1513cbd4bda36ce1cd453d49b68d2c2931f5f1d8cf23ec644c3576698026cb33ec115c4b73d6564068e8b5c61e3110b9a0d934c1aa41ca23d89e776cb00d555ed7d7a82285c885a1a5ab866df92cec8dd5e45495fd0ef7173942a9c307e5bbc28f19dccdeb38d53184b06717d7c3b153c5b82683a2370d3013de6fd1e6dd6a659889d2a69fd8275d7fc82162416c7670acf42925e52f14088b7ac65a1e30aaa7de6ea73abd50ec94768be421c66db2048f2abafc5cee98a1af224c7f4e3eb60627ba8c524b676e85f2eaaf96a6eba472bbeb2fff0fbd405590aca16ce8a5e9c6a2d7abe7b2fbe699be766df1d23b88037035ea8a049d90d72ba3e0d7b055e3f9480cfb36361052839eecdde9eeb5f45327cf4d23695e0e3a744ccb137a27a67e39bd3618edc2190784488edff29f6729eb5a9ac4313ca8ef464e3b9533b63e4e8d8a282124968d55840c67befb8ec5f825d88d49ea20e6adbf957f4cd23b4bbb303d63e29f1312eef58540f73c9f95324f795d19f7b24ba2d5476dba14869393f37c183c27592b5e570474e03a975c23477b649fd998e9c4c30d455ab45f50b33edf1478eee5de0a9a3e47411d527b2fdab8c6e0a315f743bece7cb2e91616649be4001b107593a35232b1e7b383200a9171ff21b711bde1dd41e214ff2ced2d1b0790ffc30ae8389ef61c9ff0b7deb84510429aac50a661036913f5b81c2275d1846e8ff87f76fb5dafe294c824dbb0b0d1174e256fc4c6b6d08d9b3cba3821b281588a84e3d7fe617d8bed1552f9c38496797625e4247da946a136360e4dbf0ac1435b201c6966c7598d863c4104de0d1b98fea12f08a67b6678dec93d7859f20f95feb2448341259e149920e7193f411de7c8504296ca4a17acdc53776a17caecc7ff4701f8a7dc9e9368990e897efdcca3aedd24f354f228eb3e497e169c0ea4e51215c5b6da836d8fea00089b30444d4c964670549373ff521ecbf87e1d9755aa738b99c50c22fa09bff7d6c1b3c76484e90c69d577edb588bc9082c35abf4084d78d0821901d949d323d3d459fa13dde677f9911822841546eb1183238fe2a69c213156b439bf8b598d5e37b34b806fe97782e069486155cee264f61e4b4730ff69cf372b3b27fba549275d8ef435b7d7672cfbcc9d2d0690fa236ffaaff6bdd38ba60de470f28b797c068df516a772854c67cb34e2a384e1794bda82a8a09a90844f8043d6491116a4430c39bf85b64baad45c9d2f0d214e7facecdeab79536dcd84c830d6a8f40cdb4141f3cc29b1b702b8c5305c78f148c454665650b96f009f0ddd662ba99927ad38f594c30593e6f4f27e15ba62396968632b2d11f0c6382763114b9e9b6016af990bf2797bc33b3a98164e9d89083a99f9ccd636b62a2985c193bfeef981bba7be2a180ddd265bd81586b14dcace3f657a314d11f9a51cb8bf8bebfb4be7cb3fb9eeee1e91d15ad9979f07502229d1ae91f118261f11377ed337d47c2e198b2b2c7fa622991b92f582bb8eecc0ad06847cba0e6acc2928529d5161d6c89cd386e0ab4f6c42e9df1723bbd7a8302ca8cf772c723c3cb5b22700a6b1b026699edc985974df9b921c4ab4a8ddb7aa598a157ac67851d8f14d29d29fb67992e76bc219604b664b4f140aafaae148114d0a96b74b9c333b3c9522b7eb33bcdb048b2e9888f6100bf4787ff649d0cec4041b49a239397cff26555be14e455ed44e3322c4f4b156d24170d17932a799bf02114d1e1532f905258b2f7d3c141924b3a612d8901263a18e4043a70b467fbfd04c79ffece7f2ad9c16bb84b3532dbeb99291343334c7b5350cecc16ff3c231eeb5b58b325b0cf54b4aa9d3e3a4e6f2a9b3e1d8df26822b01712629295674557844f1af48ac8c3dcef7adaff67d23987ddf5681b1984f768986a3f5f86b8e05e9945d6b0c609a8a55db35c4171f38b56bd606dbd5fab21b91a4da09741f73baf684762ddc3f6898c05572bcbbc907174f41ef71bed8d79fcfbc895bea2df2e74f8a2e3d104f8224d272c4ede62e3085a7a9ad1f6e51f4de8f0aa5a7d07c0ad2bb021cd59baf786ede93c7684ec592be3eebd89318c5fe072bd0d4d1a8ecb3528ba8782826688e6f80e70c795fe5daff116f34029de88f59c55039dcf279d1ea671d71c255b9c68de51773a706268bca0042b52774c717c53478dc89fea1b615667ede3ab6e58d7f1d60851ad3838003a7a25965a3a1bcf8fb59187ec490e7bd5cc8ec8937af87a6ca10d76c112be31cbe6cb7ff1555bd6d48293d8fae0655d926fa2cbd1da107b1cf047de725a88cfebd66e497b37537b85998264e38233635bbb8add997ec2d5c97cd9f6cd6d93366036c5da5f5b624289b4fe1e482a0863f6635942cac7f4c16dd276a1a627ac5b46c74a5315e242adcb932bf87b20cf8b7402caeb81774fb81936562b8962a6f097b50e49839caaa406d3dbd8f9e156f3b2bd517850e9045eee9a784119a73a3d8e00afe06d1a125308149539f3da679b9a16cda7138876a24c088a6bf697b6c381956e723515dba7d4de3f7914b08123b436fffb4d009996996019005fd905dc4402b26edd73c695773fcf62ff88fc31e625dde3d0c46e0e35a6cd464d3bdd8e05e38afdee6569218ce89e1e3565b83e2aedb91bae03272c1f6c207e5422461e487638c5b516442d15bc7a8d1e8e9e31a1a4ebeb9219d2e513fad91f6ed99482ffaf95d5c118ee77170c4beca194a9328b49808bee1382e3d97d685aca3a511c911d7c6f61fb40a87a8ce5c70b829c932bc1e5fd041a7aeb4669d02751ecf2c4d3ae5723c5d60398e82a1ab1a4edc89afa8eeb01a617eb5dc10a6900fa69b43962d628e2a4057daee7af10bae44f15f84ec4d6662b828196695401838a34998563a20fe4e8ecf468e083d52864390549e0f519460a25d79a29ba1f7a93f071ef60622cccb70e6bde2c41582c10f57c72ba41485fe90fd526b86353b23a0fae25a4a91facba0273155a111f8fa5f63a8f672f5b721ae608fb658728e4b505f2985fbaf9c7e581e867a4d3e1a8b29f4946b54de27801c4dd25667cc802830b97d3e9bdbbe6ad9abd1b7c01bbfb4d0ec42a86c6dae7de65c0acb4fbd36d5b0cae26254567ded88ae28003507d7f6d22b5be078540aa1ae037ce3f9c0bf2257e7240e7993ce2dffbf1e672bc6bf5a1ee463c65a38a4f18f770406d109870001703f800251df7aa35cc28983a105940f33604decc4ea496d2ccfcd8441d8bbdb25eb35635c3a7682116b738dae2b2e0cdcb0fa6571639b9a0b908aa1e40ba8de36438972244d625816f6c5ebe195870936d9847b47cc9c3bd85d5d8f1e674aee15d66d3bd1e2a59cce0e52e9ea30534fd627ed0cfde6540cddc1277064eb15f3661bd1f298b6e1bf37729ddcacb3de0e3ee7d090036b5de64a3afdc2a987b3e4ee5f36bf864c400a20991ef075598bea585043ea11e8b193e3fcc83cdb26620d0753ee214ff1d857c8180d44ef45b3353149cacb5edacc7bf2aa7a005b8edf2e7fa4c06df79a041bd460bc7cffea26e285369d21067ed178082c220fc98095e627f66e781173db3af620967fe2cf8311ad371a610d82b6bfb295904cc8d0312b5e483c12b7ba3b7ee4cd221278b1280a7208ef05697d05f88ec1ee81f152bda671bfdc7d251964db5e757692055eac5180ddc9e9a5ff09b7bcf64827e55b2e3cf5b054ca0cd0f71958ecfb92cf61a01a3a3a6083985db632bd8ef8a967dd546a8181468c2bde74a272296235896abd1917a815beca6d8cdcf409ea88b4daba7591744053ab3d6b1d7298e939cc7698d9562a2569cd15030c08eceece91ccc56d05672ffb135138b2fd554a8f6bc58758fabda5a16b13ae52bd7045cdcbf91ab22513bf495c3234851ccca5657cbc8097eed99cf54526fad61f25d7bfd266074f90bb871a987716e4e74075b40d9929b448321e20375c4da9247543c3dbba6c70904359df3eb8965d4c184f65b4e6b7a8179210a82ccf01cc261f6ae84ee22cefc64991d9f8aade9a16938c7e7a356667234ab7182658861f3c84fd7ff9a57d59753550b4278ed2d349262ea505d0319644498c8ca8bbc6e01b0ea3595d26b5d4172c9b1b95caf3f4e835a3c933b133751415ab2f76d3824a47d99cff0e65e88dc0b3cb095b959745210e9b8bc3891a297e36388204cb60ccbfbd3b1e7ba8459e053e795068f58fbe590041ddcc7e65e4656c356529c5a03f16a710a5247d9408b605caf5027a5171d12519b2f787bbd1775814a5a8575a97e21d5b9d548d5d59ea6e919ff89e75e601261637a729667bb8a1c2210f49fda5a52a6501a6f4485c45ff107110634b1533c654480276942822433172c1269be5c82a57369df479644bf325cc31bac33d8490ebf7d8b496ea11272433ee019d8e05894a2bcde6ea5d19e492974678b7622158a21726ad4eeb7feb5048192c1ab0ae7caaaa44ee864bc7df431687e72a8b29c5a7865c33d63625b138dac38689582e1e88f525e1ac4425fe2e015432d8770dd7c3374cea3f186895a9b84bf6f23037cdc28ba8d0ec52705bb24a47f881a9b174e69d0bb6e472625ee99191e4b0c2b7346f83b085fb44f2c3e03884feccf62813e69822dcc87896e8d201529af801cd597005a92f4a04589620b59e3d37d17aeeb9df3c3705e3c60624663fdc586a37f436db1b209eb0dcb4ef0b4b378519d8bcd9227da32ad534a7915d89b2ef3e9f02540d64d932a1acfe4ea39c7ab0b24666991489c121a12d0aecb3ade805309487540fa0f0833f50dcfa629d057d9f47926f50eecd3ffe568f7227f8a7359dcd8d7aa457b5eb58ba22c771c03bbb799f84448664ee21695672b3280e145b932aed7a3449e697a1509d6c3860cfb03395761d1f38396f36ac0a84861d4bb052e412df90d8f3ba6e331382da6fae6542a653742406c00abd59e9028af79fcfcf49ef752818f00cdd9bd1fea1d7ba8bc6d1178daff197c64ebd6a0e11f1f1e6d111e669c5c3b7e4c55a43e18de874ecfd8acdfd277a22f0cd4e38efb8ad4723bc1a015829c33b62b31d413b98cf64f8d00faf1e18c119c6db39d7d3eebde4b61af915092582e427181c18090f3c968745f0510e46f303b16fae3c0557ba11838437c289dae96889a2c70857a4c5a4dc0c6dc1d90f9dc11256cd0f10473ffeb9089dbddbf12821562a6c4a05917626a77e6a17b8e9bb464d9f1babef6ae2fa7c83c40069f55a10b9d3b2aecf62c78068fb200b0ce372b0227e817202735d2f8b208e8e7ca0ee6583ce863aef593476938a875370040fa263f03d430c7d8c039eca9b8f7a0c2737abd44dd241bfff01a27dda565f272ae546882536e2767ef563f93bc8cf446562149710911079b1a5b08c1293f0f7d4a66bc9de0b43a38b0929731305a630e8f0aceeaa6b01fb4b39f945f1ad090fd6e77988f44fa2334aac4016387b0509b44e9553eb0d6b4c428c08f0940d22b8a88bc25d1843e23009afb61bf8acc76209f420d4f09eab308fbf1a94bace3dc94d0950a7841970894466cc6f5c71ba796409496fbbd2427f6d68310d206e385fce6b585f59f6097c4692b571e4711bf54d765c7c12e1af2f82b26947dcfed824b54cdb1b6567aee3cbcd48bc7bf9ed0556949ed8ec3f20d303de28e9b3f1cd2b71d1b30d6c8fd52d41515100650e3e03243ead47e302c828aebe095c1fcf0c58267764f6336980c6784ad129dd9f4127f6ff69372b182d8ca4789f4fd0e495f6fa381478f4efbf7dd474171227c91be5a5088b117587bb0c43789f27893ac242ae69a59f2564de2b33b34ec8f3d50a35fb5c576107aaca1773ff41b26a1d0b654340e978acaa841b63c0a0f90929d511c6beeb199b239d5d43a8f709d3daabfb653cd817789c0677d1e0e6141a6258b30308e9b102400d2a7e987c6b5d00058d5f0b7ac4088a6682ca064280651bd9d8abfc76988826385bb68e95b69f1acf22e68d2ca21145e8038ff72ecbdcdefbc5a05aabb59dec912beefd41c73721a7b35490073c4da08db006488c8d3aaa10c15e09f2de98eff2ee1c9d0f6bc401fb5a4f79316584dbb54ab47558db6752fe8bddbbfa37ab82d5689be0cc88ee7d0109a2fc343cfc3ca393593f0f5c63f2e524cebfdbe6a3034a3edbc556f8c0d1e1e14e8dc2c26cb8953997c8af8b9f95066ebea16b3bbd5d229e116810dcfd47b952d5bfe96c42e470a709297f174255425b9048848e639ef6ef2e1393728edf3274e171abfc7b508c7deb9668cd0d7fcb6073e49db74f8651063866146de77be5e465266bf2bfd1d2b7b9c0fa913195afa0220532b6c106ce1a32c97b29f1b753197c586ca335d1a5c076ad8b559379ebe8196e7fbc4d20a59ffb594830ae26c1a8ed3f93029a269cda3d6c54c0ae21d5f66433f0f626a5da47409a057d242fb18ac93d61db109ade9eb0278736d93d2c19a71c4fc8638d7b9ac98c036caf05e1db9fe7e48923f19c2569f1741389b312c8b990649a4cea6d22b556ecd8f95c370cc562d7f04c40b54a2fb80c2dc581df20e90ac0e22195b93b152dc61fa7d8e020bd99199f4eeb4793d96dec0ec92023a3c2adf5be3b884dd812d23a66535e1d11aaf1dfbd147347de7d3608f233fc51047d5f3179fadcb7a5fdbb93d5838188242fe0254cf7d412ebd8ff06f6ae43f46199811969ccb5b885d35d643ad59d0cd2bebca0bfaaee5bb702a20022caa493a376966dbc52563818dc86a98b998762436de5eb5d94604511d769450f3756e59e706cffb51d44d85b001e23eb807a2f481356463bdaf2dc33b9efcee9036c3fd1d50fb4523d3a8093b1c540b7fb9c578439d19ea789713e1f4f5c6a4a65b9e52dd9e0b91c9653ce9e971978901fcc946b7e5a0a825b2ffac71be986aad7720d9fd5b6aaaa761db66c2e46cf5f653401ce0d207bc3a4e0cefbb94e45793421c5ea38ede1a085babdc8c367d608f9917dc4c0132f90b1225929504ff311aa6069d99ea464d1a5da400456cd19d015797a6ce8915759303da1edd8a4b5a8d9d78bcd9ef8a95ad9fda40b9681416a401c3ebf4f10957c51f562572159ab7071dc1dfa048772bfb585d1fc006b4c3249af9b70359dbe45a7a8ee68ba67e0cabe2b4f007dfe617d3faacbe4f79a5195736e5311bca7bc187dea47a58c44f7360e1c4b0adf91b4defa8952f9e5473a1ada047eab0e3702c1e3570e62124b7d817fdbea6207c2de6c047a0c0f8c588e36c0422bf8aeeff3b4d27c229805bc5799aee0e53db8635f1ea00d46b3cefc0583334ecbe07a7567fcd8599bfbc7f2a5077d5666e3de04ca81732d9c7be3f19b6b0d884e45a7793e4ed1df3340d2163c7ee35efc1cfc1fb23dd317a74b15ecb9dfc48509001671425be0dcb83004fa2bfa133549f16dd19bbd112be8ac3a3f317c7c4749dbc70f57f94304a1b178fdbde65a43ec089ea583554daff38779639e81a4e490fc7eae8682f2b29e4480186fb3b13665d905b0e3ecff8bbb730f81d78368a2c767020922fff34a794d24ce476728850eab910be02d9c1f2eba3b78841ec7ef81d00309b14bd706850c5bd40367fbc7ad9ad4f9235207f92ecb0b085a0ba081ee7427d87d6996836da8c379d3744feedf39ef1543e416eb04c2bc93843716edb05f06c26747ae16c02fc7a6452f45b6e7b1bb5700203d41d8c90d9c7bf5c0400be8bbe35d0779ee6f02c177953a734daa51a8b4984f4dfa90cdc930b80dfb803870d3867a959235430c9995d8a679cafb898c964cfefa5b4428ea3dbc71d4eb3083c7f49700a3f21b6a51d6a9a5e0676fc4e6692aa2bd993689d0e1b17cfee76b6cedd33895f33a753aa882f8972d1b6b7bc05917c26bc2feb2b0343af1b7602412c2d21f6c5992bb56015a13290deac0f1152e9c04f5c20116b232762a16f912eedeac6aa5a532beea2b5d407e9f510285b6aa1dbfbd1ed5108a8728f00376e1a168bcc924b1dab52989a1a5971fc1b79312ec623f7e7eaa901c022e3c55b11e3ddbbfd45236d6a4c30c383c6917337958bd03118f5da2779255ff84a5cf5df8efa599ac2c1e58ecc0e2257b7ee0fe76b74ac3a76e7efae1a52dd48e2c65f8537b5fff61716ecbb05ec8dcb1ef60e0d747a26b1241792e2268efb078b090bb0f1efe1c56505f39f1faa1104994b9b6ecff8f2b8150f92f1aa06629dffd0abfe09be220c8c3af8926613d57e8e7cbbac843233d6848b4977314a8cba46f5c852a1fc475b53cb2d0db0dbe9ce59530b343c9106047f8358ab8cdf20b42e5b859b557db77bdcc8f03772430b684e3a05e0cc4d603f3f4bda6b108489f3bf163b868d505a865923a841910d4ca58612005f67859aa3f86c27471ca96825629f8df958d9e53d918bd1ed6440f44ce698a9188f39b0e195c2c9f5c456044f11ba4f52090564dbb5be7e6812df8f7e28ece799ff8cdee3d608d46175e3bc1d81d6cfd1cdb31e0502f60abf3e0871d1c5ac5f90d2b73d7b0bf58976c7dc4e533f2422c531162d04b074eb10d16be718d5c52af8f0af0be1dbe2d34929760a416bc28dffec2b6e832acc64c9cb6435f6188f34ea7a29e34a9ceedfdc7a07118e234f0b419c6dbb7c7f5af92325035e87688be55ca62df28dfc721e50a273454435c203de2778f4532603901c50a7949b6f5e1318450fde4e63fb6fe06521a7e3422455ba76f7ff5b5e1bfee5cd3782e2c158fa7be3b6b480432a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
