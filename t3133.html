<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb1bcb791e18bb0c7096b8810df6a83ff65e5558c4e0df449a63860e281f7fb5fb12a636c89e3f0e8d0ee2d9742a22c9aefe2a811bf6a340bbf9023f8c59a0b0891626c51e00ed23ce1c63df2293ed0ab866f0d4ea88a6e029ab06761f0d53c994ecd6a9e5885303971633bb4096ef53799609bbeb98df20742c663f5b83338fe1dd53f33d4e858a1984f827ba6beadcd3bfe81093aeddc660e6b2b2a56e137b78b8d83fea2b5ed0a63e49a7ec4ad7d1de56544c17d39199cba5663c4eb3a56117943d72f3834f24dd31c1f99a2a49ac5c81cfe737a74dca462441b289fb38391bb78caf72f1f101edce4321d61a27efbbd876e0d6a9ab49082538dae5016aea464623009606f9708557f16e421416120ae46070d7df6174825f6ed9d82a7c73b0356b9274109b534892554a1f796f5f1bc9aba240cc662ce156917b0e87f3dc9b331b479636b3efe33d9ae404981cd1b4eff2d3799c4ce7cb7f0a507ad994852bcc3d38f4238a935fb2640fd01ce98e419afa0246937115cb488ceaed09274d66b6f47459e63165d3d3e240ccc52ccce6a9cb9721bab2a60a653c02b46f780eb4adcdeb0476e18fd2ef53c9c25000d6859f0515538d65e0357db592e861d28318210d9c749d9e5f8a53e794dbf023688f806fa920f4b9d74c1ccfa3742bfbbfc27fe838ed288d3da2b5b6d917387415662a733646611cf80e0548c36d271b6e4e8aa56804d68218279b21033171164615280083644cbea34dec666e1571baf34bcf0718362441a4c09853494b5f77dc080ab774494f6d020780e07726e14cbc17e2b06e82af4868379201bdba432f12311d686db4198e1f1f999a7053d92171c192ba2464978498fd3463f944665a02b7aaa7d8817e410429e72e4dac23a3d1be4ed740c2a45a56b904c7804e8daabc7b64b11817dda67dc87a9c5e193f4a8a1f235d2b6bca86e82db527dc0d2f4f66f248ae3ff0b09be697c0b9145eb9caa9eb51784b034f1f236b8a667802090723fef80ff7b77a8e89e1f111525e1124ce028785af2a8339da28e4712323e378a418a608643bc63f007c41fef5706f81d6171b43be0d80771f743c461c38720102ba7e763a43d7f2084d13c3fb967595130230f2d853431819dccbebe3d10fdefd7cf5744aa1c6968c0ae34e7c8daa9e07e4f440bcebcd1576460ee7887d3024d621327f4af19147b4cefed5baa291cc6ef45a750809c8b0e9a72b308ed87b1f45e5dc303d012b13c8d1f5709b5b0eb67454e03c276f80a19d211232ee42f3c17cca85b790f20648bce515d36cdb05c9a6c4e454e2ff7f702355fa8524d616aac01ab4d00e4308f9ddc299012efcf84b2177de500dc14fbbc8ca1707d7bdd087363cfa5b18b3928df32bd23aeb290e46bdfd9b98352a409261cb82f17ab899d3dd1b9562d914645cc6c1afade29851b5d5f9fd3551735e1ba37aaa01ddea71dfe608e29359431b7bccf997be04407f03e4653bb484d07063dbc0b533f5aff73176c73c407e4230b02591eb0bd6a7f76f0a9cbf2e89a74a7908e260762451cebe93f512cd96e061672b680fea4c833f28623ca310e3b1571065767537e46ae18941390be45b030183e83e08769d2a26449379d38c06d37c735f969c6005969c9c0d84bbfb21b8a15164f305ccb607d24a0fb1e834f9f17cf7a3ccd078fe293aec23f518981c7ef9b91e93bac7019939d90d803c1b2c10d5c836e024412b88b14beb2a6c512306cb8211f234ffee1d935db5c1cd0d40c8c38a7c8db62faae9de9eb6a9ca2e0b1b0c9ebb82d2fbb96b6e4e561dfb6d791d467a6acb12c22d2e6ed9c1800e56b3f6d15bac72122f3a4e1cb808928e515992f15f91c5f9129e3d607433b127de52906b3d0ff90327b3e1dd42816d1e8a282fd4030052b89bce93142647815848c936d97188b74e3cc70af466dda6c8ba7be4b07e979bfe062e3d9e52b26c2324c2463f36dfdaf0aea3283673f6348abd4bc7dcb0979582b3915727733215d0513f33649d796676017d4349b1996e9e05e3648d260f0e4389244932e5870328638ea9538879de59f618fe5c21b13c46cc1dc2b658213cf8a63c98918f5428425cfc34cfeb645e88b0c0971878917c8826fec2846dd848cdbf5930c65d5b4ab970993dc2c38235da47bf5fffc70c66431ca384fe316f9b340a7ca4cb83585ed0b417930857f09d6bfcd1b79228061529e6a51c677e4b87ec86c3dd9807fca7ea8d9e04ad029aae3a0170e00988af5d9d821e490a1e3a1d5702af200bb5b76699d2606cf8461286e2787889cac9e551431ec725de6d983d23226b77f4e10f455ee39ff34f9e36c03f0cf1286184e35c7c098d32d8a4341dc40e2b68de908e49b1d42d95b51c5b5cf03e847c96facf8867d1e7d5bd6d235c1608bb6ca8f30d674ab317c0c78d50883b1dbfccdd37a0b7ed6cf35bba90c424848372825d55b194e88fd386509b59d6b872c2135069885040fce2db0926bf99a470c9c599935fa3be19426c36ab838783583947ded5e5756bdb0ee0b8e809696d3918af1d0214aaf0f8cc85a887f10c57cc36aaa0bcaace09fe84a1dd15a52927d8372d232d2b8fb24c73e282394afcd9eb52ddcf7fcdf484409b073d60d1b1c03e6016e4c0fd57082c253d6dceb00f755b11507ead624f9714f039b23b49a118e01d6e50053a80c0e5f46553938bc1e3900cc23b3be0cf0316dd5d06c4728497e1a7d9c916e42246cc547437aa70f74154e49df6b996566297038706827f75ba66afc5da661a1a50b353467b2bc52587fa17d982ce9cf5f3ffc6df7a2d9432f24a5e6e64416710114685bcf82d45dbe45895e2f396e9fd35f9ce3a7388397dafc04a3c89cc9f0adfc39404bc2a81016097f41720632cb8bf6b9416098fdbc155874b83dadfa61039dcff57a17730a7f572a55cad62acf4bf04cd03ccba7851234922129699bae4c043e0b42ffd92d4a9f5bfa1e5e17b7397c9416cfe6ddf7df589375007495433698a0d78c8450dfe2f90864c3382222432a68e7c2763972430a2a45843a754bbb53aa3378c38aaefb6eec2141ddfb6829f0478d418fd5e7e91b159c3dd02f780913e8dce6dfdee0f1dd2d96dfa8703faee5c9308f17c256a34ef29c2ee1b99f672fec67689cb8dc9a2a30555819decc31ecdf970302513eb730a8260fe754e7267d50b4e7c679067bc587c5ae6e122efb78f943ce0c16f85274e17115652000193262bb470902f472698fb4924ba99f4d40172443c2cebe5c3edaca41dcf7f14ce6f1737d24550d38c029b0607461277b6012de1fc30bd3e50dc28cf0982f48b8a3880b7ea8fcf25ffa81f5297c76e946758284a8b3e55cdd199ccc833d9b150d1d9203859822b8ffe6d4255a24e65082137b3522f777e48d4f5f705a867323e7ba76b7c5c0d67c9a8978c0518f8c55b40b943af3cb14a0f89fed8a8e8efcd4b49ab29134989ee694d2b69ea8101ef8f685a8236f31c60112212a8fd937b240d07cb04a40995f2604febccd1ad57b852bd0c26309deb1fc16ca2831b682cd0ce0bf714ca5038a9848ec9675de5e0f31a8a5d84372e7d29a5e6c47504da80b2095acd4517515b5f3b45cf20c7fc13142bad2f29a6bc95dcc152f8fb8f3db8f860798afe0f6a60a6cd139a9733ffd3d930b400455cbd804f4393cd89884891a632f19f3a719fd109d12430b9cb28c982017a7668ac3209377faab2dc8c750522e3ea7d8c5cf5563aa931e4478819d42335b8041a5e47be7a85d4faeae8e6be172e3d15597c5ef4e7b29438c6dfcb0f1ed04e897c445e78729ff6c15e1af87e6e2673bf04123a649ba1990128d018663fb0340df47c656fc73bd7c208d50e8e5ae1b21a5380a39681fa08cf4a3f703d72d448c72c3047caa71c81e6dc7fc8aa6401331ac7fc83e93e95b2da7abf55242338231c1154aa4c4a8eb8aad1a09f02dd9d59b10c92322cc8e6a276a0688444d7db1172ecf42c489b3d3fd88858284919895c46bc4f32f142383aac382da4cf025202fcc7480f35ff81e817ff2e2e65eb587ca22cd5351497ecc9d1f6f87a04b7cefe0c2b120f7f1507c1b8bc3dc6c3996545cfe82cdc1ed59c218ce6f3d03c43ab63a748f22e3821eccac2fa2a831a083a49bc0c7eede73a511f7cf71ee5d03585dcdc0ebb57ae17b50f2b4299360d573dfb276c5bf94132051fd126836a6a2197db7053a01ac29711b04b4abec23adfffa27f625d2884bc7e9526dc532902e7b5dff63c079e2e420712e605c494b510add7875ec84970ef13fbacd7d69e1d78a90d40a76ea6602abb0678246e6b4c73934fe7cc3dbc729199d08c5431e7401ee26204568983bad41aa59941f5248e1fb40d6d656f08fced82791c13fa36d88d9728f752928bb63246552428efc5439475819b5baac5031634f40203205570b9ad1a1c903585ca8eb0aa8d818f181fa5e305a973f23660e45f07f51527b3f45198f13453715fa6fee8acba87116e10e03d23e88fb1ae52d080076f7a3d0c2388ca42f1314ff04b1798d633438dc9276a4518e8ebea6cbeac9a4207ee54a197c553d70cf0583f634b01b82252dca3b64ecd1c805e5290bebe5358e4ccbeb1c91502488c250354618e96bdc6af702524a94a83cfa2543eae0686a8888c9771f0e8de13e1dbf1384815bde872c2d2c7e20ec4abd922acb515bc6e21c4f7b7ad70c75b81070f730be35ac15e82a7b4a26c39753df4be56a26b7dc3dfd67951113fb8756f910862d4751820f59e8098b256eeecc32d8baa8550a1699700e692f67c75bdcd516b60119eb50ffdd404a69ea89da01179041549f0f4073d84c356b5fc44d435dfce30781a9d451c230076e22b8ccf33e820b93980f7855aa57434ea2aaf3eecec62fbdd529e0a342c3e57ed18d6850db488e77ea2dfb9b2f9d7d80cf1f38abdd4d8d3d29a19122ff8c2e295cc6f240491c9af2d31d095d1d472d5afe54f15ed33716fdd67e012b3f1d23f0eab770682d863de24766f1c71580b1df614629d2402e379b0a4249172716679a481b98c2ad0d70c7a36e90fada059a3da76f6b56f64c1ca6661d27e0f407b23861ef39d31d27a39231a27885954862dd7db4f8c14225b7bb7fae5a350cc77c0a71ffc8d1cd8218fc8c5a37a45690020b399b2f349b94d696e37cc9668e17584a75717979787dc668c9594af0ec7aa6e79c6ed0b3f112e1d94e5d234062710c67e55536289b0a8ed4a252731561cb851c1b1852b48c402523ab91bf31230ab2feb88de81a06652b8589437cb2bfd9d0e114c6c24f49da81ebda3706061ab4c267874981103f670bd2862db9fff129919429e33434dc0c59e8d28fc3ba74dda5903cb0bebbe37e4eb6a1e36660205eae264af5b01bf780e007e9e8f1e4423041c6338ae071bc0d578dcca3c148d4ba00003aa1205172aca4bb33be5d3e85e8711e4360534437b1c92f3696396a7a135d7bfbefb46464b5fe13b99294d1fd35b385fa8578be737b95e7287ea402f6e888811c5ffda73b98d5f239468b23f77221e98397a5d7d7c7649341772b82c39c724ddb6749f95bcd6d05096024b318a1dbaa71c326e95fc29c23c6f8d4b98744e905c81fccb9340ccf453eccf52f6406211cc6bfbc9319dfedc138c74a96e7bfcb2bd31c14c0d4a5038fed5be982aae7c3cbdf797fa17a692497a1cec1e59d4339f84c6cbb2cf1331c1f11c3284e2500344df58f8f9ee08ef55075f9de9514405e7552cb0c25df2972be6a6902d3b506c4741d9e6ae39fa79fa5bd69c3519405735f0e1142609c29c3912edc4fa5777df97d0dabc5c0c521783913fb74a93c40335b8cc8ef05a2aa678c7c5fdcde6f45af694f763314d7019b13b0f28b1fe1e196905b4ed5e9de39bc07dc3501c71b9a8f5e05b15d66ccebc7deee1a16b946ea84c34541a0916523f27e677de842ed9cc820b9397da05ee5cb390e5b4a83e16e1489a72ed1474d6dc3a3ea192a2eab7a522fc21330e572de692a96b9b2991fb0fbdcb8c459110be47e84a17c20b51bbca8307a3d364cb4ac261faae5c8df6774b54395811307b1724cb86e85911b8b848a6189828a0aed6ba02269a4729a34dfa70485334638bfbeba2bd4d65791fb95006ccb935bdb15b0a3bb8e65c292f88073825f5ad28fe4effe68cdc3ad44f49655328ef861afe5b4f888f9967c9731d73fbbd20adbc1abe135bd80a87f2643d8b40df4f9d10fdf40e10d6d3a142643fb415aac01c8e22cc05bdea2b52f49520d7c58b73d064d20f70a03cda261f0c71faa5f9680d7549f7cae9dde64f81a936ec0057afde8bb0481df1979da1299bcc6cf6ffffb5c740e8411b0effca924433d55473281b0da90752ec8dac8bc67a6f604a144dc2a53a688bbacb9b7b9523ba4ebb310bd10589ee262b98e03bae30b19272a0e58dddd96ccc69f43a1f24aa1404f0588aacfcc1b215713e2069278971305ac6a851384a3df59b0e966b16e68568229d519c6aa614a16aa8f62e13df825faa8c3fa1be344ed5c97d956777ddff6ba447fd7149b2b755e26ed352f96b9dee42c13c367a9e7557171dbb4eae5472377987575ca94234981415401c3bb6e3dc83b901096025fa0a2f83a612451825d6afca52e5d28d2c6ce90c976f54a56cdf273bd63b12a288bf17b680d0d1f94337aa758917d55edd5ab6277df3d6ac95e618d2dae10e5bae789f30aba00abec4eb2550f1875e4f377a0c3122946d711d12bcefc17be60d6598c14c2c8bc28c6994f5ef05e1ee169a9e3254c859f3c5ec0e64e6e0c72c71188e94786090e9b6b6df77ab84128567285895e2bf5d2a1f893abeea601ff8169983facee053536a63d06d03cc5d130ea5b6a0ef9cd5d3ba1eb30c1e1b0684e61cd8b426295e08307086aac3b59f12bf7aa9dbac3c180263bf3de314dacb2460a251adce4a602b70c9be86ffaad543cc1e5739591a4389d7e92cd61d83108b98de476f8f8c493ffb1fe6db271acd313e0dd2e3b975705f874547821f21d9f164d25603470c10f5e583cd3d02deac9b3038424f6a3e6f13896538f26cf7ccbd9688383bac9b8541d17f341ace2979b411a2d8657b66fe8eb17baa10ceb98cf3cf86861c2d3a0ac89cfde810327dd0356f9eb49247372f97ca82c82826a18cee769e3d73e6bd3b585fab0c126c32c56efd834ea81908db930579124b8436e7d4c5df1d4dc4b997827db579355b6354dd54f1c3f11cbc6b821d10c9077b361679cd39a7c17a394298c77e20a413e76838305ea117743cb78a5aa3798f5e412b0cd64aff2b97364d617876b25866bace3c71b2d07ab4b9b931beb67ec4bc4641fad7fc06332f320568d465fff5152d9613ebdd46a94611e9f98a0a20172a044174a76a3464c0d569325002e10ad0470804d9601fef00769c54d33e43783ab4605c5cd831ab924856b72cd33e71d4be904a012ec84ba2ecb94aeda5c761307b7ad0a8f0f7333b836877ca0918af21c372bfdfeff9430887a48e99a30fcef94b3c9f041e5b5bf5b5963f9354c5d83dd7c4183f59c0592d627b5127cc00cb6121bb32d386b3be5e35261a7633ca3eef8848ddda3ef5e54884e05c697114a70df3bcf7cdb692e2d3cf83aba010acf9fae14e82c7f912864c46ded0b52dc6ef7e10c75ee318573246fe67975a06fde488661722c4db686f5dcc31498db9c1231915e9da5bdef82417d1a8986b39e062ed0b81dee58dfe24761bad5a6583675522f85882712e97e9e4202a1b7c49f6a8d2ed165b4186b97fbd5462613946704f8c9271f34edc24d178b9fcf48649dfeb8f9f3a2b27336fbb02bcd47180654a4992a243e1b0ccfe65aa06a3073637a79bce7bbb8afe1e113ced61c07f4731b6187f0a747d5e717ba9533ca1fcd821d6de1ca349eece591f5f1e105d5456610ef8313b1963f76b5af13a5bfca930f76c4dd96863acd1c1132bac93a3cd92a088f191c0bb7eab17beee095ee419dca411e18042c6ef7acf5d1000b004a1dd3b9d447a7b5f44e75b6362a83ee6101ac06ec633b39301218a1d5a678dd696f2d3048292dc02294136bedc05888d7baf6140d88861b024a1b3902de0dc1e9214a53f23fe3e882a179f3cffdc435626d0d9ecac0571287429e15d9963dc3c40170f72eef887c30134603b73d38073ab7f646d7ead85e515aba94b7144770bf61a5347e1447cb810b17b54b6827f73093d52ca01877ab455f1477145b4ce7427f428c6b42175ad0a6bdb6a5a52b018a644e9596aeda9338e6c20e383e4d1a021de996315f5cf56db3a165b3f5f95be8741b36adb328ed04eec960d84ea52baea0b673a98cf7284e398b9d2043ab0b2a5decf3b8e65e0306fcd7777ce13a41de9cef023a9f5007682e09fc3a61016c4cc164c56be8f86e26a6c7ab358fcce616487b38bcf94ae864dbb9ffce9ccf69a4c7b5fc30b4ce62c1e0c3fa0d67344aa48db0247f4597ff11d3dc554971641b8b6d26b86cdaabcb72666b6e791c615051dfc972a7bb3efd20794e3aef999fc4adcace6e36a76317e14100d2c06c136d4ba83e6ed10a373454c3dfdce9e40cf87df5d55619f95a6b55ceb5a76c7ba13f901cfb0052f7cf2218a86f6a418731edff7d3651ad7df56ca9c9e7745a80baec051bd4c8643683cf6df2da1a8c89ddbd985fc2a34f917efe07f92906cf0186867c2813f7b378c370d55348a86a0e437ef00cb8e1729f230b83bee27d8ebfec57bc8eab1a1debeb78dc8a44b060cc1a2948ff0beb7d42aec963b5f9c450713cbbc3394b309803ebde96eb151d8f48b3c31d6d2db7cf35dfb2fff221107d56049ba919802e7bd28c460c839ca592ae57287c87a8a05d5eec2c12c28c5eae985715ee0f458f50ac03d215f4ec259f97dc4250ceb0a1842a6f2387f4b28832bc4463dc84b5d89912aa3b30220df5d317ed49d1df09eb3cb5e3aa93f7a255f2cafe1d19916b9c6baf6662a953914ac01fa12d25088826949d9ecb69e216c9350a60b710037d1f41214b9445ae89fb4ada1bfcc4aec591131f882b7584ead71c2c9f893a8e7061dbc631f3fb7e954a6a705fa41e9b18e2d00c6d865527005b629771c31670e31fb02cefae4a7f59b313a5a553777323b929f08b2b81ae40b34efdbc7028e57fd5c220f12a82c1084eacb2936bb9c22821b8a2e873ec3c64c7824b97062489dd0e76203d07f3a0732c232c5db06718a5734f659e331e123cb0264f43e7d07bde2a295b26bc6ba2b1d2b2039ab3a5d2ada0c89e129612d2c488be5626e10a3cac316c36703d78ea5ff233b7051e2544c0111b898eb04c7ad0b1101f02746137cd128299725a448491e17fa5170f417502bd98dcec4cd990f4c1c265d9675064590ca939d36a3a3d7c9c3dd18b7b610db9407f7ef21ff1202dab8ded8542412e989a4951e2a8a601cbcec1749b7da3f7e704cc49a94764d7eac02b6796ff0402fba7292994c31746c983e8657bc21f9e492fa6671520eda251a2a033f4ff837865f29d19c8f996aa84720eb954da79dfdb7181658b15d6e1a7e982fd18290de351ca7886b0b430ac2111e994490a57d87a159cbb5560b72051a00748997feb0905cbdb64dca00d9435e651734a4474bbd666dfc2e4fb7fd95464a2cc0aa3f218785bda525a0b9b6b938f16e4c5b9dbfe4207ca4714fa26bcb507ec01d435d0475fcd3f66cf4944cb5f00cb8cda93dc4a3463f72d790b5c703a1acef061c9d8e4657bb150a202568e7bb421d793a831fa9a5c0012fd3b33387b7c7143abd86aec5e71885bf7d1ed46a9b63821e6810407ec4dcb6a1b561e9936956a4311f25d44d6ebba0069818ba6398e2241c75086555cebc724e5063f5eb8b4df8d1227110108cc076d355d08da1685569972f7cb9668845f36840c503a2da57bde6da208048cc75ff92795bce41742ca0c7b871d959299f842ba60eab8a33a43bcd934e24b6d8b6e3803b0836eb8fe5b858cabdf6c6253c5f4d708a8a25f5ebb889189b4759388ce4c6daacedc7aa94be018e21478d31c0fd0862b60f89b966539a76ea94b5dfee7a40f59855ea6d79eba18fa96d370e9707187c4c95c0ebd8cf930cdb93300cecf31ec5f3c9c73d37bfece98e979bdc5723e9dfbd1f3d0d31babf3e6833faf2861b1d44b5c0edcb9648f2854c6ce3abbe964d00829236a0034f5730363ce59ad9fb4fdaad0d5825fd32355b00531bbee85d8af7a1b9563d3594459ad82a1b7a78263e7034be0769aa90bb2bd0cdd65c2f7c5afa5432e2a34b924b61d5840e753c950175493fa3c09f3e7a1eb5177c5c6a13bd36aa9140152d806410c1d90afd1750a384244d9d849e1f27def03da8ff62d6675e7b9cf38c10b91202b5e56fab0f75da7ef78164eaac23c702370e15627f26f2923c1f43f47c03e29d50038ffd1b9816013ef6723972859f975625f394023f63dffcd4026ee0123d314728efede2b4216d72a99db963e574e348090dac307f2d04ed92ee1d3fead2a84ab1f29a213020f7d501491ef967d6abf00ca227e1ead4be2a411a3217b65df5f418cbbbb581f7663143e8808a614b67a70f79eb39363d9519cd159812eed3f6bf3b03a7374349fe4271e41b23d6dc5f47ed0c6ba14c62026fde1db822a1838977a9dc22e7ebd52b54f3233c54db344270d25a13cc4fbdd2d84c5e1f398f9c1d77d25142a52ee74a07fee82e0db7e8349a817c2d1d5160100e7aafd549e482dcb207751a458add32b89992284c1deacea9a2fe48d7baecc7ede81f31a51e7716b0d7eb5b8fbe2c19ecafe804117e288f42d5dba5e7aa4bdd725b5cb743df547bb6991aaf246f6f0b06e49b484ef89efbe4c76b920f582e3a42b74f08cec47348c276fe226adc8be095b0fdb2c73d11985a940aa90dd320a3b7582fece209cbad3fcfdea5b68d24edd972490d77a715bbb624136e3b7fd82301e591c0b765bc5f7672674dff84b966f5edcc0ce2d93a2b7ae4822d55f8023d2e2b02aebb571d5933b6cc70089bfbd59a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
