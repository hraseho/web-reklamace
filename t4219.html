<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"18d0834d21b822961d61488129878b339ee343ad3ffe09fd7a9228055c57c1ad9a7fff8f252bb8c3ec6736ce5eb36bedf1a64a79c97157187818d779432e6d264fe93de191cd2002d8263557fad6f2741673f484f9b3c29af7d7af56d4e9b481ba8b13504e4890128ccf15c84da9cba8056c977b2743324c25507c0deef150165938684a746e62099b2e6cb053992729c50c9d013427d6532e77493b9f7236e82544e349d34e0d3ea499789cf54797e3ac08e2cfeae1582631b413914d04fbd7c2e83264e2fc37e09e1f5d7fc3effff32530735bdcb8c1146659be5a69f9c7a95f3fe4f69460c4f42b6c8e7aad59f9ea5461cb459ee7ddec51ce1a53470f4890332eb994cdf9f7e23fed267ed4ce857bef926303cd4f25e44296cc24e09cb7328d5ce03cba68e03741e45b55989c64a1040f24b4662eb6b4f115777bbbc5491f9d384aa05a05d3007c2475e4ea0d3f95b8cc937682652d8f6294596ea2c2a627724ab71cf5325207c44f7f75a4784c50c28f10d0c2ae812cbe9dbb0091ba81dc5b0543f1b1344a98b5c92e56244706b30ca58c773e0374aaa52f0971589a861a478d8b7002e9c6b1ffbbd26fa927ebfbdd8dc762369424fa9cbbc1e9da6a325038594664d09db3a3c871f655995eea4332fee1d969bbf18b7af1ae4b6b39b256a36699ca38002f05ab1331caa2a09ac8bb8b8cd75cf58cab87fbf158814c60357db7df6193cf4ea10dd2fed71e5e54327594e1205734184363882f44423afeb6a6c32a4040099e3eba3b66c3bce98d514012ee6f6e09f2a16bc541deb46ab6eff69b5b6255b4f72a35043cc377a2e6d1854dfd1e59e8638285656566fa93ee5ee44162b36c63d0cd3f28fd5de2d19e09b086397d046f542f652849c8a00de499e1743c9ab3aaa45b4371459c792540c2f4c54ff1ae2ae7324d2df175e6b087d26f84af21831afc7c1554b21add21eaac7ca4a0156523167e3cf88922a058c6a64877b122b671a191f8e1c7870d64132e8b61deaea94ebfd827c7ba0082ab6938c35439e974b1f6b411811df12b6255c8ce0a6493b7ea9f71c62e82f72d8d602868eae1083169d5c2f3f76292a650e962450c921bf8e00ad3c791731681028a1a23d68f841c1a4211637ee80444bb62dd61c408d7fbb87e973a429a3cfa4d66c25b503d00d4218e61d19e2c14a5b5d79a7fa32828766c54864372fe5ea8c3c43abfec26da273e31141605d28a29ffb8642b6e3060c2f09c7edd28d261202f860352b718204725014787f8585d8d2108f4b4cdccd76937ca7db75970d9eaeeec57fd2b8f2f3e2e589fc6b7ed7323295f97893e1cdafdcd60963f2b2f0f143e2ce280c7382d1f5525b9da15cdfa17f41c36d47baced4593fc4065bee334d8e63cd5192d104bafd940f9f8193d94ce33992b89cdf2b2fc2de7ac207ca73f4490ed705e828ea1a491098a3dc880846ba1ff68007d9112cb55fa9c4693302c7cfe50c30fa9825a82f69506644487221ef0230ef913ddccbac20f00a48322005c8f30e8a73c33a62c7c426a707ed3ec1255907894786dfba4374b5e5e299467e88e386468c119c100e0a5d437e3702300cfa616bf92b063b7a79551a4f54fc474167bf2467042ba6cc52b6807f04c1f4d22aff5e5d8a285b331206c2cd0606089bbf526aee47c13b7a538504a45345046c7b0fa07c18f2ab0290e403020574e810c41a9161d4a335f99336f898086445df6a4d56aa4cbd85cf3db323963a818030950119e7516396e8bb9d4a0d86d632121eda4ad2090439d8678750d191069ebec34a823e854d3870c00868887ef7330807a773f6c67fdcd6068bbf7cfef870084b2b6a03a24e8161d04fb231936fa87e708de0d398f24c60882e90a77af0d30e17bf15763fdffd3e8c8f1fc43391d72332aafeeae1d1e256a6b21e46309dc1ad69d1c2608b92a58a28cf3f0c0b397b17cc5be6aacbef0b8a235f721c950413d2f83d0f455f7ca787f8a66444aaa9679f61ef060e0ba5a7ae97d7d6825dcac1abef1e87f98d855acd8e676b4ac3bb650f65b0b9c3c4477f79f8ea87f7c4c4febb8d29660610fb1bcb095a6fd6b96f14931af74de33ed1dbe586448cd89d01b27851189897c7fce1f98fd95aa318557667b29195457e5221ae6b0f40c99e9350c02292dad2048a7986f4824541fdf13692bcff348d807d7caf1f10e3a615cb9c79b09729b878b7619e7c3c2594e4c1c96626520dc1f354897930792227494765577e18caa2973d0f4898341f0715120e0530d2fa3664a9ee0659f5b4292f59cb84c2abeeeeae0b566b12549b8a541c7ca0d753c1983fc83275c8ddbf98fec9e7d24d29c02b173acb5848a4ce774e6dd3b05a1dbd25d9e9f61d825b10baf4ea144a0bfb1031a3995838a665039c81d3aec38356a5d2d106dbbf89cb4d2e51d3db51abfb68999ed6b1b3d8f8dba25c6a58b94f9b8fb8c788dc3f59d89992d9750f9281424a7547ff99a3631383bc7886e0886706736b0e9a889fa473b93cc2ed6cecc3cbec19b89300867e6c2733729805b5c9d261474a3c9e5b6892f337f1b365c35564d48308e23f7d842bd77fd2e7b7be261cf496b008499f9f5b84de364eef6455109b8866f575f4349518db1b7d1f1086998e7dab1684c3759b9be7d7be445820551c2aa994bcf3323dbae47a7a26afe3c35d92481be352230e3651f45a7e953c18bd77270e93d90701aaaf02131fbb752a3db4ca517f1cda4f80b69545a8cb0afd23e761daab9492fea17abd22ffafc12961f6cae1be2342d1906d40579ade7e302a6fa9ddaaa86a98afefd8e622de8ac9ad76ba5291eec3b63aa38c70c21d8d665ef2e00a82f4ae222b75f547a465988e724a0d249b843787dc5653e342f2b0a1c1bb0748610a0c505cd4792856996857bdeeb0af9fc1e6728e62f4a9aaea71eebc7ac974d11268012877a1db119b8b8a39b6363c43703ab3a63da4e8ecffb4b553612c4dd4a25ba23261a9d2b478bc85002c81ab11d3942748fc2a3fffd5ca63fbcc6a0fcccded687951210ff6e85148fa3ef922c32cccfed253706aa5b89ac0c58ef0ececfe87bf531b1830a61d61574c03c3349031a07d35f9d652f384766854e6686b026789fd321ac5b9f3fc16f1df693a67c1d467ebe067ce484e4fc8e3c8a9510d1d88283f24c6609833798dd4dcf6740d20f7d6f104c49e683b0be4eea38080da8a3ad6f1d1a2b86eb0ed10ab7258577cb712b25ec13f9d9b37ece587cabc857b30ff60ac09e48cc424f3e7cba366d316d685164383b07abcc79473309ec2f14775281176daed683692ce870970bef0d2893f61c54101648a9c59c33039807470b08f95a6db59b5122c19453d50827adee7ebbf0a0c99cd01cc72ce29e9691a632a5c864de2e005f82e800a5929815dc4599a4624f5ad4706461921077523ad02683509a7ab71f48c05b73a39cd0ce79c84effbebb0400d2102de96805dcf07823ee454af0dd4cec93cdd979923fbabba554bc326fa28d0b70ad9e486e69d3bb4aa310fd00f9ae0dc8aef5474a7436076faf12b14ae228db02c6b4245d1cd744d14ce605b0da31dec04e86f3dd8992a9699d9ab2cf274da6182748345fa6e416cb786faba89b3b99da0c6edf648339e34f2c472f347e677a1aaa79cd856869a98c042a4bd0909aa2560fdd96b8127aac16451e1e7d81679f4b82884afbb4fc6090c8ee8b2678dc82c5ddf95ff63f61dfbece7a131e3aab5f3494b483a6e35339c0429e7151ff4635b713952500842e6acf4dd23f40fe910becd8c78fdc67c0faf892e7c646c967c76755ccf6bba10d9a3e2aaa50d3bc06af314c075af643da1c178cb82ddd9d001b94283b0d7caeea06daf6c7491680211a7e74ae9631fcba15dc7ccc7bb274f6b71273f3962811aa65da32e51d17c446df9dba4303944c9e8910577ebb4070750dfd792dddc9bb7360f79a4a53b6ab986321b8a802ebf19767099bd09d6b2d10594e3c8c9e2c16e405e5ab3f7ea9f54df91a75082ee6bda3da133cdf520966813bf5056a99edfaa94d89fa894ae1e917e8d0d0af1a59e46117b8719ea87b36dffc9f3d3803bc5927a8165967ef2d3405002f3ca01c8a776ec4e737a1045a2bb1bf08293648141d55ac40beac271a22f34a149178c4fc488373252a441118a1a0a45913a2e7b4d164af422a9f18ecaf4174f6b9ecb9b40bb808269671249d7cabc09e4e2d98191ff00d1307aa85f3fa85783030613d6616a61b7c62fbbbfe63409f3202f11700361343ebc2a6e19e2a1d39b322bf7787215f007db7ee57979903efa6cb5b68ddd7619cc4d55ff53ab62fbb78531c12c900c4802ef4c8daf298b0406bcfedf6f16d2d5507103002cb5b22aa88b863c07f74fc192ea8fbf5a04309a1a6a1fd80f2891504d5d1e321c04d403f68f6f3b6e1fe60ee640f074855257c9fd911b204e7e60ed6132e2dce04e2d572cba005691444fce8a49590de00b1357b6e04e5eb8a2a57e08825765662acaca6849777fce3aad4a50dbaf992ff29768aa25dbdf13b9403dfbfd8c7e36afc8257ffb0eb9402973e9b018cd182e5f1e3e0e7a25e19d3775d10b738bf60930504e2c08216671a0c3fb2ec61a27512c42d6b50588d113eff4cd8e261586909314776194b844e5bd2dade16e8a537149e3461393284513e6e3ea1317b0f4e43460e210afd3eb813c8a52d711a4072b1454fd0011c3173024720956e1343776462edf50495da2f05e10b9b0fe14becea6ab33e268b796d689c7970790ca616ec0dc533db1889fe9d7481f45ace405236312d9a508c6cd67be02c9cb4247d889d60cfbf9a413220a2843eb03933e39f7127caf3b98ccf28e5606364f3c11a764f90d955d82e1b5247f74468efc3988e493ad294b3596340e991916a07eb2c2cb405ea0870a17dbcc2f38ef8e5c5c87f62da34e5af4debde2049ab87c58e60200bc4403ca2f0489c5b765f4be613f26c1ec4ad947220831a194c05d31c6fb9f7eba6f74253407d37faa86ff71a5e9c51085dc2f34bd71665ace7cd7ac9574b176c88e24ba69580ee1111002586b1c34b32175419937c10e70a376b459ff54cabbd6cb0c588ac663fd05323507d99926f3c882537ad9e4eb043127fbad4a62a54a72a409576017527f29f50674e6ebae7efd904f69c2b94e64b9dfe13a29312d3578affad718b674cfe3563589a09fe18324e1c65e3d8a47d9254d65b30edfd2d39e7379c101bf64f2590b9094c9594bb32dc223ec031d4419ef499dc60fc07378391f332a30d5e87aca577e0fec907b9462bb18567ecc8a7fd1020a1cb700710c695e31432e10d283d4caa05320c7785a607fe31ed56a61a5ea7d0ebb5c3b2d7071b079f9e47f44f69e83f5bf5a616eb48597de4fe035ac5ddb922be4e5fde3a42a8d5e2cf4a8522e5e205f1ca096e5c9d20a67519e3cd42bfb4086355ad5c43bd3983248aaddd85605bdb688f8cec7fb11472a8f21d96658a86715e3abdd170974aefe51ace4cd6f38a0cd38cd17634323cd10d7f5673493556c70441176f3fe01a416295e2041dbf677f06e495670b0b67f70ef7e172c0030379fb813f3d4b42bf0b73c8d8ecd9a8ffb01a00a054f81b903a2ddcd14ea58c16275d8104a175d1df2b795f9dfc986f91556f6d15ce9e109fa08539f2be83950218004d954f806d669cc13b3420414857ec2b2b06e3f07a45819844fe2e71fbf1606d3ab924c0b80619d605a3b32eeb41b3ab6cfb38a7846810bbdf0f357ed215208e577afb34ae48d5afe07974037fa8e543cc2cc2c2170803c97fbc2b2e6fd286ea0b3f5825a28308a26f5512afc93dae64eea148e3dde16ab1c6a2896e3ca545e7d12e42338bcfe74fff640d8c81b6769b91d8c164dabc3964bdeebd792d9a2b3039f833517a1b4d23321adf7292289493b6770c2fd6b685f79c1dc1d7e25b844f6aa9a2294353ee24dc253f92bec5e6fafe938abe78f82671f863a9d9132f35adc9c8d3eae680ba0d1b2303c5dcaa4b9364b12451a333229a72eb9b9667179ed46920c7ff336658e667d36045c331c9ce458545f40d25c6d55676d334397db12afa6e6acd6db8b6e02c1b5b4533b5f86953bdd7af1e1da229dbaef27768784ff8e0c0f9d83f01e76faddbf37f381b3fbabc6d99a6f4835bc54f5534685fdfa74e0f724476bac28a4037479c6867621ba9c0aa0875c6d259a8c075c00b8700077e0539853f7362932b4252701a7dce43f933c706e5a6040dc44759663be13006fae5fc9e6c95d33a5270b2feb7e654e7a590064f50522ef5154b68842708f4d1ae61f311d6055c7cf84d2ac7c03f6c696917dc72335f93e9dcaacb831893a4451d03e3f0cad5ba50de96929ccec21beb608e789ceef5894a6cf9c749de7a2ea228709ced750ec57ee7ec106d757b0e63516d0ec19a4a023f03fff69fed4108a492a42bd3e670c3999881c787e8c79bfed5075546b092077f274300d6160248e98665faa745452cabff9b0077831a03507d2c7f235c12d7ce17fc909477cf988d6de166bf99a95f2d0dbf241ead8f7768256bf1ded680cb0cc06521f9354f2a6b16818e3db9978cb379ff9f571cc8051f187f03da30800d5434d865b1a7f917cfc6dac78ff8a33e95e3e7fb7d5fefecfd336831507a13c738a1c6bddd22b657ee6abe3f60c6ecc188d461a94458531894df39b8c21b98a1dd755b6814c532a30526cdd71ceac74bf92b4d492d7e16c017cc58abd15b3014799c195ec738a20460f68fc3741b027211d6394432c2c91f5014b11f6f5de530ef608d567c265afd6f43ae903d01e36010b9e8ccc9f371a8f76e1ad9a68d3f018181c607883446c10ee35fb7b2f914fdbf36f44b4679f98b1f25422a21ffd3129151948f76f0bb25f6cb2b975731e74a123209aa821a05246eba98d272a577a02037499334613bfaa15611eb86c1787940d8d293d02d6fb6a8ff2ce4ad28c0ce9935d3852a80310b91de04c035c14e1bf91d163780b90ee02ccf2bb61cbcc665927948af2a3e653835ed461e09290a7e143c2d2d58323189afc240cc06a2259a56df656dd41258e488b0b7704b09ebb993516bcd259422ea5ee6f304bbd27b3e30b77c10a3efa29aa21aa928258353389a5966beac71acb61d3bf0752109cc87abc5b39acbd36fa6158341266806d918396f2b37cd443de01e22c4f4eb1549ac0cd24cb20cd9ba5a94412e80ce3f82016fe7895b363e17167fe3c9c715d44e49b9232832a682f13ae97bc2d0f8eaebd67f2fdd1fc90b367a978f1ae8b67c97dce166d5f4874d8c6cf29b169f106d36c1d500ace001cc4b71a48c9298ff4515f05e61c12647a7f6403b8d06060db58c52462d996ec0286a2d297303a819ce66b631634048d53a54263e3f2da649056e4cee2b78e3dec0eb9486e6e82066ec8897804f0bbe7b3ca6e37f659e55ba2831c15afa0d83905b9899271178c5d760949bce01c3186881592cae68a7b987d5a264cddaa50b1b07139b8b3547cfeca7a5d4a96c473b257fa65348ee4b612ac85607517da02c31f9405176d57b88e48bf0ca31c9ef4a96faf06e2064c30b3c5c823c04c77d7b37120f6962a408005493e650f569bd78e1bcf5505a3d166a79d9db7844fe46f8d18b78c70068ea8286ada58166f9957c5acbe03e73189dce24dd57f513d4487e866f7c2e3768796acca275f90b5cd6ee1d3c54654431a3def15fd4a82fd97d1f0dc7376acaa50ccf76cdcbd75cf083fa1f1fe3f41e7e197bb007f91c09c74a2fe3288ae165681456aa2c9e0fdf9d44b31685aa7b7b89f98de6e9e078d8991dc03bf02dab43841999ac3e674a3b3333ebecdd2fda892826e245233ef4d48f83dd634eb6fab7655b9372e899530c971e37ab5e315737396b087f55904f81a75b5ce978a2f1bd293d132befaee3a5c5828fa23cb7007e908b5dccf4d0a77eb6b7a4e228fc0e03e4d0ee6e6b68bdf50c19b66ab930819596ef71d47e9b4783021d7253add142463019df9f5a815f54664369eaba798a8ccf050080894e0cee2edb4063173b805c9d8d4f130c5e88e58e044d740213ccb3e0d517f7ae2d309003fa170c03ea92374c9a0bdfd9ceb937b5cd942fc8a290f81cd31179f0ba0a6104d28363025e73e868d3877c12c6495c600f9f034eca0a78d4ccbf97ba0df129f31db9482e08b6458fdfe7cdb0f81551b62da51f342e0681ea81de068f15aad4d17fe069093b8720dfa566b06aa5d96ff9a1a6db3ea2d66e14ddb007aea8b58179bff9ff1b062981bc122edb8047e1e81c23cd225da2677bb4d3a16166324e5cb22526083fa6924f4ebf4e2ac988528c27093a29e2358dbb2c6a39eecbae183162ab8196616330d8e76a50d0101e431a331e18392c3bd4d26e80d1f7dbada2b00dc0998e7c9fff8c5d9d4ee4209e9886746f88325c60701184ed407a08acf04ae2dab1dfbbdc8b327abe3dee149499dc7f693b8db9e6240683d7c07a10575a40670a3a2392bfea89c001d304704f19ab925705987a30b5b5a04cd140dc6f6830195f02206e1a5948fedc17a0aa922ee87fa9aad302dc053cd344fa856a280e54ff5314d66450a1b6cd191d1c0a6857bb7848fce25d2304c5e753eb4a8502057cd5ffe445797b0d0a18d1d4bb2741a64fc14b55d3e688ffc7d5bd964d3665e99b6b07244f3c384e1c328320bae00b58c536326be965b2388d80ee7fd42ef6fe3cb8e2bfb42a0eeb580c37606598aa36f96dc099fc90424d00fb8aeed14cbba3f357445bccbb6a024f6dadd0ebaba9591c4d86d4da37ae0bedf8a3618892eee69f5a67bb979e98274d1bb8ae33d70d33ee0efcd25e53eb8aaac5dde50871a054d0869f8c90fc6290172b4ca785e6a574110137fb616b17435c9c9c4ea020d0fc5187da66d3671b53f9d74cf8afcc099a50607d38d542e3e9fbdaf950a8e90f17f5f6db1350f3ce6272fec2af7c8bb1be8c2f15efacbd850ed745ff8cc0a2da806285195b7fa2524ee51d1e83fc98ab7e7f7dad174f137de2cdd3c2fb1e498223ffb1d235af0baf3ee658b588ed18462e4f34c4189cc8731f3b1cf72f90b90cd361ca057669ab49d1839bc690437bddd356ef78381d0391747a2151ae0245adfa1712956a67b5517c677c821f9c60ac567cc98ebd7f23c0a9ecf7cc4cc73d21f17ec65b66a1e53ea88ef02d522d9b0ab376cd0c30868a8b198ba4df275ee8fbcacf1187525a68ccb7486558884dc017604d0f210ad8edc94c64240a8a082cc19fc5b578b0408b953c8d38565c86abfa9078292359105ac2b75fb1d3ad70e4ddcce7340797d7e1901a12ed0a664d914c2325377c72e66aebba28153b78f31b9e2cc022f1c42b019f7182861f7b6b0513dae982dbd3171df4e909a7e92637402b890c4156094be12519cf175156fbcc44eeec55515d9a7886f931777256da0b6f81dff93d5d8c400f03b9808fe65047ca9b265940eaf8a93bfe2f7cdeca563dc1a06882c37d8effd1094d98ab96e2f604e52bf2e6e163d9fca3187d4b1ea1522d575c6ec8698f0f98c32d3aa26ff6710ea504db4acd5fdb3636a3724f6e1a57aa618e9356f6539a2402cc5a18e14fdc3c274b04cf4a0e796f46851937325bb3e6807cbedb91feed34084cc4df3e22fe870d93890ba97314941624fd84ad1da7e18e2aaf15de1d655d04310e6759719b87438d06a02f2635420ae3ba46e2126135d504c46178b93497ea7a7681ef3707b05aaef016f1b663aa875d546e4e44cf267507f6a72590a90f1239c8fcc67ac1efb0be1cc1a590f801df9e9f67d692d7614bf8a9ce544a7e38ae5c8c2b5021b5f9ea91a2d429f1caf1242dcdb2aa737ad393887e6dfa78a1392f6f5ff47bbbca2fb81f3181c521618c0390bf707356c4686dfeef8995e45c027586504d7cdfb58243c618d6a96abe350476999fac9b5f1840c0c0e0e399bf0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
