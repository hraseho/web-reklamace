<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b4879fcdf45108e6c57167b0f6da3613a09d21420aaaa168a45cb572779116d860d095631245b47f3496be94b7ffc957f555bd970353bfea59d9500569ab163cb1a8d13670a752fa88b24e301aef19308add0fc5b3206ef726da39352ad3b39405ff5d0dafabb071def42e68e3cb5119ea8bd159d7074345f59e46ed50aa6837cd8c8b0a45b854be947acbbfe38bcef01d8c5e9d2762e4c0b7402b4d221945f2e7dc055cdd86bd77103f8b4104d879191823a7fe621e271dc265db9dbabf2b420386f68c1d720d9cf820f2a700cb94632bcc6565b0caf8f38c78d5032be4e27931da6b142bf1eb22aa3547b667812767c89c81325f4c628ac72f1816cc6c86e6d08fc5971b078c35c4a96d52d9cb5e5f5d5603f8f219ae60e9498d9716eb459b93f716daf6ba93c34e4c004861a56db323ee059028621ebe041746256e6f5110b13e52f12b0a63f4e0abafd389e99c3b153ad179658ecaab2f0be1f2469e73aed3e0ed6c635fb095dc73ba15c1e08031452c9000b35a06ba5b703db14f535e3f7929326557b6fb91f0789ab72ca37d8f485013ceae9bb3b1db097ee232f48a4d731ed78d57263b3c02d6837dc5111aa2285ed1b8a89fa8de155e755ff89fd0cf4099206482863df4a3d908fc311284fde5726904710019c8ff80034dfc4231bda38743ed7068e03d2d51fbc860d1530b64270f9b34d6f49b2a63258986641ec14db92c3e637dd4c882743fb17257da1376601e642259e649063499404b91d0d9ee78910677c4def9fac8cf4520e45673be619116d602a0fde73a40daaab778c0c59e7670cc0004ea3145962945b6ed44ac472b8e9aca8fa22d6192dd30c444df1effdee893a6f12c86e1ec071dd9bf13596a5fa8a63f922aac3da8a701d15c8b7b88153de9c5883c50ba206a03a0b2a4f58742a24c0756f71ce95f10c35e0a8db9ac2207a74e653b5f650ece490781e5950c7002248da433884c593b2618932874c80d16d69b2618ad0dbcb63016ba99a1513a2ad82e6c0d264c09f613a65786d7d3aab50a8449d053deae2ba86c4fe4614490b891561b3d1d99eec68b9f4ff79f2decde8231d06dea168040ed4338464e813a2cd3392931b210408cf2ee5527b94cab055329b4dd65544b779225b61ff98f6348abe84feea944ba0a8e7ab665ce2a0f940ec34b0f85a85b8862f28196ab747414ea4263b752f810db7d2009b4c5c0b0e7bd5f623fc36cb09ba3f0d580cefeb13a00ad045dfe2f64a39ea60ca3859c638982faf173549e0b35cc606b5da35fa6a22b2c4af7a8c9d439ace118167df0bdd9a20b375c54d0fac4abfc4a3f0e19276a3ece43f151a87dae12aba88c3e099b86ccc4a75485d30ad81c932f82c74ecda48aadd5c8d5ec01eaad32e51d55269b3ac833523c08df0ff5d11f696fe30b3069969d9202dff96f50c2458486c3065cdd97155baa93b0ee6798165b1a093af3fac694c066d84b647ab15147fd056855612494a7b684a205e477feab326bbc9b0094afd908504207afdebc62002e970204aac54839f37c044a2cbd29171b335229c4f96c8ca19e706a1468614f7a367821dabaf0f779335b81c8a3cc726916d97613dfbb6ec9d0d38c74c77312fcee7a6f1c4768498340de0e2c7fa30f6e6e3558721994ddaecac8f84917a905b50746b610e60ebe8645f0978b8186d469f18bada34860d7629df096909f0018ccc3364245107980e52a66cfb1e78933d28113463e575c39bad105df333352ea1a68aeb0681aade93cc259ae04d8f2ed04b8a71f9edae84e17c694c5993b2d8445a209f4cfe3eee3abc58ef8540ca7bb2eb9c1ff00c8d77091f93eccb3c7dcb583fbdc4b96a9442e2c775e1f4339cd557866490e69e055a8ed93444d1496da281dead605fdee62cc071451d04c5c3aba8196e9305aba9f002d5bf3fe964f83043c0845831ac1699e911a1ee64b9658495d58b91df2bdcc712c3f0398a1ddce9dae096b91e0725f48ede7b617bb28f34e346442a63b94b6d224ad3ac6085f117dab5f623cc5ca3577f5de6fdcb57a74ff0ca0612dab692eb3c0f0e3c09fc2b1d19e5c9c6668a8c7fd640b7197d4eaf50c05e63d28dfba8bccd01afc24495e2e6b46985cead5ee2a8b74c808a837fb0e89a8fa1124f910fb98c57224e74593ef48ce555cdbafdf6763c0ac41a9fe4af221f1f9183f738a6837d4e41b2102ab0b14e395fe01f5ae579e84289f6e2b69aa77cc0417754f9c3668619f5513df73d607b8d6627e806db8cbc758c2e619b883e83f88306649404ac8b25e938d9a623fab2856622fe697ba75cf89ce0a590261e47368676ff130ab0a00514ac2cc1dba2380e2b91bc4ebf0b036f507f419b15cce6ac25f86e90a2567315104465bced6868b653a130c4a5f8d03044fe514657ef0094fd4a3e65111827568c0e1e2cf9645a6719491d8789e16f6c3ce02972d5843cdc363ef728112624b0bd72fde03a96a0ab3bcd39fd7a4cc071141adcb156b1690e3ddf49be648eb1b825340ced267c962d60d85be189613cce098e2eaf92a22e55d372864d35c3172d87baafc1a1b45b651ede3666c9c0c7381f38b70f1cc0688b4a0768ae54fd0cafbcc54a9bb5acffe2d69934e875dd3da459c9e0c7db5890a72d089db02278fe41a2d015007138c54e01eaef4380d22914937fbfc614dd9840a4348efb140dc439e992e0f41245006e6eef36c9538b28e54a2440eb93c78911ce85783c394aae8f54a46d67f28409d279b8a15f56d3d983bb39266f12bf1c073395ec79e15eccf05ba8c890fe09dc86e1d64367c2bced10b7f7b4df46d0f5af643513c867c2951b58003d65fdca5416da408bebb312a8beb01ab49db2bbe8d1a56e86fa2b53fe945ca7e18b5117d30df14c6d3c543279ae7dd612aa28f6862dbba72902781334d2490743664fbd4fa21046bb5880bd657f5eec391c8e101c3d8877c9fe8cccdc55a37bae31a2a6f75f8995e29109c41279aef5669e0b44eac25b0864ca2bf14e6219a8eb5039d3ab004b7c3ac5fde0dfdf90e98d9841ceb228eb86c63e1ca6c34fa88004dc60408f06c1101187acb3d422466702d9d2c13300c8a3289d11e9d73f1618e1dbb188f1313d9dfd4a267387ad55a6df5d9b1e517a30fb41a8062d385ab0203534570f41f59310ab4fcaad5fd4159d769f9df618cf3871d8364cd06b74539d837c79e657965fc178a0ae9701b6909566c649a6f16a8cfbe9090875a4e23f71095645882308a837493c64b27fb2d06852a86f5e3d2c8fe2f2b18746c4aa3f77af43b7b915a40aa1856c057ecc1de53315e7a5caa48a158d330e3f068d200bf7d1d01259391da605a157bccb150873b5561686db91f612cd71a2c68045937a3c2011abd75086f2195a58fbcf044611884745b6ba240eabc996673b32f94bcb548c5f939bef25b0e8a7621a584cde3c08debe6954ac6bb6c3358b5f17e02e418f7873ec9ef5b7271cd9f40adce89bf7cbf2464cd740331404bc952047c8073d26dba305fb1c0242d89c39c8a31acf15e2f527a55a6c3ad64802e9aef771644b0e22a38527cb6c5c20c876dcf9b8dff3a7814ef25f21e37c06b36d8630dee905085c36f0d951c34a4f7d301ab763a62275135628327f0c85ed96e7266b76f678bfeb4a1d72263d9801c92313b2b3646334a8201258dfaabc5f06bd628eab2e591967f2f54080d24ba76a7af49d5cf523ab4b009f62729c558b0891bfbecc8647f454b3a1b9be66ca95a4b72d1acc647c2d60ff56fa9de90c6c3079aa6c4a58b9ff0eea179d665c8348c7cbe565c94853dee0a19697689ad61a6af8d7065a9c6c5636d9624f8abeda17a67527fa40df33327a3ce4fa82b24c4a98156f70520a870e8776c47997718425fb789fa1eb7d8a1e25215f10fb52993ea4ba8367272609d2fdcb6575402f7c4f964904b72f9589e01f53f46c193d00ad55242159e88c0c79d8d0446868eb8bd19f0901c54db20a0f74639610ae066e09fc89d73d6206912c117e3eeee3a3ff536f0749945b77495c02162632c14529cc21a09884af66c776cc4164ab1f9c1d41c2a32f467d6365c21d38fcdb1cdb2c3d8b12f4d9680dbf4ae35cda992e798138aceaeab28579ec7864a79defb9f1fa1634c42f02b5fadfba902e87883670e9b914138440d9f0b9f2361c37402bb7b6860943afe205c5599f45349fe0fb1921d97f9a127c415cd1ddb108792ab95610bfd6c7333a459532dbd094a55866245c338a96541a54a2a1d06348c7fead5ba2b4d1def921e5719c6a8a9cdc73130f63d071ffcf27e13003093acb972a5249f671469a0e12587d548a3f2b3549edd1cfb3c026e515e018488244e0f977aa72a221bb3db5bdc4179a5928238e02838c707591cd1b122a6d4cb5ccda15a6b04df45db518d4637e103d0e4d3d415abfe5ce0baa0a51d82e4ff40ba4a9f113ad652084d62abef73cb255fbd6a1fbe3478afc6005ba4205b47f64ae6af6a80c3ef86e8274aa679a9f60dc5ca980884c46e41b22432f10af8b2a04ac4a7b802d2a37009b0fdfb309ec10212e00e4a6dc9c068569b8c5cbe95fe49661b7b10b07eff5d002577997b6fcfea84503d6fc1f0998eec855f3594f9a48a7cecbafd3e845607ccdb1ac4258052490a6bd7c60cea6c7af6f7f8ff1c8b8c07cd457461c29a71312a0433877c07da7baf82c35f1d2ea5191eff1109e9d3e6b60c52aa8fea5601d1e3115254b57d961abedd9ba67be40a481ff653820550ec2790f342cc2be40caa7239b6b43602033ada4b7b16cabc5e26c7b92dabc3b86b9701e66ceae6772a5fcb29fbeb72b14eba695b6c247789370f6cc3bfa4cbb653dc53799119427a9c2d6a722afb224edeaa3baed9d686f071ac694192c41067bfac02e9e068fac189951aebe83a9f2ceef916b0ede019d0e5b034624001b85da5ca48d87d7ae39d52f1072eb909cdc093f3e7feb3990e2d6deddc7e1920bedc450438fe2862e5d5ca010f8bfda4b0dbe20f8b45c634fd388945060516ef80681b4a2c9df7ab709c5f33c90d4cc0366b03771ed12f2c1849d727d1f344cdfc9a25d6de26f7222be9d725cde2ba5938e48bc2a078ae05e9f492b963b3bfd4aca2c58ea48a952847a209cf3a387863786de798e50c7427ee322bcc56249cc141e1798c6aaa983cb0855729f573adbaf79545caeeb3feed84c35e5d902463c03a97310d6073a433b4fa3b88a62b7fd04ddc973dad9e87a71496fad68c20d0195bfdb71aa6b523553b5ef61000e3158e5b6913a06b773ea2a58904a769ddbdecc2e6c7217fb7d9308686eecb4c22a796aff99601af73b5eb0807fa457436c32e33dab4e64e8b1f52bcbf42ad059456dc5734a3379fa36331c9a79e4aa8e01f59043b579bf2461c1296a2a14a4cee46179252899b39f57100d7856d71d505234adc1076cc6bb150fe6b5b79a3e2b80813b27150fb879d5af690228d01b0755b47501617efc3fd981f9c532fc79560df4d1cd03350a202d25adb3880b88afe03d53e6c87b0b8c79ef589bc12dda3b7caf2f55a882db529e583595e165a63464dddbf3c9bb22b76eb275f7ecf80477f9a845751f97025a4a7a68011598e93a8456ae7b853e9e0895369124b270d031778a5c70177e6b5e388eb7c231b75c8b14be6bb88af27fcd7046ad036bf1d45665599102f0590e2cb8e955219904d7565f8be10c8f4b9fbb66c72f87fbe8f7e21212913c2f20ccb4d466da3aa996c46691cc3a08f9e5ca0d55af150f48b7bdecb000bc8fa808ec94a1a0efdeaa932f8b39faf063e04284721246201c82bd11807f5f08bb9e40cd5a26bdd69339482b16890f4e4d87f1b23f87099a58479c68db299a19cd54b8cac912771a413b35a0d89de9976a99fa7a3fd1e3fb37d817424b3ea0488a435649adb6969172b7ac7c7f497fdeab7c5db932ac14f195b07521e55a0fd84ab2ebedbd1ae506ef277cbbeb4859ae15d11fb37542db868096cc8279ef31d61751c179b92a5bcba84234cd1b30773970e09331b68bee49109eaa0307a23c3db83a571088be90f526bcc4ca88345f968b900c874af8a01b8111439d6ae49a7b3d81fc8d923bc2152b40c572ec84d23fa98bf217d859f66fc78d1af3855b8a6258ba974ff76832d164c561a9108d9933cc1a01ed7f01547526c396ae6b0691503075662e605e7c5ad2f1eee6b3c02a24cff83447eec309d2cb956a768925a6b3888613eedb0632bfc5fe21d720d2e62aa90bb6ca0ba4f0edd6d89a24bcb5ca10ad0976eb09eea0f8613f81624d81ed3c3a770530cccababfd78c41c3d6c39c396120a7cc93afa8c91200e1a463a3e98744c2327f96a98c79ca7e8a853196a2c99bf7579f7f93af22124084027dd16c62f252108ce593d74a7e0b1fcf9a36325d84f322710c851c7e704e61f3a072d85f84d7722dbc787ef55eeb84dff9df5d4e038cf715929ea4ed2bf52eaac6e6cadc1c721ac0e844812f0b2c8be8f9689daa3e193f7f8afebe724404be98d2ee9cd003cd3dee24f67bf4f5346cef47ce8ec71ad56cfe7e1ac3c7da341894bbafe98cab450316bd6e1b4368470b9ad452a12c654c7f082904524d1eae53d56e661bfada716e576ec26d5052794e6388d89d471355a120691f1d46998d187fb4dd9a3221f12c19b90061db21eadaec38aa07fdfc725fcb497706c528b348449179693eaadc087c2d260877bd4aa6ec9463477606db3433b7014ed56002986b7ba0dd893995565eeddbc7eb7dbba784b4db2f03925187772be49d0b9da8621f0e1f706fe539ca43be7dc19f7e7f93a789508459c91960519ab494047edbce7688d7300c42a7c914704ab2d319358009fd77258e4930b4f7ee758e4255284168c062642b2284741f22dc6fe5b4bbae609cd3fbb6ad9d2d51575075f580699291346b11d124ec9836b90946b51934c924545a8abadfa643565e7c82d5ba4cd65817e3ac6b3ab98a719cde46467c16bd58552d148ace8349d92c9fecee7f08eb1b42d1652bb38cb3e652525cdc95d741f141cb595c337f2e985d0414c45fc0e8fb150e53aa25a73d3a9fb49028cf5ebda4d07e31183ab9cee719b076febad91823a1171964007ba49c5ec657931fce6b3278727d0bd5224ff1f076a5c89ebeaaf1c0baa2c26025169f6e2d52e489e9a56739c16353e7fe0a69bf778540c1f0cd37b8204b811a977bc2eb0652e16e3e07d3d4bdff5d26a426bf0c0d3a1e1104b0c89262bc78f70e9dce14099dbdb8c235188b1cbf24acb390dc4f106e64ab1cf687aec862b58c80c707095dd6d4f2e9714b636ed57c50399468dc683dca94b34a02dd6ae82a691f679616fc99061a58c4a49f40e555da9b914110c23d1a728c9e12563b4eeae0ac2509895a35b062e444f508e7f8cac7e7e878f382e215176ba8e350e4c2d7cfd63634002ab10e97693f7730e4e34f51e6c0e089f5193ab1005d9c3961fdef33f1d8a7d67c0e5299c41e5e6bee5ee6b9334134415fb1643c83625da12831404edceaf77bda866c6d9da622f6c162348e6477068e047ddbca92477b73ca9dfb5665bd0b8255e45dfa8118f85a51a3f138b13b36dd57f4b80d19c7a00e898c47eedc61f942a6d3cc00dfb09a87e288dfceca12c2b0c82b1081b4bf6934dcd07d9284f9724d10545f73779904f4017e5f3af3f2c6948fde9f1854a0a826e1b990575c1d63cee5b3909c088085b26dabdeabccdadd55ff1a77549cf9ba3bdb89e90909d2159044dc81c04fcabd1d457ef93ad8657efa70f46c8cdabceb8cbe9473aa321c00df8517eb6a075c2e4fde87864b31de85b29e2dde8329ac5b53dabbc8a124410158805d2693ff2649574c3140ea00edc6d8a0ecebb1cabf3e338a12a91b3966167747ae1bd8f4302b674c8331b77b0bd8ace32c51a72d65c6437d013d61017039331da984e2608803bd12971954eb9eab58d9def0c523b549d4f92080f7aa91f6e2e43e28f2cc0ab75d17705bb344df5a0cd38e52101fb989ad943dd3b8d844677113deeeb3560ed1c52e48a78426e65e65b0eccafc911da5d82608465420b2957bf4d62b817894f654fe7b080786d360c9599047059ebcb8235984e985550b2b9c5d434402e08ac69835bc18f3fd2934c5493ebdb36b687639dc9149b46e9d0bd26250ad7b00139abecf08778d9473fd724e28dc0650372efbd91d2137e66a1def31c586aef8efe62a86e2f9ad43d5c87da3f03184063d7448dca07ed4142fb536eb1137a40152eed481ac716d30d228d3590cdf7a4edd5a509a9bb0d0f2d946b9f985793dc132313bd7678eec05e711ea9a17c7238f0c40d4a542fa8987be7e3e2f407d504d63b853a7f5e5b9a77c5d37c9b346c5d88d3981b85ced90a574eee3437779cbea58f0aebb74748fc1cbfad52631cbcfced09b0a42bfa7faee07aedc9203bfbb9bcbec18008330c54636acb289f548356c7c652e5b6de8c5553a6a74ea39c34e2ee760c5aa5180245ba69eb3cd4bc3bca4595b03a9e4208b5690265373e5e0ae4c27508880d15fb3fe1ae7b698381209d51296e5035b1383d30b5a4d1dd112259419914a0c4822c66d6b47f25559d45ea6f239670f67580e9e105778a318bce076d18001785dbf6458a5aee17028c5a856f9e847d08352f8dd0b01ec3fa5728d3e0e135dce731b3b5833aec4665fff4b168c08254201a92a68d2ff2d0dc1a5bb1c1109a1c6c63baf161ec9a4866a7f6c0d264d5d901ad85b3258e994cae3ca1975eda497cd9b5e9e279b3ec007bc8739015a5be2606809612ca4aaab4b17e25aaaa8b36e96739121acedca160f1246c32f74beca66df0ea373379259ecaec1045e1d50eabde3b06249dc1fc2554efb5c395ce9546aa2d612d6a1d6de772a5e9832ae19aa2cb48edfa923c01930a2a7de4a93ec927915ae11ac9ba0fd179d7af6adbdb45a6e0ddf9e9ba04424543bbbb49b1a5d24ce09bb0e9d7e61cf9acdff9c3d5eb54363b6bd727a0bf3721c1a22121823e832852cec222dc75ac7e6ea14e9d4e57f51ce5e728e3e520f55306495dce803564825db5d6de81ae77d3b100591e2b4e0dab5606d5b360b02884c2d41ffc219395ea6ebc237974f112e994e463e51d3a84be2a621066bfa15b48dc64e89105240869b453695da85cb321d47cbb627b18b3ef6d3a88ba1693cdac5b126fbaa222ec25d3a1a5eccf4dfa1d78344baeb02c291691847574a534cc4704929dd1fe2cf4600df29d8eee2e817f90089d465da9af5570ca0ed5263ded813ff9580654f9a9d07ab5b245d4e7816ec7aafcc90f355cae61e1a3ca402364d3a72a2bcbba4dd1e4117c77718f6212357f5cecc02d5c4d4399fdf49819924c458129953362f6da3eb25abe6a63f3b8145635f3df12a3b34cc57f6634612d58583d71ade78ffb17aa43e0cdcdebcfeb421c5450f17664eaad4ce2c86b97f6f980970d037db137b0635ebfd263f3c6b92284524386c83e183a7af3277ced0248229f7452967cf90f811e788981f6c9de35dcff45ce56f2c95561bcea6e3a6bba1ac5f8f45d969d6548d812fd85708eee0c1983c2293b231cdc86f505f110f7f15a3d565cadbe84b53fae3a10b2e9a491ccfaa8faae598685f437712bfcf17f47675796ad8ecaa3ff4dc29015f63c0a4fad63bba5677219bf14d38911d76a06db3e95f33ba9c66b6e8acca21a491337ec3c798d8d3df269f21f691cdb470a54cba6b42b5e8d96e2fdc3d468a5e2afec054164d462f9161345335052e4a49d31e1e400441e9149be1cad6782d784458225d1c009416def21a3faade6678664207f761fdecc7e5de9f9a0828c4566160b1223b14d4a8d7a250f4cdf2249f3ac81a1ea9cdbace51d50802a1b817cac91abe7c1249b81de5e0e41be64f8c737cb2ff01efa48999dd449d3470d89b05c7ab77b618a2a6b6372e9a671037067d426ea57870a024ac04e690b09aa2b1248f1a0719d894727a92b41bc60261f2530eab73249029ab23e4e97e4fcd5d1f4099a07f080a2e2684d845c08ed17a737ed66b1d456a13699a0974b36a46be0a0fff34da5042b2555ae195430b642c18fc1ee61894f9581b72b4de11d2352c027e7612750b4c43b64279e622b92422d7d482fa6dbec5a60f2e8d402a76d48503d030faccd29e68312c6740b1ad61912e561856005b6077daec74db47a56537feb7385be1807f610eed8f309d596abf056d6a3ddf79b3d2633a47f176575d738962aa0730eabbd11c7211b758fa7c478c4f56ae1349c19da1237ddc47bdcf3d3f1b32314ae8cff9da6244bdb99b9a61e8563736a6292cd59498f80f754e06117f2cde0f8c33465dea24fa086c0dbd8bd77d1c050a81312ec7712ca6fa60c3099bede4949c2ae2b6ad96ad147015bfd90195c351d340e439986d410ab9fe80836f749921ba6544daae026c7b0f05bc79c93fad37720a2523023693bf622ea0b9b0a0059d87c15476af59b0f01c77db94530fa1a763a5341a2347c3d97f6ed308bb5c9688e23814a24276ff9fd26872eefc1752c2e061382911507528df0031eca97e0ad61b251595d1333ca0741fa635257d7d68e7fe5e9797971c323cd71d7c00ba8d16d19b967dfdd345ee58e42b6da30bbcab422377b745017cd740651cdbd7bd6112e27442cfddd8681be74fb763786897f4ca0e01f8835ca44fd667b87a99dbcffc57f57aa737d39bfb682f09e457d4ca2694cdff0a37c55aabb8132fdaa159b2f2e9e086b2a4e87deca07920bd71a2bfe1ddd215704ee5798bc220c9c2f92b5e601936c936d0bacb7224b3a45af90e2c57239e53d0d9a090f06f15fa91a228cdeacbdce6f98c55b4bab4e17e7a31008b6a16c49bea1d591e7d5de39d012dadf4f028351185c5aeef7611916af850be835891fab6651b8e8316a967c2916d05e100bf95bcbb29cb871e6900fad26dd3a009d490db7b2996ed974dbac313181f40ff3221b058db2988d11e48f395b1e53b9ac02b791879e6ecd78408dda879aab64179d37e2ad606f8ac5ba3650a9f114d449659f10aad779da25678ef2437ec993bb1b49f9d4b2f5c16372c9ddcc935de041f2d910163985e98c151f49f5832a2cdaa252245b77c589b97308729784f021bbc07062ff941a38e5ad73914b51d0dc2b830b9a1f447927a04ea6bbe4e85d8f73c66d8d92ceb7d3e8ae3f4973ed52eb92fc02b9b41d0828f2ae8bdf20096cb2771011159ce19460894b5ad1e74ed7f630082ffba76e9873e516bc41a8e467f1e1b833d42ffd7d401f32a4065ed4227234ab9f674a5f6c55054223a54d0c179e250f829da3d9c155780229e70d4063a46744a54f08e172288c90a15688729348a9774b3fd7b46384a4347c8e71692066b14cbfe75d2c3b9b239ec4a52ee0b449366f72b556feb5e6cf23d995644d229f3bdef2de4646305fb5a3aa167d5fbeef4e4b8c9006786d9973d8ff03e0dacf6d3f84c9d3a7c873d1019663d80a41102e92ed0af6caf828d2089cce41b636101fd7ec1219e184be483e59c987d89f8341e414207deb8ec419893ed70786d4d17ec1067ad9627530f86f48fe1e2740bb38c679cedc10697ac3b950469d84670ba911ced8cf953c9c3f4a795092b397f9a601a1b4ebdb51742a866a8b44bf981cb4c9ab92cfacbf8382f03a9ac8aa3295316127bd2e665fd75229d94ac6ed23aea81affbc02e463595f0523be076ecbd66d261160e9b6386f178965fa5f00e7f0ada8bfdb4a6161667ee03b802c913d245b7bd81f516619a384ad8820ac93528ba65a1202f1f4fbaad3a1c900c082448a464d058b3ef8b01924ca3c627903ebac3475edb51cd238cbeff0c023459e838592a62cd54ea16fc2175cf61fbb5738bdf9bc4ea19d71a763d125914c1680aa75d75e73ac11de01eb9ce9dbc5d5d6355dfbb2d8597c83b46d30bb079f9aab968b201e54491093d6b792ab707f8e82a50da4979e6e9194d9a33f4be21ac872c663f8e66e739fd9329000a3a7b937a52778d2a443849dea735ace0ec25f16ae8b01ade5f0cd4a60e52cfcf80983cb251ec2e446e35d8be711930909e27aa6e6853bb4c1b9a14283e285b4079b4fe1f32cc969fb8ae3082ef30255934bb0792d2391ada62eef533fe8d07746b1602d60194fef6076b88177dad9812754a55d0042aa44b07966eded245f631e1485773ae0beaf9ddfd75f991d0ffd57973b502a2ff625d7026906343f8297ee82d0986369b63f4699d01f691f5884e032537092297e8ca633ce15d1cb355bc7c97e81cc87119d777bf7f85facb57a862671d39755cb4d908db7a9ebd199c2421fc65f3fcb79827b31f7cb82a9ab27b14e54fb4cc9272f73497e7e2cc7987a46a6fc64dbc1a81d00994296d7f87477297e94989785eada680ad08aab293effae2fcebff35046b8408f2a1c6b60041b6c4f55072d3454ad2674af6046836575b1dafea4afd74dbbb23cb81a37e0bb6636ef6ff72a71e39d6554193a54e1d54b5bf73a14ccb75ac0ef5a3a2824fd30349cbeb8755e10b9a29cf943ed434ae1c8266b03f3b1b7b5251932ae892dceaa17175673b9771c1136a231370ea846dac0e85f8dedfc65753d65e0e4e93e1d0e2bf489abaaf6e87ec7617ac2de0ca7b922ec06dc7499d5a9e7e5317f5aa55e48e86d30acedfdc4945c7cc9b2fd29d29771508a8a2d7fbb959766d6eeff9dc3188354478a847cc24afbeb28cc02423f1426e6499db59d8483633c04480b432004d90643cde6f7130a40e09cef6bde659","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
