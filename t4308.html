<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"feb29c8dd49701d9086e98b55ab82ced2c9d86724f48ea3cbb3f3883124c1614050327c9a816058ac0099ede5511c1f138f8533c52a3a1d4b129ee3aac31889034ae2b5ba704ff0ab45b79bb9d4e78c6f643f122652ece4a2183d7321903f0c7c17c79373603b451fe393b776e79148117560707022949a2ccd20ccdbe32219c2ed637250c16dfca50c626c9c612c34eca96e19ea8803117c73a5c55cadf367b719449cd06fbc0ef488a3b351950043ef767b0db12c20a083b2e0832ec4d7aa8563ad5a2fd05dce96e522212800640c9807b2add6a66283d84ed415e8e328ffc4a96d9bf94d07d3c6d06c92fa2ab859aaab3330751695d86a86f281313cbc67641805e8ed99db16ca4fecc24b0354688c6d5d0c13842fee25bdcccf918ccd43dbdd3d02e91e009b21de19bc44564c240f3a39eb162cbe8009fbfe40c21f6ad256b806efce5934d908918a9b8f2362a9dcd421170861d23839e8332e504c3d3ece00b7da0c0051ca2d8a25a59c7b4677db64a4931c183681e6742081b8cfc11d6db56c0f6371005064605f722c8109fc0c5ef5f642a5101f447f2ac7fa25e65554b257781ca37c8ac6c96d84d4476c714d341bf762494aca5343b3ef8fee56a6c1f4151ae6f3de1616ba58cb5dd69ddfa3cd7b6cd756a6b2464c1045fbfdecfbec893e5ea24ad4158b1cb58bf0bd93046d443f1aebfbd4825da73e023890df71d5cf29dab583652b1624687b6b578fc90d265b258cb605a4f3d8c89d05f298094afbedec2ba14371d878e702762cae35ab6195c126e6de4c66dc0eed918551670fd745857a7cd54ab7f7471a722143b7b9972b947c7618972cb0d6d8d13d3eea21353e9275d1588d2e9d21dee65a2c60d227070de19806f38b57d5d90ae1fb32554e5e3eb1ad6ed77b9a93c0c1d2749ade8ebbd37d3372da7867abc734555349badd64a1616a7c56c63718b49da8acb37d56da718bcf5b100ce67243156939c41bc55b1f928aefd31a69b69b4d20c489f5a8b6323d444a0fe22568089fec174b8f05ceda21258fc5a7c25877077a8d0a384292e9c5f3c7b79013f9d965cf4e24752203f4289b6383cedc1a180e40824a30c8b84f4ca00c69c0e1ed6cd7fd55e622fbca29955bda9949b3df543a08a73a20deee1c75c477c49975bcacaa2d51097daefd13e8aa473e9988f6be2cf1d5863116f8ed76793ff5e38bd391da6f163756242ef7e9b1925745fe00ed8a8230d1b3ebb81dae4e6d041b505c32ddb877aff3d00e2a4d651cc4c88fa578567c78e88a6020cbeb3c1ae70b37df9390a9dc7b9f8fcdc58db5ebb694d77098ce5c646be85b89a2a81677e47ae62b8732645df3a2371dde966b942b1030e404cd8ef91cad122c06fc6e14aff0fc42696614b911b444e36598b92dc9b3a9dda8912c63a0ad84d357a0ced831bd060abf992e205f6b176ccd8d018be116400b3907fc04c8a9e9f61d4f7236adfef507386f084b8e3551ec61d0541cde3e188ea91c84b00fb79a4c71bd05801d4dca4be96dc1aa9f7b54e4d507fbf6c41cf4eb0f1af4bdf6783aaef1dd242a66594465fd4a0a9cd76abf5c00381228d8b4743682c1adfd0776a93b7f66c49de27c92522f344260c00925ff5f729beb6af28209feb249fa224dbe494b5fe2a510dc7edbc44ae85e853a2196b94037955a86a77dcf53d9074f2f1fe262426ae1385c2d5579257598d60ddbcb58d0b64974641d786f48b7d542198e1548076036a87f8e2943ff6348eeb3d6dced80526b3955310a82ad7dc8e27d1caaeee457b9d5c5fe8d7d7ee9f461dcbab69b65d8972e02c67b9169047b8fbeda5e8874c8cf3f713acca224fcba8840938c78398a0ae7b69efbf2936ddcde13432e902bb0f96420691b9197f487319ffd18ad726c9b5f3f075cf3ea8405118b6536c680ddc11035da673cc70da2dcfee2752048fa1e40f3304362d5b999eda52a12740da9feff86c3002e6d8072b64009b529c0df81b3ec0d8b83bc72998bac00c9ef5bf846ce4f7e2cd008055b6b12456460924722ab7bcdf417afecf12ea5e50d2d295ac260ff0e63c27756adc9dd2d2f22c5426cd5b767ab1ff424f14f1c9b13ea6e7bf462339a88eddcfa95e9cb1b688d0c4bce30a76270eebbd84dd72cfdfdb46f2a68765f37c1d16ed5f4113a175ac041c888ed92ccac863ad994f4f3a52b85d20eab3d1970dcd5ff478af816f24fe6c853f7295c8a120d7a3c6c68d74098b70aa22dd205b2fc800fa7880eb43c6f768e1f63c67270b8c4e842e11609998d7d91d121071ca31effa3ffd520037d222536728a7c5ac0bd3b5947abd1f1d6c04740c41a1488ccb4571f989b45750fce0cd14cb1e6c279bfe75f2078b4d5cf45603315855c1a91d6ad5a5c1c554adac57e4af8989484473e30f3eb62a50d61276776d826b47250a977ad456d9d66ffe3dfc83c83c6c069da18f0a3ae785a258293434a6a0efbdf011b2c04b47a9718faa43d0aaffb609fe7fe8a9dc61893ecd16426c8614ebd4bf1015a927dc63c57c74c3401939036e258b4b69f5f99cbed59b6459b2c57c065bdbd7c2d84555e31516771530150e5c633072865f4cd52f36b3cda39027325a425ad8be74908755615252916a8a0313794a7f7c83705bb536afadb184869399028f32b00666bab9c5bd2b549d705740bd4ad12310b3ef98624c94f13dc9802b591499e143b0138fb89780823ad88985a299f7fbbc7227b64ca05e743547f53fd6ce8cd9cacf70a788d24c8d991e348350cc9e8a4c99144c7d71f6f63f0430a06fda606fcbc55285eb61547004201bc07b5e620cd45fe479c4c2164c3d0570ae04a1d21072f9afa42000f0cea4a257b04839575bd8e30ebb8d91bb63ccba41b46e4cfd533dab466b02173b25cd99035743b9510b93ff6fc4f46c1b1ecc2c6722653b17419a355c1c1c16933489fd8c1c9b807d8ae4a8fab1835986eeee17909446e644c32534679c515662dbf7cf367af51f69555a0ec2c02130fed172690e2607e38a021b2fcc145ed71ebdb41f6915b0f65ad5a70f812fe479c4a18a2687a91af1c780756d88aedbb5b8a0520c8e5eee42b93ac72d2112aca8356fc66be920ffb347f028960fc1ff94846e48e2cdd90de6eb2c1019b16b122144157c801f5e11d2e6c356d3b8bc091730d0c0f50c6a12f376094b8eeeebd6810ec4e7636c41b281a3ccf31a0a5f8a6bb38cbf420f9933eb2cd8c0d3d8ab3b553c829ea6d9bbe7145ecac5bed60f4484d0db3bb108414a802e793c515ce8f595cf7b4437adc56afce993af03b20821497ee1b918ef6275eba47d83891f47756895a6101cd5e4a85cdde255c6f89e7e3af94d228394bdc3e471ec32ec89a30433d29c0984997e1f604bd2abe5264ad5afd5ce205b9d6ee13d103e57480f14410fc968f81ae3b8d6964bec3cb1010ce9c1ca15a21b63f7c1dfe8794a4fb50da1eceb360c880617164370869f981bf8789005a940faed95202cb311ec878734babcf1e6aa7fbc9aea61019fc3380d32a360395e00893064275ccbe56736b6cac514438e8b50d8cdfb91375b9b63384813a728556ecbf16dabc2d3bf38b1d0fc5510a5f20f4d58674344716e79b19ea09d3b67830688490662c01f350556255777dd31d806fe5abf4ce8430f5488018917a295d8b2f2c219988d9bd7a64070decb00743e43702300032aff93ca71f9d8538cbf539e1665ae9205ea5851a750eeffe236f540c159d6f4a9f2d19ae33da8b4947e4b13ab4f0944980e66fa71bb4fef6338861efe9c0e461aff2a80558e12ef96eac42e4451e2685be15faa0c8877df89d9459633c3a8298205d6d0ca425907d238266b0ef75712b84565ea309d0061b69d1af998cd75b425f6f5fca027c80cad92e8c79e40f5f89e012e02dbfda2740d48f8f16b7f72094e46d386054b5315b4f2fb0ae410c63e3ca75e127890f476f59b8175c5c07eca21471d81e5de1b33a1b34ab6d975f9c25d4b7bb960dd64df14553e44d78b4b8b48163172e2af23fc3616f2a4304ac89f934ac3f7fe8421f4289c589c59d0a9ab414f9d60a0a63186d020cf24edce856ca2236ffecfbaba8630fe1483c755ef2674d5fffc629d7ce0672584a7fc1465b9cdfce1b0cfeb6b889d6156f1c765183d876bba0ebb9be40bc0fe0fd8427b33bb5a01fe533c589614ee205a98e31a8ea5913ce93394cc5308b302bdaf95e8d5c4589d27709a7f1a90e0bed286ff51a83a98a18d58b6a46af860ad4dc5e56ceb228055f73ce52c9abc8bc222df5730c235766d4125d521e50fb11c3b9cda0e0522a39f5e84d3eab6e9cf7cfc3eccb9e755bbd0cd5927b37700383924707aabbfd7d3faf2cf8a7ce615549bc331588ec002a3e9c376f3c8c74ffa808c2855543a5c859b18ac23490d9124a91ff7108d9b0cb3b229da6bac51db317522973617ad3a3307e2d8ebee50dfc5ad476fa1da96931048b5cf7d1a8f88821c658d3707efc8f2884e67717842dba0c9cf242c7c5840397cb2dcc41d504dad064846e838969a7cd83c55b16f5bb1f594b34194015cee8cceba957a81ad1fb3c740a83d6ce3fa5ca5db21f289234ed7affbb3f9bc50ef43e2c74a3041f9dc04992b32acd66652c372addee1d6b9241ed671207afc4e7e65348728727bd86f59ff51c3ca9bf11cf62a0a6f9e7c5f06343d089e211d22d7fd9c415ca6e056ab4d984f4aeb28846115db8640dd9434cbd408beb4e496a4ffbbf4b131f03fa7a83a95fe96b0ccdfabbfbc9a9446d8702d03c7c38b7ab4103d476ec133b35d02a9dd16af8916ad5adf4f1c738255e56a238f90e95b29eb780d13ae11eba9bf804a7b376e33ead1b8f4d517cf3fe64a5b5c308849799b23c91a8cb8d913c45c00bba676d3d945f8f6cf14f2da1d26c5dc9bfb3916a664f616467c625725d97b8adbafec3f8f8dad24df7348c27511c17777e9a131881ced631662a8bea55c49e5d9f4763511f0db0eba15566235dbcb2f751359845944d4ce15a94971bd5514ff04984b00f7d824fc578b6d9dbf05ae8396821d9b939430f710136420f0282b8f048ff79dc03d58647e82fef34da39e31534dc290818f945c9074bece2f8cdcffa5423668e6fc67a78a5accec0307a556dd517f60b22bb22278f2f24da2bab1f588a298ee7af8989a8d96b158f34f0541b452690137dabb68de63981fb2bdc959e671af39d32989f19ccd048829438064653f4cd74af129f4ae843d4b7b260357419227d7deb06d1c925f53a5063366339e4b4855640ac3da7fd4223203247744eb8728c818d91ce6d63979f9f51dc1aa2930fe5d6a49430f4e842956f1ca2bf2c74157f2bfa32294bd3186fd0a68e180f32576a0e0d9d57ce8c7aacaeac2298b52a8aa1cb22735dc8bfeca8f548e5589020f25f35ee71a996c33e9d47f232cb16832eaa698655256cd633df1ce8e7586c54ddab4f9358a5e95c1e2d42e14ea9fe75f467535bd99c055a93017f7532a2a3ccd26d1c77e9c1c164089f348f229cf8775673358fd1e583d8d40e72151ee2348636d7ea8599678b462e427665d2c9176faff8f2d055d993eb2376b1ca3e720290422d7945dac11483a693095812c5d428cf7266670a0753953c3f8db84eafb50c5da15c0503c40b8388b5ca4a3847e3a710f80d6d06061c23261f28a03066546337affb9237d0c9d21b8f44c253215aff0fcbfd95b2e775495c9b7cedbe3ea2c5da8e31e29642a30628fae93e427a593e22f24842cb705b72dfd47a5b2f40ceb8f59cd5d8e27d72f2dca026236879a4d2bf40f315a59efd0636cb4541a691a8071074161c311c91ea46f0feda6e84824ceba9d9770df1f8a312c31a7ebc5299063ff32b672e90c515cfeb3e74ce427cf3312ee783aa2239e608734c173fd681d2debb7700c99a5ee1391a2c813638b39e99445650712fa7f3482d6066a2dfc9993a39f264f172ee29e3ce3d373aa5a4f878b7aecefa0e16e869bb478042067b157be31463bcecca155cd8e2d18f7d9df3a69bd3fd6633b3d4cfbc8aa4d9bae0dded41eabb2492db73cc49f6eda77f26d7939a098674d18660df124c29c67a847e48ef19283a570f7aefc91fc2f205206f3414eee25b6e7347db807ea6fcb2ae9248a993d72b943c4d2984c8a5c13a7fcca1d99663734c64cbea31d2eb7e8d29233005c6649c9c4a795b4ab81899be21dc656cfabfeed4d8822f66018805420b72e19c07daff3e83be5e41048cf1ba0103e66f9195d634bc846705dc7a8d675238bb869616d1d75732bf535eabc69013c0923a5c887e9abefdd81291029728a467ed64f9c59ad55accaf50ece1f6f069d21d84588f6c5d4a12dc5c563085691efc6305776c60aa63f291247983a817f53baf158ed6f94b19f823f19ec375168eed5546e3f19c1f4027732bd6660e2f1fa7bcdd0730831181437bc944f6e7d4808aab8a3585a5508f88ae97073977e86de28a6189dc0143a0eddf9712d20ed61e98fc7ec4b65375b48a7e9b526cf1a342edb1455da47c69cec601654bf815229502afda0d65945f0d2c8eb0bd466ca63f3f9ed94ffbb9e9974edf8d3e7ea0eacf27b16362b9dcfd7bf233e023a0f4d2885de85a417e7a7ec0dab166afee672fc7ff26869f4ef9b467c42b7e7bea96fae8b6f5ecf0a37fa304019e5079a9946c7f8252291ddbf90b06371377ec0d57489e200ed5b1957d3f727f98f2d73f619a6e0899b13702f2f1e4efe03859e3c726277acca261b27290733893b90a3e7133e7eba480ccc14fda5e46334b7ce4dae7e15d94ab5e3895d0a28f8fda6cf684c601333a081aaf4693883ef8811e85668b70153943a6465d600c4c107ebd6e48b16c3b60154901997b94ab4739df395610cd6527eba08982a730bef4515841ec85a50cace69ad6bcb2d9a454422b623016add12aa181978588e678e87ea68dadf8a52eed549333c25eadc9396aae5712c13ecbdb25d396f4fa6708d3bb6d8bd01c0b02041298508de1970aeca4cda9422828d58400cfc165155091affea8fa8442a1eabc97bb94cc275cd0af3371ff8a61bbed723746abba97a7ce4911765f2d084dbf5f15b0c944b9303400fe352264d16e026dff1f2b027e82f0738b39b57cfffc0dfb8a1c01417f7bab99109346ca1746ef02eaf9691f754abbee23d13b0fa76d532ffd65f590c7c216e7472cd155548d166b156d7ae388aa8723b08d0054a8b09346ba4e726c45971afeda940d95836b62fdb65913bb4bae1113b705155d38a241b2be075b408efaa344efcaaed892807506a54efbd932b76c9ddc03a115c47ea6c8a143dd25e7ceb6e4d45df324f63c21c3c24e62862c4c28ecb9361d172c08236265bb4680c805aafc5ddef98c00bc033b021c92df2d0dbe755aada8b1d04f55ce3a36582befc86ce555d506fc77a199b3c6eba04781b4e0e4185656d0707e55eb5344ec2a25f06590f16a13b13c7e1e0e6a3cb48b6a38e5ebded8396b2e46dfdd528257aec4c22d05c73e45f178c857459b459fb29a2bfbad885a4c067a16df164753e13df801fa95d96e107ca31a53ab1817728f6d820a439d0506a63a0d2799c670c10e74c650194378cd8b495c74f65c6a4778741280231ce7ecdae72e5c656952370eed3fabf9e28166de783fcb81ee9171b8d6a38bf3791daf865a1c96d6f10911c45c3d1b84e3f3ce35b524dd4f9937d63e2adbb1f52bc8fa2cf1cd3d145b975de509f88a758a3af63491596a73fccfd3b2a3b24b74e7377319a5bfb5c8f895a2e79489ec2e3ec359b49d2595b741aa543d996122c9b913edfd79c91f42e0febf5ca0150f1356b64c8ad1abe395c180a8980d182c003e632a66e31f2a211d193d88d872d695a88ddc36f96b124904e1335d2da22331480190a580e2b81fdfefd818ed05d2478448c16f3cc619a6473b1ff181a4058c87e0f53e23af07f72b372db275dfe952519e199c56e41418b2b64d028a60f7c7c924947229e0eb42724035974236aa3cc95083a6b81e792a9b51147749d6c0937bccf20d15917d771d273167753f0f4c0f95cbf1586630f247972d69250886f1bb5f05fd83428b34fe4a42b88253c4c21f63d803befff5afeee2d18c826f3dba90d3fe986d092ce59a6883ffe59b74f8134aa674675576619695a91786114b65428a7d79ed6291de5e7284eced06861b618db0c5b14acf6fe90379923000f2ec2ddb80ba6d06e7723ef8a0e37547e9aa4252ff5bd93368804b97974fcaca17d62cf223cb3196dcca8d1a43bac7ca9f919a27fbf6dd8e329db081866a1d241e1a4aa5c7e8b8c1f3925c9eb0458c93c823b1184ca2be14003d313b979b51651e05de72dcb18de0e1fef424b56927f9c3392eee6d877de4f40c15c5356a809120db869a6df2e1742f86eb06f9a6e305098124a4faede2943ecf7656bc95364cdc475dd1538cff9a7930598ad08f01e26e911979f6ea8719620bc8a704991021f96e213862c20757bff7325d0f7dd68f3dd70e062cdd3c20d7a64b2e5b72eb29deef14b44c99a531f8f62f00cd45327f24cf7b5778d0f74652a5b70850396b7675f5fbb399a337a6432bf007b699237daaa64f25664041330d761c0ff00fef0b16c00228d4cedb75824d2e8446a78dfa289a1889e59711abe32211650f6fbd5e74a9539b7389ba72b04c0e0aaa4668799e4b17a75a067a327147968a6405def91a1b0c53e5f06b4a7af6d0762cd284712d1f4f429f0bd626445c3818ce9ed5597e6d9175d713ced2c76b1d81832de6b0f69870231419f83679f269dd7e0e454ccb6fd0664930f4afb5ceb981cb32a55b14147626f848e22d9f4431c6eb8dd26465720464d2d5c96fc224044f3b491f0e92d5dffc77827fd123e5ee747469f3f3811a703a0c0dc1b0eec21edbe7b6cd69d2f920afc7817cfb053bc302b82e4cec339796b48d94e568b91eb8d0a8da2873e147b1a61b0b7839ce4d545b2cf03634b3de8fb593610536352e4a9a93ac07b15d2dab0cb2e2ea6595f159192c936b747d1c5cd1e2083b3589592ee6bd070d230bb8d981072f959bda558a3a5514dd2035b58f796be53c1f79735fdee6178ad92f72df1a504c18acdcbeb60948f2b85710ae7f17798f354d7bb985f863bcecfbcf6513a820eacc7d812d1f1934f30ee0521c0b390655d1a5ae2e3f4efe1249f7ea133adb5a5c08f8ebfa6b49ef72424869e96f2bacc59b9665646cc6c48f51ec15053c403daa5c7686b8fa00aaa7d391286ccffae7c343a84fa6160fd730743739c2240acd63e224e661da983a46f26d17b3816c8ffd6722ad7acafeda8b6d532281fa8f7a4dad0628a68ffb9cf644318cff5bd9ff18460b5608709b4d8c1260302955a72801cae0f5a1cc7180f461e2dd60fc704c1f62a9baa7b465bd8ea0990de88d46389bc29a4310d1cb61f8dc6ed2e34062b177c4c089543e94ae62d804636bf134f7a35980e98a6e5eb701769d8f1ef1e822eb20a8276759dadd61dbad754b9a8f8e4c4bc5801db4965fb16f69f84257e3441e0a58833568cbaaa066c240c55f087c776dd6e947950770f61e11424462d1031dd316a9ec608097b5fe7d60efc35f3781ea046e6d92cfd712f27535051c9dc42f722aa8981e5a80ecff89759db252ab894544d488c8b344bf9f228c612fc1826d70f00e7030a9db433c072ad303e5e3cabbd0f363937fdc5328976a3dcaa36c8d1a2f1052daebe6c1a4243fcd89b2836711257b4456a0e2b33db96a45c1971181170e76c26357eb5a3718e8625a2a6dc29eaa4fc67c7d4fe9492bcd0829c9bc42ad410a19bf8fae835ad477862c592dd5a36346ce02fdd48931497c3549863ffda60a319c4fe89e74de1ef4508d692ccd32ac67377cef43a1734a0d6a403ab835932b61474ddc421b9348e13046592854cdee7f03bf3ea0e66e5e06b7e596858c35aa7a422a177698331b372f342a2c0e8c99a6a967b30019b91bd292fe77a07c9f4cdca5bbb6702169463a8ba4314b47f28557d5dc7ff062f97846b4eccbeb934","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
