<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e88ac7e36b540530eccc33795b37cedad316dfeafb60323433431d745d540e360362893b6b5d374bc871aa38fdc015494438207e6953f49f74ca22c88f77c44a15f93735fa0bb2df102742ce66cd592bd5ed5de67b16aa4a6d567f9ec7722f84419728e4090c03f4ba05a6b0a4362133515d4e5989404324a80e17382504f6372a2fdd4029e8f6b4762356a7e39245b71a3613353721c0f9bf822fe7c1ce4e1e7541aa222e0e818cbaafd9b86543caf2f3129cd1d23aa2889055cc8caf5be16add97cd00e39d8c884a257207665002ce06cf3d2d158bbb73bc29f24e623385c9679e3ce93a217bd03c29030c3737b2fa13105194009c7276fb7e38c41ac1da36157874c1d6cebd5673a206804e957d262c7dda0086eadcf70588c0dc1dea4013d87c45e491a43641920b2ddfd999360a7dbe2a4af3b2f5b1ac0ccf02361561e592ddecaffd1467aff65cf902da564b9928e580dd5aad4eff85a7ec401fa6ac7d1a87b69e4a36a39a423a1a7e789bb5cd102d45474dfb1b33edea6588ad11fd3cf3fea0299a24a9217870caef9196bc767fa426e9bb3f16151355791d0ef609826245239bcd90065f185b2c55fd837710029a08db41aad4da5e0f4ad65594068fde14036801d15f84a5e3269d4767d54204d010158a5f45989c70286b73d7af0c17379fbd8ba7f7347326715d911d2c33e8e2d75ded9820d3568bfe94ff600a74448e159e77f0b0eadff0d0421f5cc54d03122497226a1c1f2b1bbe704473616413cb021451c5d546bc6213a3f6233fcfb76711cb8b93ace2272e4fa30282884760c45a04819828052cc850da91c6102c48f5682e1fa75210d84df4963e9c8afff2673f601502f612b16ad0586df00074b3b1d14ee30239c7df7776f9af74b33b18ca518a6a1972f052a73dae6021968ed3c403dcce89f490d5a889ebdf76e339c45e739a5d181aa5e0ab6fa06c01db89f416fb24a6eb2e6b190c7879968ab63fce2419c358911607e543f05fc7c94d2026fdc823c57597057c07555940ae09f44ea9f902c4f56a3ea7b357d993cf7f94ed375b28cd8ca0457f242e575ffd027d891e9a1e69ec57a7bb487562ebd98b14558b592e62c8834e5c186ccf7cad7e615a28dc35e33a4f46bce955e293b1d51c5322ec7dd5aaf19dfb54a98c72a810c26169253685e12ae2a26b8e99c9d95b31343adb8a3d6251ce5cef1407aca2d51b3ff71523b637551408d82b7e5d627c13071165acb7c6e4d67c9a0cb986d6c1ecf402f1fa206b7bbc71a022e5fa7423cc82b76f88d8db751adfe7b62977b2947a0cdc3dc6bba1ba059b1dc372891d8942393a18bdbd3ffbd2024c954aff8283d96508474b04ee8e13d39571c61b6ada5af1eb95c89f26bcda9b67b4443dc7ee42936e102096e23ac16ef6a1fc2dd3d893b8cc6ae90f327ec9ebd4bdc8cd427b0c59e4adc63bea19ececb4c74c71a9c459f02e73b61f908a8ff9b08d3a001039fea673c46e06febcfd05ed5fbeee160213711d232c1df9f330a97457f38cad0e4aff9fc40e9894821638ea4304dc7bb1c1ef5e49e30dabc84f85b64cf83830e2bcd7597d2d2997f3aac0a7dda6c7d50437ad1607b55039a09c54807244d2dc9c5120d0489606db039814402f7f4cbc05246f4ccac7f944def14eaa04c6ad6d4beeaa8c915048a2ab93c5a76e742b4d421f3eb10296450c23bc399d3307e55495d43122bbd072bee4b1516fc3254dc16892ac371d48f27089b36bff0b8b67f8737661fb584d321f1fd8eacd8acdf0103602e848066572b150ece25dd6e876678da544f02050a416864d42b7cc1888f7d95910130f9bd5921f2f1a92c06840d35e43569061d7feb79e4fe5b9fc8de83d59ad68a61f35b9767281a75d582c22669a32fc0a93d123aca764999b8d5deaec1fb2fa292c262f1235329e4ca60f14833d70e7e32f3405187e7e4960bebd5846bf1158570e4927da99668468610c84b3400020020042e30a199576237528f2bdfaba7bd64ba42cfd0c57cb3312e77b3c1e48660b8a2220cdd629719ab8273f972de2f4dcff4f2e350102d81230a024abeff219e21d84910677257ef4f8742720d3198f0d7f705e305510096c23457d9edb7f46055d75042367aa5597f0d5105355ad44de2246ebc575116b9477126ca9c63892bb62d5cab25ea1e7c3ac93e2d6bacda8fbc04ca60ca19784e80a3d0d5d215997d4ab87703f70801f18570670e1d0c820fed7555f4a04fe3700d5347bf264882ac121b7eb8f57535e539f2905e54338bba1d5fdd2ed7c4c720d142642f7bcf0dd7c5e87a872e1c7f5760b9d3360cbd186ba47a11f84afdcd303373404741905d50a1371933f3d7ef40e5be56a5f180a31020df570bb618aed84166f27237a5bd15d0485df7320124f7763523eaaba488dcd5e7703e12e26500914f9c02d8dbf9eb37c15d00b198778a6a1a22b1bae4b0fa23d79e3b27b834f6caef3ef19b8fd1a1ac7a1d6cbcae346992b8b17b861d65c20f42425817e1a3abc618f7869dc8a3afc837e562c2217b44ffba7f84f24b2a5903643fc0b1348b1fbe97d1fb2849ad5684db9746ec95cc73f3583db0582f7945de8320e055b426b7686c5c20cb7e0c9db662f4944ab0d5f53f83bc6e330e4ee04fdbec57ee012b2f6850b1023ba024cff00e68eeef60e378cc3586d4d709581c2f8e16e6b58b4eb25595e24546a853562a4f5bfb00aa392ae1fc64034b59f9995b9a5e383f08cc2106950484f29e8f0f183ceace3d35cb4783536c19a7c7b2cbd7afe5d61df3bcf8ef892f44df4d2e2c4bdcc1068ba244ac05769c260495c2e43988d044ef4c5fc81a27f6619b0571f30f0cedd38a37d4c31f100cb53b37e20505f02a5fb801da213cfd1e050be1f4e394c2b210ff764df1ccc7597cd1775f7b856bb53e4461872cbcaba7cde44c8fd97aed30abc86df3449a1fb28f17bcb47c05ca4651412d22b54422cfa3feb8b2c02f27629a07a2bafb620861ad580450409d4c4ee3dd89330d1ee862107cc3da4733ecf8dd5e29fa1a5bebdee16a1ce513642813c344cdb9e30576d5c9392077264ff0134c0252f5823314742a8956d4e84ac1a5663dafb9720f688a28cef91ebd67cc0b675510a266fdd0437176da6da939cbf28f7f83bdd5eb58823526add17d5dc7a7be567f77080004f302f7baf87d5d993b236734694de031a3701f22d56639fd874466c5388afb424cbef5b80c4f5103b3430c23f3e1c090d06e780be53835d5da36a71c74509f12692fa50de315a424c7654bc1808ec242b8e6baf0b0afe70cfa7d8c8185b2978f8b9bac1b54c3c6ef4b9cab74f2658f4fa2f9908b44535c88293239d520b99ded67abf2ae8d58c493cf038a9b77fcb84847c3fc6415bd6e665ca4cc39db8ba3f01b1dda964e5443a7c95373da86c290818316bb99cee47b9bd5853d60d3d569d10524bbc7511f7c84452407c7c72047cb78d89c04f78ca1208c37796be3329959f1d3b35a6a126fea10581d05c7add64d034297446c3d8d73c8a3e0169f7ebd4e973a07b019d3667b2e6c45132c140b90caf35768b2fc588dee8c4306b1ac39f9b8b6ce3c5e074d307aa5bd535b7d20ca04982f96d3dc37e6994bd29568aacb8969a4c76f00399bc9e6c04942b272e08c4bdcbbd1f46f363377d0c5579c0edf561848628fa07de47fd5c1bbfd7451a0b7ec600f80c938d928d512649b66df3fd84e31235f4d8922476d26ec1f32ff09f86cf76a35fad41d722f57afd6c4ac93a0a2fd2f8a8cba2950c11447b0dbe88713367ca7676ef8d91b2ec6195daaed3afb9483ec8012c1064f9a40244b0ae7dfc37100cb6fcba77465ccdd836b6c68f2151b01f1c5bc443b36ac13ffea82662eee8707d07d1a458a1832b1b3d40c65369a249fbdbe5d56e08fb959d453f4c4b2db4c285c3a2400a89d2cbf22927bca8bf297282bd66e3101726f54d4ee36d4f265b22d0956bedf59721a65cc7890005f4ca28d28deb36551fc1c9042cebdbe74b7373565691295b466576a9927695c358b7b40838b9355f194609d99545127e46bdec61b85d220a814b73da9c2edb348883a4ee4bf9d9a2c364fa4433cf6ee19b13faaddcfb72c5582b5df221a425f7b66620727068d9d9546c1f56e121cf24b7cb35df0266024bf88a7fc37d950e681dcdfb266dad4f5ef877cc6c3a5f5131a2786db317e4bc8f9f157c216d81782539bdd21736003066859e796ddb7de42e323c45bb43c687c82dff7984c0d6752e2364cef1b513e1fdba12644acad4d98c605f29768712713e5a43c7e6b66d187324ab75ee01a6a2c853c357346eb82e4c0fe58416545b7bf4ff1940272c4d29c2b9af3753edb41b5568fe8f52d60986e638d16e89535acb8e2abc30702858efdee94d537f42c5af9bb45f7c08221d276b22133e41b26927e1a27b8afadec7d179c34fd5f63e2afe7a50e340b28ec822440ad08abc19aee44dc1d1fd51702548b8b79fbbc65749eeb40f9c8eae9798fee313cb77fc7fee77c1c3f150e609ee2d65d167dcc6f374a7a426c3215645f9445118f9a03bc4bbd9c63130a4670f710d291619633d9fa992443525b1fcc499dab6ff44ba1d29b27e437bbbbd524421ceb22f331065c9ff0a9db1de9b024d06b9d4cd0fdf5801e6ced00f1c96b508761a76b73c92cb5141a1d066df4e4245c9408a006caeead932ea7c3de686ce9a1091d33cd929ed0798ef50ec0e3f950b02d4966976a074c9527400e4489a706674578b854dcb9ff884a99a70e0029f285d286829d3059f15e5d53e617a2a212032e5b584068608c948e34e9ac055b7f4f06d3982cec7a54653e4ef997b344fdb9293ff4e25bce3730c9d9537d3b9abfdecb2e32b9845ed1f85d28bf43485e8dc7d13639fbdead1b1f3567f59828a872548cc45a1d1a8fb3a781595d4f36b99ad302b116622d778e76c260b5669fd782f9b63e942e98915d16ad0390e7ec1018b0a4194b20a833601afcef2f590b67c4f01334ab504cbfba7cc6870d1b6dcb7fed158da8617673b0f37a2e75987f48cd2c3b61e9e3345152824be125015b46209fb6a485752d23bb5590b9a137df3f3991bf4e6e6a49057f26f90c2c67654d39683afec99338ef9a55975d06c30476ff66b79a9a76a540881b6190ba4f442b0f6bd92b82c18e0d985cb498598f08c64e25a68751dfa581068753427ffde81253f588c83755d60acf22b10c08e0bc579cd8e28ee70c86b83afaecc7ee93039901c322b5c76152785b5dd8c7d255c14246b6cc7dbbfcdc4377c5a04e874980f17dd4c18a05d79bbbc12726b5022cbddd98cec35af3d3d9ccf546d96f189b98b672eb41988885e70975585c4ca1ce4871ab65906210a6853b45935a565d0f03cad88558d092db585aa1d1427eb15789103e4c5dabfc6a83fdc8580e55b10f751f75a48d5e534be5bba60002c0ced3998952e74b94b0c897390ad0451d6f246cc7832b9c49edfb21e2f8f2927bcef835aea79dcbad7708261cc2b483cc0f5e8ade938740d9a7b91b3f30232fd19d58a699947951ae3c778ad298a2aaba81822d5cc1e83d20ca17837f318f26413465575fb07f16a28d1797a3b70c44b121246fac9bd2e270b72920a6491b081561b4f470c11988cc29110a2093041da8f498e5a3d036cdc6234be151ee230f1df394e1e28f65381826bdb6367120a0da0dec4ad93946a19af09d2c838ef20871df92cb877b3d3fb431e1405912223b0e3759358969a9a9f8dfdf2fe3b74c9cbbd6fa5412195d47028f1463ad772d149c809eed8d7ebc50102d47051c4562edc52b9cdb08a79450a07a445f5b35f2c2d7bc0450416b872704b84df76113aef985fb2ca3523dd2ab847d96f22cce61501ad6eeaacb46443f2d505fdb30ccdd8c41930ed5838b1ce774ca32528d8c5bb48d847c86fff6a790d69a1de14f38e0ee584af364beaa2cce5c5820d5534ab6da9b3ec96b54a96387cdd1f01cfb4eec557854841ea24289db47bce4cea058eb76bcaca71cc4b0bc0db761dc479d88d481ae1cfb65609372683e3ee10473c01a016050039d7b2a244bd8b90954866ffe225ece182d3e314a242138ca40c5c7df078458ecd05811c81c208c532c1136144a518537843e66c6289a70c90e441ce2cbef71505c42d1187bd3a4df4745903bcbd9838e2fe50b0494ce3bdb28fc17ccd8c495897178b2d498376272a6408b7be5a9e5951625ce055d1084cc7c413ad1b0c52f06b01dc2475af84ce945d415fab3d2a0e2965804ebcbfa8ec4567fe4a4418ac58b0c6b51520ef25cce3951c89648bcb4e44a0213520a4a8def500cdf221e48ee8e74b28d425d5febcc70efb79354527e46993197cd201eefd5f5933032dbd51b23921ce0aaab3db1fd66de73451b6707500cad1d7c65a5f1c7e9408d87299c82d85b2a4fb897531f0eb0595cbde2bffa691db9b6771dabb8fd0e245a77439b057e56ec8d581cd4826224cbee5306d8d80cead6b40c32cab90963bfc90160dff0525804ecf53c18258615d2611424aa1d86b3a4d923a6d5155e00429a2160c97395209a1233396de9e68a7087151e66b40644b8bd9dd6b2d19aeeb504cba2980d6825202ee0b654e3f10c7e715f511509ae80e50ad2e8f9455ad3501a586a3a5b9c4e4bd69a8f6f26f2830be2090fd7e959d1fd0b40601052d1e49d3ef51f496a69c518ccb7d8f4ae347ba8665f9a0ae4e5fca423e0694442f5d9f7174b9e81c9e99d4c4cd6f2ad5528a935a9bdbb93d569f17557f557738842cde463629798a7acef8390198e98c75b3759377a33ca124bdf83ee225007ab5ff9f5d8bca905d1e250282111c6f1b68fd9a18afdb274931f0cd343541fca72d71c5d76461c6c6c9fa458f3c7e31058514e552de714a68b4964edb6209dc4ec00ea41c3a60c24a5ed49b02b7d00168580308875ad3251c7fd686d9abd305ab2e3a9da4f2983cb643e51cd8d06a8ce07aa7ffbcb6fae7544652af9c81a2317307c29300ae7491d4160f60ff31b7bd4a749f08eff5054dd0aea7855d23413e94268aca5f79f9d934c9542f449116685fcee020e8829bb5be07fe79a5bdc6e8fa66f733564bcc1636588e49f0048738be3c686a548c9c1ef7795fcc3793b344536e1ca48a2ed939b1e3ec4db04099e79eec4be62ce80689c52c381ccb2f4b7497a29251115c9ffa146f621437dc0349dfe0869c5365fe24a684feb46cd90b1647b68d54b99df4529ffb5ae53300cc006380178080f5909a70fe5d7003ebbd77ffa7b1ff1c702e90e1d52e43003c272b56a2bbad2f8f6de162fd68591be6710a205c76082c5dc539c6fe8d2534e7fc7e37d28664fa0898d97ea1201ee7b5e682453402ab495a2486b6ec70fbe9c397e648ce439e8459a1b297aedfbb86cd9a5c38d932d8c9022fe24b61e92412e18c7c849b8ae7ef7e7423a94c4b8d9f02e1df799f58de1fdbc446c56bebe8a201551a3354d08045f64760ff3444b28344f1de8b46f56bb36fba800c638d7a83bb4747ef7fc05906c5b57bd6b9f73623ddbcb6ae945803f4686d7a0527621d01beaf1b5f1f20715dee314897be98edb4547574bb83d808182db2ad13e9f7dd38809161fe02398309af2ba22403de8834839f7a962bade80cf2713df71f0530462227794613d47c475e1afb8ce74ed70ca955699acea6c426f9e1b55531a5d902904d648d1bb29456931db2f206eacc74794d41993619bec95483b427a6d0a2c9bedefe47db07b12bf85aa9e4f5dea5ae7baca044b8db5ec411aa3c7ff3f8471b8dd9e1b27e9f5e60462f616c1c3992314d5cc6ddb82fb230d5774d44c9d038aa67cb1ec2fffdba0d624861273abf5f65d09e89456db882e4051e723cf2a8af747e61815d2887d642b598d32668c99f5979ba60a5462ed61402e5c4e106e3dce5c04b9ac9d7c80d8cc12e4f1acb5f4e9743201d28425f54b5980a0913ff1ac4bb947770b37ac662f2b9914cfc65eae7befc92985099b360015967a2f568182fdbcd11dbc944693167eae4673692db06ad1f3f8776015a2d827680ad75794f6c18a090ad5e86964190e1bdba91544d20dd0a1d1e895d79c4daab1dcfc014892cec694278dd13631b491df00635732fb2bbcc32a43a121bbcfcbeacb7c7cf6cc9b136de94a5b54e4a6b7d33a4b4e8e13e3c99a2284aa57f2fb75da40d792018db02bcc70121d237efb40cfd613d7d7654af698c050986bb636351bc0c8048f34088d9340989b7ec692b7b41b7b430aa66e9180f947410b0d5f3e1155fe0155c41e9a78d1f57f29c222d9b5499565a2ee4a7af1aa0cdd25e2200344058f8e84e61193dd5e30e1a2f5126366ffe6d6e053e2e8bb2bd19d0ba7d3a595b0b7793d61c79bad11ddaf3969b1951dc2b469f0d49b0dd585a57c2c2b9cc31f598a36b4ab8154df08eaba35146d66f8855b6415b12885f94cad7c0253f05b17e85c1b12071cf80b0d2a4ed78188d8b8ba68d9567727a47d1638efdba84444643803cd026f147dc207163522966b4d3bc80d7146dd92137bf11a0ef519e957d00454ed16282c9d60971119e7861c8432cb131a87c30784f58b57cc3d945f725be7a78775c757aaaaa19bc2cac809a7f993ff402a8c8c133e71be7af05b7b38441b384b1fea3921937457cdc8a7fa63bfc9623e00d83ac5e7d9df1223778ece0be8ce3e0519311ca734ed046720d93a2ac936ba0b2b4f7498cad21c14a582785f5eef8b976a457331d13992d1a6733400d2cb7533ef4ec03d674001b5cced75f634cc5df038996d1d0015394459574c2e92ea3d7731cfa3d9a7de1a322cf63c85093f1d551d5fdbbbb7eef05dfd5262b10ce8904a96dd08f53296fa89fbfdf7a85aefc3271a1660ad6ad5c16208cfd3ae2fa3c33fa8aed2f46d47a90253b43d9d6294460410a15144e0bb036406041f7481882d4d9f66d3a8dfcc3fce44c666bd93466d9201f09a25c3541d44fc5c236b394a9d6a0cdbb2aaba563d5c86a0f9ff1f776720b5e2adcbdbc3a258116e5d040087ab2b23f8a8a92b31515dd83929b84f1dfebcb6314a83183b5da4d840c8cac00beb8d0cf31d3202b7d2110a0c977eefe6f8cf8b656c9f2b08ddd5a4996cb7a815cd38d1e58e41d7af740468dcc98aa235c31bc2538255812644e98f950bf21ec5517588fbed608e95388f1d68a288826ecc369d8abe890ac923cfd5ac723cc5b9bc22333e25809a8429184d2731d9dcef7099d21dd5acaa7dd18256002ba99f567b6b59d82cc0638fecab91c7eb1a2c1a1aa8651aeefba4d318f14422004cb8cbb630b18935cfe7e65bfab4e27f03a67ec4983eaff36df1fae7d31f6839a4130cb05bbee69b7000ae9bf545ad60085f0db8caad32f6d204f4f97642949686eddf299362180a551503258ed6bb978bb2bfda38d98d4ee567229dbb96fd2b3b1c7e5c79ee25ee60bf6785993b42d2012b9b182a44e0b190c6679e453f314d90a95423ca5204f4fdb359cb2b8e6436e6c78ae01ca72a5aa93a33ecba539b610b5d76d23f6036a73b541d5a11aea413836aeb578e45c56d08a83a83bc605498b12b0369bacc4431122863d10a6425fd5a6ba47d7589c2d9b69de24c2f0a9c7c18d3a8a091093750a940e79d2287570b82d1eb78defc0017f26c80333fd852bcfddc1739a0f8449df39b012650f8141e6fdcfa1e5b77cf229515bc4679f6b1d92ce2dcd3e7cb5da50a85de665f1d9b86ab273e6bf293b5fbcbfbeb4c865c4ab9c4286dbb0a4e9ed4e82d52cbe665e3f87ef08d186a41b45a6ee731b3116af9ffee38dbe3173a2a557bbfeb72644d9b09660226097b10ec02fc1690e11d3c3822c36cda073526799f5e32601ce5d6e0f020a59d3d429602d3bc330055260d5ea9c01ae6ab513433614da495b9336a59987665515ff49b3b4240e9ab94c9891b1d63d2b3e86e92f48f417dfedeae6f2e8ca51121de8ba12521f7784e8d0a6e819dd860b1f2239c8d0fcbc0c152bd6283ed1b4baccbcc051111f552b2009c9d4b7fefd0b18a2d1dc11db3192131cf3874dfd83ae4ff6582108c729e6cd68bef02f95cb6ed6c1270480bdaf37bfd4cbbf48e67131f628587ecda1fa3ee303b5dd8e413106a372aa39fdd273fca393965370ee1ca012bc7cee3aaf99b9ab1311fc5f5c63953fc8a3e4234f62a0331063c43fc29b829ffbf636433477ac883947d6ced915ded3e9074c760d1351224b705b13dba134a6228ecb366223a5189b4dd9f845c35c2e514d5ea0c4a7c3bfcd421a234a42bb6c86253433a9ffbe10c331c1d304d02e92a80ef110a77d84b8b0ebefeef155ed9c67600e7f896b498702d1177b34a39d5727254b1b1bd122262ad0bae15e769e25723b51fd22efbdd2bd97bece531379a7932ccbf7446869fc98d150ab9b389b7fbfabd82c650e1b624ea869fd0a393d1c310467a2ed0a44ba5ef77a87f973d3a0d03ed7505adc0ec0046d6ee1ec14bab96aec753eea3e797347d80cbdd1e779b0b9f1e460acf61799397f2795780d67772c455fee8b802831159b1e90c380c092314c1b931a0e9d96ef2332a46c7305eb4f93c0ef1e9f1a033a712de72efe6be6e1aea7b57e7745f11d94c8877f19c84c5eb3daee1089ece2c01c04be093d54056cb756ebd0dd6f3fc3983f5879093d9304423aaa8887a5249c4553b137a0a949ab870b101ecbed00ff5969e616cadf1cd37c240a378a0ab58fcf71f84962286fcf0f3323d4b6e2fc3611f995e32bdfb6c75e343cc4378701e451e1527a8c8e890819c0072c0b297667423a07052b0e0406c3afb81a5c5c2cf6b09b66946274668709477df100bd96473dae107f3d5c56e0ddffb7a721ae7a706fd9ea0169755c68a42b495f2512ba492bee66092220ebf692f93ac41f5b73cb60cc627cc07172d5f4fb9bdea8498474bd3324cebc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
