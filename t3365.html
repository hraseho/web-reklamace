<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"605c34534b037eb68268f2b7ec7038cf11123e8eac25965f64fa199e1080af867b656c0750d929650199f425a2b2b22764690144352c43a2a3e6f002cffd680e3e9e6c2b4e4fd51c0486890f6678bfb2dbc2eb66624ada6db100d431c15b0c825f53aebb5acba7c2c6fcbdeba993010695eefb00a580a8fde48fecb4f6a5ac07ffe09196a0e944cda0dcf17dc6e475ebd913d172bba046c6ccd880b203f9c8095272ddf74e5d3c1434fb808916169fdaf0eb9d30aceede3560b67c9d4f0f7bbce87fb93a8cbf00860bfbb8ac093cac7f1c5f36af6266b1cc10080803783217378c4f4ab1e85e10dcce386f4774af4613f8675d9f1b9c3450abc8f821172aa69781a4251ddea60c4d26dae344421dacbf3f295acf40e679501ae4cc10a972ba5e90aef5cd7e3b67c9995f892492d6c06b4bb856d363c2bbc372503f644c3012a96b79181cf82f4a7415251ac894dc42dec9a36542da6451da1bcc2e9883cd3dc3dec6ce0705be7b8a53a9aba180ecff45e0af5f1c984c469eef2a3ba72ccb33222b53045ce31354cb875490b317dcf927a3b6abd4e78c076e221ccdf94b17a0a25cc2f12586facadd486fa74ff496ac02b82e3a8213f7cb70e4295efba09c03c0acf9c4dbdd44c75eacd277f7a9101a7006f03bf1eec4f94ac5a33313d92d59d24b9fb3efcd999bbb79f81a871bd058efd9378bfa841cb6ba01de6d6258bf58a1499c93867a9260fca26f9faa082697361d1b43f70f1dbe162e9f838089e14fd84c5fbefa2c223e791fbefb1a4949378663ceefb89b6120cf684352cc6638c59f4a9e02abfcb8c17b46a69ddb9d23bad9a106d44fb15ccd2de121b445c9f2aef572bd03b7f112df8b12ee433429a4e94ba3674321ab249eee7d6b9f97d3d3034857c7c58843aae0891e5f2c96c179cc7516c562b92c4c8ae49129fe00bbbee5111cb20ebd93d1ee5fdb91149c8184b9d4bb75629a05caa16f2c2fb47df991a66980b9232e752658dd6fdbefa56b4462f9de336d9179ae30c970bbe8b612fd3713a77ef77888fd4b8fd04ab785564925bcefae190e9b99ee268c79f7f2a37ec97c490b81a3eb1c6dc83bdb3de8a27749699e1744cf07cd597747bf1ca61535e67170c6fc545b2f3a78b5de81dc1ef5e2a5510571499c9b49d5d715e9dfe287e3374345e2155c1c00888c9561471f1f43796b4b8927e055bc9c4d62c08eeba01c9ffb88c9df631bfd82b1e8688c385220c0b8825542b0b4d02ab677f1d212b7d6adaca71f159096d7b7af69abd9242c9f40244186980427aeff4d42822fb8ce51fc397e186dcb0328d0a0ead57fb29470a0fb74ad8b5cec1bb87873a7d2684edf7af526b375379e3ab6d442119d3894d0b3e7240671e44f07f60b61e83fef1c0d40251f4ef3ede7cba03d60b537f66d9651a1b412d01710386f3107b6605c80eec5b7182a96a4fbdbacfce3ad2d10b3d35dda954d29d5747e3eae24902920502766792069beecaedc440fde3df7eba55244fb2827d0be2761fceb029217f674c85f3c84469c4cdea85e68d2ee88f0bb0a7c5659fc54db9fc861fa81b911c10cb811722110ff27b69e3816842a0ca08762937636df39a4509070826b76978fd17100826e61c89d53ce84e5936c007376f3f0abc39f0f4cda9563aeed542bb524c9281303feb2768e9c06d8591d74327ce7a1cb25f0731ec725bc326d93185e5db7a9fcfed7a120322e2f85359be23849cbb295f95e60b9c41078ab48bb8749c88073f2504fb94a723522d0f2a5495930a6880bd7a1e9527fd0a1bcc769914cff1928993470b134ed2a1b59d0e21933204953fbebc496dc0742f965a98304cec7dd600e8e93790ad7f96469de9067883e63d93fa0c6575766831d2e494d7a2d21d70f633bd698dda6a10acd1eda145dc7fb096509d636ea6cb317d09ed7ff00867df3e6b00a8cfdae1d65feaf7b3bac7d8fdeb6bfe835e30b388a40716205c9007c1be382a5e7bfc8eff7338d030f626c2945edd52e3438b8ee3093a05b6db033a79974c791a6e2f74272e5bbb2977f82482b6386c9dd5840c0cca454ce2ba774c908689e321c783b9c414d840196d18f9b9d976df31e6e22a917fb6d13b73dd828219e4c9f72562a880e195418dbae95a5b59fbd3144699d63c814f2a40c7072f873de2083a444ba3a66e18823d33a83f24f4b5ef3f8e9c0beec8fa53d6e452b7926ea00a855c7458cbaaf9db1bf9d8c5490050470d8e51acfda9460ee74a91b25165c18e5fae0c5c6bf7bea8cec297ee15c384378110673c8a2267f9c08ab7bab7c8d52da0ad3a61147bf56bb81f01d1dc36891a95e5da93d152e143419b7ad1d5ab399a0f6ed640d13893029becf506797cbae9cdd435c7851368575539b42738836015a37848b386892204d17046323084d375509aca5abcb9590a59858a310c4d3fa2eb67c8f2556efc258549ac23e7db56c35de1c3efe0604db57e630a009f8f3bf8a8bacaa77ce28df6cd5d1d13d694ed0d40816a0d2c5d0a208c46be7da042ebcce3986955659b410318cd060b5683c26e5992d734a5ab90cf14e643d0cf4b7abfd125cfebb2ec68b1d6622c0d1e5dcff414b572f1d039954307c8f14f6ade908ddc36862332dfc86b70cd514b860f8f8f8ada25235af9f34a07b0db2c7b9fc319f47852c1c0b3e12b75dd01ea8e71849be6579788e80fbfe832f2a030a3ae3e3cf05965f9bcb7165cdcb7ef97d5ea2d41f414f887b4198ace09b68a369675c429fc0a4e045d81a946f3dc687e19c2e458b708de2e6e8827f40618997364c86e2e289442dc4b63e956f8952fc9ed3a29e419794be9a1ad8a7c3d1ee99ccfd1a71558c72151d3436d686c117c9f0e176220bd30c4e7c2543258c7c6b4d5f16d7df9bc69c6eb81fffc92518a875f41473e8ec477cd8c0259eebf2c6356e6e53298236226140a4afaa92b6a5a7e8d792834dae418ac068ba1dee9e315ac7c5ffc36ef226a3e538715e3ef8cdddab884b1efa6dd311d6c99bfd070c685d07d0c4475a787fd8b9a6fda312e4d2a0d668b75691f9548ecc6f2b9bc4265ba918ccaabc120d48139fb7d94b236cb88264b19d1c3b2b4b866adbae477233dc58d8931dcc0241df7a3b38fe1536281d49e77b13979b986336583c5eff33d50592dbc846053f3808e9d735bde5365a8e7b2db868d60420e7f577f89b6e49b688553f5139dea2e3c991bbc7c13d51568f3df58b7e9739b280003aaf4675603824f18e58a425a0150453d5c883e39bc1162e3f6d3a9817d76622c982f3da27ba128ae85a133a0a0531233b8eed63cc30bc1a06dd8ec7498bddf619bd339dfbf7ff175a457be717c6967c40a3a71ae6a2ef3a28a0f545bc76eeec4eb5130084796724becd62a8c9e85e528517a3519478bf51ea5120cb77a0f3a1c7c84392606072a40cb03df959432cc9e8394108ab929ccf7e5273f3f9c720777dd9ed77a28d1de982f0effac7a50fd89c06c004c3a93c024aa5497c804931b486cd6640e5786aa68c8828ec46c9a1397e0f0e370b28c383442acd72828e949b05f7f7b11e7f5c3cf8c60fcc329412b388d31a07014ec05471b6ea8cd1965ed04b63bcaed5a5fa9e1ca8272a1138106abd5537f1d5a7586bfaf95e28f10accf877c2856ec9384e057d508e5015b01f7bb8f413ca7cbdc35eb0a215ab7b90f88c62499fcc69f015618922c8bd5358bd7820cf1ce53e61afbce2e860447071a8736e9de76fb468c6e02e8bd41d89a7463ab0e6f432a05bdd70fece275c23ca94a4217dc1c34c8dee2911e972367f9b2a1bf47c62672e4e5735bd4a63cc4e4e8a79dffa7ab5257d27ae866fa298f6bf9b38b38bc0a9311b291b1f9c8c86c2847f1797444746f90e8344b6e53f0d020d43219fca3bfd42eda78087af055b582a38cea7dbf6179e5510a172bff97688ddc9287c846bf5cd4dec035111e9d87417ffd6db4e9fb114646ec327219b89585971a2f578c6e429d9c2f53449fcfda9fc4a43ec56d6ad3f819d3a94e2dcad52fb83df7262e49e5895cda8cfcbd3e5abf021cd34a870bfa6456455bf57d585158f37ab9dccaf7e5c7fe2fb7c1d33b39e3c04cb8c49bebd729d3581be59440d9bd7e334c822c08021673f2d01b8f179196a50ae5105a5d501a623e99b5cb71935e7da7e512e768c856f759d1fd134e9c8976e4b4e54806aed089c01c1a7645594b5914092be56ceeef4dd61a7b0df4b4b9b6aa9feb0267f66714ad99305bc48bacafe2c74746764fcd9fa5ec4bd57af9cc96ed8e4d49c0e259c80e1204d15484bac26e81cd44546d81530974bec0ea05f901b23fc96c5da50e05d82cc913c4130c5224f41f27db8cc3ed6e25abfdb3b8a495c5d72b38137f28555ed1416907d759013d0458627cab48444eeec252883a0f78f9ead4df9ba8b93010a89b2fb11e55ae229290f26168bd4e1ceb7fa21f882a70120349a754ff8dd0d6fcf7cae035e22afa1b53aab4f800aac981dfe23b1694ec7a3320c5e6f6aa5c13bb64addad8b0626ef71491f5b9f060b14c3918c2f92d9362c307de9faa02c95fdd3e94a72763b28c6ef1d46b0f085ed0d72422acfb3947c1f58724f5204552e3e65ce88c85d125c3a032a030e8421fa38d6a78d44bb0f86a2d3eafb5205ccf648bb86042df22fef7602beb7045502d8498e08ef11c5156d2b7f4c3c8e1d11364357cb4c67ff9b91a1b624a385f3cb06362f25c08deee422778d092f05b708a5ce3c0823a6e92c72795ec9868de7b0bf6b258a22b311b81a43871a277a84aba8aa0403285e32235f9f2d54a3eb61267b3ef5836f30a9ff0540051af3efab1f785eac736ab7367dfd2cf616c041444e01c8d4ff09e0806cd911558c1f323c92dd74754adf9c61c60f32f0d62b27ef69a1b1f3d553599a49d6a16bf70d25880216b80c7dd221862bb08cf8b42af440dc6abbbf20391d99e6813b2169ec0173dab374f0bbee4e3c417bb9ce69eb4dad50b6670c14d07b0df641ada53a5e75a38eb660beb36c8ccc997f3cd38b3c1a14a3703bb62f582721452251a8272a2ca51b2542622f4ad4309914cb82722afb4908836d933939532cc17c70f4832e28fa0d4e7bed511b9cae4450b2a2a02f1f51e3e3d4a91175e0ad2d39fb251089438414c62a2d9462ae993a083cae7d14b1fe917437da4c3ad94c65ab17bfea8e0e3bd0646ced593da35d4c40b620296f5b39eda113b8727ff52b785578af6fefdc6e454bb5acc0ebb140373b0ab8db6e2bbaafb99c2fd4aba0076a87e553713083cb788c9797ac20bfeb885093f6cfb0ac4a964f39119e856d13cca9ab0dbf679d11e56016695717cbcaa1dc676451afdc082a90eed413db854baf52eb3f10046f37c0a77f8ae579b6833ed4d67d0824c0409909b50fa95815ef4c61f24a89114bee7370d0edec6a3d8cdbc791a6f280f1779cff6e7f83a4e92f09a43a08eddc998ea4636e3030b69383c91ec671465b6243a3d482a303fe5646023bcb26958b00698ebda0c4cc2ce5baaba7f1f53c939b29d1c3b099a77d500e9448df9b74a579c1606cdb3897631b4fea4ad93f440c4b111cd88f7e58d6864432c7b938042fd74f38d70356a5bdce3516c06d311bd43520eb2fbce6915ee10acb98572c78c79bfc7859822663a54cb4a4910324d41d80ad83021f713fbb7d7ab8e1f13cab1e2fd9e5737fb135c8ec9ccf5e82a174fa35e19184e61c340b15f3a932788077804b637f0812354bf54c31442487f69e8bf2b7f1c8cd03b192051c8a0ff3c7e4d8a535fa9f3fc767515cdd242ade064fb85fb9d9d57bdba16f9ced7304cde8e1ed21d164e554a4769cde4b847908e4d0d8e99d77a202cf6826f4b96d081e780d6e6311a3b3275acea20003abc3e881bbceb5b354da121d85dd35e41d754764e370bed4cbedb727ceaef2cc4aacab90c9c2253c3d6dc3eaa46ec2f320b9da9e00e9a0cf96cadc4e741beb01de89280eb09451ab8a2303e372904ee7b9ff1f63a90114cd3ae1d2d1b6ce49c91a4fc2616b4ef4d7bbf358912b8a9b4d39cf37e4589a8379105a64bd4e2423bcb9982e8b5e86c0543b3675d9331b305624d84ef684350b5e01e035ff22a30d7969e0bc9b05a51e51237e30cd298e7440c95e8a08b962fc635aeab860697d44e6a3bbf700ef20ad07fb817dbe72bfdf4721da930bbf60ceae364d05abb8b2461a9b0f9b999ba677f41f1b1a991ba6b5412ade20cf18c4110e722e1a6bccd3c290152946fc79200da83c72335a0679787bfa7f5b7c35612365b88b970e70303e0e9e95b22f2a9e79f0d2c73ee3700b19a00647c9288f0a1864ac8c9c0c40eb46bb6e5d143bb14b6e913cfa281243ad11e5b14288039005540f93059d6edc239739b6d979aeef81af50071b22a6fe181df63b6bdb6263f30ad79a62435df34a676af950787868cb068956b6ecb91909a00161fcb29605320428c6696f4716133958d2307aef34a1845559c83abcc7d557b7a283e5ccb4d165f93c6e37fb711507cdd5a1c14ea6175f18fec06b19492639405eac17340c2f894628937ccb467e9bffd93eed568741eb44bd2f78085c391360924b4b1304d85ea76a5dcb795561ccb4e954812e0f833ebad46a16b479ef22029158968c51ccf3183da16666c0cccd4ccacc1bf54b2f43be747cf411ed4fbb5cbcfa5bf9ff76da3c83b3cb1e6ca423abaabe32553cc1785070e7f1f34a896b4066a446d3459a7d7267a002cbd545b59e265f9d2f310619056adc05fb52aaf2132b4e83d323bad6df74d3560e43ac2ddcddd49be196b30ac2b4a95a1d916fa6f49856a2f7d29596e4ebe5e380a16bd5a2f3e24378b111f0fae3e190f8f20be1021e620c0b24e8d52c78b686544503d7566422d90f84be9e27c623c8f48c496bb06420e3e457b7a54e4d741b954e801254111550c8b2108202e6890c8596e026683b95aef665904e98c3a0deccadd30d1a9b69f4696c3b958a7f3894f98fc971e45a92c314e56415fb2adc20d39b819c66d9c83fc784755f624a5989f826361871c62945f919eedc84b2e0b5e3aface36b4416aaa27774a91e0d9dc82bbad67ad38f48f9b6854d99f2ffe0a1f85705b94605f0875d5ee3bc65c8a3e852e0d76369b5a56ee002a206f701d56ee7f6b93094abae3973db6678253894a2e13ed54f8892cb43bd6eb7d3dd32fb3de3b67d611c6d49a8feaac9c61658786fd15c46b3db3d9f8c77a832fffdf4e6ae5dcdd7bce61efd03001bf6edbc48ea807f9fed3a6aa620b0f2d5b89f9bc14ca1fa9f01fb6dc5f40e3a69b6a480e68b0ff418ccdc6c6183e803d730beb3cebfbc5994f176f6042c23d598c01573dca51cae97326c0b0788172c68b0233359fe04783e4f81d8d1856f43533fb108d2b275eb12e3a1df52535f3281e26d3ae74051ddee668d56cf3f0e68d08a689c4f5dd61c4831e561d4319b5af59b762961d5fa47ed337dc0bd6b9a5a08bacdd58e4f0b0efdde16ce51f2a37fe299f2ee81ac43c612b827c5c3c45dcc9aeca78d07b6b690a645b1bc36ad016dccf79ce5826405d0975aeb5372ae4b6a8436c2791f517fbe4a6ec3308ce80e6fcf59921859cb7435f367b01f361ebaf8d2ec8730b64d822dd958f325122eda14f418ef276be2c96c325795ae50d4474e10013dc18431c1681dca1a8b7a2c0ed7b2eb33fa6aa9ba8b14ba58b6fa215cf7218625ef8d468ef76aef5962431c87dfc6ba11e501f7e8526cb6b2ec1b7149dc1df8952b242257a07beb6c8e4f42693cd6ba1cd827f2cbeaa0df4747b1ea63ec815dfdef4bb2f635d0e2abd69a8ba8f427716061d8d8ee5b2d6a1b24d8c1f894b36d2fce805d5188c278c7167d2b9a1afa853d79a1db9730a906caecd9719d710ac9ffb63faba115c8e1eba898ca6699679e7a76493bf5a88ab1d740f56ec07c8bb7fbffde93854139c783ebcd4e45ee3dee78d3d4eb7d97ad7e23605a8cca7d7af5b47c718fe774a3ae5d5848aa1b2ae48fdbe6da79a1f06eda2743e04cfea754c184b846f626b48167ed6d38eab0d8db37d4b4e012997024369b5646bf2ae8b2faea9247e201d21e5deafdf18cd14ee2c57a1144d3a46bdd50f2edca564366c89e662027ea6692e462ca8e6c52006919726c56ab701a0e523485af56c348a1230c16728fa4868544bc267f34d5821cc8a2b301ca1131ae27b52125deea8d79d9021ab95b358645b0bb6179c74a3da71f529c701422967b0ddbff6dbac2740c3246f35c8e71c6bd733e8cf7a185139eba924815a9f03290f4800aad8b27a8763ab52ec77cf45a652b4d59f59613ad60f0136a44adfb94b379c2d3e77b80d4170d8a33006bf7183f731f36038edd6b5e8da98b509323adc448585ca2e9afe0e51c3c4148ad2697555299ef4719bd8738738f563dbba27b02ba11108527ca0b443a44f35e85696da81e5b1222b99e8e2ace607cec53132c7a87cc8f33cca9e69c52c6851d74736580eee8436d2b7bd0f465b10acf17902b64a8aa04c9b138df37e48dad6b5c7c193136e23854e5c85264932c32e8c79d1f3d7aced45b7e121d88e15a166a8b7d5c441871a5cec13c1ad6a0fa827373ea64a1e8f55bad72f3b05451a2f2d2d02258a1253272daf104e2561d060f3bda11ff7ab0d0cb4f0c24f4e15bf9c98b9f657bc983e2a4e25cbe90d2a7b27b052ce61b458d821db9da9e0b4bc695a47f064a5846fe0347e7993de00806154a3819d6193ad0e589337fbc79aae7992ae5c26f355246c526c00baff20515bb3ff0986aff662e4c680f3a3bebf8433156c8cab61006f5b3d6314228ee53268c9ca309493418d32309f97ad7c47cd439ffe4690feb992cce9ba85f100686be5917f98b96cb6565f69031b5bb4f0f2fb0e76d1ca522a0fab0f11e2a1399b93f3e5b370f67ad3330e55eed89e903d0d7263163fb71929617a194406f9d0a250f86f5fd95c038ee361759c6f27e27e3409a2fb756affbddec0d0054d885cea85a956845537e7b1dd781f49a2c944651f3e83a88e4a9a4864c2abb3f2bfb2a18fd0d6e51e89daf1da2014c8daa272341a43ba51b95382d5dcff47951241ced6aa0e7e369bb818541294c32304eb23d48c573b93a35bb5f078d1797f661d9928be8f8d019a2acc5c56549a8ee76f2ac46c734b49db2454d919c181171dbe3df7868d55fe7f6c9cefc63a0478e5109077302999339bd98a31b25a87e92312c8a1d6ce181d774273861c057ba0aa2dbf9cc398f43456805728c085995082a03d57503be8c0be182e1823305dcf9a5d1654e2e2dd2ce9ca60e308dcbd98d8cde8a1b1a469b3c17145145b1e85db533a3d63b8a5be6a4450540ef9a3d3883753195a7c7974dcdec41dba7d1b754462890e46c7656447fb1a344c38498ef87851e0f27133276b00933d9ba90530b9a04fbe6073bcf0dbbb5effe32decaa71a5a2389ee8f14a2f09d6df592fb2b28ab21a4fb908602607171dc320220f431712dc625507d8c729b1522d21ea3193d3a782ccc9e202ee62239bfb9e25c986f7e5ad7cc715d7ffbc2ac46959db9258e7d2622cea3d41eb45d70990e54b7290cbefb46a63e5a1b98bdb3828982fba7e6e34e964729614c268cbf59ff2a6dd1615d5330da6f93bc426c2d0d0d476acb2691174b12fd3ed4846fd70445dc47352c3ec18ed0d91a0e7e31e35c4b2e36deda081533e824276c2c60b46a3497f0fd05f52f59a5dea8eee9057ce93cb7ea8909a5cada389e5dc5928a5b558974949f61bce95eedbdf728ad04666218a57e098c0b7386f4070d22275044c8fd78826d0a12076dee179ef01f0c6cd62d966622f4a0d0e5662c09dc0e9a119325e421f3d83d41df81c4ce2d5388afac28ae816d12ad9e3d83e96a2d218ddea1b92eab8ac1f698dbb9a1751a5073953be16d387897b200254e056759907fdafbdcab6827e0b51b9a699dd756be8e156254bc245d864553f641c6ed0b8b72b3ad43fef499f75569415d68ae6f73b9df6a700013cb32ceddae3abf7662a383099f68de54c679eb13ac973886ca0b503ac4df85a3cce5ac8f80eca9cd78dde4b9d7880fd96c4800d724133abc9e8b306069128ec881937c3c0da58a3e3097c7412d4e196d4cd43f7c5b9fa339d82cb2d0066a3163253314d82df696944181c662b58cbd8f8ded70a5eaee30d7435fb72996046b7a51f5da04079c55bc17b5ac4afae905d73f1c0f222787c400061065f84e7353129c4bc2328c72f8ea7d9f6314feca9237c9c2cb82631217fa58bc08f669098f6b43b62191873486f461fc6801a9f5c4932f15d264c387f8da0de78c08418e68c427e90cc9917b6ed693a8a2bb9116c20d9ef48a28cddadf7c4965490377e9dfa60df48796ecea8634419380f1ff39e2b735447f9ecde4c71ba6b05dc4db58e2c31ebc8364f9a166c4aab539b19d66335d4dac197e06f8e6461d66134ff68e74187205637d8bd47dac5759f4c0513daf1d0234e2d1f3b6713473100ee5a95e60daabc7caa10c4d75df3da9dd59045dbc1918aef0245affccf9e20c07b5680cf03431e0233df538bf4c6e26fe0da8298bf224cb0fb12015eb6c057fb3ac5b79a1dc66495c89b0e05a2a59e98113993da7b820526fbd128473bdf1f2733e47f030be8f96730c6369a7615fa2f8682e0f4c95530a117a0e49b9b8b534faa2f0120f8fc5329002de810d10dc107c0713f29fff9107080ffacd7b71518fdc7660ef731e28baec1dc33a5f11267609e210e475563fc87858d054e4ec820d499193d13e0de4da6a7f09e6a4c2c0cb7af73cc3bd81a1d4883962dc8548f13c537924cb007058","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
