<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3334f0fee2a3330baf63b310465eb111a62a12dc4dacc1deca582314bd8211504430b8d175a0b51738a34526d6db625b3afc75559a081fb40e37764ae41af10c46615f26ca58cf81774d761328f21ee1507245015741f4a132dcd733815f4767cef7424599781f9cb2af9b882d307665d591564e0ac139fe21ae1ae616d4630faf06c6f90cb649fd39239fea22dd4ef577882b8663d4443ca2f6337eb96df9751bf37e7ee73fd293bc416fdfdd0d408fa477789ef6c14cd6b04a8775c7cdbe4e0710134b12b03641400fa08f1e480101a9b7c4b8466b0d0a9dbb4667cd949e1d6298321619f125c626a93697e2ee664f71d1a1da1a803920c3ed3c2d3435665b27d2e2c77442b6239ea7ada26f66ffb32563fbf4086f11e42cd8913d6afdce8f8200f3f8bcf6d98c19edf8c6bbbe3e25a439b2cc36eb7d033c2080ce4c23e30e0652a62b7e45fb1949aeaaff8becc72e8ca8e3f63062e31529d7bc07fa358065a70a41e2df2828c3094f86e29e92a639c3efbbf248dcce2fdac24509e747d85092254e97b9778e586097fcf88f9cb8c8ca68d0076cc8d6170a1df98f0085befc07b24a31b39f00d469124aa7ca01dfe9a5df6d3bd0116ae6758de11da019de8aa5ab40e63f5823bfa86e6bb38bb53ac12d3d1b5da1c3cea6d7e7b3cc42dd4998fe1f20044ef65ae284bc883fe4e6b260e85ac29e61ec3c0d4e76e25df42daa5f58b6400fe7a7181629217bef84bdc40762356dfb523a4964d57766ea49d61853b0ed8315ff2d58dc31901947b2107654669a81ec951563988ed449236035f7376fbcba7b43822a1fdec80c94a9a9d0e62cb7e89f3a50ffa1c4fc71421df9b932e242c712fda2139096cd7f8be5db92af01aa64c453783ceeb50766fd9dcf0cf7e9c6a6af1e08575a2dcc54c4eb5548d4a4aac5daf461fb8538997aa86c5f750f65f95345875fd697a6930bf0b937bb8c8b99f54deac6e5c31b4b42613e0c30d015bffb19569f2dabd01c08e0f3196916f9563a8c8d4e4829c9de8c836bc07312c57b65a380b1db66348505e9ad7068b24719dbcaacf98a27caa6611381050416f64897a677d45543f0642753d652d3d5f039dc17f0e5d750fc133a7b509b8681261c1b59788e4bd955453a47cafc4b97a55d678b576efd74054e08daebd3b794df863b245f2799438b0e292fbdfff151a5ee41fa7c74ff5d88b06801ac8d06d9cab532d2473cbe265dc04cbbf31f641cfbd7efc2bfc078968a93649c96497f29ea030944c9282841803577963910f0bbdc24094bf83b84511c5657651e80b0924df1f298e1b507a6ef72ce67c0613f166ec9b91e288b3d3ebba5812a74380d509fa72a13cd1d1a40a96b98f2530e4550d9ad6d25beb5f5229ff15bedf65863bb1153c2274be4cfd7f724c63c1e690374064bb508c667137b4da1c0fabc14f190b62500356152752656363a44276e674d418c13d64bf5b520bd956d92ecfadd6e8e768edfec5a70b43657f779d11bc05205c590dba3055312b9a164c278da124f34bee9b59cbad6b5fb22e949aaf07eae5fc41f7e9fba4130bdfba6b9d155e2d2e1c672eb5f71ee15a3a544fbba402604a224e122aa552ae28a0f2539926427d4a7cd69f9986723ea2023f23776b589b67a4d1a0d3d72dc3f56e5c1fce05f8d7d9545ab3af8aa460812e892f1a97f44c5afb9c6633e36d0cb2f78d0cf9667fde4d78bdff8eecbc0f8c81be15d21677c3d979080fd610ae6de258e0f40a85917b2f3d8835c2f73428e54d9055c3b86b5cdaeb51bb65b05bd7b699b1078309c24110cdf98e26fefc3f75ecbfe1a85ddd56c74881566662c0d55f28c43a25a9cec99597ad5a55bc89a3f88973014b81079c864bd7b9f42870e1afaa29dcbb3b3644dc41842a5849df1fe69e6e67619e57ece338c1d5c40a309c03017b98a930a55983cfa4a6c9afea9a36558dd06b3347f33b3a9b17f7312dbe12a097fd579d1881947c97fe9ba5e372bb22ba2484e6932b481a087f53bae5e5ff94f696fc73fc5b2aef1cad758cde09215bef628b3b41fe908285ed16c8329c7078a42bfbf27f6d41f8a9dfc77829316c8bfa178c60192087ae66298192a8c2fd81e53cf486df18b6620bc028d7438e793d30ca11dab6a3f323eec9a40adb81f41d3ab56dd9780f04270f9a2e40deeb57562b51ec8664e69831ab157ec5c5f8c4d483b85062ac2c906aa783f66f1b627c86cfb9f0a29fe9fd4ed890a8f876c94ffca9cd358b4e0996ee8624f8ba776f94fc35cd7c4a33a038a489efdf6bffc9e082dcda7676e85743551930489722b085b2a6c23dc1f67220ebf3087e02bb843d03be5aae171957915638e11f34f412060092c8090888bd8db00353dac212e92f7e89d75743606589e1f0904cc7b2c28a6cad76cf8b2ac425c5801a41eeded8bfe72239e0bc451b92edc273fdcf373aa2886ef122926e0828c105842d6568e728fda1ee923286df61d7492a11c43d1267066366166a3c16521eee5c238ab82c3f37fe5ee4548819f7f4d7dfc83275bb166de0722eec6228263392b3ac1c7c69d5b9c550056071e21fec4d465f596742d8cd28c866cf7b350c14bf28da996eaf39e9fa89d916e0399eb70babb15fcdaa7e017b7785309dee00a7774994eed28ba7c5094bd4beb084b8f8382e85a27aea46aa54bf6b1432b580a9f62523463d3ab5c48f6448a88892227750435f53b1e061c9bd8c541e2c91d3c05feccbfea96cd0ad723decba20f0186aa35eccdb1549b0b1bdc5796e3f80117bcec2fbe7d7689b70b3cfee4e6c48f5d2e639a6f45f4cc1f3f32f9dc4653ca84a8c10250ad29ca73d43fe1ce0d5c4bbe9fea8e249ab716a97175bda0f9d1272f0d3992ce0ff14942af413364c57c6e19ea5bb9a4cf94c1dd10758fd7d49a836463ba5facda22f63a7da4e8eebb4dbb572109818beb8d7ae51a8c2491d717581e6daa7cc2220fa2bee388f1961e76279443a889bf8dba04f9c1370a2d953bef7b6cede18f4c53dc093407009326d9a2d4d8eb60caf8f4c553c268b7520b19760dd5b828bc3f063d91c0151871154bc6b6345dc7a23f442d7bab773a5358976029160a6519e2f463c178a0da90c7cf2cf9691c631aeaecd91cbe786f9120cfa69104b42a488338ddb78939bec059416fbb34aa66dd71c8b0ac8288e4ba3901a6d3f651236665fe37fc370a2290e618fada8b2d7f1eb045c0481389d40e2fd482bebc9f0c2a8025c4255ec7d369660640560c0735ee8bddf2735ad75c03f2df52e6bedaeb80f31c410a89dbcfb1d21a1584236c52300891f5c0e3bc3eedd500efc102aafc587e357780d16dfa3e68272a5ab7a78d8a51bd1d7047ea105c4f01d10d526013b0ffb65784e35fcfe06c1e38597410d6fe39f820a353bc19c259fec8e2ff3969e0d6ba802f965f78de8e7acbe32278c0ff30c89c0cf456c5ecd227f1950ba4e03efc4d92e3613c5e6da4f29a6c95c0b9a2a7667314c9624f1a0e43787aa6cb1d94ae08c63786abc77455c6af2a94a26d68b9f21043bde14ecaa99a8f0976d822da85a0ea1b284ceaf82a9f9e6763734c3339ca7061b48d6402c39889545e1f273f80f3a89cfe413e6968afc368242b53396aa00eb02b83730ab7615eda7685fbfc26408e3d73782dce8e2812047eeb11cd1debdf8ea84d7c273d7ed0554e405d0b0d7b03605548ad945364105a74cf44d2b57070e520f91951168da12dbbf8203384208bef56c7d30090b30312c0704af89cff89d08e306f33ac7cfa7b5f9d482ff4902f8af520cee2bd7dcd26576ecdf58a7baa0cb17066a0c9da4d2e05aff60c6294cdf1851d6d0ddb5cefe5e69f32b12deff1dbfc4b0fcdab36338fae87f18afa879e52310100218c18a8fbf9e028dd2a65108dc15d26f19f6a1ba3eb042e41a49f0cfadafea661d15e39e99cd9c75890a8716fc2e0ba7452cdce75770ba9c6eb7db0a7b9c3fa73812fac8f5c2731e248248d1da4ba6376a395dbda3d0b311607803f31197cf9b8d2f35045fc1430c9dabfcf4e537a062606b549f88b5a77c2601c0d7c0e5f7cc49a84a057f874ac35f6eff62ef483bff08cc885138c7c9d6e987874bd696567709762b207a03c7d757260829463bc3f9f11ac034cb563f8914b2986c98850518db2ffd8c2693f70aaf9039bb68b7c874da32921650feb104ee23fedbbbe08d3cfda50ed8a610a8501641921c3555890f02dfb4cd50b4a352fcb35d3574920b551514ae97350b05bf0d9e76d9ddd33f4ee979d60ffd0283003cc98d483cbf068b8cc61b9c8b2f4ad0707f787e132525bd20790ba201fa075614bfc6a1be0966286a5289e3e43d10fe1363dcdfeae11bf7b7c0daca845c9a1d8e601cffa0aa643459efb33dcb09a17c253b6092f4a7dac897d3960d87ff45b40ccfc87dc5bda352647a12c0136776119e6964e65eee2e656d52ca97b0a3a4ad1a5876826debe144e3a8a968f7849415a3e45333c794a81dbcc5b1405b555d74d1d5999b96b1686253ee85e265aeabe193e267bb904ac25a6bda8714357840143491e853abdb5a3b68c1575b446518ac6bb09e4ca3a7765b822ea3da7c87676c461fefee0a0195b66dbed869a859f65c02a099de7025c6c40a407319bc3f183de62b4a8928f7ffca2677a824ec625584efbf8911dcbd38ed0e98e2783f45768a57359364cdc2382ce146747116b53f033464ebb8bdd4ac5147063f7a0a5fa135ba2a8ede933921359a217df2209b4206281f04624817e6140dc1c3edbf5d75f49b1d4ffb964c363b2f3d6ddd59002b647bf998bdc29aac95c4d980135385c959c26fdc0add67168716f010b62492401d35aceaa0ea5b5a9be2132faac2c1f20b2f970d0f269bc8fbad498fd85e15276d80fb9e8b08b1bfb86843038df98afb24f8bf37953195a535c96571b0f4120f2eb938bab2d869edcf28efb2282c5f630cd8fd7c97907661b6ddef3b19926cbda8474f46864e7861ed3f93a101bb9f3b497f5f52e4f3ec4c9b88c458f8ced9179b7b037d506ff323c009b7c0b52da5a6d83241996e730b65b29c54231cc9e726aae10ef6ff9b73ebab7b46a2fff281f3a1ed45e1f3750c6ee22a19885bc5347446f29812f3dcce559308e57e49c780347ce02f01a597e63b20afd8e8e6fe601d2c7a12157ac7f9a2f562e6c771672f2836a2af5f521fae47c450203786570e2fe14fa716607047af7bce3cc66c35a9f2cb335a330b9f4a5ded0479b7efcdf18da45a5cfa98d77aaa34395582184bd912686398111370f86bb052ad794d4af30a4c70afe77cd53b2e3a80d37c3a34770ce72aa5e508721597cf26416235bef4ee92a66030e32d3860441ab0c3d849e1972ea228399d0beaf2239b79e9dbbd6864c402aa01e80078ce1341a02b4119589a9054fc82fe3697f97da917b46fb35bf6555a5bb10c2331af24e192674b9c7cfd4474ac8ad774d41e3d6e1ee08030c3840a5e31ad8e9dd65f6b873cedeb77c5fd5e502666fac98a36a3e189f697057f1b996357775c3da59d482beb5ecddff0393c6d40a32f1f73fb826a74a11a0efcb70944aaa9b5116a4a17531a47d7f64077a7393b7bf4cd229eac1ac057424b0067ad8e7f4a2811f42440c8d7d6021f4119e3f6f8c8e2ef4a54480a8137954e62dcac6152b51da135646cbb5531df6fac51905db144542b8a0d62e32b54c6fe434b378323ce476d2b5a63954026f21361e7ecb51c2c093f6adb3efe07840d61c35db395018f0f00a3223fe2edecfa41d4a722933f1d34f16bc5e9ae54b901ed6b3799efd6c4eab7bc815847bb2f6e0d372be578a1f88e0ef6c1238fb0af4e2308e7d771ae8a743872791a591582bb65ff21ae5c532cf0ca300351d4aaf80690d81809e7261ec0d7fae61be8f945aa9f1bd8d6dcd664743bbf9ea6a3a3ac65b2a56579b4bc66c4343fe52e51eb7f282e34be0d3cf49bb2ccd2db5b1e949b8d362ae5c1f84db43524631071c278f49a2e81593fdf9b5a05390e0d6d5c663e315a50e0e7af047a7d43f9b80b2cb8b134bd7056afa53915b66c66e4b0f1da90e2476bc73790709dd7f0a74df6239c183924abb903acd02e2d6a3c0460e008554977b0a5e1557c7ddf9b5da3c0a35cdfd1f0a692be150cd141e17195f01b69e6a4afb6d86d06e0e27dd8235a6ab8df8b30ad061874aedcc502bea754e85008665626ff735f5e3f8a226330fe5ba288e33626a81dc1c7336f11dcfb8b45037b667946862408da502ee20b4e1e1dd0ca8205c047bb1438bbac5acb0389f9a3b841fff271ec282c7b41d60783af440c2ac6ba2d07b3f794fe6bbf3fcc0cdbb2e4b4b80f48c7588f8f6e7b013de158bd1cda6c540c3764c15f974ff9d705a49d784015b4fcc8d62f0573325760b35680aff07be7a868dbe22919ddd277e0be6863667d25f0c7654ff651173dd6b46c89d148faf2f8c1cbded4c998fc5ba1b3af9543339c80125c30bef47f489e9f274d931343dacabdd7f4b7e541a6a60a4a2ad573c7862b0a3f670af1a1ce63f800771781791c2119d936bfb82bd87d062f3c48b9bb3289b215fb77e95844096f4688889a678f4696ee300e1a63079b5ad97d5a94308f324f6e11228262b137c6ad17e2ebedabb3631bfba399333c12c445cc80675b2f7957711aeef539c3787d1c6102154e23acb5719030cf7bb875fd81f2add1938be06e1ea6318aba5688e2d46934653473b2abd58ba41b99497a2aab67c1b26641f390fdc89f5723d4594758f3de2f7da31f71b30dd18d43a6beffae8f29e06f031614781f7cd039b213aa3d1fc7ee8d0801cda0571ed80376729962dacc871bedcf3cf27e7c3c0333558b2c21442a336baf6d80d2c2ec8d0845fba77ba4f52257714d454e98b5eafb3643ac3f605f7321cc565d7e75df000ae0f524848d9aad63b2be43a371e979499f631ee2b6555122e725fcba82e843310e1e4750b2e5bac6e27243750ed8bcb0c62b3713d27ca8e7f277ac50202e2ed4a58163fe77535611802727491c86a82453470c8601f406b621d508fc9d99dc6f318eb69b13597525e54f84d205940fd9e66d0a497e71d3dfa25c7af8073460550f7609382e80d1f7183d77d67083c941da52ff2f8a768a99ae78554aaa09615dcd63adaa754453c466e779ea6c2252ece9f9a68e30b10acd83d8c28c003d5d8849b8e7b7131580104e9da877fecccd675c60d6a855a1e3383529b2bd254a2c9a4d25355a5b3fe29170dffbf99a2234e7d0f40085578a5071500f875f328073bdf2ee189e6108f006a93a80e511eeb3adb8ff3072e38dc7bb8b0dc3764beef879d921c0e893683eeadb312e5c79567b9193b798a39130d2b3f75f09ab63197bc778eb3d7b5f48073f402a4672733199205662ea366a95151d85b0208e8d52d04bfbe9fee442f81f43313a8f5a38ad2cd17596ac062d4c355bd177c71d1d2419c3bbc6af0bb3f057f0a97ca63602e891e0764cec95925cae57898bd85278d24b842ca8003259c04e27abf69f0019cb6656bcb5181b177570fcae41baecdd2965ef1da6c46354ff3e81babf4c363534c54b568f6cf16112048d0548a4aebfb58d808a3ed85dec6dfb4d7d5237eaf1e56523a540b018d05603a3c222e1c9047359580261a2b5ef72db9f7b507895177aa706ac5c5449713b48c7efc6ec3d35c3ab35390f20e067f915d6ea59f63aeea58f0ae30de4ccb66307d074194bf859399c472f598d8c93853710699c7681d280097a56adfb4bf0b69327811fd41a0685e9af2572b7ee74adea76971a184e2608bd5191cd432da249aeda35510ea0060a15b88ac9d2abef4e36ee3fec544200672f0e92ddb3b8bb7654e7a0d9164ba344cd52eadcb22413783674141193c6ebfc966b50070388b9a924f904ea98830451f9ce81ea6ed7ec34df6d7ad4785cc6088ecde25842135ca47759c1f69d63500d08c704d8ae8523c8c126f966967b4201481c83b67a19ce28ee1ca4149691fd00b1547b15ef077555d8c921451e0089488d2d819cd801294964bd1d789431efbd9ad6f4fa9ab942077bf03f68d327063248d98e1a85ce45f8bbf7fef9a3c9baca797c0964cd8aff458fa7c4cdc054282e66d5e03e73ce4a1641eb1de66cef986cf5e2134b00b5f0d0845d2841bf0c20cf0468274aefcd584fbc771658bb05e5b49c760a9f5c139c8c70b5fdb361a6db2f8bdb7a55ce64df1f935d0d4594b5edcf92e5c3d3964de4e850d946c3ccbc76be0633054c466186a4a09aaa7d051862e9ef6fb92a9f19634587d0dba11e0f75c8b422a11305175cec0148bb47a81581aed3ee2032da3167ee9aadcb1a10b546f1db0e60fd8ea6f5454de91bf39ac7071701aa86c1e7df319a9e98a83a5ec580fdda81d65f89938ccb3d456c53d75c112d7f5317647c5bfba1ed07e3acd2d8f774136468992a045548a6114a473bebe0d8a38f4713295340ae67d621649544789cd480ecb0e6b7c003520ae3c470911f0f5b6b49316aaf9fe8a60d6ca9532c93e43fb38357422ee910b2a64c6441a902019f7b99610c71c974dc916187c2cfd82e7405497405b9e13bd4898504f3e91e4b6ddd10211577f300d65803c1868729a57c2787bb9519056edbb5793ad6a5a6a7d64a8a553884a547d978c5a7631bbbbfd8f5e53deb73568a806444c624d029d4b5f0631c8ea9ee90e010069b9a3a0c4500aeac8c92782df193deb1a4a02114f2ce77785d06571597125d2decce340d9b5120e02738e85a5c88bb058a4c1a3a4f5c22fa9adc096aae4172c5622f3748aa70e2a90cbb558b896c3178751d100c88042f9df8b9cd7731e286192ff8b4088e832265fd90928320546f63b7d167d6fd583283b6aaccaa4a5e40297e8ba920a3b8eefa14f50c6c2051e96af1ed9383515a6da78fd8559dd0ac85cc2126c77949bed62d52f0b2f3817e0e9c20040b107a439e561946aea415392689805cd04799108888a711805b2d5705f2c5c500237e621a9f53983504ab3bd62eeedf6936ef38f83aad046418e895f26a5712b690ba309be6dfe126b68dd0a81c4d39b4187791229c2264bf4bbbfd62e0618b22d4e9072a8bbbe77a1fe6a3959db72ba83a9ed4f8fdb536780a795b9ad5667be30997ab220cff13595dbf8684355322c186eefa0e2c0b5639f285757c00f3dbc9eefe92e833370e6b6450079c71fb3e1ec6026a584e7b3801dcfeb54e102810ee377b1b74f1d1dc3a307f5f62336bc0f4316e91cde96af7a5f4b337095082ade94dcc8a3725d16dbaa961fec61c6c6898b84c3de9dac412fe2607b9af7c0a6682d94fc61bd05b57ca5212d71a3b5b13671caf4accd64a25cfcb9b84c554b5dde6c07233c8781fe4df3b51c3bc0a8cd87b3f17104fa98eb049d4e74fee80d3ebef5d76784dc7f4ea6922b87f77625a9a3d35f040646f9a70c3881ad2e6341cdb8d2533c32e9ef1e4e06365e8dfd704b204253d539edc34e6f75f33d8a9827589d26007aebac58a770bf5700c23a1a5942761a05bd9942aeb1d98f6bc72bc246f52e472d591c64184bd36fc6b00443ca51aebd11e4e95a38e4ddacf993fd2dc9207e390acf73c58892c38592c3c0355d8bf6d9dad12752958b1160ff9fb1acc6988fbda3cd03b9dc387fa926009c4939e00664c28f6d1876962abda5c7108125597dab6befe7afeff4c346a8997a11fddbb1b0c0bd97fd85046cfae6b750a07bcb3a2c297cef7991b5dc9ece6f5a4b7b057295169beb282dbb9887e9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
