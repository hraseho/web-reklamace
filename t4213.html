<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f96e9a18905e62fd4dc5bfc93cd6692bb4052a62e742e08dc57fa0f6ff6ce9201415b674360a4c7ea494726bcacc7233609c7ae18d88f7ddd7454ccb360a425f74ffced69e7f1f9d63ca68953a423aecd30353e12d2448fa46377f2f3645539d58cb5258bf252f121d16b902882c42e4e3c4ccc2eddd72b6d65410988801a13c7d129668d07cbe88d286062cc74116e165812cb857294e513af5cf8f5a8d8a69910edb3e37c89bd3c59aecc3acc66de69c3eca176e0d2829c3959c2adbb85d72bc21c402782a4f024c166a813760c335be0812f4c440756c7e6e11e2462fc6c32db57204352c0400ea2f4423aa80e91a01fbf86772abe1dfa69e8ba3df7c4613c17c562b118207ed5f520de09f104104b24da31faefc6d4135ee4b785e9fee15e4c1e091efa1ef52a4702ed5f8d737a0bf821c2f086acb5c1886316ec8083081ed5b2fdf75776668042e9eeb424edf2d12354fb837db0d43fe814d5aa17313950c48acae76447ef07513b866bc19fe6444c0fd303da74c50b88384a81b892142a5f87d75634607600910176a72b1f2924af1a7b58b987ae1a45229cd257c8beffbb1723a834b9cb7ec3cf3743f433dcee1b9aa30a2386b76697c0e28aa642ea357c8f005a97088dde505946aeb41686c1f36a64f36285671607242e519c9eb2d3d98534a0102c965a2481e4b831be8573d423eb3fdc4cfcc62a85ba1736bd846e61ab2e0ef33a51b4b3522fc685be7491a1a2399d4504056856810006b0b9da317aabf7a49253740900cdbcee38cf9b21d17663f57d6665473d229d3292c6f58b8f254b7101f53ce007246556266b23c34d536918e36656579bf736f0e9154285d9b2d6aaeb91ff5424f07b4eb93aec8572c402d3181ba72af6e34506399a876b9d3475c306637b78fe47ce20048b1c74d11d9eeda82a6758e49017e81c692a2de4784fb852cf4c3c9504449bc75bce20f5567b2e901508c9ab5eb8f787562d6939ea1a283145ef0a7492b16bc61daf7f9c04effc793eadd1694ae625c93bb07d4c5d5f195419615f7971d67b29c75458fc8934856710a74c2879c19044c90aff6d5477b528b070746d622f8f69995d39d4a238d39ac68651bc2e2848b8425dcb0de08b1b73ef8f0a54b9a63837878c84eab3eb8702191e617166edaff929364f2f0b96de1d2667912f5134a1de14c1846791964e8c31fd5daa1c371a6d996517c0b53dfd9802969052029dd6df967975ecd5cbe8c7aeeb652ea2d0c6ab12cd5e929a7802f39873f76aed4bb53e8b8ddd1bd9d0b1ff8ed44fd6b211e06907147cd70f720c41da860a09da1b3a7730684ead5554be78bbd23db8ad339361ef73415c7dcda0a8d9bbfa4cbe468322ff753d5ea716f5da334c35b93048c669a090427941394c8be320126bdd134ff07168ead2742fd79752451508fbbc9363f31d9f4347f07cd5b15c53e6f5587f905beb20e1384faa07ce944eab8fc756dd089b9b0871fdadadfaedcebd41d35ef56a74d481affc5970f2b43fbb32a3b4d30d324fdb73c2ff788cad86c50f07105146820235f309a07d00dcbcdb78a6e3c9d4fd928fdc24569130cd8ce2bbb2eea15e43eb62ca046aead780c036fc125554c3da122be827a26a401e4dfe338287a97e6f7b6d165074bdd3d5b47ce88ceb2ae6785b5c015456ee51c5a78568189e8ff83b36dbcd535604006d6ca2ba1838a25e153b49db38dd355bc599776399912d388eefef1c183051afd1b36da9e24ffe56af379341ac0cc071ba61c4b914f80387e6a3865317a98ee50649f6be9f5195a031bfff830ca0b1334a680f473b0839acfefe80bad285eb072b2e3d530eb35df2525abb35d327f6135af18f6c66ef012ee28f9a1d4077c21bed998bf2bf5738c64f4bbc43daabe4c668a090e5ad20ff653a9b3dd49a8f4bb7a32b0a2bddc3b52928b4e988108e914e3787a725aceb8ca95071e8cbfcc5e03b97527bff2eb910bd6d80b1427964e31fa29df3b30d714471ee84b6b2df973ad1c11c467fea69a5bfc72a91b5c0a4eac8e52d8acc8877c644efb48766ca897cef2d193f878f8116fbd9747fc9f21bcf53f01a96f16a31ab4c42facb181d84ffbb588fe902f86cd1e471956ba62e7af5d4ff998d6f006addbfbe8f070cb1ac2e348e1e7213a777ba0ae0592a84c2b604d3f8d6c3ab57eeacb90714f0a56fb47fbacd86ee9b8a9cab9ab58a0880a399366f80b258aad51a3675553da2eaff578b098a0213f678e82270b3bd70a2f9cd906653f3376631d42cd30c64f24137970a6c51591c743e0f88f5858a0350279c82706d4ded07855654a186d04f42f66f609d70d41ac684f428624376c353f06adcf3b2e3addb5710aa2136785378dc7eb65d38bb0cac89b48348f24000b476582c5e91d7c724fff929ad0d208c392d77b564910470d696aab0cf94439a20efe70e2cd2f0351d31fdc869f79668c2eaace670d54e3c96a7acd3947cf2ca10a407fac2b2a0a22ebc429c19f3e0540497dc4c3d1efcc09fa7a15d2ff6cef326eaea4ce35aab62af27aff3b8f8abfba7e86c8d27de8025809fcf194e819e56487ba6a4f0835cbd92747665f3ad1954462aced1e45fc8ce71b2860406d6068a771e08cc69c9984278ba036130c414b2978dbca1963469ea00d3375bd63b2824d708b70d477380d8d6a1cacee5bdd227ff4cfa3ec9deb1533ff9e6102212decbc54ae2b7898d65754946c23d9e80cbefb5977a5cd7882bfcaf21ba1a1161259ff272e96053802fd863e2591347a045faf7eea2aa297d90d6cc4527c1532cd101c62a371ca36b126b39201a2d4a6ae19bef2c5f2b95acb12e9127237b1b4198c281d7ffddb36fefa3f7f539f3b4fe81af3c15ba80cc3543c70623a5008e739f39a29d1ec627d802f16e0833522499572f669c3bd9d299bc98da808446ca413dfd457fbaa60a9755b0cb18e3781e30b154a73d362c05863639b1c5c6e1674f1af69ba1fad6f88d9770beec027c64e1323b8c1ef5dc4f1cf31d9fcc25022bd6aef981967fe7bd1838d5a276b080cdfe541d61e5fb4c8ea4767403c396e36fd8c714b1d3519b349171af5590198028e2fef8b1cadc0889b46b88297aef07efbb9b80c0869f89bc36876cae1320422d69a58646c1128396793c416b4ba33196fed536bc0150f3d9054dc50356f2d2621e63bbcc4dafb63508d4a4bab87e62c28f674b6be0ed22876bc2e8512c7065b2a4bc47af78d9439ea65aef74bf791c879966c9cbf0b43c377eb8d6712a6ff7351655ecf4d0f325665df15860166a79e66173db29acb8a2a49895f86ba13dc8ab88bf031cbf2e2dcd867f79df4ee30694f58287dcf438bb6c43a5ea52e7aaf9d6eef592bddd300772d2dca44e80851a10fe27283e53ad0a63e2bdb02151fafcbcd8841bd11a07373bfdfb8fe1aa144cf16f8464910fefc89530ff0c23242bcf401ee78c647b936bc4087ca88cd3be83fb2ca2f861cb0048c5e2d7d104782c0c50770383abf053df26550eba19e9e6865278ffdc1ad061246ecdcacb3c7214905b258afd0e2fb272fdf3ffcfa9066c9b1c9c71c7b0b0d7ebe625a37bab87ac079f57d126dc069c3f3d3c52b939b3d168850f07b23b45c9d89cf432f90e95619870bfde667e651074b57536b0bf4d054782734131048b4306c3493b859a05ccd6ac9202c0f0e5c59c568339ff4e0ef54740979fee2f805348e99e4a34e2308be3e22a6201a1d583f159cc68aa32c52a72f8e469fc48cbb1560e357fac146ff86bce4b8877d6cde3d44c9548924bb8d8129762f3c82d8d02b8a5d94dce7b8f4211e8a78e981c036bbfddce4447da136b9458ff31b99ba4dd417bc72e246c628ec6f8e5d529a6f83a70970040eb224ee33d88b536d6f3a86d53d4a53e86ac8e9a4fde9e8ef97e9efa6e5e6091305af6b8de8cb9c1aaf65ba4f7747dae96d35446bc781881dfc5251797f6dfbd92743c46cbbf65f2d88b721236bbb1f4bf76f30e5e16bcc32b7b40f23ee6985c941fc9331b01fa34eb4bb7178736f548173f77c87caf15e06968d9ab21adf1136c3f25db1f52a3814c2bee0aac1f3cbb999a8c46ee04565797d221f7713bc8764f60cb3370e87f5af67d9f146be9273a77bd8fc37e7a36ce9e8add3c5ab238f9be8361bfd15b3559ec9f886b43cc77df09b876d906b33f79771792b0e4e208ecb90cfa6d3ff699300453d7d084b4c12621ec6682bbd360a24d4590bec35ff39290a056c98fb5203aeb694e081ee4c1b64e4e8cca096cac9815cdcbb9710cfe7caf6cac0cb3eb618d45882c4a4bf6171d1449c58ebfd757af21dd5c34fdd4f0a2787f7b235a4a36805ec6839dcac33182345c45a40265ad2ee281f2cfeb065c2da4cd461ea3c233499dffae61061d28cf8ab54f840f61cf646476dd30143adeff217c23efc2f5a0a6733403bd9a3d019cde332fe4a1abfd71029b16865ce38a7c830967629251c188fc4fe5768c6d73a9d651c1cdbd6b5611cc49d0949ca85cfdb3ebe444cd7cf21bfa0fa0a898302be11681be878220b793d781e60701abf1dd8c1cf6b5f6192a61cfee055570f68b83ca6cea4ffa6f23293f2fad3f9f9423ba94098aca5347db29423049b171d5076a25ab57ed7f055d3fbb50e9ce06157f047b8ee064f1b5c908bf25e2ca1aeb34c60315376bd3f94cda4445b605b1edbe5b6f182c066da387d9df7b7aa74d623e24396f5ff4b02d70f2ed46f23f0182d101279d9b5b026fa42748b0ca4bb3c74b52404b7d37bf77bf5845cf1c643b9ac83c5a175d2c81ec89842bf6c808e4cb9cfe2a336763ce42a5803dc147f715b60e441e64d055b921e2a071184cbc30736125072ce95a958e7d2f286031dcdebdd2f71cdfaaf8190bb5d1ee6c1a6f35fa7d08b9d1af094ebb55703b2f0d807853e9356746d07a44467e3cccf4d86982ed25114a0fca4e504c64a479b59e69998e5abc58a7783335a427360f25a9c5fa116af4c3f10a27f349e51622274e522354904547b0ef46ee1b64bfe35b502b7ef7ced8024fc2305ee8d1b0bc75eee592e2f4137cb61d91e39dfb89a238d31c97fc8d3d7c06d1e0688f2607d112ca5a7525e58d4ca8b1e47175a9de3a910be45a990ab0dfdcb04da08ddcffb405fa0ce76b221f388e7fe81ff58b0130b3e6529472c1dfd17b2324904b2432c269bf1d02e984a78ddbe64b1be25e9694d93a43deab2cd1f8088025d3d285763b27829816ddf55264cd07ca6921e02b0ea9721a134b12d6613e29830c5f072d80daa753b41fba222c40f381b6f2a49bbca78579bc59b9c7d51d58f3a2efc492a051e4b57f2a381c36a0bb936b545c9aa6b3c41102c5390bddcdf0c6eb18380625eb29e789ad02967c8c83b6cd60e51e7e2344276bb66421931c5156b098f8ad2001107b1bb7756e05396c2b16ce9295a11420dda11deb70ab9076aaf57e5e9d32742a9842d89f66c5dbc6dcb3c3bb9bb6f1aa1a15c3c56641b59d040d5cc33a5b7e4240bf637fd48a6475e0e99723cf533e6f4fcb4f0a68e47d9a0c943fcdef43334cc64f905c65f8aa3a5e282c3f83f6ed5059aada8cdcc1283cac7d7719b568bc6b6ce058e49cebe2957b4e375c01663a14a5a41a12f71181238d1ef2f6407b63330d59593e5bcfdf9970e8dd8ff4018e12102fc077628c54866a696761acb0d122776e9b81aa1efcf69eab7a551c16086314762b5c894b1b2cb6fe4271f301acee5a1e77b9c7cd7c377aa3b8886d64478526f5b5e7d2b1d499ac3484be41fe89cb8c0730fe336a34ae77295088945fee39a6c8671af8d43d4eba121dc3492de1a933a6cb58bf30db7061d27ae905617873e37c3bb5ce5febf5a0c76bb80a6f8e3d5c6d08a9e62d48d7ad31319581456314d1911bacee3c460558c5d49f2f84c902a79172d8c8c77cf36d0d3ce52f3fd42535ee23479333bed7e51fc1f5459ca30e1a400957ba267cdb4e1418c4984236dfff02fccd1d7e24167e7582d214c6866786cbbdbf89a2bc9f8dde9899093635dd2f338d910e4e46a3f785640cbf1d5339416196f8ae045b810fe942ac7b936c3f85cc827eea66d5a989617e2fecc7894d73ee73e50395ceb54928b5dca3ee4af8c45e953b407b8ec34330b067a958c26886f3b95ea5ee0abb26948ab66baf04bcfc097995a64eef4e427602464af387c0c855114242033b555bbc1a19e3ad47bfe07d0df4ad494575239b65d3f1624d670a54bd7b0af4ae912e445b3f783bc037ec42d106f6890c909400f3c72837671568c7f15c95d1c7618e175dd8c8a19802da55c65b804d59f2e3f8103e00db3fde0f3b9935fd250fd28e60c5664b2840af2877f09b1ccdf38d9dd88146e6e47adcf1ee09ee578c7e22cf001b76344aff01b9c55513da5135335aa32966c5741c80df2383298ae211be2bf2d605e53d7d30e599b6ee04852ee6f1f8bd9c4ad8a276d1244ee66f296cb39ba684da2d3a70b590a1604a9cff3f9cd772793026bce56a9ebb768861a57e6e33a8ddb41f5a5caf84d94d357f4de47382d10081280938ec8ed324f6debba149af98386462475bd759c02dba150c774fa2e18fff3ca69e2985af2532356a7dd552671b41d15244cf2646ecfed2da7259a33dbd4d5aa88d51dee3211aee491b91359c8d2d2aa628e053341bdf68579849c9a2e0d92ce85208fc6db21b8a6a73601a4f76a60b660f182b136f684ab1b54e1ba3555391d7a1760f00a3accdb0291e0d5747705e1075abf47cb48d916ebf583047668404d5f65995ae0c18599256e5c34f1d66e2e8e96b6562747ee4f9fc44da86dc40c6c10b20b480272926d0efa6485d383513e3ef3bbef6495076d314ee7a89822b33dd43104c0ebfec05d9926840d1e039c96a0eb63a2679b0ebfa65e2d54588b59d2c2bbf6d139f96cf5d46740e03dd68162855aa0aad44c9c593681051b20f8c8adb666ae7ce2aa98695abc1c5ed9986afe0695c425a9b13da578f88678e5e44d380d1f9ca84fffab91afd9bf4bec10e62832965ad77c2b35baf61721ffa8cdb7c6821303e15db15568aa7ec6ece1b35e41d0558a91afc4d9aa47d97ea2c093930ec0ef719ea6bb13c85d7c23c11b9e11abdd0b804649822d77cf817e3ae5bd6f60dbc84c7f76ab1a41ce1737329a86180375efbd6d3d0c4f2e54f7bb9dc219b009e14aaa2a31d2c5ffc2708557917a62214be08aa2031287465013f410fdf07b03e2e8dd384499308643c114faa5ed536aad01e7120224ef11ab26e2412129c85b3d18583cc1ca6312713fd7b9290aea81a3ad53c910f1f819406eed690aab0753ee6e5c1de4df57d87e0298b882f1c5106d062573076abc291cb1cf831048687f61d6979c04898a07f050553b4dfa672e5bec45780d32090f0a8ff095324de11ee8bc9202d685798cb14a778d78c21443b976f147a65994740bb24f31363dfbc5bd56a0a90a5ca94d76ade713415abf725510a36d4be76db13ce99398be979f685cd2134c6d4cf39b83afc557cc99b89e61486dc7d1967b0819d4451fe17c129b2379abcb9a953d9ebae0862bada1645dcf34aa10eee4ce53e17df28477821dc1a4b58511541b1453c2a5150730d9bb928852e5e6640d16b789f1d93d846b0f98e9877f9ac87da08f2437a5651180c785fef7531ecdec615cd011e2155ca3925d6966de33e2b28ac5e09838577aaf5f0b864b0c04a447dc8b0641d6aefa6e2c9ac8d432137f4276e11ae180dd2cb45d26a7b4712c0109215ef57234d0d30c4ab7d5d7e67106aa642a4008f9c0c5e571da20003df1c9353da75b9b328573c805a608dc4c342a17f1207d7edc252036e43d7ccd357a16580d3bf3635621f89d16bce04396262266f1dfc3d7ad94119be0e4bc823a0168a8871743abaca15ffdd2377184a259d39121673dc2a58e31482e85ea66084f16fa83afeafd0b1a5d69d3ad9827d9197569cccc369369a98c4539e20ad6ce124f931f9deb7fb9f3b4899dee51e90c4aaa7c43efd03bdb436cf7c98f4dc378b0f73e34cd9c0775c7d2ecfb3f63ded3535204eb677ce6ecf679cce01c87e8c53cff8c20b0bf6cff80c1aaf2766f477d63f27ef87e4baf3efdc0d8cff6d19f3ae847bf494e41842844a3a1a661735c63e70c1be4fc17075d0e1a4dc1f504de5f694e95e78055316bd7a56a24ca36e009262b510e41e39961191d67cc97ff045c16f793dcf331b016d28c86fa8bc1a1b91978a175c201680cde0aa75b898f1044a61da3076309fb37aef6d232bb0548dbf4980fc87f54a591779a8369db0995187797b15e7cb6767bf796c46a9f3102555043375f0cf1bd0cedd35a800bb31131a57318feb5cd1f32142013644ed7a8b349002008c6f30026dd0314d38c5473077615b9634a056cf03a81ee7a558ab5a609b322525abf90dd8021a9cfcd5bd339bc960d3a4080b7c899fa7bfa5c8b827d7929162fec21e89da0e624a35151e246d45dd58c53743ec1b5059b128fcbf3b9b5c7525e99c8792f09ebf149fc4781028befb2815439f681861040633f42ad840884e0c9b952e55c20f11a47462d85f55c80737475745f1997e2bc0936c4fca503bf164a2efadadf19a0cd1ded77b91174e8e305224a3b5afc11e33e4d19f3c1fc3eec57e63300d16629f093818051f63db6dc9f703df7ecf377bc355022d80a238238298c95d79bd18132bd81e8b73014cbded5916b1e8c905a01f6d8b15ef36f0566a75df8c02e7b1ffb8c64109ad7a215e673123f2d8256d2af09aef3f32938bf6104941758e09658d013d182fa7a4c0422ccc3ca726c4a4854adab9d280000281248c25dcc15fd36aa39670a784669c7408755864c16fefa40554d6cddd638a5f6a7995af1534f8fb3873fbdfff7a92d03f43b39361b033bbf0b73eae6361cea21577da28dcc6e6314f91f62f0622c37c0d2d758872a9339590a6cf00ab8389f86618a6e1c7cd356f6830f0f73e0af2cd8c2fd857e682694a626aef13e41df74beb8b04f807a29bd5a91c216643de26febb60db1c471c54e9bcea026e702d78e596984ad1208ee91cc2cfbd6935785c89a521992e8204ef5b5da5dd6c6c81a7a5e6df4870815d34e5467b1cb3196396fa3feb9a6db40ce402fa3e071bf080d5387367fe99482761ddadf396777121c4384ed96b34b0f498265ed7b43f2045b0c3f60e507e53e8c79c3d8479bc2ad20c2eeddabf90a86863c41ad5dac70cccab170ae0e7ec58c90a343f1d0fb73fc9a5604770ac5449d80de5dcd8581cb227a096fc721b2eab54c71700fdcd0612a332307f6d4fd99dc3a60d98ee8b8b82787bd4b160e58cc175362604a644223356e04be6bb7f24eacb3e50bec0bef7bb613654dac798fcdba0f52432cd4895776de8992e18574a071e3f3aa741049e2c7fd66817eb0f973679177a1ee5145631b26a525e14f0d6ecae0bb32f5eb4b8f67f99d5574f855ad9ae47878abface2b81b23a4b827602ee3f1d105780fb120eb3418b1b16647ab7cad2a3dddbcb767b1c64c24344485f637b0c1141f92f6e1e60d692f914ee9870f7a9261d8d59155cd58ba24411d5016ca098d1ece3f1fa9d922c8706b7ebe529360ad78ddde75f8327f8d9a28dbbc0f7ea30b3ce37bd211488ebe0a98c35a6dead3a0b05d9cf4a5199b6b877d03dbc26867b103baef27603e30428d0505af9e630b6c5783310fc5e619768dbcbbd528029ef4cb336dcf6fcf8c65806c2ca399343d046fb21dd274591ec8db52b9af20c7caf1930bedc995aeeca13afa0ce4ac571d5bbcfe0493d4e4742e8e2ee9db9e2419da3cd530b1e856b31fff01f73fd04a97d1585f5fe95faa49d0c0662091ada18fad7f8850a2a4af66d4725c2f76a07af4a01b5097619be4f50ef294fed9493f53b8c7fc6ef0bbad5774f69d26ed858c32ee2f3fc49e32f1498db87b25aed6c52f1744b4291fce148ecbcce288e678dc3f2068c45fe7cbbefb8aa126dc83becebfe6eb19ebf20ecd18193a89e808467d8cce06541013c719d34057829c286e968c1d34488b733ca88f2f8835b8c5665c417b7adb83d9c2ffa83f9e7df4e197fcba0184c71cdd882df24dc711ac9b7df24cfad2afc83e12a771e4d24c9c81a5de69f1190bc7296d4455feec2aa57d58f03b7e77cc9b523d9b9f7b6ce82458f238d38104790bc7b27075994b53d4af4043761cc92ff60502ff65562898cc21c463e5e8f58cd56f7d007274e2ccc40a69af25d6f8952e5f1b3b07c19b77291b7fa2a1e49fb92bd6c4f8ae36447908ad108892894fb91d30208063b2803806717d02f286b8cfc1422ba8dabfea04bc04ce6ad831c8c8721fcf8595719c344592d33508fac4d9cd31a936bfb323ad701d2adf2f9b2d556106140110506d94cdd4302f4e192af15e9848cf6eabe83d3f0ae31eb9023c9a8adc1b25076c716b3749fec3e27896c88c3773b22ac3319436d4fa924dc47d3ccaead07894b23387fe2c892afe66181a2477f0ad23f1fc3bd16266548ad7d4b6bfadafe565ceb98524d9f51e1b63036f1b6f92472094ba9ece7bc697059af5db698401d9352ccbd5e51a6af8b3a2746a4ba06938cab4ab64c9175f5f5247cf95a0ee6b348c013d43fc16a405daebfd93bae7cd6f1ae70734427b8747c60bba55aac50bdf2bfae244a797923106c4a2d64e3b66dd6b62ba2941bedb766d0e6dbaefe9025850521bb4393f08339b9df2907ac67b5fba6f5aaedea239df238bcd2d7ecb165bb00c7f75e51dc523885cf1b9f5799c53458bac16b498ce2fa20e859bf184f663144603e4ecb1490c2e70f76478dd3f108e5d89b3683812fe67ae15f761812facc925cffa920437a7e42047992cf7dc4e388bb65ef3e20a2669d0651bd05f4ec808a31d851136832d6477edb2053798ba66fda7d548ab0560496f597c32bb64cf0461331a0704d2110e67c87397ac6f899ff3ac934e9cd9fc714f7aff76ad21e8f5c37a6955cdf63e372395f824210083f8e3f3a75a0211ee4a9812adf318a71a147712f4b1f56280d442928dc25e7dfd75e05568449ceb4cd8ee11eef66c1b7611892ac9571950657c500cbbbab9c190be5c6188d1c8596a5d2a37ff93504ca197da1dfc6f4d0d474f94b05b6171693900ad05b66d4f5885a3dfe4b6bfd59c96086c16fb75af0c441e341b2db146f296171594511e9c840116021a63e2e7095960dbe17a7a54d6f32d3eed93d2c3a77e5962855acc8f98c3fcf96635948277920ca706804f20cbd671017c9dc1d17a71f68ca5a76e6f838f020beaa1905748e24e44b8cc653b293fd0285060873c0ba46cfe9e9503abc25180e4cb22dd92ab76fdd1186e50285881bd1fb7e6474b2ab3fd7b6c7fc7cf5de2ed8d93ee36aef3a43cf05c6f8ee448c07f2927a5db687605ef87f8a40c1300785c30f8f737c1d119d7ec9d3668a7bc24c78eba6df17c6cdfdd6570824b06403709b464441c8ae7123131a7c2d9a1df2d04620fdf671c1210f4b841be0e57a72d8e54b231f9fd3045e61791db397eb928603c75283936e5f51cd6aafa8aff07f2b1dbc7fcd50a342194b425cbe42872cb97cea71b56f527f98ccf67bed88ff1da5906d72a8d329fcb5d3f35d1e1f8a13c21f0eb5126cf599e90e95c52eb2706ffafa82dad05c32b75e07f02a44c4d3778b6ef6db0ddb6abb215448fad896e0fff0a5624f4f0cb70b648abd1510f56b85403e85cb349dc537a8da63f9b156223d7dc0178f56b4db5244cf4e6a1669b337da8a58cd1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
