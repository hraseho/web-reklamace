<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b91e7d4db51c9d3a366646e0ca6de5d3633792b767ede7c7dff9029c883a47684e10abc521773e88ea1a212fc55b6d53044ea818a51d827e93ccb1a093019a0e49f53ce2a8910328d41a7097ff5b38ea2f247fbcca84d95c30220491e9d1c77af122328ebb824e74aedf3ab9e5671dc7d5aa86b750d8012314d31885993ba370f0f9933a93983bcf8b680b245b53ea530a726936d78e10fe12d96789a90440152bdb808475721042f6d5b5f723a68e42a8a734f0ed1a5fa0929520b204847c51a07f7f241320f5da3ac4ad82fc93bfa1bdd56c036de10875d795f636c84ab70efbd71835aa1e59503de47c7a7672e6428fb841f7645b6e2b2f10deb22c13baa3d4d7943165b2c491449a3c6d5f790a0fee389b72238a7a826b34349ef9ab85726ded628bfc412f2f88d356e0c4148ce2ea53b2ad8361e2ccc6d82aaa61bc5de18c469591326fd0dd613a1b0b1d9b3d8fe54ac92edbb6e8e26e9078760d81c77656b43f9d4515f4ce211530505e18ce079a9f0793e192d72c51d3b3a6715f686e69aaf6f8187aa7f0debbf2248813320b3f8c163668e4ab56b42b73dc2d1b5a7f26f9ecf8f63faa51bca32d5f0cf36e079f80f37e88a5cf2092fa71f5ee0294cf7239be571fc0e79df8837492e712b5893cddf44814ddd0adeab543c8bb05771cbca4a9ed90bbdf35a2dbb9a40a4d4d277694a9859cbf561a4495e8cd09960fee597ead3dc7e3c9034fe73145b5f4437e81f2e36276149f0eecfc81e79ec3d03d909ff708c38171c675e59f993d5021a37e0ca950ad2b970744595df3714acb40e0faa9dd3c90e7a2cb81b85600f33b3c05d6cf536b554446e045f1569cb62114e58eb7233791488a92ae42c5d6c832347203485e1dc0c4194d82b0f8bba52b04103913ec588b7eafb4ed5fa93b14aaca6c84d4aca20929c7e8cbdbfd29ba8b83b7912b308173d9d4b728f80937ed4b0a6aa44160722a82b7bd81fe034366f9c242d74fc235b9cf32e7e9d6889c0cd17661b1e5167a182c769c71d40292e7c081b74094ce8a650db457fc80c7b7b3057545b1c97216756c7e2ff4f619853c9dd4ba529f600125f3c0cb5cd91799b792a2088f2ba6a18436789d71e441a9f7d5cd3e935735177e01b59717cd518d62e34bd0c68ed60a21ba7109d564ed9321f7756c685303087b11834a65a851e856124cc268321170124e1da47f9a234928da45e16bd818bf9eeefe4e7fcd83fc71313c1e374f6a3f1f3e988caa9529493b9bd6d0fb4fdd7671a58979a5b496cae42a9bf32f7377edf8f16fcce74918ccc6f37136c6b69327f2a5310b756497657b51e7f62ef9d743e0176fae358502ec95807dd98af13611e49115a38cb619a32e9463d1565baae3e7b5171e13fc6615ff5661bf0c973035405533db0f19c754ef1090559bf33a7b71ab70600009ff69866e41516150fb073b0961afe74759281ffb8d9c766708fe6bded7422548f6df056309cf888187d1a97ff23948c71f304b7c23c72350e68aa5c2e8f12f9214ca1adad4f2bb3f7033951de695d95b8fb66188b85244b64027540d3a1ff413de764489ae88bd84aca502ee3495330f064dd038a3ed1803d5d08a6127a73b371bf3363fa79a5a1fbcf60be2e8ce9e4014f2be611968f963fbb71d22504d6f5c3caa75a35b47e3c267d1f16c6457269c52918faca06802ee1182af041cb3cd2398790ad318cec8c7c6446f615bfb27886ab5b02992bcd660ae2f9564d4f7dbc2c4278b879c49bc307e1834c726d259ced288d596b078a2231eb5ca3a985e743c9564fc7b34978e47db90a623273f75474d7dcf169e71d5836c31ab05fb370c0ef0e99f6245418a6aba8c8f6423c2ab64e72c0c44ea701ed9b2f61cabdf215218b2c787ad3b66db2ac94c0379a7153f86e5cb01dbfc2e4edad4cf9e3213261a0a41076a48b867bd2e5f7ebbccb9c988c070f89dfad43a241e7f2aae86b655d07a90b3d5bc7adeac955bc12d26dc2a2219ea80d2b41f7452ab3bda5552a57ec59b29a85e8ecb84c0b52cd5a5617e33941b2f209a90dcc93b87b49daedc3b7d075add43cac28d8352333096eed5d70c6c4f9a0b9abd488d13194f580670473f2ee83c5662b4c0b8a275867ce892b87159b427757cc0e0d2e5d29c2b55a055e572c69f7ea61390f589ea10cbf2e0765807b8dc04e2065f3205e86b192129998a95650ba3c6adc1ef63ce2a0ee745d7cf47c4ec29db18a5727e3d4df1e57d501699043b7d94e9b1bb58af526192a283b42008dbc3235d265741d8e782450ac244277f07e61c718d9fdf45deb021530386d4363140fab4223ed56e1f46794e825fe56a601690ebb8784f203cba83e008e78c4128f787c840fe80e5d3cad69e126ce5cdb9bf58bc65cab2c6a5ceaee5f6d5caad689e60776e92fad7f8931bb62a0c9b1622dbc7f6447a7e8babbbeda2720fbc72ab9e25d69a0b07702c137f47f3ab7c7a96a4ea2d7d44a7aeacd9bc87a2f391da71334d6f41653ecdbc40607bed5ccdc22000749fb587a059fb6331cb23c4fad2f7fcb2853a523f782b801fba73e50b13480da903a22c16d09b2542813d37232f6fa413bc73b75af9074626f4e1bb058a8ac56f60ce28601da584fcda23a0ca26131aa6f97ae27e1c353007ba232f2dab6e34f817e84c0178fe97ebb32d799a2a6dbace459aa897abd15555de9bfd1ffbf68615dcba8bdcc1c049d127482b8c47c246299ceafbdaccd21d548c2151156c662c135ee2fe3c9e1d1e4f0784407fa99d08d0b6c196fd598ca991a15e5116a19eaf4e09861aef04e541ef3617df1cfc48342d6da79489b096caa02d8dceb771d0ca33e84a5a1316b463d2d0abf1392418a093fd474d730618308c887032cf3558c53bd64187faf89691adda10e870f5dcb607bf69e9485c21d5ef930f9dd2275b05c4f5b06dec965bea088bae42e154156d6bcc97d4b5f73e0777a688ceaf7bf69280b093d6f04906219c1ff39fe303362f3d76cdfbd6dc340b469332ccb49b1e5f62b8977d92c9ac12c43f4fdaedc4915160a10ea22ecc1d3c5fa781925df8fe69c38441f9bcc927ab85e6721848e6e3d94522cdddcf2969e82fe1ec9bcdf117c2e2757945f19a76aa4fe15dab04f5bfa0a1d8f88c18bb3a8a28d36fafc9e6c753c2e0f379cea179f2be7d3aadff1ce7b6bba6f717ed01b9f7f371c0272b05aefb309eb4c114224c2252f5f5aeee0c97ea3209bf6e0c2c2b1bb6bb578726905f5513dc9df61bdae7ceb30ea78cbc270c56163f8c11945ef3950873d333d35a76eb26de27e49854f02e9f6af2b648646a06d944df1270372f855f8ab9c863c6a20cb022bf1d49b8dd793885249245b1a3f2d1bcaed7bb1cb9eae75569365f35e686a8dd966bfd77d8fde9a444a923bd95b1f6cf330bdd59c5828723debe9bf36b3e5e79b9135da73cc236384a6dd2f6502c67c2b5d99db85c576b5cbf0231e012e498da60769a4a473d00265d9c90ca699ab78e0220f2397fc1c5a4e3045dba462c5fa025a7c84eda978e9d566db9f9d87e6c19c31e206ec728cbf9213f7dec9d1aaa36b4656dea9cc61290fa31a39af0f47785eb0594f13fdfab727a04a2f093e0c0dfe2e939bffdb9de3c01e14c11448ef8899aa91c41d17a9eb2862de61cba6566cbfd3b27bad68e1f90fcbd4097e21eacd27a88d7313c6f35849b051efbf612f8f66b7be2917ba02b455bd030a8d96e6080093548c442e9c045eda6ab3da62859b61c9482f3da63e609573d063374509cfdcdf20f7a0209b2e5eff7dbc66ea5efe1e13d8b6901269df4295a5e3249bc6dc298bd76c6132da4706fbd57525df5a4c7877e3c379fcc9fe76e56ceb46a0bbf9a6236160bc77bebed1c1b28954056c73805ef82799e133dd439147018a6774d2b6b0cf1ff78e6232a935235de4ae33ce6b65ee832874bb4241559dbd9133399d773e51d1259da9112cb83767c94ca82128c0bbaa328bb953ab0b51bb7c7703bee7dc9409a9a2c4dcfdccc5426af95968acaa7dfa45f54ea202052c2a9d2826182fb81671a64f02249886d4cf63044c5019fee3256c1cdc6c045252a2dfd7fa17d82d54e6e612c65fbd92d8c9dd019db16e1342c467fc9be4998dabb08f23c214005c98e60953336464fe2e7c79f89965520c79a1979dfd5eb410e747b1ef016f48a5ae1019315b079d11fa25229c959f2ab63b0680693b6ecd7bdcbe9c8172a73aa835eff9712a209ed8a908b33036002f0f6f9f841a3e50a8ca85c39187168ace1e6b4433cfccd73172c9cef4fd7496593feafadfa40891fb0c2554b2ce8c38b0ce05b00f9e94257c7af72f3609cda2e80187b496dd21ffb0565866c3e61402f9333f4fadaa8df531de647c3f0d37a1899a2910ae6ba93a8d7e6893357738ffaf09ac726eaea8cc0bdaafc379d0db7731fad33eb8c05dafb5571d707acfeed0d431b6582113cb996f33654ada8cf0b8bce93590ce07a5912e81cd3de60b3eb11c778434b058cb02533a8c56269e68599ac8148e05ef0f3a9259464a0e21cd685ca79c9862494b336abf7160981d505bd047ba38203a886dd9af360abb8dc5afd2b290009fe92b4362d6300aed12fe7eb06afe6e42ccc9517948e73cccb9cc4c37ff2cd20f3a20d6382f820789990ae7d43382b0b51b341d43e520331ec1dcda6b3d587aa5f3017844b0857ed96076c3403399d86d7c3edd5dd98a278e736a364471ae49ca881b994c0132778b5b9a888362857ae00c99d5cc29c4e9f2734f8e4a66d0a2a166d05fae11bf874c1d90155d963ff3d0a15cbbb0ef086ab0efd99d307ee883d34b175283d2ff5b1f38145539ffcd6250ed26995d0a645dcf05641d319a713dd3b54d6c4486029dbd5ca2d2d797a24f8c54ad3ced4cbd52edd05361defe83011de26847020cdd652a5f0cc5e22b98ca4f63ae10f8f9c98c4cf10bc18e5fcd934c9c46f51b6dde7e364a34050d0ec3a9277e5e60997b4a447216a4eea83a12777ffd6a3f5ed534c8945e370b996973a1adea1f811e51ee8d1f4d40ab37d6a6e38090ae54b776b6de5bb043c0bcf3f15ddfd24c7ca6546def65dded48a60bdf8a570419d022b0c79ff92bee5dc818289d1bf2be9292d810322a563284e0e3b028ac5e7138b895c7576a189756cb5263934f05768f055b5761f7307009012ffa111c995775acf810e32a3b7c5647c6146915d30373d90344c9d2bd65ee187d9fc7c8b56afdcad76e01f74d5f3a86e3673eca5525d1a08c1c03663371b24e28b491947c2ec4fe6cfcdc58174bfcb1c4f2593d7257a7ba801856e8a648c05c661015f71135221f10d0e2b1c3c0e8a2144397ccf5d05a920c1e310072bb8fb4b34093c40258be3e66dc821714b58823da824a5d0ea9ec504939c250e773b536a970096568d4d2139c152b00e23d34697972dcce7582944a990260c4bf736fd07e839c1a1e6b6716171c139ea4281baa0bc2ad071a4ef9402e94eabaeeb30afc22daf83b8ef81b9dbb7d6f59476b148404d850af1c43a1c5ac304e63436c54fe080654966e6adf6ec95b6547c5dfc7ea3a3bbbbb974c84405ef05c6271d3e8be741dc340cd6d9678488b1fd279b6901e68f1d0e103a7fb12ed208ec5699dbdbf2d2bd831a6bc2e2c76479865ad9aa80ac6279b082ae3ab3ac9337316e580a7e77b228ae010807cd4f546a76cc0d44cca72685817aa01aeba5644c5bb9cde23ff68187f8efd2e087c5269182d79dbe28ac82356a53fadc51161627f7a63daa982a0ad3120862087e21db40478836a49d64010a72f4ce3210e78b18d71504751f61ff06aa81faf6ff1fd05fcdc49b478d00800b842b14b72279befa72f3caa34bc97364f6e0f3f48ddfa93e4278533314a24b9d743141dbb45a79f86cb8b4c65f59ceea4da8963abdbd6c1904be607da423c82d96c34c4e4692edcaf552fa5326ce16a7cccccdd10d9a962f1a2449d810f9b29bf1c372830a432efe52e7fe4d5f54bce4eb70b87be01fefa3396d95ea945e7070830a764646c8e7f74dcd8f4b30fca55bfe77963da2fba10cffb87cbd8cc24afdf0aac346c4b60c71a79f3f6c577489abe5c5fcec7132c861a7e67059b305a1484d70e12263d7c0bf3b96da0bf947c8bf6c5c39336cb6989f9c2bd4e624be54b0db19fc8ccf4ea4a76a9ca24a8d1fb8f79a8c79611314bd8b652b13e136a886cdfc2a61380f66728cb85aa6729c474e2bb0aa1959fe207440c3cf1ed673518732545654823703d8decaa97e563e44e139611e62b136a5b85af893e3556016e51b42ab50b502e22cb2b45f98ad7c3dd7df2573e1eb0a751f48619a80d190cc6ac23507db46e8e617cf560444c24ed8b8f8867db4a724a649252866ee92ca5884f63140250a7626166d70ee1b9577136eb69032a76d5d64861f735e11ec176584f84807864e32c249bc06dc270f68bee8946b46cdace9fd10840a8f28e0547ed28daffe77c1e822b0def224def9e6433fe64983076ef1e40a1877d83dda91929c0ad7e0bf4348550151b8541e2eb1a18c9e9db6cb7f8a78bd12106f56cc04c850da47fce31a6abd02a5c316d4846f4890e024aecee03911571fe7f3902da138bd4a93f1f5bdbfcab5e6b384b74c2da3b1fd4f0876b3c3dfe493d52281ce7a6e421c3a908bd32e5ab1a5f5821282c94342b55a9ac12fa445f2c962226c34596361504e9ee725068e220cf97432fc7104ef85a32fb70e0be0983c0d1620f6b7356eb20e3e1c168b4d45c2236d4bc66f3985dcc0ef1f0f7d6bb56f945b67c4df559995812771ec164dd44443bb91ecd4695bc1fbf1005ba9369113e58b29823e0fd52785682508103be95ef0038368bcc814fa78f1adc8ee5f7e8623843e605f59bb6565e9ea6e80b92f636fc83d564044eb1e58a85d62861cc5064ecaebaa63288f18ba8223d215ed20ec5b91347f28405f69965a5e839d996d6ee7690227a24de6bb2a32429cdb3329edb6432f59a812ee04207eb7f4823a763133d37356eb64d11f39b7394c38c2e218d45e4da316b00e93856707180a4de05f7814e535fff09ecbfbf1b00536f97bc769d7bb33c9adc9e6c8528bc778366e9131c42e7af4facb3eed63c813b0210ccd8aaa55191ee5fa891709b67ef56946b5b0b58ce8474f0108eded647683ad6687cc5af5c4457c6033b269db03e86b69eb726a0f1a1386e8f65a14d1e3c688b2ad98c8f5bffa0cf51ce3eac8f80c20acea39c5aefebcdc4b060c31f73d8979bbd23116da0f92369f50be97715cbff887bdd19dccf68774d3ab21135d3915e0312a3669622b4551213267a14900e40c05e839fadf856cb50b0359a704b001323a253d4ca9ccef62b4cc955023d51ec0b6cd500ce21dacb135127f15927574bab0ccb9a458d92bdaa6ada9c0abb3a9e8f7c9bd2cad77e576aadee892c8b07434212a1563d53f35033ccf387d158c04666c475eaeaaf37ee6ea4a5daf7ea12e4eeebc9fd9003df94c9604e346214fa7d08aa646588b75fe5b7aac34b2db09bc2e4242271d683464498f126b6b2a5f0bee9cbeb4c831d2725bb64840458cf4013e11cc0c40d52c4de17cd32b8dfa5b85c846f57cbac2414b8b1115d90decbc2d8079f21e8242d9431823eaf1272bd1c798aa12465e49d755acfa842effa730b4b10f494524df43ae3287a283c764b79ac6cbb74aca50e8957f48e9da77270f68b389c12b553a9461c4ffd0bda884bb4033b3b4e7895c29171637dd080b7620dcf94ffebc3f70c4424f30354976b43284720f7133aa61d313fe94d65e1bbfedb698669b7efabd000600cfd14fab4988d48defcdfbd356641cab261a56232d042dc8231bc6062bffbc7ac8a1caaf92ec1b5259bd30dc650e7587046e4d6f7dd45a8b3f5c16f857f2b5a5e11bca47126d84dea5c0561aee948fb636c82f5c70e2a98267aa966e3e3be89c12dad12dc4c1a082e65fe331959af62c5e1a4237264fe73c04ea656a9284a70eed71ed6617823fd67faf8a3344f08a5e5358030a6e0be731a4c5e7addd7859bc59a72982ad474585e9730cfb2dc3c2c45f2bb9a4d31f83309d4e72ba8ef462affe16a31203309efff4853d4615aa51b07530d5ec6a23ae37001ab889d86e750774db5e5f6130dc00bc53474f98edfee8900980436f1c6b1ff9429a26eedb76ad8b548edcb9f13285090176669194b685cd3ba5b9adfa8e9f4054bc6019c1309d822ec71383a9cda241e17cac26d1c2b7b436f708a52b1367a487837c399b359ae66229361bed788bd2b5778dde7f6abdc9c6e33947a27c7a7f03c6d10d5d02bcc686019d1546dc0c9da2b42c5fd9229e7745b149bebd718f3d27b1efdb62e99fdc947840bae66270d0317b537a26a82e9d237536e381a189913756c6e8bbebf630de42aa6d0d995c8b07445d767d95ecc2c4145b7f41affcf02f7b8c2d3e71af155ec96c779eec710773afdaf6490279ebd4d67423b95414dc36e1e4d46882e203c54313b3e0b8a6d32bc2b82737bf861c829cbd8eb8c32353da47831c0821d5906c82a08c1b9e6f4afd3a8560b457f95c0565b0985a5793c9b576d6d20ba1e6e8c2f99c44fb8d83354e614b11c8aeadc10ff90f3db4820e961ae42565d3dd044318b514059ac987ac5667c4d5c0efbd692b2113cd5e65d6fca6fbf90c25042224033ce1b78c2e9438e059ea7669abeb8ebc94fdc0cf1a6d530104126da8ba37a16cfbd92746f5e093943f778d7dd12738b0a60915fa348d39559254fbdec6798c1e863a1a60d524e4ad786c59c61a0b498d00926660e7c1a464b21023f5af36ef143f6220bf2ed761cc29d3b1c2d8af4da8386097b34fd985d4517297ad8415680d19f5543e88bc79b316ca34e269f6055c05963a03c4ce7d0c8657b5bf5a05a5e4787329ff1682ecbe93c076cac515885f6d2883f4d9eb9a39f9bf5f1d9b0bcf7e501bb09dba1461828b730037c33aa8c1924a6ab80794c415e7fb3db3c7b2cd8fa262b036211ec0b70943f7f5e250f0db919ccfaa7ccef5660a5666767fe6871774dd139462f5442b322a05c7093beaa76c9f47d674c6ae917ebf3134be75476ff84cf8616547fdc953551161cf708cf6be67a0e81abd4541777440cdd9d6b3f489183a3078cd74608d41dc23044f21df17ee705c2b65a02d69fd96bea7c2a594253834592484583bb732286f8885fafe02234b0ac28a7a1f00f6996053118b01c64eb37462ae5bf717f972c19db83e7896346ca8e178d4e64aa5cb1492f868fd0816251245f5275af75c08edbfca9b7b31b4ce591181ca275f1ef04d00f1c3b4a8ec8816446b75abcc27f17da8eda54afec1e8398718aa6a6c360c575da5ef619c9ae126b62d8abe9d46fa3c5937682f0eef3c1bfbf60c28ac33347d1388c993341c87999433490b88ee0b37c91e00f8e5ae059436627b0cc019ad38e6373b546e01f6d6bd72ce63834ee73fc9c076e62a92ebd193b9dcedfb359c7853fc55f5e0d8b6f7269ddc3341cd29f7a25c1c6fb5d75a662653d6af672d4f0cc09000d401000dc5f6de3f3265be2185d368d1967561b13054d6dce42cc4b10117c8b6df3b97e302959cf7e8f39c41f716bcc16ed25fd435cbb45ccaa60415d6f40f617f084239e319de74b56bb551e01f5c4b357a3b36801116adb7b0bf90d373800a590e6c14ddf9e38d22331a3ba51f61202f6eaf8a97f3d9da7dde79e1730625d7d83b65b3db5ff8c64768c081adcdaf7e864f3ca71f10ddcd5d241289acb3c1702262ef82af06d9768e5a4dc8cfd2ed3a145b39200ad6c69c126bca2020bbf7c1ed51583af86bf6fc72caaeedda765a73c6d51b27758d8c46579fa7a1a9c7d826e5dc17293d434e6d7f6e33af334dde719a9bec5959755222a111b2556f9ef31859bab73e6b1f0a6a61833671ec2d3c96594e57d423e8205f9513993a17a4859df33433b57c242ea3a2b62f102f0275d6ff9ae8b8aa9b5bd9e6b226755e9c697bfd7b6f18623ffbb954edb5e2e420cca7b35cd4753c7ed33bc602dc98d80fea29c19d23b814cf337ae875708d3b3082ba13b613497c54ca60401b778e2c1064275b1aad163103aaf3c3cd0c73e7efaf11aa937ec68985bdf1c5ce0c753a9fddbc8657bcb8e31b13b92cea5f3d25c542015165a94e18b5a643a63fd378922c3fbe8ba4eacfdff60759ad49a4eb06a0efafe226967097c3db54894fbe784fe23c505988daea75d44f9ec624f2c61128217319917800b8632a9c4651641902c6c920ad7ec39f7a1f285fe2959771a6c7951b511fb17fc178921b5a16db6bf7878c53baeb639630476fac59f885154c881c3fce5e433e005498100f82deb046d5a94a46023ecfaa9d91c34e16521a188b189720f5c663db06946ab02ac99ded5f4f2442d784d9d47ef7c3b4acff9ae1dc1a6437111d14b29380cdd7a8983c7f263f4dfd0fa3f53aa86962353e4084bb36b8ee339b55b4bf809a15f69da14a1c576009889b17fede8076858293e4882157ec933d24de45a30eca1be6c8a1f6689074ef17d5b666ec0a3668de7312a4792e27873a4bd7a20b195c9bfb721abfdb51ed4dc9d56ba92246bdce4e5fc3317b656b93687b2b75a8596c2a73855429d8e287960522742e563984187224111532a42bc8ede4c7a1a96fe6f1fa498e58eac72ef297a50e53fb02e104e44fc1375f0a12e55359dd43859f0965b3956b06368681ee0964612f74c5591178ad8a2be2e95d8fc1e2b122e517adc81b53d20abdd4a8896fe5da2c6c4e53a8707d0a545e124a0c45efc9916691ffe0175e7f98b02f085e28ff2a6d8bf7141f5dd7df22b595404ca14ef10b20949964e9db3f1bc95dd818b918bdc58c94ca070682aba89de5092e907e5bd8862595fec7d0b06c441da8802792c39c559989177a1b86708f227d867efed4872cae1aaa3d4bbce7efad05a67a159f0d48e000f3bd44aceb7126e15b26a6bffc608f807fccf3568ce9ecaaff0b489ff7f6ccca274f250e4fae3fcc17e4ec5de29e164e1d89675680f2834202a49815f0ee79537d1782d1c18d176cb20eef4c94742ee8ca2cd500088e9e13a2bca6350df51c9c2893f1b1a1df3ef8a8cf0d9ec17f5baf89e557ba26acf17db7531345a99c612369de34ba083853ac5f180e92852a0ccf525c0e9cfe4694945b59866d41473f417d5040c70638d3f5243e42adf2a02284ea498dca258f3325da03e33c66ccbb2469499af0cfda19affc42c655b673a1f785ccfdff7d59c51653bed0466aefd00375600e6f471001bcb9c53b01cc534d6050a5f563bf6ffe884560e05a03aeb5c57a490c447de53f0e50ed854af62695fc963ca2db92fd42b6322802445aaaf6da29edf73bd80c21edd87e95bb9665b2beb804c32a0090fb3cd7ff7ea764fcbb65d42d46e7c676709f0d5560060253127f7169636c26f739c508872c3ee6519e79744a44ff61f4f2bda8f7fdb5df8d1c9ed6fd3b1cbea802801b12c597f1676257c4231b18ed2d49a9305457192df1e8d413654cddc8914f6bb1e084f00f53b0880727be2cc96858c5c2cb7504eae9f1b0ad5e6ca8a5f6c45b5e2ebfafc1d5aac910313d7204569eeb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
