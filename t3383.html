<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd20cdbe5c63181c0510753ab90a31783640c2b6d02a4913421aa9cd825eab70743ffc9980184bfc1446bb27abd87cf64ba829cff9dcce1885fd6484ae35565b7cb9f5e718bb5030aa14b6c6956ca2c31824ef91de4d39b474e2f9266681f97fdf3c603e9c664a0ddefa404ba3aa41f66881cd59e685f758d32894fced6a6ea4336c953eff862453deb40620e8814b6a2679559b17e377c7a912752fce3b4b3e2dcb70bbe0d74d91056c124c80034498b5a69af43dd9125c339bd55bf1e02e13364506ac87bbce05127dc800c6fd872cd83b6731e715cee1c737c06d753a686f46acf346de9a2785d107272f25f9e61db04c16a30c88f02c827d283436e6ea5dc19bb963d76a6c218070744297da05b5a06fff55f0bed371dba83b3ed2097599b4c4afeb19257ea4035e915a352d8f363ea551a1008c705ec92c6c4247ea7be3dedcb4785aeaa6b11726464bae0a7e22a8e9ffd05007ba8605b76f7af244f838cd0d5ef5f672d26fe6489a7738e4cadcb1b98d91b367445adefd6f35b1e01c10b07420d69f1cda195b55ca582526eea20342d8bae7aeb0583f4c0e9481043e2d10be5625bc4f6cfb9970c298e3e0a19de1ee799b148cb58b6200fc52400cf778e087b8b9db3f92829f4334ea23d73ca7f1ab24f74b0869d13fbd1ca3ee114f59d673243711c49c5dbd0e3f92f9c7f64c7dbb24d99e2fd3a0ec8e1a04872ea2f3bf3139c7099221b6c54567575e058994d67c5f8fcf799101e376f88ce7163248ae29b632d2779bc62457c067bd830edfea6575fa52c5615c7a4c4bc0c1e02aa0c0f6c51212e1befebf2aafadc7b83b682b007465c307120a3ca746f1153eaa2276481ae741bb470db081dd8a37b6f01bf10d1a669f7a945702e2935806c51b430c532d619421e3526c4f03539eaa4492063ae4e6ec817cf95fb03903254cb52abf6dbed785ec7eabd36e796312cc410cf079338ab6dfecd8e9c69c41aee3e08bbe385de1d5c9b23e11c0720ba1612edb82dc5d725f8582c9024ce9d2267c0b1864747173b9828fd4a092b1ed55b15521aa49379daff6d1047404abe4885fa361bde051e080271d3760bdca256c7b12879f671f46500acddead0a54f890244289c8a8ee96ffdc0bfdd33f29b40da5db18ea970c83d65e1736a7768dc19e1fc7e82e04fd13d6f0cd9cea088a3c90922516d8d611d3f7f0791421a7165c840145e225cd539a3fb02eaf57b656ae103313cab3c8ed657849e0e22d0fade6b9634605562a9bce72b3b6291502569d5ef3a6037bbc5aa37db79cd22c4e8407bda6a9eb112a17bc8fde31d66cbddddabc3e80c2210b9ae1f1ee231ced1a5bca6bcf45a949913df9c4d8ab512a0128831dca2692c20ce2ba15bc3dd2580cfba2cce0104b7f80cda56e6426528e19969d3895af5d55c1f50cf2275aaa2c9c06c9dbe40f5449f473d2733bb906e66508e89e14aa520c96462de9a1e1a5a0323b49640728cc7962fb463f75dbc29ba24776b6d0702a0b29aebbe29ba63146078de955ea928729f08e2e081d522c9a6fb2ec728d8f0c998fdaa425d098255578c9acb7606d5cf356a85c7e105d6d45f6d445309fab440c74dbd026d29d6fa7f7a8712174c3afa4759424d880ed9d0cc5802bb8f44fd30f5fae063da826f825d1105c5f53dc533f31978b8af97250e5dc99dee1a7d536b97a98145efbd08f4e59b4ed89dc4013dc405bf694fa44055e6843541b18291c8f9d30a03e48918e01f2449635f7625f06ce0af96329147fc6544eb2e8a9a68fdf3f480e46806a1082f1790785244f88ffe1b80020c4d443dea8be45d3ee3f8eebdfce7b0fde92958f9ea55652ed1e0739b7aad66f6548aed5a185279ffa09056b4d7ef5668d79d21df2e6db1491b700b16296c6d2ad4b11a4b50ec799ce8b926bb203a0f5b97bebbad68deb0a1834c08b383fec17b38ec0f020d96180f2825c4cef5778f47fbf5ed5b5f993d8bfddc936f0ad2e3a36e7e1743362c29130cfa7706cc60d74e05ea8c501d2fc0f84ce6377697f847d18fe9b33c2a5b3eb5819423491b93ec273b9bcc7c617218708446deac7c3d8e9700a7850659356609d24fa05942100117ab484aa4a3627a6b90bd0c35b74319f9ae03c0c5ddc4e31556c3a75b4fe4bdd4ab9b90499bf4aa39bec0c0f118455ca32e161b684307d9b8fde49afd31141d110c4134e7577bd635008f8b7980182efbeda2f1483a9438dfe161c6cc457ac60a081c7b480d9979ab7b81bef5837ead0838ca641b30f76ebdb7b1ace66b3a72a689d7c5888a791d5eab1fd97be27b4755a7241edc27b3924bd7eca709d7c135d92378a886deb8b4a35b513a9917179218a5c8a85b532bdb92e74d598927d24482b8e98a221e1d6c15064062f3254f2c5f75990264613bc4d45209a88f0cc202d23b95a664743f75b8b5844fc5fc1816261d281e0deac1678519ddb0301b2497b1f5813d579c61a3f23b963672c6bc3580703947204a394b395c3d0b8b06e80fe439204e4b7d65a9a58dc3edf764802a8da595fec31f90e10d27ea3591f92b2f73a9ec8100f49ad4eb3c9658d7bcc1698023328764f89763345d3623040b6f4cfe2515622f1a2c78b3a620a5d3c750f390a6dc244ff05ce6592e197384e1c4525e0315cb98f5b13566588d73a94c69e047bda78015f79e20d7f6d619335982d8480a7a233195b8b18e1510eac86e9b9d92cb0e2e744aa38f89029f68e2800b4a45976c4d5c50a2bbfa4526f20237b523231e3f7dea4649888fd53295b74554cb74607f71dfd539b308a83f0abce88d8bc6e79146d468eaac971698a20274355b9585264e07aac0539d91aeae069a17560117e54f58bc8d43f8f9879b2a99857849ebf22c0117f66d4daedf53d9590b3d17edf6d13b1ba43effde32dcdceb2b28df067d204606b3ebc3bcdd84ca6ca14fcc112da9b62449a1ccb8644595b0260213d10bd07dff601b02ab49b2a52d2eeca25ac503e16b413d996ce5837311f4a839985af2ab10b6fb9f6e9861f2c375b57e16a02db66c64e599af81f7310e4d3dcce8830627f68f022f17958eecef088bd0284ad3050f1fbe1b55800bfb926e52030252cbb35390aeaec20a77ece6df543cb1c63db9a34d5011eca06cbe97ecca555088128bed8e71c5c7029710b482e8eccabfb26942f76fdbf3b3a5a1e4033964119851c32ec728f35f1894a6e8b57af22353462eefe6aaf81cb77ad0591f9c369590e2b0f52240142dabbb423cdf77c1b69b838b32eebc888134034c74b9d8c0d6cd101caef7256ba1fd55ea067e3307d47de7ffe27bbb86df00326d491ba67b7cb335ff8df83e9b199b47dcfd10b328cd9bcb772cab9238f89441ac59724fb4719df178f8278146fdb4f9958d045d76496b3146f8cde9d8971b868f96196606bc737845f471ac339ac7d87d16cee1c5c23978607f7dc1aee09c5743d54a27131f46c1f42609e032c0fb7de38942a1246b0cbc77ac487fd342f6df11e8557ec7df6af633466dd531d18c6d16eddd950da3d5c02bb21b2e19227fb42e37f3463aafcf8cadc68f2e047a482523152d531043bc082779010bf42a2f6061cc6250be3e7d0a70b37542ac29cdfbbc543c888606941c865de832e7e901e227566c8c1a9b38566f569ec3aaf8b2e5f63d930478fba87d5a770cbf40e4701d305b9e3b2ac8b9af1845640c3e8e5334a299a328aa240c0e44448564242936cd4fcd474b2bd3c5ef7b3193a9cfc961d323fe68fcfbeeb5143cf077872cfd1a13df1ad350e2313df0aac2c9034ab0954db1025711ea2c423bdf6bd69591ea5a1871ab8a8d72a59fac5a12cdbd272b306860ac8ee267dab35e0c936962aec1f28a8a7640d0d445f002d5721076a18f954dbb110466a6494deb5c1e2432766fe407d017236b0c54cf2a9d23b49c45e00fc44bc7dfb765055a9fb9a8b7ce3d71bca358eba469a3f3111c5bb009baa168369f2262b8ecdfe747e80d3a93f96c56254be4f0d195545b196e6df736800cfe51f7abdfe7ebb51b548dc33a0f31ded3b81769a0074a59306fa12ff5f19c20a16dbbe803ac39e56a87101a29e4accf4ec8cfe3feede3a18042cf060391b49802e32c0b162988997e17fc1ce8e796e30f0ce1c598e0fec42f6875619abef4d7662b343c6a62542057b09663b46fe56693ed60949dc88388fc0b49db8d9ba8260c11d00867605b68ef8291670d237fa8c4060070c198cdcac2a80d58fe61b51dd2660f461cb42a9769d716dcdddc1eefcbf40656c4ec4f4f2f9f80a32aec92442aa5d881cb210613379a7017ff161412e8f3db3adb589040ba737b5c8be30390f83bd8401e9bb75e4738a97e74d14be0146c8b7eeac1d098f531b83578a34c5029a87f6b22e4c470e01083bf18dd4f9b2fb920a049624f828387ed7e5bf6b8bbd609a88bc18911883bf6edcf7b53a5eefcac4448cc1ef23accba65b188c399b911168d88ae47310b797e6c5512e8472b8444166d95457fde6b86bb9eb9ba5d482470aa846fff10fa0edfcf3fab301851b0917121ad56a24d2d89ace25201e7cf712fef793177a36b14dd821dfa566f79dfb650f362cae7bfa2ba2428f500e18f62867dc98c4051de2e9eea77365c2e0e3370056175cfcddc6b4444ed5216a4fc11b63324a65fdae742a5a61d0eee074859dcaefe8f0458f9405ae743ddd8b56002cd98857dd6271d4615ac0d08684b6f976bdc5a0a8119f2afe648d7c4328c20002755c65d19ea1490e9e65b5fe98c95de297996d2f92c4501c2c3de8508b2e2d6b2cea37127f1a82eeff3382e2dce3534018e353ad94d99c0603e2269e4c6637601a2a588336ac72fa64ca1b115f4fced900b4a81c4e8e4982a44b62f83b3f687175276e51b930a11bb2c8e8a3fa5e51ad52be62a6a1986933e9be198a99072f3c4fc9e830a8153a7c066c8c30777137917e074f0d6fbf320eaeac0c11080b50a8662804af830dba8a5cff88e4619e3ade9fa4ec7bd865212cd6cad47ff9df496cc3b3c3093f8b9f097d679e2a015e7cb153da5e9bc0d5719e50f869b48f5f5ffc8e5f092e739d82107171a480654737feb5dc363be34f6a3c3f1ea34bf1b4bfa76a4c48fcd67fe92ab903ecade3b5f4af3c185946fb8a7ece5b71c0d389818f09c0a53eb82bdd107b70aaa15f9a5be4502cdd891ac07a59fd562947895b494aa17673f643f64f58a77572d250200082648932c00274f417b0eec1ac05631a4c87e97fffca5c43dc347af21a197c8fd7ef3660afafa7b3c5141b322380203d0f9dbba04f316514950895a29aedb287b82e7ac4b3e951c55d48f0964b376b84054ffda736db91421dc3a318f4986185c49725409274d363f9492d8d8fbb8d7c76508bd27fe1881d1e11cc033e908fde89375c02fd77da64b1a98f676acb43f22f1213d3565c2baae4d371528d1e531da6ec6f7c80fd82c2538171978ade8a3b89aa62daa8dd6ff0070418b632fb70a2bc9248cdd46d5598034801b71d76900a4feab42044f34c37e88cc236ea801b838f18cf55565bea3f7d93547b79fee9d1b36e05e4b3b6c9a948170f024cec8b21937dd5b55b93bea033e919b077317164a0f0cac92cabba622e5786a19bcc0495e197d33ff3318f2ffeac6430b83e0b2f1666a2bbc15ba81b20e88f28dce204701262e56a9cfdb70e9b046b435e8e55bfff5a2268075f08c5a0a7f93196ee3bd43d8724d9f1e7ef008a25b8797406922cd184182595cdc5d96bf2451723e9e9395f49604ab4ba62397ccf1924a2e6dee1e61f73fad62f367f569fabb0db50cf78e4659e7f5e428db51c1a5844c7ce8d29ceda46f46a387ea1187f158c89fbdcc0951968e79361cd75adeb74ca3d67ce9f413326428aebccfd6033b1c6fd228d77d39fda10d5a45a685a210a4c8d96524f77d6fe1fd1894f24c67fe457a722cd6da521833a4d94ba3ab7119929855205f4628941635509bd190c6e33f2cbac84e3c53c4d6a3661a7b094c3f910fb40f0c1686f844d210006a499ea727b1bee1cd7f2c403ebdf98759f396ce82beeff80dc10a121dcfeb70ec29c3600f89ed12ab626588a0ae124eb2534f8fe0c2baf6f13bcbb28cc3607ad30f6cf7af7639bbb02335f008aee9bc9fef3d31eed7f6c4fa02a1e446c34bf677126698260706d8bb59f6db4eafca20c58a2f156f07a9d4dbb906b2f8ba7c984b1afa614d0fd78fb4694c393fe879879be36cfb2ed8b528d7acc94773d14fb6490b5a3f9cc8b79642635dc2376985202ebe912103a182e024ad846c4aaed9847f6bd407bcdfabc3aaee730280aa81bafa6d8ea4f22a87177b6c4d1618d196707e01518f8847357180cf9f66cb15c4368276c15a3ca704be94dbec35412a77b99764046ad04ecdd96f53e1a241f90e5d8ff19f0421ed0808db93ee45057e1154fae498fe903f01a4106a3e34745547d0328246317c26be711965427027c798620ae9e91906b1d33e3be8a88a9a431ed3d96f277eee35d2325323408a408158ae1a949dc74d8dc2e3beb341da80406e7f7e05c7c0795fc424f06edaa9ff85dbc1bad893bd0ea8ae1506fca178bf84563cf83fa6bb906f0e77c3aa543e64d7cd7658c7f387d5871a9885446c8f9ad4abf8e590cc9f6d59763db7a7947d52013a9187b113fc74769afda81ff9c83972fd8913730de4c0298df9b1f65f3f7f7fc32e1bb9a978f8c1cec8636597c310267011219c5ba85068e3ae6a7b7312942cdf5e8700bf7cf061192a50bc9c3ab0888db9dd5a1ee314255e82691fcd6b8ddbcea68913d6d46e0aa64793b760f8ba0853419dca627e53ea5cf9bd611f4cdfe94c5dee4783edb9a0ff980f70e0dca74cd4cb33993751b728d5ca6f7cbe94cab09c3803a897a7b40a0d01eda19531b83487a5eed1d730e55d1e08f8a5612e58ee9410d185a7e87258c77fb53c748ec4d7ef92ac78687d6922b6bd3ccca8746882883363b522fe2a163a73e381351f7d800fd946bcd1a9e25c5820fac4cb48b928635e9ff8a2be5267dab288f607efc8ef8d9054e805a3917a8b8ecf66c648ba522eaadcaf6a6cb498f2b2cfc57d355c6f0068720803e4f44593f1d074f8664e30123f429b99b01c00827a60cbf86ffe7ce1786aa16756d3e1dbe77851466a0efec157ee6ce9c26feab76765b9890dde4b3f3d5916a9e34ab8f386aa377bd3c4cd97b6e6d09bc9fb2f7aa2b64ab8d5167e9314fcef35add574c4d24c2897dda2dfbb68e5e3564b82834d42fba3a0c3556630a73b65565099e85e7f76b55866f18802552f0520526efeb8ba9f7164421729016bb630348db9e316d01c1094dd4f5872ff9f965d0204af5d49a5d7f028f88b21e9acebbad3403e4a5933f750b8627490d8ef19ac2d68c421cf201ebc1ecf330734838fd92f244b3842ffa84a53f1a1579ee08e3ec1e315ec76862ef3fbdab24592839a9fb24cb8c713fd5298c7d4f2ebec3b6bc72a908793585c01ba5a2797bb08d0243fe9451c1d5d468f069c353e2c7934c398ec1f8d8a70a4b31acf8ecd0dd9b4d1110de45cca1a0264ebe84a8a53c3d34677bb469ed076805a7382ca91f0fafdbb8092edbbac6d761e262c249ee84706475445f3bc8a8963bfe8b47018edd324f3ccf1ebbc5599886dfa5996770620412d4604ab534ef70862e132ac3308454e0c3b4337ec521fd9be0439974e191d5d7c289724141dc24b06740357ff8dc9012dbb8dbccd261dacea96effb145159500e8f31996299509d53cea74866b4d6dd576faa41eb252d90d210e93bb89e85659518375027d883af543a4988a52e2fb8e95d6d27c7170cb2459d2a62a3ad355a98b58b05f795ff2cefdecdd73bf3957c5c541d985c42600f73a7cf56ea57e5ed7a40fedce88a7afe03f2e74251124c50c369d1271a595e5a087f9d4f5bf31a2942281ff4019077a591befaebf9f97dea7fb3d902f29c41487c8a13802be007fc037dc994c3131263f502ac62b05f6994135613a619bf861092486589426f3917b765b0868f7e54a5eef80eeb30475011a7cfe13e9600e34c15db5f675c7c25ff644f380ca94058e2da42196e50caf103eca297e105968fd788306b84f048f58e4d051c9376d8cac24a371f7e60682a94860c54ac592b1974a7455ce1c7e53d181975fca53d5b49446af1b6edf62ef02710251dc78d35682c834e2a30054d200ea6c55de09407196ed1bc1a8d001d70a1d3ea61ddaf86eef9694a505a8c6866b01c7faacc8286fd12512bc83f670cab2c9f1592edddcbf15e187b96ce6b0a7442396dd3e170481911dc31e6f5226837b038e54387b49f9053e2751d8185b1e8f5af6f92f507897998900ede4dd81259e58974126246ea932eded41834685cb8faa6eb93a22dafeff6fbbbeb3b97d246f4f129e5d957a386ba036bd396f5d4beab512520df3da6fe6fa5c0bbf862c7254e45438f4e33d32f32a32d85febbfeacc64445a03cefb2537eb20cca17364d2cd3fe8a36e6b6512fd9910e3d849381e53afc8d77ee5b2579b4390242f16549a8885416b307634c0800d4baee49a91746f70c1e21ebe6cf506b23c38855269acb32177d0acf9ff7cd746df9839e6ace498265312de95b2a27cd13b1f01b1f50dc881ffb9bf4c45b18822627d3fe79106f5c0604387ced0853f2d6c531cc77a158bad7ebff5d0dcdf09a736270ed495cc686a0cac7c70898035c16e497953b6dcbf16244001785faf98813d538db53e5d09ef4a75879356d698c38f777ec6338accab45128a2b1ebb504f7fa7e986bb18c1d66781bccdcbd17d172998ff257476dab91a5eb9ef9c8531ae729194332db4ca5079e518bb5e7e29a8fbdc649dc2f42f40c6186bee3e15bca1fc87e14b30ca013f67b6ad01a3202a70c4a9403f8bfd6b67371463f8a6ce68390cf6ffca1c767fdb4207112f43a92038ac21039e9d977f1125c92433f32e897dff8f390807c8723a927b073c10c6e727485154961a15947865c2598ea260a75ff5682266aa0fd80c4de811e52391edae1ce4936f3e0fb1b303344be181a11366fee92814727f65a5fcfeb7b42c69cfce84d7d3727c497fc20afad6c50d9c03eaa5fb8d9768ae88b655a2ee44ba18e8fc454bc9d6e79f3e0a40d8b99c5a216d341b9b9126a1311f734d8903cf8570fe5b632a8e0fb3c4c50fd8ec7a7a1cfa4ac9c99640c2404272c4458fd4ed68dc83e5c303fcf13cb3e8f4f12456578a6f0206f49ec1d9e0c8af1f5a24c4818582b96d3a076f555f70939acc3961b73663593d23fafd0131583bc2ac0b5b3ca7c41ced39a53416e3e3afe3858e900cc576b5771305a14591ce1534b0001fdab88f84adbcce821c878685052507c53e782c7d646eab4fe38c2aadcd8f75f57a11de671eb6c222c27bf8f12727c45bdfacb6e723762aab6a528e6f75d7ac8cf85b217f83995bdd0b654b1f870b131f32eb74b1ff19ee526557b7ce71df10624615176c9746834a8ac77459db55b035a28918c22e373b5828f0fa9a85e694f65f328f5239e59953d73761589ebedcc6a04c6f8e447c67ebffd295d921a622567bb666e8d96ee280044b31bff9dc73764583a934d64755663a9670fa5843dd0985c36581eacb06e56f0702f2ad07e340c58a33bade3eb28593aeff44fe061c48ff9a4c5dd3c1ca5ca905cc89d7f5bed7c7b0b4b3927b25df0989df111b064ff232bb2883e1ac9b34730baefe30514827a75fcbf3641426bb305fd34773196984761003b651194110708d9e1b5430287fdbcd7052a2da5e24ad9c70087c98019620f650fd96fec8e3c64472402f69e1b6d66bbff7dd304a36fb03b91679cffc7fa12bda2df17435e44919b1aab8f52ded87fc093e7f775e84250fef5d1f62bb4bf0ea91808ad002eb3bafd1c854b90f2e3ebb1190b5a9220c7229e1b6ec00c1381a6c8ee3322ddf864ebde204511c42085f69faee57b30951dc7c04478e1b17427a616c48197471255267c171fe91d949157e9994fd4ae684a311ecbb55ca5121815a8a7b278a891120fe64828bc6dcb5876cfc545e642ce9bcde1b355115369170e82b260d6a58692c055d421f7ef07522ce8f66259efd33d323ffafa7bdb816759e4998a4dde0fa944ad01c4f624622f09ce60782c4f441470f3947f4ef9b70ee0cd5f6e79097bf254582ed6fbce74ff99568476e96da6f87be35d4ac5791b58174f5043354a1f4b083faee5d7d4c6c7963772f45f8263df2264a1067888c8be21de616ddeea90a9a5eb93dab16d19991564d6b9a565107aa602c0bd5e1f268762b30b12757ae6d4c0f0a21bccd99fd3f38bcfbde331dc86811701d13992aef2e61a0773912410ebd0fd9fce8fb63c907680eb027bc875c1f6ee17cd0db4c3cbc9678b0b0fda5eef620fffac22f07b42b8895f338d895a467620f7dc2a5705936037d371764c5cd5d2f8e18d9d10b016cd51f989a81390bf4123d21781258d27b360262f1bfe8501665115526b9b93d4db99f3bad3f214f8abada845bb9ac0b5e4a66c916a5fed4010507ef89be9de146ef72650d657af91d85cd5a6b52eb73132922d77b882400ef41f469f43fd90a107e681e0aa195734928a4bbcd7b8f4cb783e70e0023ab991f690092856724a0c843da0d4ebe5ff77d5b3f76a08994ec8daeafdc9fefab43d9b35b37e04a61abcd72a7ed08a5fae227af1ae92e158af3415a6e1ec3830ebd1ffe0005b0c7f7dc47886c42134eee7f4b7019bacfe3e336ab05af76dfa5051376ab14d8a1bc990e057c1728982afa3b8eff823d0d4dd7880a897749497fd4e4ff4e270ef1353dbb2ef49135f62ac40beb9054ed68774591d1cb1caa40e79f3eacf84efbc74cb77838bd8a82067ebbc94ca4f5d42e165dd70de9e15de58e4b2e366b1c63d774ccb3b5280a5ea9e170dbfc663c9156f3f1d5a80bec98ba045a1b407d41554c25036b3c363c33a7cbe73c9bdd373a3730831bd5e4c4075497a069a9c2b15223380390b814ae30c317774f94c1b0843338941787f69b6a08b8508adecb2868d418ae457fd649b2823e64aa0ef90396dcc275835e704bed875666905e39f3f5f422587fef80f04032fd2451c6e2a6e8e3f5ff60dc5325a55f7f325aac208598046d2efcf73ced3e6e92c2ba219a2a6ad2a892028c726876bbf37e4a712915a4677c69c3b31d1acc758268c8b703c0f0289abde05e3f9343e15b949b0f13e47db0bc384589475e9683a8513b08904e7e53a3a8130bcdcced1f45bdd495a54ef8a21c31dd3451b58a63b18fcb0415964ccd94b029c0a1880302f9117aaf44d871164b6970a3f5261788053b2121976b5c6dd1aaa472a46740d43647842d2fa90c94421af95c403859bb257bf59f09aff44e21ab984589a41f5ea1a9c7e6acaa040611d0295544adfab36b8a7625369b54ce14d6466d356cdc20dc974f31b80b2630d5d1c669fb5666a4d1bc8a847c3f563a7fd24106e699b5893a6dca032d47825e5fb389a77a39fb4fda9926a41bcac5b0c9c6255ddc6fc7e3229379f84fb24ee3a2f16751451765c8e580fb121d63baf981840d9831523ad33fda15940d33cc50d0741acbaa86b4d989adf563857f4ac81b4d10950f146ab07117e190bb76683582a51d8527a9441d0a68fef199103738b26ed8cbc2960d380c26d4cdb457203ea9776fba1156ccf25e93252320e16d6de785b894f72504d13744ac069585981bfcb97fbca60d06e74b4909cc983f9dd536fc4137df3062d0b4d957025c247c59b91c1b0f9d3523b3173e43c84df531f1eefcc8a6ff5d311df845c677434d51aa287be77faa37d69768e9f302bf25bc4666809b53622768d63db183ba347327e705a6834e7aaf0115eb2f7316e5d76e517c3ae041e6c350021367833be2dcef5194cf17b7e5c84951f2a666385ee49fbabf66c595852683c6a26daa50ef1a314b1e7b5fe1c1ebb2394e21eb0c941d79496a707460f14b0784399daad501e3262bb2eb879d3bb37cae546e38877a8f484c388771263528f76967874206f86880985ba4d0602f5f2ed06bdc88aff73d87d9e4ddc39bac5ce6b07bb20001812e1d2b0a4acbd8b9d60d60e5c0dd5d3799e5fca18b41ce0056aef75e54aeaa942e8a5832629f8617ca051c2877bd19abf2bbafec6d5a45ca2b5a461a2f01d25cf9135a541bddf36f67b80e9b4f866132d45028db2e04454023a71ac5cb198ad7cd4866c81d467fe77a5eabf960661e262d2a57bf25174938a879fb6c8013156ef18446199083d94449842b7fcb3b402466547db24713f3da5524c12e3287fe42c0cdeec5f0abd2f55d1543e9308916c82154f8d8fcd4aeacb0e71f34f15bf967abf224eeb5b6e495d5686c0493caa1ae1926e2e94bbf37722885876265989a407d7484e84da19e7eb1b59ce9c61bc95af76066bc21b8961851299d013dd542803cc7f7520b9d20c7d383709cef19cf6f08abef72f91ea249f5a2fe191224a0e5f290487c608a61540336c11f9e4d3b0c5a8682c2a9e317a21a5a29770654786a326cc8350b2b2406c89a959b8a6932d1a75ccaaeae38885d9d4640d8fb5529ee71a249cb10d4b193c235104235f357aefb13b75ebbff7b27ca2214d48ce86183d658355022d78b966165ad39c87cc5c6551a0d09567d1d8e4a2807a194275a9f67bfee2a0829a564ca63b68abb609ff6e72cc0b4b2c4b6c8693a71143e7504525a15555a045f6c2c0b9bb46793f734b5bf45ccf243804badd046792007825141a27f7e549a058694a292ecd1db071aafd5879f134b9341e53da7b0ca309951994b8b6a69d2d54003c0b229a85135890e79209f0cc34315358bae14c286bd83aa92026211dd0458f3b21ce4d0e600401b72453d4715de0549b8cf0419b3f7bb4812090b7e04dfaab059deb3ec82573bb3180b1064de8424b56eac1a54c18c1ab1171c38dabdc904a5d7aea11ff5a71b8ae5a434815d7d62796b62ef7f35e82452e6dc97190b119f63e08fdf7c4a8a1a5662699bd82a6168e7b7e20885682c263427ebe4d3425548ad84ae6aaabb4e9f655fb87c25ce9ef77eebf948359bfc1747bd5f4d0c92c2cb912be4be4038cd25a2355a8094676fbfe565e65802564a0f8a2569ce64a7e4921d9573b9dbf65411388e57c595788d03f29abf354ae5e6ef72b2b0185d9980420f578c754d168f77adf4846c9ff9156cf4c0ff3c9c178b73064cc21eae8a8b044e22bb62015e8c5138c66019fa247d485a49678a78404bcd3aaed323b5f6d77344672e42027e88c939c43afb7ad574c5b1278edfdc740657f56b9eee7e067484b24e2109b6cd54bd4ffbf7cfe0b901889bd67fd74294f00f187864afdeb0864ddf14861ed4e5bd01c958f254c85ab8e8bf323708d6b5adbce4849809b045015308e4b61d305c848f3e668116d15679d4a2edebdb71580f7dfd6b800639f8a8c4526883bce432b397630e09289780221f21f1b2579722cab9affe154adfb27d21ed76a20210393f10af99b1e671c259f906af8cc9be3f98bbfc4931c4be71a46f4a406a5e0de95125e0758fd6daae3448b5e94e15ff0e399f64f97a05ccbb5eab396b7d28a90e09224c0701d77a893cde6c4b2b5b0e9820d37b3ac5de2b71107e6cabff2bfefb393b5c629b857018c295e0d9e676c1c9ab7ca618cc6f71379c7b38f5fb4b97dce458ea10f04352228af96e797a6a1647a59750a5682fd6ef9fc71a4db5ca231f4da078fe0c01222bd3911258165d5c86b891fafe574a4c12307824d1fca95bf08ac55280991dd12411755e0527ca7044849778950e46f9483921c7a62c071f307fedb96d454fa52d327c39c270ffc3f1ab80ef96275edf3f3582b47a99c6d528fc86cba3dbf91483266c2ce8f93c0d5c9556faeb00613e7f4ae3e8b51dbf3eb556a0522ffdfbd7296331a6d26cf92793b9b12ac5737f0a9d46f84ed784260cd459bd4f464f44dad21d5405997172f15f8c2cc70c01afbf598f2337a743d3c7531a5350b70d94ff12b975ebf49fd5121898e37ef79e10981c6955c852eb41ace9e542725f8fba30c3b3afcfdc0d59890b2e0c97f33085dbfe72c03fea396547ae5c5190112ba7fd85ec66577c839a8616bc502af0f13bf659aa34e243f7f79119b506611d105ad092d17c2c91707c59be7db846300b418196e72beb44d8b76b6f944c310fdf4c202e86220aeff8f509ec4c3912278e342d17bf70188e8a98954aeace8183dafafafae2e850fe25cba902b121da7900fed0bbc4150ec5e5501e94c48ad76d0b3925d2bfdf222d1135e446cec8aa532574f1e0ca48fe1be0d4bfa8d180a6e12656cf435ba9c1fd5996e920bd0a907fdbbf93c74176d0caafcc31288cd2f49e1bbcb5ff481c167a1ef9831011aa99644a7037d35a31475b258100295fda3a4535fb728c77a7d1bd962b94463d110fc88b3c407660e7a8ea45463834463c79d7b294c30e58bfcf5c6cd5f7910097093b26a7236046546a19129a5f953ded42e1ca14f4f2e500c97d75beb238eef5fd2ab180db5982a134cd7a7d09e82c17fbe4ad87d78ccc9ee53c8128c49beeee4f8be1aaa5aaa856b054ffe0ac3e336e2791ff6ce9e2a1dbdd356037343348e63783718cf815c47e55d187118455e685e13c3608407316bd1028058c2f4875629a55f303edcd81d9ef93546ec10af328bca9676c08e694c00918e065b914eb40957f242a03c8c26a918e44711b122f37a6610724457289c9597b93b2cd5cd6cc69b0ee66c4ce18603dd10651416d65ff83f1755197f5333492d02dde25df54964dc5a81eedbaf2c4de9de917c95bbba8a1d97a4fb6cf14198844640ef15284a45a2459564ab08e186402528016585540a3074bd84232e5210c6abf4b82714689022c9ac4553d1a482c4c7f2d525032735705f7397441d30da5bd3bc19816e5db23240c0922e4e8541e8a31701fcd55efc12b81d6b67cd9704d2b619e51f6673e67ede6f8396a54ab7e4f62e1cf8f8a4442e6f38e6df6eb8e27dbef25624594d3aabb082966add12ff6fdb91f660989347d9865ca53b0fbe6a2a7a6a4cda379d478b834b71e4e9bdebd6553e7db08e6a7f386898607c3ab4f78ba795926177470a67049b24d7c4f93579434488f3c28ef3da6a99e863c57f066c0a24d95a761805077fce45a80daa17b7f4bebb274fdea395ff37b1271d5759642957d4540adc3ed66d3d6ad3469d19beb9544c1142e0420bd4a5b0f963160ba0e730a389887c2578107e3e5e444adc7839c7d1600a9207e2d0d9ba94f7c9bccf0a07df902cbdb27668e68582365e2a80c94927d7cf910bdaa2b04c944037e84516c3c9a236ced72ced7bb590e7ca6a995cca1d12a6496d972c5d4c88bd0b834aa2c86d8eb33ccd6a01fc73a1d8e0e2f01a6d1e6b01711a677f9b872ad8c339ead5736f9672064c06a171ef29bad083548b454f95ab441a29586f33ed04e76584b38c7b99d4fde99e4d2af1aecef52ed2c2a43656623bac7ee6cf83e53a0114aedcfbf1d597eeadf7efb69981af3eac3bbf4a9532a2c4992dd7213ebdbf70be60045b382daf502007cc6cd7fa4e993ccc85edc0b5da3b02842cfe6a86561b53301d8668f7af8f180bd38f0ba41e575ea606bad7d98bdbdd8a16be02e07940aa8b546d0d62a1cb2ca86bf8b2d6fa1b2111d18f5773c8bd05fcdb6b8aabde5a93714d712e642f47784f55a5257b7ab543ddae6f1f20d227b395699b03b0959ca426ac89ee0b2e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
