<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d881d9eebf43906bd758ab4b1935ebb7151c3a2f74a471635b2db6888670e5e8b1b5b965eff2ffe6931bf8eeee73b6117cc61929b7e8de5e192d2caaacc5b128d4677534afec54c9286f47cbeab9897e1c0fe8f50ce8a96e216c3853f86249c3570637910fad2b073bbf552de838e97dccccdc3248aafb98ba2f47d8daa390d136e0b4afd18013083ea3fcc97e73bbe71ef7bdfd85327d207ef5a6ad844cd50eb06cd15debe6d3a46746894c126a407cb5dec1174885c2e365f6c1d616d817e097ce8a5b474bfec136bbc5662d346b812175f7276b278367c9d620db740e377d914006114ec4c68e74004dcd7a5cc8a8cb3ebdc101259b601ddcd1729cb85a123408ad2d1caecc9b2dc4900ed3844d2c2ae6c9ecb0cf7714d18cc18c8dd2cb41c53443986d836dc192e7ee0b6470adce47681b70e577c034fa0e30f6a632d20e2e12120ca1c8a52352bb1db1446cc861f8c71568e3a2c7caf55c7cf2cb1e41af2b3ecddb1f745a104a0c65aa6dd6b4707e60a96fd6a54d0dae5fbde398c33370f806671d2cb0dfbd8a48f0f17cae34ce99fd6c534857316c39ab2fde1cf8baf25d79c992f2a37e64c1b6fad3e8fa204b00c0c2271ab2116961c405e1cfab54e303c6fff3c756d7ee0cc80c7f03f345906c1e63ec6fccefdd71553ba6f421ee0147b4797d82af8264281a6cb1455d3b1ee9a7250ab086c8b80012d3e3e2ae25d1cf363d9cd2d97ab8b59c1cd754c33d20a05153fafb7fa05005fa77efb5434af09877ab19646de6ac020b7b6f6287f3acc011f7184d43a7114762d3574c37d288254e53af17d3233a76a0e2466cf0c7966a2b8087ad9b41b6ccc57223b1211d6c25b827eb99d802053d18b9b2940006a1d35c060b241db3527f8e12973c1194fd017c159fe761d3cd529d948e5192e47628721214b1aae1ee1f40fd09cbfe4fb2f26b7b4a15a49f38ad1bcf3b9aa71047aa6564a547f6313c428e7636c0013e69384d773f512f73ab0ee9ffd2e4373ce1b07866df63563a5d8a136ffcdbc8223c0b79bab88b2591fd45dc42ec02c10d7ef0907c59df1dcb5cd7e5eefdd9935054e6fd7a6993842c45fbca07872d52314f35877ab2de3da760e2b6a88257e46dc6b06fa97a1b6637a4c5ff48ee716a9adfc2f78cf85a3ca44f72ea0e007a7fd121a00745fb7a5152e7f10678f73e83d66f3003bb101880b4b405c1038b4f9cd380b58e2bd2e0192b94d44394eb82e5d21eaf547f0940bc7d0413c848d6d7d392981509ac907d4100e959d0760bc6631a8b37482868eadffaea0534be1623660070e6f58a7bc531531f28ab15c79ef78ef93d663affb555496cdc459b47a53f7e205f46945b3ff769eeaebb8ef71569b8052873a084ad06c56ef92604c0d411b61e182beb3f0cf6ed59bd1ed66c4e92d6b196eb4853b8dfd11d227dc4c70db629b84af7c0b4fafc3ffface9521d1ea827c750e1a9330a9c18238dd9a60c8c35a4e8bfcdfe710c682fe39cbae316f21d81efada57dd6f87c71eb403fc7857ea0ba7df59d0f95789815700fdd86583950fff7faa3c6f463e37e0be28deceec433fb0196818d389f88939f27fd1076fbc6e74854db0f33932719f10e020703cc7375109ec15360cf2848870b64da02881174eb648d5afd6212f11ec1c74b162876275cf4303b1fcaace22adde1e835111287940644e7fa0aab760981d81b9b2561e0ee83233790c9f769329287fad35e6acc2c7ff331d2eb5cb82549f6832bfc393f2f0b54cc7ae18d2c58f210e798e7457e5566fa21778da6812c363ab8de4fb90c2c0483a98f6481c3708f83464dd515a91264e5edfe956712bcd3721a4620136b1be5daf358f67930ec77fe7e4a28f5aa8a1723845b816c50222f5a203b59488de57d95f0205ba967258f1e00787aeedce1facb1ee2199c3af55e449641f391d9071f9ed26c0230eec19a9b46ce20ddb772f7c3a41ddb683951841031d452bc0a56cac0c9b657d153e8ba2227766cd17feec471b10948c083f6d93a7138f11f7881e670eb7984bf17aee84bfc64d7eaebe7e62db722d9e0e601f64f12e671f3332cb1340f1d07fbeaabd110df456832c64a90e586b8e4fa7fd79e91007d14e61f67d89f79ecba164709bfdb433f4467acfd05809369d1ad5d52b4075476c36c08d36fd852262e69a0b0b19b217b5b0b09d1ecdc7ff3e30f01b1c2ce7ee5dbdfdc5d229ffa354676ba54db1440406038227d50571a8e6be295c78821c7b0660c6a37f70f937d76eed1f210c389c7948315f2a85b0655bad6bb4fc29df408eeb2f5426a9e137324e46eca439184f8927896f7fc9f0bd7a55bc42decd676b258c0e76c5f65127afd3f1544e9b9c15ab61e0bd6f260428e2bdfe19b96d1619de8a01ab0b4c7e742d59d6e58aed5aca9c78dd1317f2c763548440d479cc55c273b5d4afbec692d8c419c3fc085ff2eeba7c45163d23eaf392e3815060a983ff9b1860acb8d1b9e7e6e20336319412bac62376a75c293e0319c0d7a48eee5247c571ab06c5c012561cf710a9b00f9a6255a07b342d0e46e7f94b78138265ad8ac911422029f8f45f175f6fc0399f6e34840afb6939368d619fadbd237960a86fbac23f2c3ac0d1bd54de51e0858ce392befccf2a50149e44a69c968c73c09f041fb21941a3a544d4e13e99001e0096d469b528e52cbdba228d3e36e02a3f63cd1783b1d7f224e39cc4b3e2c9e86e61c8a890f9f8f3cceb3535f1600476db957f9583cc2036910616b345b22fc52c4ff0e7c0fd84d04bb4bb89393304cf08e435edeedc955de0b19ded1e05aa0436e496a0e75d7e5a3c11482b59abf9336dfb18969865fc41ba2331e2812fc21eda51424478d4b5e60439841e9c27ecf017349b90badc8ac1968b2f66a7be06d9d01fba414c046407d6199757296f84a024ac035b96a192f0538d260ddf0b7d77a3bc9a0da375c236dfa60ad3e63c711672655407fdb7e6640d215c5a832848a11dd3dd4ef91687fea3513211006b8ba3d2188c1c9db6f1a2ef27d3865a176dc4d36992ec8c5a9905b78595485692089171a78ef6e1645b7939afe54307f6e91a1b1ae630b6155092f0d23501f49c5b8c2b7af7a14ea2ebc106327210b36bdd47a6a6fb15658cfa8219ef9fbb5305684874a7a0db11a22d7bcc5a885e8588e7be88dfc7113133cf195e1e7111c0284fe883fb272a2bc6077eff37ae68c763b981525a7499b9f9013c21c9c300613deb6bb238066f41dcfa91f614b3c0b74057f8c792b1c2ae3f51bf137d1c2dada6defd5a0ffbd5349aaac392b1832d28b17a08d6a0a60f0b36dd67a66d11cf94a9ce95e018627c55f765180bd77109e5e68b58ded4343f87d0698f70bc5bd68645ec6bc2e2558e9c5655cae644f2007abb4389a9afa1522c01707effe916aa89fc32b6f62f3453e91e3fa69fe18960df6fd107ea8d316a1767721a56ba0d5ca99fb3a4b248511ae87aa6bacacd7972f972b8401c1a85b504845fefc0e4de1e2ec8aeb606d4e87b3ed0c43d5fafc5734e24c263118b94ec5b8e775d3fc7e3199951f9108e3f3594c254dedb4c18bf5cc857d1a3d28df2d618302cad2fdcbb9e260323a46674cae87116fc0f121a088f98690c93e29ed42eee49569a2255cee59020c0344a0c75f60c3c823c743ad158936a964793e8c1de943b7162c092b32e2be3b0e61a86d2d68a3be99ee68df219880dd536b4c4495bd460ed9a72e3f42a734671b51870da228f1e7a1ce3085512782fb0c3200beb2b28f24ce9043285c54c59bd2aee3c7ab2c997be7933c45b8012cfcc2c5304e424f248707bbd2304dd607fa5ca14f32c1127978568b1b3e21fc7e775f669a425ba228429ff367c89d36320576761bcda1dc5aeb251119e2a6a1245e129b2e52bf8cf7f0265b549793094a8dd05d0f8b8848a23265e85e6c67157faf48d32d88b5c8399c241e802fbc593a228a9490e6f10d50b07b1de3f4f66c6b699a19cfd1cb7b0e8606d4b4638cb09aeae463a28f4d2226944fd9ff4ee9224fd044fc09caec4726feb06a67179092712c6c4fd06cf302ab944f85b55e58762f770b4b22661496055feb7e45f997bbadf9cc374e94f7d5811a39585ec8e9f6144a8ade2f3b7058cb66dde4b94fae6adcd093fc7dbcf44e5f9607368f7a85fcd337fd79c1aaa252e6bfb943d0f1b7e09c73c1a4f89b92b15eec8731c901266288b5b1768b20b9f0755262e2715f907ef8d97824fd5231b3879a9e25fa1c77fda53769920149c6a7beb7784073b473e88b209dddc48981799f4522d51119beb78cf0f40a8b042f7bf2c6a722b6e96843a8d5951b3553910ab0b50b1b5ac7240e7a564b7cf59a0a4b68ee4f6a92c00364d3e51697a8dd3dc889a2b27bb6ab5e8387c8a7b1fc0f56d07d829b1fbe7ee88274dcf332b38ba15d05890c0b81f3f924c78568fc24ccf20e7660d0dc162f21de41bf21778bef5dbc7c047e26643e94adaa30b043c86680168f029371ba4003a02216b28cdaebdb3d071b3f69acf5f2e66b3468c01253dd04613d93de4d3884776dcd625b4894035fc6fd77585c6464b1b1b652cde34687c5a92e1268da61590a52876f4e20a4b43a8a8a81dbf45813f875eba9fe8e5e06d82b4207254758a7944b105db590fc23a741a948d7546a1e20e4ea3ac38ac048d2689015a065df66bb3570a08129ff4434273b5f655bb42cf5d09a7646a78a300315407a0323a6ce131d2ca6d3251488d1ac1534a3bd5f83467ef159d99fdb879c79807bc91b05f88298fc2ae9524d3e6f0ea8234414e7e454002879f04ab2a6f4fe98160514e10821647e0b8383ebb4111245f7deb8edb698c2ce746e8cb3fa7cd22af72c5866ffa725139556b96d411890cefd68fdeb8305a2c59070e40810d5bcb5b5049aacb8ea0e2dc258c26384877e9ad9a28e205ecbd00c5b99a0e571518455697421300836371e581c0519bf043a404b1af10d628567fc61432ad25d758ba8f5872681deaa698de64e980de6816489c343c080413e818316b98f77851ef7125c98524ae9daff4b788d95c79e5f208e842815d907e4616f6805d63ac5923dc587da3e1399966d63b0ef290b13ef621bc6d8fab7ea44bd6304d1937ee33a72c4d6b440dc3ac1817d50235c3fb18d5c23b4a13358b601ef9975206131de4612bbb6eca7a006590b699b67726b34c5a42d0f7c86b88532b3287eda6b0d16fff2adb29d4a5acdf5015baa2f1e0f5cec8295be0727d18932b860859f66bda622203ff2e263cddbb73686ee3541ccebb4467449b36042d6075fc0bd4b8691a79d53f841f33b1e2b15a682af5280057ae8f5a1d302b124fe4399ea762ab526dbd798af13a34a217bd58dbd122d7e3450858405d099697469d41c29c2ab174d2d95925a106da0f599b4eeadcbd32e68a5e1d94300b7611246926d53d1db8c8ba25c88d41dcf8d82c36607a80db461c7dde4e9fe1ce10327e5d99ed2fec3ab77955d3f7043872b2c8725a30055d410b498a8ffa3e761eaddcab5471e29565be4dafbd69168fd3d7072e464ce7031442d9103bb9b34da8c806304f3bed2bb786bd41bd4b02931c7ae93581090b1e544b60462c06ff3a9d38c7366069e0d5444c61465ca5a84f434123e1dc4068a0b894c1cca20dd67b1b3f96f43db9bfaed4774621623177b30150415e92179a42609b7dc97068e6bef8904724c5c4fac396d998ce1485aa92c78801e5f8dce21f6bc367a264e3b3a34cdf84e1111d3cf8e7c6b8aceb1114fd804ce0360c79dd4eab50bb84968c44dc5439c253f1facadc23cb596444e979d5484c3a3f8b656b58b2ac587cd4746357443cc8f076ef467fb0d49c6dc03757290ee05236c6827cace793ff5cddd7451ae6ca141806f5f0f18ddc7f88991d680dfbf1daddc1af114e633e3f234feb5d5e0edcb0d33176960674b7e36a90765bb578c7b69fecfed6aaf8e19f3c3d90d16f1a4a2ea6ca59c3503f64e5b623b25d8256b75fc2ab50db8c41abe5fc30d9651b71b017bca2001b0d531d50c1f0e7ef31f9441144b902a0a459535ce79d38f05563e996922226c6f6c1ce239668c2c92683d602ade99dd5d0bab3f9cc3887ddb67b87659fcc51c38852c0fc0edfb1225ce9083cea73a08bc430b3cfd0ea37064376775121997a65da77ba808c9a495350a0851d5ae1001eb9d96f6dfed64c8236f6547c5c420112afee0f7a4e0084b2a352b3dda3b2532c34835fe11b9721c35a8cc5d6a9e08dfdd080ace12421ecfdeaa5bf402812cc529434bbcc0a5ad1dcd907a2f1f2643bd21db84af318469286cded7e2f571d013c7e3d1f42ef3f51efa469fddbd974a06a78733f39dfdf724f816d1041fb677ee861fd613895b17483a7d34705ef0afe0c4c522f129d5ee06db434bd3c8249b6c6fbd5f5157445dc57c230d6c681db715555e6bfc07b21397141ed956018062510d9ecd084d182f9ddea1d41a258ce01ff6ef82ba6d89f1fbbc5944f3e1db07d0737145f5470799bb90ff4c1b12ecb8fa8f209eee3d1e0824d6b459dbd82beeffdc7ff0d52ea2d533260690b788854e4a23288fd35ead282805dd518c411adeaad0740a296dd6921b20482718ae951272bae03996f191a2e3d76795cd3ca62a142d003313e457c45b89fb6a8594055322ba997a0dc21c324cff607b732f19fae87ef590f6dfe174b71ff4e2c12e0e80b852a5bd68dfe8cfd6ffea7d08bb793dfce16b80d2d274958d60b53dd4cab08ff568e65771c1256c8d84ee9fd851c322169bb6c543f83bee6e047acfc28f0ad7353bc35438daf809e1ac378f5afad949d83da5d4b7e1ad8f1a3eaad2304d8cf2c7ae1181c96681732b0a23f8069e0ee90af8ec1b6e42a08f9d84ba27b7d5ec380517458e4dcb14f42e1dd72182da736971e223e579330d88cb84f9043c98a0d31b2606db70c9edcab936570aa3efd144b4a6e8ac5af76e92ad7cbcdd13a91018b8c7ac364ce1ce47a56bb802fd1dce920774670e41d46d71b5eccaf5f93fcef24a894470cf6352ba4d3789de94a53f5cfb241ea87b762b20ec7ffe29b395b2080cf9bbc929080ef0c5010070d1f8f2f26f53e40d37c3cc5b3e46437b0bee969eca52682c1ca5561460e0c52faa3270defd2fe2426d24aed0aae98aa059ad729751c367e587f6e517ba88d677e3a2076fa215d3b39617c526884c9b2d6e52266925976f78d9f5c9f6b922e4c30b7613d6a74e18d7ee584ed69dc9ce3e0cfcaab9da4cbf90e1708be7889eee52f6d87b39b83b632079a898fdbe1e5101d24fdc45dd40d65be6a8ad8fa4778c48f794efdae21aa75f5c2d0f25e39204014b166c882923cc8feeec4a09dcd0a62127edcc410c423cc71349e43fb23a5673df39109fabc19ea54eeb35c42b5d993d8a1130011c81281189e8d70be60efaf7792dde5d9091b4af99a5bb03d63720c390b72eff95a1641754942022430f0ed65a4d1d80bf2f78ffaed9c506301fc4685c82c99ef9218eae5f541fbfe7441c702e0ed24a41ee8c0592638800079c1c6e27c5e10383c40c29d9e61f2be21fdc0beeb0d0fa568503ba0010e2e89384c0479ae33e2a19c63fb4db76840be468adca8feb0029b9727189072d69b1596e0f75cbb6bd515e08046f1040854f8a2634e8eaaa7296aff8bfe17f2883ffdf07f299b95114eb97b923737f24a7a47c4f69ddc0f968de74d6beb1e16ad5812e9daadb0497cf9f8d5c4edca920b3f94b96797e9b58bb31114ad61d5686020bc03032624e4c4f804d9f9b0d8fd49d51e0de16ada7df917e59752dfc9ab845fcef3359d820c9bc4f9fff42bf1821df1542bee705227da447956317eb191cc97a2438c9c49ee10f0aa8ff0ed41a3e25e7f6bd4992a32284adea9eeac02a554117787872f0e5c4fcf2e64d8b37c09b8ff329bce744aead52251038af249ebafceccdde985f08dc4597bb6b9a2644f03dac838b30c5214a3545b9c1ba94107fd1a2ea67325ee415541a48af423f562d9f061d2eafab00db86ac7b4479247b7f45c5117f8d5fd3b841b7939c807bef6ef3d486cf72fbe0e80597df562351cdd1fdb134da4e69d4aa33556ac02971b2c5ccdb12531822428e843c0f0b27cd1d5c3df3e984f361bf8447bd36e6bc1a8049a4c0d62f43d80265c326fe686438e409219fbe6c51fb7eef5e476ec16e1b05aa6c059ed4855be484647506c8e83c55dbb6969c782fa5329c3996ed94b7fb40cfd861e540529f5c2b14e521dd84ad7d99e51d83353d878cb9b1e3825aaa1a2cec83367fd31829bf36c4819a5b6d4c73b80f126b214937b3ab13bb32e6eb8dde221929e3c09997b730dcd7f447756f8e052e0ed81a261f0513e39168d097a19995135b75f69f582810622bdc8c8468d430cf1851230db2588a7cf7aa05b40b9e5b19e9e9ccc96cfeea2ac0f4fee0c9f695e01bf38109d8534479f0f9a2e610423ff4aa07a4972c7c151033f17e60140950a5dc6dd8133f77cfce7dd3c8a76e8bf1169daa9cca015dfa6957ef2dd3f37c16bd8e0fe918739d3ab57c29106e08ca6962efb3c77810d1873bf780688a6c010a33bd92f8f16d3fc5db5458ed43facb9b35315addf6fefc3f73354e28c0a8cfafd2094677ea556dae7088a61440193b3db70180de9e8c0d69c3cbf8cee180440386ecb21a963e3a1d6f862693d71ed966be8621010f30fe6d44f59c745aa754b2315592028d5888c5ec02e5365fc7e3da1a159aa6dd593a62fa7606702d3cd223ea0414a66ebc7959d9015f21f44d92e1a4a527ebad7ec7061460b2a4f2fab15f205fcfab7568bb6d000ae8e1e5dde0fdbb02229f62d420934841fe0562fa0ba11ef07c4932a0ab5f7aa6bc9e29d1098a89b5542697b83f82346c63b3c130af4da6a578b9753fcc6c15e55209320cf5b24439cf7cb94e3a5fb3aef0bfebd73b015409d455164360550f37481c76ae2eb306e929af8c5cdf0c2e29e968d53709754d4d2295802150a00fb1df17d21bbc0430cc41075a281cee7ea3921f308ddb83041ceb38fcdef76fddc3e6557126fd540de33ff26e09acf1eaa94ef11af90969e166fd757990604f5f73a471869ef4a5d94b2e8effc937927512febd16dc0d8680b8dee67a4c73544536acce845f4347802ca41c01cbbf3b1571380c8ba06e7342a31d93e2fe2c92071d985511b15ac2b6526613d3935d0dc7e252637a9743976a748eb696b4d0eea6e6dd7a8fb0fe74e04ef16b354559f81d1a7436b3bad79038dfdff05ea193d3aa1ddaa5938652c93388de815af4d2e5998cb88709f0bcacf80cdd0150daf4752abdd25e4f07d1377e5daf4732a166384edf8d746c9a0ce2898a4b8e729e21dc704b34a6f241e53345655ff4b793c9de7e2cfaec405b7f3f54e6489155d1c6132cfb3ec8798f124a298e3016c067601fb138815c4a7c595e09d6f551c8929c8dbaf4733bfd4cfbbdffcb9d074df6773c945ac5168466aeaf7a41131ec2e716540d000a643311255c5e5c5806b2e621e9b28902de08593591e1b59afcaac0a6628b310a754632ce59e0f3d3e9f81546b513e975e1c4adfad2bb489c3692de80182ddc72dc18178d4b853f25586f1361df00a1ba5bf0191622835c1bd7a227c118b54109e05a630064fca0af3be9388d1360368ad1633397f840765c8452381ac713c9c1480f4abb5245aa3f58aa41a13bc8204941702b100c0b7225009557e5482ec601f783edb62daf2663b4f06bb8b0bd8cd2bc745bce09a4f4df8a07f075b4562046f8974eee2a4e866f47e9e7cd5df99468bbd5fb5daa9f53ee35c48d8a02b0708acf541f69392d8dd327c424649090af289d2d51358c61e1699f4c015f6a1eeac5f4d613eb4011edc6d0a64c13178dc4807f331bd2973e864c5c4160120887d4a9c6d32cc33ac1dc5836fdf0075a639d508744c07a5cd86479f80564b2063a977b73d29377da6c5260ebdf1028e2faa7c7a2db4b30c1052ca1660d557e2f983229a4e9e647cb41b4c0faa34f621d5b477f836680353c8192d319bcb3408c336bef8c18f8ceeb4ab52e6812214b96a4fd830bfdd58a78df1aad5587b6ea06c145c8160c26e846af2d6072ceb831541dca05d1decb4e8abdeaeb49c53bc321a50f8afab15ffb999f3a9716aab903018f962e441b40af9a955d9a1873acdf4ac54190ae5c346d833fbfa30360545175b1ecd0d737007b9eeac1517763ffc15b1ca0bf2299a0de520646e68366c6475177456f21d006874cb92c726331a84e9a89b540ec7a9d9958d5f388cedef7539560aed91b107a119be51c6e9f8bd0b30c63e68b66cb2563cad6d598fa75381d26cfb31a0f8f45b6a11fca08683a74520ce68eb80e1d3b5a77307177f3884dda5beda4d70f68c279d61e7b0a4b1f380e5f36a8d371232a8778e6b568b5d26463947505f455ca3d10dc3cab9394959e83cb487df557a4e8cac32e5529048534aceea310b4a4794cd00c67d6f6df6698b8c8f9e9e07e930f90b32fa18b0fce86731a53a5a0f1e85f733be21e8be949f16328cdcfbbebd7e4f8388f2323c5e9f85750869a88ea1565c229032e7f85501ee746d01cf52a4eca32d562cdc2827c6b3b4b51bb485d9dbd33b21db2956aa4be11be1f90105533d31580d09b0b2985aa1af8612bd6d10ac41e4a4a565f78e3147f49dd143eaa7676c5e419839c40715b8f02568061055003282dc6b1e690d6cae79ff11edbe66c927edeef835b61b36aaa1900f7bf465ffe582a9df7769b7b929a94033a25291611b6d8d2802dd05defa3577e59972bde5b4c267a3e91bfb7a353aebe8e7c489617592fe8ff229020e1dbdc87859e691eb76a46d9e94d4fb3a66fe0c5b8a141d3cac6c0de977dae61152920ee8706b6d390df539124b437daadd4a0172d8540e7d6fe5f7f1499065d53bea842549a1138bcd513f29b67dce55c7c3f04748cda4fd95ccfce52757bcc39420f819733815ef4aff8fea3b15dad040736360252bf14ad38a5857126665197655d0a284f2bc7dc7d6fcab531ad2b8eb97c8ece199d15d35e7de100b939f846b34b39d4ad92da15c674e6cd9c51422be59e5add9ebbcff81c1e16185928ee8eb1990189719a2367ccfc0eb585515021fce355706649b9768486afafee729a91082a577707909b782d9bd58ed3f7733251f2fe8c614b57163319ba61c1ccf18f3d03034e864fb30d0be757444f8ead953b3269ec5857517f702614f49fe0beb0da501e20bb742642db675fddb7b7035780c4a278ec32fad666eeeee9e50f518c95f6104a23f9fc873c607732bfb8eb0308176e1211574c7b24758f03bf0c59a9a71522d566b21ea9ce37c56a579a4fd9c1160829b161937cda3aa7812e898016e146c98d50ff31f567b916ef0bbed7b76754924466729162a682c03ba15c7a37a268152d2e62e89a9767edf2844d3827645e07acee954e6b611d20cf6e27eb854b0511691034b8a47754454a9b5a8c1a66f7646c33287aefb1093f2496352d84cf1a33f2375c759e5b78e0e5dbef16500eba2d5b170eb8694409c5c2a87666777aa94d408fdf9ca6a02fef6a0fe8e55ce640e3513e174693784bf4486f4f89ae16179c435e9a3015216b0ca2fd42c6c822a7f47b6ff526d8b20dc28c1b4818cd728ad145582ad010f5198104d87007d2df9fac8adb86a49ceadb941550293fc4679f39b4c142e34454c4cc9a6f07f152c87685034b7b4cb8dbac6d9b41445822585607ecf7d6c6fcab5f36fe5f0407760968137cd2a3ebed35d641d51a0f7910bc92287f38864ea8c75923dc26f77c4abc9957d0632b6f88ac5422347e31d4125c1a9ee14b7a92aae29ae9004ea2da2b63cde232c899589e524e11a376783a75b347f995e043fd1e755d8b97a4659d8f00579623263f5a49f416b97bfee6b49a62417e5cdf71417ee0fff678ba1082c22d8ff366ba6d7a80f0c134f89a47070653991dec0aec8f241f8e2c8fead0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
