<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"539de3b5f3f774b88cec2e02da500bdce67b19618c9be1af302e3e2e0dfabae5ff704ad1eed5901b830cdd1c7d823c3261767391f32728c3da3d01777d3a1f1af9cce5f1d95cd872b2b06894998bdb4ee3b63567df997e1ea404b3e9e0634c067a9085d67f46f48bfa97a7702f2783bb137d3e40854545072c7cbaba7522b6d93d25fc3c05cd3e9faabbffa38d5655663920f445f52a595834febeb0eb0e64f04be6c87d744889610f094c6f8f17d9d2a796ef2f40091ba179d5c946b1630d21ba2669226da87dde3534072901c14440f345fee12625b7d4097cf1cdac5027edf830ab1acf0e8d1611eb0ca2d83e38b04383448f0f75bc5850202babaedd52dbe22e09e3d673a79340794c46e7192bee9a453070a8ebf3d7e8ecf320068523bc9d7ffcc09bec5a7035064a6122d9e2b78c01df7297bb69bc7d29be8b856d8bc8507232ce13d60ea8dd1bd6c377eb098a766dd9ab9e6f0d4137fbaed82fbc687820882ef98352b915eccc272af42dbf29eaeca32b50545c4e9002f70d2093d975a5ce1fc3040b4e5022a0d0e074017f66d468b3ef88cf64a22792446b4dca3e84d82ee6fcffdb2258c2081fe68c5f7248b94bd3c9e51d0d78c1c37d58a0a54a94c9b1451aee96c16d83f151fc022df7f1e781d91b3e65e0e92548b52f7aa26d1237d033c2a7a464ebde97354adc01c952922fca11bcd08023a17c30f817038a3cd5df89f0a1559dcb2517668abdd55c3c61d15e481d4e77552f91684cfd714037b6abb580c52521ffe54e5c3e2cb90b0e83e5186a4fa7bd86b390e6edf94a701ba8c7038b232981bb56b487cba49cd90b035c9a21c5de863193ba7816ac3788444d1cfc44c222473ee661fbccf5a806a3ff70ca359c4fb8d4c0d174dfecb6bb10023b5b2e56cde0c62e810b67a5f917714245b7aa3235da8e9356929f24bbf07d8000d5ae66970db47eac2f8eb0e6bcf4fde75db9a01f08e27050a96a4908c4ed54a64f5866d807572be5345a7f4c3286e3d6ddda34d1fa3af4760633b34a3fd8984dc3ab26882d53dcf4ae4db2c20763c17d89e6ee620cceb877e6e1a9b09be2c6aab389f5549c81eb3d02fb778d78135ac43acffdb1f7e12f64a79fa0dab6ca72ba91375b631a3928c9951e763b179a5191b3945de2f46f7b451490f1aca187b422b141fd204a40dd5bcc5503619bdb9ea06352198b00c474b86fb0205f8682fc8211b56e3cc84f632db34fbda0bbce9507f36ccb399c6cb761ea0015a6bac2b74fbb9336c03cff6fa71ecab1c5fa0f4c20070fbade15b914b2cf10fe9c41d655343352aa124a64e6ac97a60b9fdd60b1c7865921632c8be649b4d080fbd09ca71313367e5c2e9fd3fb582d35a152563438c8258e6d524afaff587566ce4280b4caf93b3c104c8e5aca8d48ec634037d3d19951c859c314aa98d8968669a2f60cc62d4e188aaf5371e5464329130c78c4311a2e94ac71527f2172e76614bb2901b5c29f3a2be95e211d7cbbb6c130127d7d969824bfa255387c465d93fa6ee4ecc87460dc18d39010d988672f26af5a3d47c4aa2715dc61fcbc964a51c22d5243ccbc8defb1403163bca510c96ea879d659ee0769f89fedc4e62a2a8a2871a86152fe28153e53f7d82852c9f4fd01d8b056aaa6f6b6b607a3f42bb7abc355e10b450bd90ef0fb55afeab823894eb3b2095f35484a5ef9029ef4d94734c71156ee8dff823c1a6165e56dc5aba15314e3b2d6e764a62e979ba7d0d9d217735f62623874b79972b17e5ae2d4adff13de42e1b2d1cc553525f8be91e830a7733c2f7bb0cabc735ba0da7ba2148e847ec1619894738083bc34f67e404eb7b078438f0ad39c19b61a979d321ccb2f12fcaae61220215fdca8c93c92e0807ed4b78f9cf4f37c15851ab4a9a3ef06715fcad99728203b0ac1b39366059f2d36851b1963fe4525815e925f37e39002ef78a1079fcd006360ebd1ab33ebf070a542e8d333253acc3d1edfcf4ea3b65020a3466d525ae32989299363ce86e9f0c30dcd9d1d1164395a6cad32826e57b5810d103b3dc55416529156325e86da87066a43afd185f34b8b32a2a9c7b1df53884d33bea0195038b83ee1267407beee3fcbac461d04914ab336beef0f4ea9c9a450d3010dcb72f34f1c2206facc3d5c7524111cb4a985557971da67225d8b7335c1d1bc1970f33c761be65ff8dbaedbff633b3f16caaca3a08dd63a8c1e068d7690d3cf5f20ae0d639b2ea2b20a93c7133736138611a7e41dc6f171dfc83531dec092d24989ee74b62f66813cca1683833e9459c85a2020f154c4c6413e0c89e6431730d0241610b049e7c86825968c0c86017e38b73cc60ddcb3d60e72e63e0b11b2a12e73c6bf64f57c519039190bbeeb061f8a457a9905f501d7385b3369357d589499e2d3e25e30611df730dfe8486fc60e3738de009a590f3dd057afe5cad9c98763f3fdd61d02990c2e6415eb310b442abea5d3be653475f08987ac8e9ebe492cca5afaa587f72190f9b28df379bc756790390d26224de0c3a8ca8838d410dfdadee048c9833b74bb3e4d4172dcf4b003bc09abd2ee90a844385b855323c74295e17f82e37c28768a9f0d9c1055b9d3173292e658d300dbd52a16bc67e9c62e53b02da0eb6f3ff74065c39af53fb33c7e081ee85134aeeee05e8d350459a104384dc8eb7ecbfeac07fe78d1c7da48bef85e537ed30dde0227626d90c3085cd29bf5eb8b237c5a34df7aeac19ce7e85f6b9b287d64163f9219a6c46b690e858136dce72349d53a6f8e1460de500a1a64e2a48a87829938032832787ac3d7775d1c34302ce2e1d09b46db21116ba65547aa6fbc66d2143c4229abdf1bc07dd8f41a6d6df3883b88941d5d7fceb7180724946cc6e9bab9b915e7bc98674a5a49f9496279967610a257b9da450c6b8e2504872007ef6d8270c5498e50622d0bd71b7bc65a080a7c22553b3c7573df53585b7ec19d670d35c255ea117c11e2347b04d9ebf134e257a70c9ee0570beb969b3024017fbc51046d8b4bc6931da8b7070e9e0fe486218ec21ec9e4f8c95b28296b7d0908399d04cff968322cefb552e864163e8de9400747a4fb7bc3fe5c3b0e87145873e5b1454ee7c03631b25737a9ee35083be3bb39de60381c225edc7723a727298df1cda57b653353ead388446535db04cd91c582db6c59ecc4fdb1dbc3085d5d48fff3a50773ae54d8b302f94e16374596fda2e3449c55c26b840c4217aa26f84653782814b3ee216f5efc72825cdb151831b91b7e8a27944a3efea5d39ededb3ed51c4139097ccd231798b58d0732fd4b5c398494ef1de90ed7e93c19b9869a1923bfa3f75f894f1fc6a0c61e7e73bd5dc158dc8c90db5edfa9832f2d7578e766deb64c1ae4514cdf1cddc741dd088d95446adafc5878f2fccc8ce42630aa7583c98611c1da1962110bac39bd335a8428402e9b66c8f236a2a7766e481c64c466becaf74df299870f06c8cbf6cdc86bbca757cd2bd979b5abfaf66bf4df39f803e09a6a618370050bb09af0e539681b880d43c8b26099ab8a8a822e2c42638185d2b625be14d8ca316ab0bf667d89b9e145d8c495f0319c5fa24f6a3eda72bd560055d5a8f34a6688a2587d5e325ced7812d82f0a17fc5c7273171e8298ddd1cc6367cd50d56d2b38af3fd82a37ad9dd30912644b0019814bf78f4497351aa784f45afccdac1ff5cd81183513ed4d8f82c35522a595a67201ca11dc1b678224817cec238e3ebdbda9968e74fadb48ae4a5ddb45f48a5d4ab0683d9816410ef6dac8a0c698e2224ce2df917edcffbaf2208fba9561772dab550d89c018ecc1e89a2e21927ea64c3e73373ca63092ac2437123fb62c2697af31a6e18443945ff7ce8b099c68db351a385c8f69ee4a38fa89df80f5cdd86b7d07aae1ded3882020fa346e0eb970cbcbc994a4a4d845ee47fae1e02fd06b195c9267fb89db6d4dc4fc47cae22202b28b9b5f647d879bd10c5e7223c9aa182e4923459ccab523b81452b74cdd441bc013d6ff57a732bae79c886d81c90b1630fcf27827d7ee9e23fdbf6fcdc472f51713fc6c6cf7950707ed72f194b87a5f33925ef907ba9f8b203a560a0c103cfdf7de8be9ddc49c8abb1de0d3594212dfe442af417dbc881037b06e14889b4d5a712b7632d6c663afafbcce97370508fcb4927cf31ebcfc16e6855f71292eebcb098c739ca32cb8860d4c86e5f9fd55e4f734eca40950de905dce6236a922fdb50fb9e9703794a899a7069236817dc9bfbcb3adb6b0222ae3994aa38443917b44dd10af561d4d5e46bcea2ec58087032c5da764582b33403538ce7d1aba04b20fac21a9b655754b0b8d4d70e903d84b0d5a5a96b5b0ee1bea338c20612f060a9da7baf07c3a9387b71ff1d630e30bfb6283c22b496553e6100427335eee06fc909aedddc962d5c2d2a3aff9097efa5a656ce470294bea0662f3b3d0a14965fc8e2b9cf824ddcb6ce5f1486cd29142a67f3f8edf74583e340c5ffa86da8b90b950c81aa48d2fe6f543a8de30df40c43970d7fbdbbb2cd19f7d71a5ceb2c7dc1a0f5c725a6e2245b328a0efaf846c81f8cc0b94638d7ef1a927b14b292c86383a847b5c45e7237e9d994e5e79dbbf8f406bc7ab2ffe6d741a0911c7c52c34072e35acd9c0dd1a45c70adf1a80ee3534ba1181d8d17a3619c2d82f7c29c63a1c48137c728d09c02b0077492394939052e8b770e2315a4dc522f0ecd826cc904f2546f8887894425ffbcaf85b587f8b733cb83a730be18448c7d47a9042c33b266fabfa71d77a8b7501e0c099eb1a304e6b1b2a58725ee0d5cc5649d12c72c07a0ec5136de737ee0762b397c6467536bad568cff8279ce75c38d0b63d014733289901317cdb4e04b1f8669a00612a7fc6f1307339b7abb88efa92ef3f9c68b47691033b41c078fca741f6a7c2c5cc41a325ce47e875bb139cdbdf15280e203afb0ba520a96b827036f20931b841db17436c7a214f88085fe66c27427d96bb1227208f0bd4ee2d73a17699b6f4ad7a975647e8d433f4183175f5904b3bf86bc5c595200cf43e088192b21856a7598b71d33a7a1412e8d224bd14cfed195ca22da0dec8fb6033c030acf0ca0c7a02049bcad7445cabb540acbf15444e3dc6758fae1d7f77125b02b929989519143a47fabaa8b508797346fb82e1b98042b3594e5ca85d46defa8d9dc4a811e9d8fb127aeb0a5375574ae6a148bbef7aee0d2053a55f7a503d50528843ffac780d39592e52efb0ec47d82b6fcd71dc94acf23e14613991c31241dc9fb77327e895f1214dcfa1f8e4d3cb0a16ae46a24e66db9fca7bc9bc899aa7fec14c00cc77af6a3789f152deaba0300aeff720963a57f7699e4395ff276573da6c8b88b9bc3a917685bec3d7d58f1d76f8b83bf5dbed4e351b0902e70cfa7c0b5cff453403516d59e1550d8093444afdc60e0eea7c97e134e3adcefe2efaad754378951d0670f8c07796a8a6ec7ae91916feae79d055cebfcf80faddaa7a3f6e955388ac629b9b0552c8b22c4a9f6a43ec4cc899846b9be47aba87034bc33b3fd8904140db22971370cf8fb8c8bb93d122e18b901c029a8e7b227a9b9c40f831abb2c23e15ebe6192f0eadcca181b088617145db6b0ee5a2211f9cdc6da343c08944721c370655c880ee61906bc5a7c816e2322b41246aad7bc632bef37d9eda120586c2305eb4319bd26016ca73ed823ceaea007c8cf70c2228dddfd6e5398c60062a555af99a482740dec8994e6e353afef606fdc7b92ac295b63623fcb40ffa6975172f2f48abd23868ecbb7a9bb0ed74aa26a741835d73a6d77164a760e6085404aed433cc81ef12e0378838652dd0aaf7c615fe17fbac80354ed0a15ac1cb1ad21ea6506a7818835e2c4535af3f9006c29513e127e7e9332bef65b8a04b60d5b8e8e51337f8955b13a9b8d0cc3789bec71975ada766a8c69af6df02f73b08ecd42208abf229d3440eceb86300239544bd15fc4c04151b5840441515a48cd4b88dd13394c2e5727fae722ca30e4ef55c1270bfe46c723bba6732336b0d957acecbb6ebafad50ccacdc7e084ee7c945e3d83a7780cbd50c6a0599c2f4ede3842b6019e6292a4f0183641e68dff399a976d88df815394fbc1c6a833c5ba837e13ec89bcbaa1a9a1f7adf2857bfb0ed25e3ee2997a1bb2d96f8df7508d1bc52ee3749860b7dc18340380927a36cd201f9757063910ab17632b1556722835b4e1129e40b1b79c73eada19a65eedb2ba0e3fd56abbd26df2c299d976734e5d27f094edd335de080149f256a2820d0716f5f03798ca440132c08081459b4d34ac746059df28521abaa90a2856a9b433bf248a662a9ab4ef3ddc9cc338a455eddceb531d2c370567ebcfbf777bf3a87a4b49939f076c3b85561fc21fcb894400c01e30477ff5ba6681e5426a0f00866bceddec4a5713d889be39a66f366b3fa85e2b14350a037602cab91e6ce2e10e5f77f577a1f017865532657e0c619c7c77465996396e45abcb4d7ae24450337cb83d0e54e4de9cdb8072ed605f78fa43f766fcc020238c6d36c4222e38f532865bfd6a8773d0cd63a909bff1c785d31a671b6b69829aa701afe437d919c7f866d5ba1086665d14708f61e18008445654701912ebbb47dafe4c090676015ae9ebb275d792be55bb541b61eac4636c4fa7b3c130b4678f6bdde3af489b7860b0e7ddfcfd6b7c6166cb3e36a831499787ca6c6725791a07af6808cc048174e5579e95de27adf4499f8d96bb40e3d7313df6215d770767d5e705adcbd3dafa97f967686cb1005395a4f6f35c5f8a21691b409c3437a109982154a5745ff202960813e59b015bad3f10bffd2740706175b791cf9ee2a164cd6dfa6c137350f48c1edaf26e7c1855600de2d84941ff51f6c817780e70107efe7c91a834fa77593e945d299b712328f5f74ffef78d7d2d12ca781d0f6beb4dd3768b13237fd3e67fab546f7b2c907d8e2e6fbd5faa3f8016c551e5bfbfcfe11c77041c3f4a96d78731bab21e0eb3b21e27dcdee150d0eafd2473960db3892577e7c8ca160952d684b2188a5ef58b7ba91cfaca34a34fbf868886ff318d26095386a8d5616447dde629427149a4c935d7c857672bee67e0ba363854a3be11c5a4a94a5d34f509230f80a27280fd0a6a64031f73fb545b776be8b93485dfe194e22fb9bc5355a1d4c339eb11cd16ea9a3cd8f8d83c01d4826ec190599cf2208fa9ddb43c2e2eab3fa0a885f8405db1c69d739c93bf65b9e8c726fac9a2c03f005a61278c77461dc7b8e2cee4d8868ea6421f8452cbf299a5f2254de43a9d789b5ad3df3d4e6d8001fb58b293d7211f8be634f172a9be148b1aa788692ff06b7872348b611a13d6a32e1729429d4567b5b3953051b1bbd5ba5976b17af14e411c20bd6ac925e41a76f428970c9c07f6dd19104ddb7f3b5e141d1a6001dc9c2b65116947eab192415134daf94f2a75c8377635188ac04e3d938a9621077b346dc91a04ac1c5f00afcebf38c440fbfb7816839f99b153a939cbb18fdede9df6d8dca19c84879a6ef854d87eea36a7017c7b2c3a68010ceba3cb1ab725a81d7f128ee5845f1e105945ad38ea76ddabe3aa7140aa3cf1907552b1eeb41e6f70d0f0b8186a4edd4cb08821e1819c2d28aed9be4ee0e944030892810c6d1ae38403c8a80285f5aa6cb2af67b248896c3cdfee7283995e3982634cda223686b9f7a7c4b53ba9ca51073f8f563816e2595c66d2fac9226db0044384e5b855feddeb53a3173a6a27b0fe59bdef6a12a88af0a79d456947f28bf0ee7a81b644c23dc40cdc77e144124f9f8b68827ca3ef74eb1aad0460bd11979f6d7766d7fce472d5edf4a85c740bc0d2dff6f8b679c748274f271bcdc14a6b1417b298627669b7a482505b377d25b43f8b42177e3e03eaf2b74c919c4300a8a48a8da4634090b3e160a446710b2dfd59ee45bad649fd83fe833f86be0c9c3e2027cabf42d7e16cc8248e213123fbd6924c36fe8020d4218d164b56c8dfefd55218bb56554a9d68985c9b96340752389299fdfce26d55ae7664de72b8ca0905e6b92f321d938986f11d8eb677bd58c614a999f31a89a3079365a1164820457be15815bd517cf0ea2d6813ad62b652472a85fb6b3dc0875a897917f88670aa7740b98443332cdeab6d67edc05b3389b180e4d1685890356d69d6e7432522dd8a6084e6e4199b5adcc4fa6554bd2c3ec68ba152c82aadca0ddaea56ca4e104db8743285348f13dbeac347f4424b5123965f07ec97e7307b800efed48eab6780d71e2a93a773dd7a9fa52875c9a07cc3128c47dd049c34390bfaf81f06e833b53ddfac227f21c08294643b8424effca23472dcff6349e20cd54464fd07a9713a1241e6dd85cfc8f99fb2884ff99c9501b9986271f77f5d0b50a18c44b224a22a9262bda25cfca490198665eb6f2399fdf332fb11a0f5753d8c91fd521d0ca369c1a11c16cfec7d4835fa81f9fd380fa3e04e27fda472ce91521956c14f4669b520897f5567e981a4361803eb6a580405e2e4361ca8e6ed4d87de0abdd16469da455f29b5ec78779602f1ed43dc52cb3fd429a362c04523a2cec12a4273f6ca788f249d8cad8fa97e78ddcb84f10271f6748f43d19b56ed0172cc39f13cef88ab34a7fe43b2834d725151a990b6e81fb56a1769be2cef2e44c7bc1a050dd6d8e7756b78043f2bdd0b75e6df0112734af080be4004893dba7c9a86b289e49918dd2598fd88d256a9f1b3b306a8560a5187cc34290c213f7c60cbda6806780da3a6fada4dbe61944ebc136cccf31ec47139bde7e6f245c1ce48a04dc9a90bbd173d620dd53e2ee5ce90795e1bc6d28b07fee4faca6520d0832b143d8d3f8a9c807bc286be4e3fe13dc8bef5b5bef5f740a630285076bc1651eded7607d64db06bf1b19e16d3c1cf1f82dfa453d7a7faf562abc0769f12ccabcb8c902ca73745dd6952952d5d78664bc3b63d6ad5896540edf5a2011cda9a7e24fb0350a1b46a816e900bf05d989c6a9152e390c78700a3519ce0d374638bd895a7cf0378f40b4e3f16fc5480ca45d38182253cd7706489d8ff8821fd052f567ef39663ff5ab943a540dbcda5535843f39203d4b5b90bd4ca1e09f5f98ef472b939928d33167a21e6fbba0e0d42e33cf46dba05f0f70e95514738dc1f81fe168781a29839d7162a54087c8c7eaa28ae681d00dc7eb4ae8ae750167b950dd98d55f7e878d8d0cf533a9811a9a083f8115647fb6a867e6f4e4a5d414563cf8fa83713b9ec4a98bd97a87c2d428e0bd2dfa9d249dbd7a114aa70f3cab116cd2985f76b080c7d950bbf212f5e2ce911c2a7c11939492ccc40c17c5c572adcd2e1a7c997713498d92a9f62bd7cacd995e43b20129d5aa596c87866b3f8e3ea2af00d6d684410c5b77b2612813cc32785a4cba330804a3fd45fb27ee73c5988577418abc5985bb857dc87c135cf6c1311729a4e181621bf46c4aaafd7e8af3ea9e8b9ad21df74f95ee11a82c042ba66213a3b6bd944fc05771713273da1a50b0c08b3ba236b51e35cb67554c7695ecfe7722c79c1e1deab963ad79b731bf2c83b8746712ee4bb20ebc1769caaa1adda30ed28f37b27f17579e1440a01193b8a6fb085d9650066ff1ddfde7824b4b52b28ecfb531256bcce472facdab8668d6a062edce950d0fcad82efb10c84813eca0a27bca29667f63c69c4d0c39940c4eff3181ee2891e0e1a96ad194ad9e44dbee3abcd4fd28a01b9e16c7529c41c1b74ba9b058e9882a9604ac0c6d804448eb6a539ec7920c34fd0d97ec5403a5f47add397db5920cee039ffe40c4fc5d7b77ac53de5e91bc50c7a1ba69362b3f4aa8cc01a0df61eb5a20d7e7b5952a396924de7614173633de8111aaf153858b790d5a86cadb2b5dcf1aafa9774d2ae74a2a41cffaee081d1031171e1fa6c9643d8632d51b4dad42c2daa4cfb04736351d1c4f49170aeeeefc5eb3128891d5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
