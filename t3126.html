<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5598e99d438f004877570df8752f455a0e465a1db9d34da8a586e3dfd32642da288295cc05a95e6babb861deeddaec6801f13d262607f6edf3ab313402e0924df39546af2d490e7d8a54f25e2afaf7665342f7a8e6c093b482a112d8ab4d63e0da9d7b1e15275835952d71d26c9cb3326221c2cff1d188a63fe5880da31eb69c82ded39208dc4c5484bd2b2711f838d1e0f3bb1c9f3f3055657f199b86ecd235d5aa7700049e75acc2a656a8ff7b0473681acbd31026764ca83976f92b874cd27460c1d9ce6d6de7bd2c68bd6c3015ce432f6718a973c9c42c45231bed93482a6b06d44bc911805a894fc028550dd0e2736a44593bdd861be2f8e64aef57f0633abe23353accefbb86c71250275c5a23bdd5e186abb2e53c8eae7ef1ab8e2d049c54cebcd81ba600bffde4e288b26018cf750cf9675c410b30dc68f8f18a2a4cf320be6f0f1c4c02a2605a3abf144911268dd99099b286f4d3c0e600c202ab895646b2b3a4d13d8afb4b9081a8a8ccb3d6bc3ebba0709180ac53ac148f0d2d3bd697c61c16fe7f323f2b46200896ff97a665164acc7bc5138eb5c5b8361129698f87a2605ded4887e8dd333d16d4add2104fb01f82739742b8b63ea4b83b98b3159fed8d317ffccc17b2f945efd72a7a847068ef0c529d2ea2abade999e03979cb7c9441a111a416594d496b7057db4e05278cee6378522bbcf3010d61e4137a5433ebccdd69fda99bf27a3722700c757189a06762b15905b57716ff9e95a5abce6847cfadf6bf5cc00362732378559f87398d56e447694229cf925e1f69e58ca912b0e3bd82853f76cd18a10a7ac47ca6c8e64fbbade212537e79dc533bb2ac1617c55f5f97617260f3cdbfc513b2af4760562e43e044dd0c14d04673b0183f7b7e2d448d29765d56cfb746e4d262ed4a94eff923ce91887d6c4d669af411a4ca4721c3869a5225e101afefbeb759770c3e4a19a8996f66af4e07d0523db88364be6379d36f996f216b602f0e7c1a96e7255d29dd8aed7c188c7f9be47602316667a29a446380fd17824b1a9fc213837c00cbe87b83a16f5bf4c2afb972c7831b6fee02d0fd14ac09ccab57c8b96bc1d959064e55de6fbbfd2d58b70943b710aba657b3edd4e7c117abb9da759bd522f231de75dfe8df5a76fdb77dcf7aee30fde3d61acef86591c86ba32207b196964cd5554112d6249e5cf7642820491608284fbc4bacb7e5a1985f8b692dd93874654cfdce7e838d2b93e88de375d97c78077679c08cf59eaf1799b893f43c462a9254968f06de6c76823145a240bf94dc17a219b438ed4c959c559c59d8b594bf5708a3fcb35a462b6088fe128e3032d64e6f531bafefd41523ba93321392719e2c4b47c2f8ac4378380412c69bdf203110a9ae945bf59e4e6402f7d09ed0ac9cf66c1297ffa7148bc9b3aa5df155abee726a1032d12e162be490edc8c1b305ea4f0f0219d98ba3d957a9fdaa208c1f296d88ac3f2f9f7bb6298e58f43048b83033ab0261a0010569a79275a9cde30e340eccf7e817468e88b4a259912d0627a6029dac68cb54ea4df0cc998c37198313040cf05c6ac8fa0d1a9e7a93e75b0c09241943f3116e86735ea3701fd8d2451ae410b56edc642439c1861cf1f09fc4fc4d6536edb81c50f39dadcecf1530a3d6eae909aa28c280a9ca0a8ec520411546a7830c8d140da34a5bcb27a8494b60be6c54853170f8d86df800537de2fdf2a1245640e0a1080b6358d886baf790affa7a249bffa40a34704d03e8d6b1632a045a72a4820c69c98629c8dca2516c301f7426dc870170fd088e0a385a69eca0772c52f8ea1b164f219b1ca6d8751a316b225f42ac3460961b3cac1e388bf2233504058b45ae4227d9112c883e8172ced7a3a60a3b42475d96d482532c339bea725d3e452a49fda2b7eb9ec5eb712ba8f2da5b817f9050be6134dd4991503bdfe18cd8b68f2ee2f619f07c0cb565ea26cdeedb1d09ac253e47b2b1927415b535735ad03fcb904e6f3cf6c48b98d3e75d56bdf520da603fa49c3143da9d0723c9c6722077b6e3065c36e760c6a035b8b5551a999ee400a32f3c4c50b76da7526ad354a7ce2408037f827db473fcb0d2395e72495a283afe31070f7eeb5540e36f277239df797f42f9e32719b0753103f839e1596a8b62411e95230f0755d083e9cad98a76d706659aa5a6c9cb61f72531a4162b7a980da3353048db3e949969dc56d5c6374c6ac4273923060e0b9cf2dcaf2a02a879d1ec84c4ba3b7b101d482fe860b4bab6f50b6a8e41a411c29017371c5254bad198ac944b97dcf770b4eff530e4ec183e62ef31aeee4a46b6b356583301cb4592500d242ca9d789ff04bb555c96132b46421aba9a31cb726ae231d4a9224cba8b6c335257c5d1904fb33e387fac0680342bf47031b9436df7d9c80c6598fa2093bff6ad75a230c3e9782169626d40eea7de28013706008a9a8206ea41b53fa4f4a839299c47dfe75dccece5d525fb469a61e096f5f24dad19031e2e511aee234db381a8f4f42b863a74725191133501968c0021c89e50e77b5f1e65bc3256b4b9cfe9d39963c3a60368d7a528433df1c27ee3b19d972e35170e5840e07796c15144e5d85f353ca217f81b4fefee4e76c1d26ef33aff043a5eb7a6109eb341f5225218167655ec5187bb99d4e2663fdfa174064374870aca1e2a3b2ff424f2729723eba84281a4c5577105ffeb37e0b29a1f8cb8453c2a0161ece67b6eb4f5093bc745bf1b56f01257ce63da6090d5212245ab81a7b5175697369699834f135428fa93c9a4d34063ce38c9538d884ac2dcb5871c785e5b19a267821f90a16bf17658e2d364ec902ee2e09d6255fca2285421c1d5865463c55c06e338d9e1bf92c72bfac1f73ac11a5d24c5aed345c03979a0d7de14592bbec9d14f6ec27631a82521e094a461b80cd5ca87f0fa7880826497f8b255913b69afcdd2dd2e18304750b9e7d31c05104530f76e4df72af0c03959e306759eeb0b6b9b9d20cef274a01c10bfb020303642ad05c07b49a32f85da06fd9109ea0ed7e426cbff8571bca7b4cc4617aac0fdb5072b12132ad4869adedb8076e19e13d9a424a79cfdc2ddf0866383aeac25ef861086c7cf214b1f3260549324637045e4b4e69a51a1ec89875aa131bf33e2881e215caae510bd31c996623b5e9c911b25167d11acaa40fa4f06a643cedfa2bc1dad3fea6ad2ab84fcc615c771e5e901be0ab4245e945c8233c0463d7030024c13a54a69761f39d60d5e16212b889e7cd4b9217619f7df1d80c971c9522f9c784153ce5232b963ef76aee3d14865af8a74313c5c3ffc6befae8accf8c16cb8336275a2fc434535ac5446cd81a911a8b8da9cdb1defbc0ebc1e4a46e000272774c946a5843d4a4e7f3d6192ab18f3d05961ad138d474edeef083486309774bd499d23fd040aed3cafe20eb2b61a67f7cc3baffacb8671b6b6a5d6e8be3f335e55b489dc4141ab2490649be26ceafd665d9bfe5862b84a6133976c14503eac08ae44d5ac96485a2bf2af7c9b86722dae9ea14224668f114f77b7dde2b37d76470ec8278a9fc797c49b64d12033251e01e71d46122b206261cbfca63aa80c8d04d00b71a3ef54f098ba0010085d2aeed3ae45b9283cfa4d477e91504966d8cb37c8d10f492afc2fc53c87544b2577ce10fe525115dc25d83b67abcdffce16ccb4dbdcd7ffed8e6e8604dc7342113ce2b5a3756e85ee9fdaa3bcb12aa3f2bab579b6cec4f0bc07a04226204c3f818fd2c8830b022e59f424b3e5465ceac449a8ba1836860caf0b5c647fb5d9b9a4ae98425d28a3d66fbef9aab9f99d08169cfb857dd1e3e8857e302e093a87aaf6485b221529a002e1d2707d25d8195b56b53b5f67010df2174247371cfc0848d1306a8ec3122e3230c6b6cdaba1cd67ae26ee035c0df4793826a7f5655b2c19861a25d5630832eca6915b1ab071722e499c8e7b195098ea05ed21c29d9e634b671489c0a661e0178221ce2f57680660d41add7e1bec3f72fd3af14112f85a8b033a1d6f3458642cbf804ec41117200e5ecca405866325ff935973349f6c6b003e4aa50eae4faa6066f34cb4ae8fa0bf28e3502b4e1c2dc89abae6007822346f9cee71acaf541c74035ff50556298ff10180f90c7200ae0fe8fc5a1dec147262ae2b2d4e867bb0aa7d501d6a41d929154e344dcf9b3319d12d23bacfa6e874a6c1aef953c35f57dec933b38aae1a4f9f7b0c4c92b1981b03b23bbb81dd7760a938281ad7b4dd06982a2db7c5e7f7928292a87249b2abf6afacd836acef1f10d3055549101a1b17f60c7a73b98a7fc1a36902d9673b7cc541b9da34f1aec7b6497d68f3f96c29a8b91d4f0233ac0967859ce835def7cd0a7219004b0dfaaca3dfd79c97256f9ecb2002f145619d84ed465fb7f855bd0e92e41236f42a0b69a9af38ae27196dd20d84d4bc66f7e9085ec75b13e3a5958626a45dd5355c19ee379bfa82957d160f10c4c596f70944469133c13fb0cf92ca509ec8610fed243f3d5506e5ebd9b09a8b43325d3039cac16728e77e3d0c9dbff03a9fd7d5be84e1ac89ef9d9b5ec99440535a2ec92d55c852a5e8070b8873858681dd0ebf3deef8d3c7f05b6cc1dfcec018100f362cf9b823034f55624c98d3915c7f552550c9ee7bf6e8d36a766c7938976b83e6c66d02481d408e8cb5955a6fb1cfa3bce1eafa82c2e2e8523dc2ef40782409f0ddf99fe9bd5174aa5121ff620d212c5750af1df8d9c43de910e110862f59a5628e044052585e6366582f24c924e4e22271fc81380e65d81acf0d01251560733d750dc49bc1b670b080aa6052cdc2c5afdcbae0a507ec2c07bffdc43f8784c1a59cd8b26427e86451bdaef216c32522023075f45538d9cac7956dd4d6e32b7c3b9bbfeaca0da7cd670fda255afdf47df4772e5d374571fa4f0a85960e77a7fdc504b3eacba5c8b9cd81792c710a42480e7aa6c42338e4d31e3e607665d1ae33c5c75249a5384d8cf5103cc7672f0ac96f35c1063ba41e1a0fa7dec688cd013cfafac08f02f7e8ae50964be4872063c0a98dc6585e1cfcdf55d161616427a458a2e53f02358327faa003ab2af8882e017b6c276cffa2feffebfb59e347ed5f8a2a9966ab8f308b1eeb19a4758f0710560eeb946453f873739293c1517faf6dc38689cc0e582c1c40eafbde901db0b6520403d6922ee6178d6d5d53b4db49f8c1aa0e7b732e661cafb9ee55b8070d4e826429ab8d0a741cfc4ffd4f5c2f3d425d12ea57ad3ce6ab2082ad3f67900d330d671179dbc87c8cdf167442ce6216ec0a3b93684ac2affb04df894cc1677c67ce0d458dfddfd3616432109484ead2930ee0d8b7a49c0eb4506b56a2ce2640709e3ed425916d03482ff4c21d29cca7b0dd57b5cb3598195107255c7989213b010ba28a3da9356557c288d9817f44cd3a008698c88a6c9d3065b9ea53d76bdc183e991fdce2cdf46911b94bb92662e0b6614545116e0a5e3d6644462aabf7b9e57fe79f8e90ad578206d0ed3da2b6bd33d4ed714b7c03e24a0b528ee9c3e163c240ecd56c8c020d776a74017a777f7c2b1ff107dd6b9735abcbc88b7b70dc84794a3ce57f1a83bbfcec1d9764eebba033d281beb6cb6c6e4a0f87ecd7d439b45c7d5939a12ba9f7c3879da7569d10033f13167f8b5ff1401874b85251fe45f6b0ea78a379ac920be7ad61217cef38c8281ac81204380aad4c4275cbb21ec161b729d2eba4437563a97431abec8903620805216edf1124e80e1f732060dc3e35ac7496358459f2290ce7b8fb7443395e15ed3f7cb65962dd35d4d3617ec09731aba76c22dde028a30d950a1e233200ca32caea05028d5d89200b88a804c8240f54210cb0c247337965cabf20b297ceda5e69110b2cfe73de4d7ae60e3e7c1fe2b3d097265accdd8922ad41ae0247a6ef578ca5282f10763452a7fcd803177751063d812ceb5a4a58dac77ff22cd0393ccb4e6039ad082115d4b84706ea6599241b136379675139613f5eddd9b9cf416f38f2bf167908f01a11726ab0af2c3101ea874a0c23bbcfa73e789ee8c5156a5527b3fd4dc71b4d3a073f6504df9dafa9e6821c9b1e946f78454c792f8d1434ddd9591a55a942a88374b5af241e178885dfe465cf175fbbc3fe20891fb9593f7d9aae465b8b1fe80b9cac5ad32ef1f4c8829a874c08396958d338456c0c6fcf0ccf36b36549f7489eedcc0feb1097a813f5982573ed732703e3ebb5496bedee1abc46b3cb313af4833b7294cbf1f0b9014d1d97c450879bc1827776bdc7fc1780a47a04792969abb05c654fc1424b5a06367dc81cfef0f0f20734d6f8fb3fd747374e1b293ac04f3c5bf5b70dd7891fe2d3bc2247d2a1769df78e19297a79b5efb06958f732d28be9bd0bd0c973d5af1f579b848fda22d40b050cca575c2e974c880f18b6ac8af140a18a6edeb4838303f93097fe9df102c1b2eaf3fef73affc07a2b916fb1c3c924b91ff6b0d4887edc902c4baca6831b571e9fd30731380b26e32e90955ab528bdd054168b37495b9ad7efc93c6f45398d45fdab603c7bbfae2365e3c64072c8046ba1b02e795526bf42e441336a118f5a9a0e907f0a7556ccb5ffd7f321deada1a0bff1c04fd554c0c153ca7817e5230e15330efbce28aa77b3b434367ecc75442c2f88859860b49d0a9ecbb92047753f97d3875f3b5f20e9b1e7b22469777296ed9864991d5ad8bcb4588730a52f01e72cd767d727e0ee3dc979c0d737358be9d1431b59983e943d54c7cd2e826dd0244e797b599d94e553779fd983c74382b12730e46c944fe2627cf9a61e92297157a1c61b0f9dfd9d03bb160ce0d7812c15f0014c16af937dbe500cf9bcac45d20227bec7a7d36ecc6a332d97a0871fbdf9150c7d753036d9b6f31c2f2a2a6a38a60003341027d16e5aa9080407e955c1af86879db9f0a89c2311c75e3d9ddcba5aa26a2daf972e464fc71c5af35522a64ad37fbf870b6f0eb5bfe169960bf7f143dfecb2f852404686f148e1d7f982cad751cf10acea16e1e40079c4f96a497d6946f88999221143eb8f26af33e494b213bd29d993605e2fac4381a3fbc36ea0a39c7e2dcdfe8edb939246849206ed483c2661c715a19d299720d56d24322b87c8152fad0a79dd7d7943fc4241a693f5c91315b6fd43afbe65a1f1e9f172d22b2aac23a01f088d2eafd9593efdac6d8f66da5698dc433e2356428754cf85ac088fe023883b520f39c3a63d90dcededb53d8970e5f5fe4f4b8f2a47e086332475c016aa0cf0ee5b75ea3f34929729dd3a311d447b271d77806d8a917478e2f180107599cc5d89c40ebe52da498e838fd962a61cb7f876838857d972d947b9f779af509d29409a06b0718448853845cd4e6570830674a0237f472c49c18b6b183e3d4b3d89ce5a95e9b7ca65a864748d2f852518cda1fe392cd6b4ab9656498e57525252748f0126efbfefc6c8007fc7cc64bc7bf9e7ef6e3f542002acc62b6b3f3d5cbe253e5db4aea0263f0680bd84b185014bb6ffa0adc98eaece01bd582a371175a68736d057e0f089494f8125c4d4023c2a3ef15b64b53e89fb2d9f38aa133a3b5f01da795b8a2a405365c136ce7b26d3e34421384404d0ee4639af820ff17b28c2d232239ae254f36ba0a6f783c0416fa20fad99d87409948af6299c397ed5aaac1e71ac2248fff7aa922510234846fe0f8cae99f6e8e463b4859e076dbf60955c543da55c29146ab809ecd1fba8335ee7f2e1fdabf76dcfc367b02b54b6c3a4b8619da5a70252fd2d8ebf12d8bfad617dc0a200df63228dd4352673cd4036a6ecbf6f41018c07459fb7f8306740af4c8af0a7241b98fec48d7c292ad2ab1f56aa5002574c861762478c27ae5a5620dec9ee339db7a4e45d566d84fd5b2707e82e05c3d531741fce719f185a67a1221ce7ac3a143073fb7f9e5dafa8c609a6af0181e85c735f364407b9810405c4c68c5e75a80d5f6515ce4812952479438174c8586d6fd8b8913e8817d9b3e6188b61f8a3efd7a2d6773a398758fe7ca40793284bfc10594ab4e69bbbae4c2aac8ec0eea947c6f451f9465f235904b575d2cf67f123d9e10961525f935cd2af131e1093c9a2a804fcb46175f573809604a38eb1cb999ab2dd312c44f6aae1c8b05af72cd5f66185600ce29fcd9adae7a55d8f4d64daed3455b525d98d3fbed068cd04e8b139aa9ed82fb6b18da165a17540fb5cac9f4ad3106592f6a89344a82b477c3963ef4a92e1beff3048b93915976e6adde4031b2cb8bbb45ca9cecfb67938713bddad6b2fb5330ac185ef71aca1c623ef0e17d68219fbe6db3381cba0703e3b01a03da712e33479f45911542f54f2131b1a363932f54b4c32af14a6522710cc9c12ef14e901ffc0318ed449424482686ce48895dfbdc095d69558d72badc176297388aec43bafe563a519f70e4cf1c80a4c05a35fe5154df7bf10205e54e2de57d13efc67425a61a99cd60412d80737d6a306e52b673d73cc2cab42c73b34178738eafcd960e9bc0e984adcd2f889ac608b58d25e04d347b21d796ce3c49c470219d6790571d02c281883b654d091e581241b0433a952b3229901ada22647be24bd8469b94f6af27abad9df32737017238208a38c7f8ccedc375c66b2f846707de8a73ac483face3d35629a5885a58b191051d3109ad0cdc1dd5e90b5b2bc24ed14b4ee2d7a8c48b0f83d0b758a21be41e8b3658635aab4efe7ba002413981a27c44d6142f3c6aec26e5e6c19d9a765eccfb99bb4bf0d0f8b77f7020aeb2ead43727cf7a6f72324bb2029499054174cddd13750dc0b236bacbc89e78d882eacfb3011a1ea68ad462c520875b8bcc7ac24b5f31e5c1ad79826ed7a83e7bd3c2b4c14212bd5b599da25be3067a167948e820be3aa639905a2ab4ea010fa75e9b3f78eb5297a8a8215c14d4b219e9b3b4961715cff5edfb92fa8cbadc928ae97e97bcae77226ac7314e1f283957bde94020bf295933c41be01473c3e3e2a6d30f8a570dfbf8a200a47248838c4f7a6451a577912a4e240ab906f35d5f1fea02ae9321fdb6d31afda4effe9212f7760efcc9d307321558d754cd06ebddf82e901eeab26d5401405058b1222573194c4bc2ac2d778ac4c4dbc05db95fd8c2645ae4d3787ac133d0a47bad516c86d26ddea35f75606bba6b72dbf7f125c94408c038a4dbfa27aa03280b403ceca9d29cf3ae623425c709c647ec0de7d02e7090c3f6dceff6d834458fb4e4070c26628241bd64d536c0ff9fdbb36d3060c43624ca791276fccb41202f4ce1c9a7ffb63f675e952ea0eafae0f351e304ed4176a34207e29ae8634fd924b34d285da03c9cbfea95e229db5e982b2e236984d7e060fe13240b5e47ba64d0e5d3d397a72b145bfff4fe96c3e4954d937fdd042e1ccc647773171daa83e70effbe17e1b50d0cbf692c96bd893a2c35851d58fade093e12703db09feabde951934215b347a1fdf12c900ef572ac46c0c2f9a6bd3459eb7ece2b77c965f7ca3d44f6602e87c6cb5d010ca9f5d8cfe0824ed987d0cb9e0b964ceb9a12e296b452605741c74de1204fc810a8cc0f23a7e3ecffdd01a66a38c29a1442bb0e9a89feb088aeedfcc27eca3078c85447e12b99a40d74eae58d063227504c198f1a54a8e17015fb90337beeb1d41ee16a6a2c9ceee517c5dba811f5ed6e526b335da3c253d35e2f3d1b4cfa00572344656fd3c2e6d3243349b550f74c6a8f43e9243dedc35cc48ffb264f1bca807193225b5dc22f6e4e9fad2001dbdb9c5d0c78421bff7c8c0313e5cfb658872fd70db74b85ea2cceccfc29bb063d68d91c15d80933b4cfeb5b15c2126ff86c0de33c4859fdca9fd2cb2e0b203cdce3509201e11b7d13941200649427f28dd974d7f1fe1527dc0afaf9cca1da363b111097416ea64c9a424493bef9f65507ca82ff4a6f2fc9af45a2ed0e0fa12b9151319513ced5a06ebda0b86cb36857b7a0072246ce148d287ad9d22cdcee725367667d7274c427e05b702dab1a11dfd23dda37925592d1921f34efa42899ece022d490d0635b708890d6ec6ef2b9e9787affc451b9340f18983964678e673f84c14c48322ad3135c87f89bd21e2feeb170e8d93ea3fb6f23b06889d22f8ca3edbf9aabeffbe6c609d88ce0161569fab4dbbe13e92ddb71d26844defc8117aa4399b25e530d4caec87a944472f2294c596b0bb2a21a1aaca76b48385047b21805d37ecbd2b47bd80fe3500699a1021acd0546ab997377698deeac15b85062529dc8961772dce58a3c452fdaf98c9e1e7dae894559aa74227ab859d33f41f536194fc42c7a8c7076ae886b43174f8ef65e575382bc6a9e2958cb7fc983cf6eead639c6182a536fd1dc7cab473cdea6db8489c1c2c515ff7cc53123483400f4e028b2da1f46325731feb0984ba84512b698082bd418898c384a85563e815d8af8993831f5380432fa2603d4bee67080655f117cc788172e1e5944ed3b0fcbd448c0b9c24904c0c919cb7c86e523d2cbb2c9b72d5a00dc6b7440ac548ded026999524dc823a7d2bf5293473e6e56e35c4af92d2eeeff4d25d5aec6b5ed5fd699ea320532353769c0c4487a3aa2b9149bf56f02038cf68e52beecab492824c13a168836280cb72cb3ea067e81475c04798b3b73d0184336d12b44ca90654f1f1cda4d79b263b2f710d791f0f90b6e7dea7b600b13dc0d74bef7ec002cf858649a1fb557eef73300d35f39e59d60921eacf4958b641b8219af7aaa554fe3505fe9e2423f23bb92eface5550777370eb5312d75f880b11221d1bb8969cbc8370a49479d47bc89cc3c1052f0327aca56b4720a9c69862e595c76d39bbd0f1b9442cef61fbbeaa1173faeed1464ef3d940a6f0b7f6165bd442d30bc79ae24c6a0d44958feffe3292e8d89baedd8823ff41e3097cf996c8bc5f402c3b0603d6d0f3f276e50a164396249f96bae06c9e9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
