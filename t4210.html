<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d947a29607fa3ce497e2bcbf4a349025b393e57200a3d1378024d64b5b5288f8265860c192e53bfc61ea43a31afda96e6568b4f24b7ce09d1f952814a767a46a81747c176179c0eecd17cac911ba7e5bcf9d743d9e3ec3bfd653efa6a6a611562a40600cdd48f9adbd5706aeb53c4cc2fb5cbbd54f3da6498a5cefd2680ab04851d4647ef98be063c66282e8edcb25c82271096a8a2ad07de2485c11a564769eace9c305e9d9188d752b33b7e6c5d1d3d0f72148a7abf5d3491a2adb5324c1ad0a83c954e20d0d23f07c20d062b281e1fd875eb6941b0c044b2886e464fd6b157b6bab8c77877e3c0fc9213688d60ae7abb3e23e90c69a8f0f1290ff14f3cf6e1deac7c1a081c1c3eb72e6e980623cd3f00bc52c5fe2d5d33e297b7f9d1cc9843e1ee69c0bf5b91d393b0bcb8bffc9e904ce6e4d27a77069103d891f71143db5bcd4f690767e0ededc9b5b74f4ea3b3c2fda362555a0828bde2b8d8228343263c1d368a30e2fd290bf0c098261b4860fdebb0d3056a80e05a75c668f223eefd6775ffd51619b6c9cdf353e924b137c9c2cb57b7925f0e7cfe1e8c299bda21307acee776482eb20e57567e19da0520bbe1578a7416406cb6cebc6af6f0fe48c8f38097144e58081f7666d3e8445367ff7824232088900b6314715936016a9a9d9661f36a570d2f864fa1e75a075f7b771b60726d4ffdc812157115271fea51acff5016275ee90f2922878031f351871c4a09c8f7ce348f6240562a99edcc912173ba8e285a6dbdedfaecd3b5ac8068ce8bbe9c108afd85ebc19c1aa4ada3b3f0115d6da3f2b5da6c5965d60a9a1728c8ddde6b7ca9ce42a6c518d90a57c54bdadb9016293f3e280bc797e4d637583ccf71676d8c6cd39088dc63140d4ed315a51db70dd964bb7c04f50403037a6927c7979068b10f37d6a5320d68a242e669395d10e5d075b826e1c539841e9eeb748b4d37e68cd245a90858ef34e9fcdbdd5ed17a25fb4f3bdec29934b88537dbfa826fb5810170d7649abd002ca7a67549576084379750b78e4045603f1da300445afec685f5086b763e54138e68699427cc42ec5cbaaa56d60b12c95b96e6bc73fd293cd31dc242ddd3ec395b46de465800de4b06b034c9611783dceea136c5d553994eead60dcb236c05765a51edaf656b35a45c7d5549b111589a8df6b4ce91f19b6051067c5271af6d018323f8031125a5801249df3dad97d5164429a53c1e066f5cda24799fe9e0243647dbf3df938102c90032823bd83b5836f28ce4ba83a40bbcb9c298b6330746fd507ac569f2aee7acc67320075ced3dc5a9f78a119497f5f3fa37c6893bcda048c662d573265eca05fbf45cfdaa03484064f335146f6da09d1130e85062f5f195ae2f3c8a21a850fa671a09d611710c072c3562344560c94716060679c43cf2100be3781a6726d6dc92f4f5a3319d3d094a0180921f63c32f9d5c7c025c7886f2dd263d7e3174804f320f266aeea3418772e90db07ea0be2f4afd294c9c3c5fd749614e3da7eb2646370e0246ae34be68b836950c60441fdf492224a5817121edc203a96e4cde560082cc9b74681ff5b9f3e7176e8deded8e6856a596a349def518df912f77f8c78b4b32a3ec2e2d60dd8ff01bc8596bcf3d479fa19cd36930cb196311aed1a478115cbea3ea12233bd46679065748a95d65092e5956518a330b895256a9c089fde31e4ee6ac7e3c683d1d0acc6df22965a96d27cc7991c59178136869e4d75551c89977166e4c9ddf50015d82e5e95c3a8a7c24e494d1a526f48b0b4b9e5f3aca41dd53b5426d0add881fbcbb05e34fc5904747f79f3e7c6e2c558519a38ea7e10ded5eb2a5de2b5ec0efc63c7ded53663e699a813079a71c9d8471dd26433ae8086d51d711c1c2790a38b8ae1e324cd7606c0f403087d626dbe00b83680b03d0d8266905732b4886420f6a41ca89ba96fe40990944364b1ea5b817b6643c2547c4cd6c48e40d22b76300a3fc7a171c82ac35d3ce605a46608c36a65a8b64672f3abf4770ba5e81f7967a05ffd89e0723f15e97f36847c3ad0d4f78fd5cbf5802542163d327cff7ee09ac6bab203faf1b28bf87348d5c39115689af27f10e3d3d7fafb627cd47eef2108eb995d4452207f81c6ac6d9e069103dfc7008ddca2730f3263ebf545b4a9abdc0520f8ea4a5376dbad056d36224db0c4ceeb5e10e855d12a189aed6b4e7c8389518bbeac3633a6cc8ed64ce61952067f30680e27eac1ba72327d9d6d0559fc05e0adbe6481f1ae1592c505e95d0a9069e665c36fe3efdc191674ba8798c700213dd091ffbb8d67c5342539d82b821a2bacfb03caec175969162c8c2a16d385e9701fe773298cd48070419840b734bc39b650c26cb9b369370bd0f4b944e7a20876fdd2af83e371ee038f7feb442d6e9263eba7e198cec435a5063137ccf542dc6a2b3e49e510f0e1fb128767a5cd2bde20c31f1b260f73e46a4d6611a7165b061bc4d2702ba7ec10af046037cedb5a912aae66a58d1edea2d0892047f95643aa3df31b9f4810002473e2d95a6e58b4ca6a9cc8a1384292f8e286d2b61b9ed28d49a5de217ba60adc8f6d1460f24f77c08e6a9c464369bfa4a8c692a22cd4ce884a8d2600ee288f7c779a569913b8a505a1a5143ee4878eba7078d684c12d54030d2d1b38c29938d2dee679e76fb97885e0ffe0b94a89c2b9766fe6c1f62ce904e52f368f4793f653ec696e9b10874f641ddf463a58897597902934adcff40d962caca9eca3b033f7024a7d66738aef681c2ad5c3bdb6a6a841bcfe3edf7ce69bc4fdd996d5069c2c49619602b4bd2ceead47189e1b58a22104fca69ef7511e9149dbc5ab6aa06523b374cb9406f4fa581dc9145471541dcdd67bed811c60f1b6330617180c89b845c979c28ce66e0c435417d0c2fa68938c9ca879144eff0d4ba91148f74bb18818505a7753e27849953321b8b9b9cebe5282f99433ede0124b15ab6d69a31777d9777dd7c28da71c6598c035a44147f37f2df3811a95df0923a0a09bfac9683c4bc4e616a4d1199d6125b52c94b21b76951df0462e37b4ff190bcaf2a15e040773c05c8a0cbeb9d1a19aff5fec6596c77da09e481a1d531c0a0d9288c66385d620204d49998b90e9c12e0c5f8188471365c2030f4d6c176e646b6bbfd8e997fb1baeae4d0e8309348c73c7fc56de84f057115d3ed36655a6208124af1965f7c0c06bcce59ff5b354e337b7d7b0f0655ea87676482b3f28df0f8870621a36b7f899dfab6eba083b3a64e62a66e18ba1d48401c7a217d5f748b0745786c1c764151e31ffe6faf1f9fc2a82281aae8fd9beee367387bb30773210a1af5a34201615d8587d3b32d0bb160f7f61c5b6918f8e3b126280da7b16f7a195cb28532077f19c1866f586a05a236822b87bc03b085b1d3ba7f0aaaca482abb2985281ee4f1773556cb3449ca9353089db14f14a2d6f0dc7066f2b3d61f6b8aaeb5d3de2cf9212af8c2ee70828234339db7944875cbdb5b06739a5cba3d0c32e8daebf4fe8ccdfea9eb4bae15f2e718f006b5a21795635fbb63a76e174b9a4e2cafbc56425001cd827263ff85462a2478cda693de52cf574186ea74ef44d8d913891d9ff786560cc1ea7d55725fa54e77ae0c0506aba4b3ca3e20eaecb01d4463630f133cb2f8aec130c8aa00de159c30eede898c0221f9b561ed39e5846341e91574d5dcf3282ee8126f2e7ea4559711397b3e02b57a099c453b0bd27f993723aeb9d59b399807ba976b7d27498de1eceacf6ab03fe27077b70d0156136cffbf608471dbf2164df4cb2126bc6462f56a7c4db17761135e7270d5677d908168a8c032a5ef670ef35182c055e844d4789680e817b48e179ab7f7122a05f6d904d3ea4a782a424136d7169c38612bb91f8aec0a850ab943b6c25bb7d6612180cfd359489b9ef2a35f9ad35aac5d0ba32bc6b2c362d00fc996199c38908c37a7c0783fa4f501bac635917ed47c72bf6d099e7aea322872d0eca945389bbf25f16e765ede9f198e7a388bf9c04f44bcedcc60af65f5e4f51509d34959dccdebc9cf06b443ea6c3f76bb9173821ea760997a2bae46142e1bf90216802ba8b8960f6c98c5cd316227de0f84ba5ad5c8574519a2bc178eda9ff314d231f840a3d1d59406042a43026e5a08b2930ec29da8a49780ede80c27f151be4f9721005b7df593ded4d1d74cbd3184c7c96afe6bea73d6968f22c036adfa642072967c8fbd766764d4810eaf69f11a9ef21d3598789fbc25f61e6ade35ad67dc16ea283ae0f4df6205a904136b35c702a9f8f4264fd2632f051b9fae02f0d2c82279f40b31c0589ae2196937878bcff2fcc71139ef9569669867864b1eb8a484742a202230ca7763f5aa4b3ddae346cb1e8d41ea5c7cdb4e241c305399ac327ac0e1ea26cd50e869bd9bcf4a07e2b9b97e16475217c330594c154b25a3a3d1575a4009b86ef51f8d1c707891082779798d31562eb36bc20f39a22d12f75466bdd00e78ac9307b59cffd5072b4487ee733363c338caf52b0c56968014200e4ca631a541f9965f76c4e87430c5402f022f97268bb26c8e47402a60d6aecf6397a3af2e1830b896d32f2be234ba244e2d3754f67406bdca82255c7fbb2b6bf60849820b93fcb05f63f6a0d136f6e128064325d44e914c94a863d36393021226fe2583dee518b33dbc2669c93439877d1d9c4d805a835eef5fedea4b7fdd0e6c6d2995ce41e9b9ea0482afdfbbbdff959a33e28b7352bc17d4ad0e6ccdad85b470c8b5e751fb35cff873ac70e5f62accaf4ef7cef108e597aa38f9e60fb59860ece7cc7b9f9d8952298cda89eb466895616863c269d0ee34ad3e675f561141abba45c6e844230e309c14dae1084516c1421f0231827975b2270ec77501a0b51c443b08557dc749b53ac574fd3521a47b27deb20912927a3a1c5c0b737d04db63004b0964e48c8f27e7971793570947f922e6a3a5de8d2d8e1ae7b595dc58fca3cfd1f859019dd50746f0dc819c06f7c96363fde3515be11198c58c0e4e05fac0e44e7d61ff39436ed99762706bd2d333c66d11b64715e0b6089abff008c69b6bbfa8f1aba2ca7482bc9d659c8a92a9ab82bc82ce9ee8c82617a67884c259d8bf534ab5392237cb183961b22ac02b92f8324571ad009a71a7fc364d658f63f52062c9251671a57c9078867bb9d0e528416692f19306f03a139d02d565acd4ebaf1e418741d49b4de4e24e31566ca58f87b0d0b7292c1280b8926aa6e675fe90e0eb63f3538102087524a916b052ad6d1848a2ff3a0647253c33a7c085099aed21cee3a8f36f5e3cc81668dfd36cd288eb46d731dce76c5ad8f657c76bd8c0f284d89314d3f7517abf910bfdcef2ce4de37866bcd8c982daaa8bb221166cd55d51274dfbced0b724f0058c1e0ca415d8dd39c8687d509b3c353f0342e14266fb7c4e6874a2fc130f11838fbf03e5d9a0107e542150c9cc2d341cb55333505685af7bf8e9ca694965a577b7da75186d33ebcfba3a432b1e5256b2e4188e9d11145c0e8e46563345c7f6a332f86b2f7a20dce97a827f0dfb41b1ef8b46316f81902bc2ed29aefcceb52aeee11fe5b12ba1ddcddf8cfdcbae6a85aebe5212586de30fd973a7d2075da6d952be218b672f0f9a2e8bc4f7e6e1106aaf8fc7de2ed9caba95cf0593b6bf64c310fba8d59b57959692eae46a67cf62bd591354e6cb262d938469557558f0ef464b18d8feb8ca38118ffff316e00003d374c69eb674d86866d047e043c1afb038dd4ef827198b65d9c5422931c9686587f71555248d45367544f8eed7ae759ce45d0ba69481eca4a4db957ef0f2b20c00b778fa9f681b7e9b2ed768226808403b36868c9d7fb859391c7b6ec78bf7a2675db652f5a081d7c6a904c30d866b6a23988bebfd5486dc03bc8bee532c7788426ddabfa455a48b5f12a8de1e14fdea22ffce712ff11a4c35005d8d9327c42d825ee1b624ef90cec7e059e7216fe1ffc1005c483e16505d8d03ece5ad98ef501d408587e55730943cc98acef1b61a07c25ff52ff5254585c77ead6776de24b5cd45fe09aacb2f67b40edbd5bae882bd6190b76230c53cf463c654225e61d3d4668ae15207efb1026bf479989a68426615f6dc770406ca617d953c72677ec3528b9009a103d226471897e27c787864389d7188899a83f4e4334e8b1d2619efbb56216f96d623d05a61a0a68efdf5c102851706fe8f78365013bfd799b32bd0b3969da1eac3e9e01e69d7790fecb70e64b2dc9dc44e2d61001d51d65435cfa3def21d7efc6d394f2a3f3295d24858e50cb5cc2fce6650b2406321ece2054703cc2880c275c89417532e96ac59840a92839a09b28f6ffaf10ca475f6a7937e350758c2bc206b39703574361ac1ddb993194cd3fc2cb3610d33f5223aa72cee3c261260ad60a933cb7cde69081a634be9b247906b4928db0ff9bb05ff804bd80bd9f4b7eae6dd97ac4feb5c1820d58701c5158090bbcaf2d71cd5097a2cf85b65374ec8581abd4e2d462dda8f44be7fa023284185509cab10d42dc1baf1108fc00a551a2f3b690c68f06bb5212f6232b4c859454aa5d20adb17391806718d3c05ccee8c7a2ef0b7d8d9f4eaeb45fbb3d1c4e5c3a041e68c8fb58b7c07d5258c658f642bda42fafc79074058390cebbe102e6c1035b288a44a76590cf87c107e1a5cf018cb600b37980be303f8c4518fde6cbd83b0ea5e8763574dc4955dba001fc1e1d8a1769409d02a922aba17f26fe608288e8bec002700f290665d6adf4b62a931042f87fe298db4fd722edd25dc22ca0ac2765204da390bd0d8a2ded0fa0ae6eff9cb75cccac1166a56df4e29ff49f9b51732043b5152284c85136444f4e779dba526f117c7dba346d72ac7bfe89dbf8c7bf0b7d9c38b983d9fe20735e20ae650a5a9010bb68060fbabd003bc2fdd2ce412706c2a86e3c3b52716fa566bc908d211ef3195b33f54a2afa9ceb38a2fdaa5a17aa410d5ca2ec1e67d75442b9df1093f6d4e4a8480b1635af097ea34c65ed62916a0d0c4b25fcc237db3c5bd05fed77ae30596e421e26b9320253e58a75596cfbcfa0bf6d6a409758f9b7f13eea67917763a4c6cf54cc82aec2b1ad71f6c6cd95d1559f78a4fe7ed194dc1431338f199998d67de6f8ac67bd55c312e02b95151443991f64969a9f4bb32d2c937f0cc92ce5b321b22678e11c6930faa64b6a066cf056bf7a5a3e82e0a50e5351ea2194f33d9d62ad137b305ca71ff1cd4f99aec973479fe5b02823aaa23aef959f83bb8fb1cd85780b7db8dfe3681e88954744a70449b455d0e2a392923d977b3be3b681260fc0e6d433dac0a4516fd767898885bcf4b564ae21f212b1b5bf1df01155aaad38a856b75b3d37c158cd9f8811c0877c08a452a014fe4cb16727c9aad9050a90afb19d53dcceaa0650b2c6d91048b2f8f339a5814ee9af3adade70f87e94563969d8abd630aaaf8f0fda4b3afa2e6d48d0c9446fbe3d38e41991064cfa77d9043926933777e4b0a9b588af35da40153195cbc55c2db20bf428f0ed218d3acef350cd89da870ab864c470be268d98e65f5a6bd7994dab25daa0f0eeddffc2e95f5c52e53f5a60a3916bde7b946d1d78878a6ff3a3dc20b96f27db7832544643bc641743d0e188af0ac6c2eadf1c065da9e40beacf603afbfeede01cd9b8d794c4e8f919a94509611803bdfbabdbde1d4c7e77f39b14c42140b4cabb44138854a286bca871b2b4b5b482605c3b7f82d3f849843110f2c574890fe8890e6c4cb415074eaab62528ac1eafc0b55c5fa0c815fe0c81861c8412f40e870c9ddcce19328e18098a9f9a9df2a10a24c821048fd011747e734f07fbe4d833aeaf9c7ec988e1a9c9a6ed6f9b9645ae8bee279615386191adba4787118f5037536f2de0e78298931ea44f51b8ae60fd7d43f37b7f26d3007ae7ae5da1d7ef973be36153aba19f1b0403dfcb45ecb14b87c067ed0d15a0457c4185674e2859bf92c8f9d519fd01dc8ccd50b762ee6dd8bd1f2685d8fdb30eb79ebdc02c0b1f442c6966a99cd20e5481384aaf5773fa1faa348e5230293685eba96d4753c11927f02a2fdce23d6c81060208f438cf5411434d46e0a162f7be506a32a2679112e3ee76873febfae9d0833d3358907f49fa7dd960a55e5484361da3bce82d7580b85e5819323c19cbc1d5f5477f230ef7a36efa3a5934590c2369b4cd8d2acf8d97e7d6110fb831466e554ec3f455b101ea050aa5a9c974bdc256900d644087ed6b448ed1b82797b776d7150bdd43bfa8a3ce671c3e257a0587954f88adf1d944a85882b4167896f8314467dce72ffffc9ef91293248888b2a3bbdc125dc20d2823c6668f247c9f53c20c2d757788ecd4df0d4e070e93372f07df6967e5ce6b76b2b60c787909a079f92f5467bb939c3d1a785118ce44b59b78b769b9805bd1ca63cf77b767df892b6599a0f41cce3d3c238ec6f6fe10e7ec16d35f8a25cb34fce261a22d22abacfcdc5ea452b5e11d87e0b2b6a305b1e1d8ed23f8d521c45912a647da805c1e7b885983fd4ed963496e8d985eab16349c778a6b8fd73bf1385245ea2969a2e7d7e131b7f59301b7fa8d74a0888cfde3a43f61664223532b72e872852d1daae6dc3ae0f75acac8676ed356ed39d4274687545954e713732bf60bfeb2a121d51854ce406b3c5dce400d97604e863e8908a66f0f236df92bc183bc07a19b35c83c0b6526a88238899c4d121c07a9602cbad26e6dc7f3fbc78efe1534c6dbf73d31470af12c1ec1e2c56037cb4caf28849da40caf9a3640e83d2e7961d38207cfce51df6dee710a518054dad95471952f8bd0cd4bfc7c826de378638bf7a21beaf881de8cfae7c5798b855eb3a09f6dd90e585c4005f76eb63e3fd2c8d0833a7408603b2b048d7799ac0b14972ce3247af13355628cc1f198c74725e9cfacd2878d81c83a26547052f9ae44abbf73948fdbb8466c7bc1ccc95d19063dfdca451383221eb04f6915a0fa6af1c920cc78a17086b3d25f08f6849efea51ad034a235902bc701ed964048ea61885b5985d11d06fcc161dcc88efc2bb8093dac6e733a100e03da444076a2e4e2fc57007044f12e987f9f1c9f68259916bd5335c9531621fee5d0bc56376b0683ff830741cf6eab4b0d58233d54fb39200104574f01249afa28598e7fe3fd2e4c224e28d325c1ad641cb3d5dc51dc908562cc97ef15ff0d69d9ced6c16d9bf48e9fde2732487c8a96c301aa5a24ab99d9396645426661bc7559eb437b47c9b3df90fde9795bbd2e7480b084faf2a33da02204dd56e406d9aee1a069b47d3e5f6d843e002588f9e4169bb1b14b549e86fcc57034120c3dddabf709250ad83d44fa4d801f5c41a77e754e560b29955f3d514fa0211b89f78e59a66c7959e5ef86933e26db588590e5a23b40ab256d08a2e9dcd44cf0365df07a5e97ca7ed8e44c57fb6f6e158d580dce4b3f01f0f94f4d6138c63929c77630fb4049a2cf821e488b5a2d1631cbd37016623dbc3f1d3d7c34426330faca8148b986ceb17224eea5c0fab26badf0fe8b9a90aa1dd72d582bb8f9d80fd1f9161f57838559bb4bc335a5cd3ff595ace0b6aa93db69d23eb5050d2e226cc2cc3de8bb2ff0d6920247f0d73b9cdf48d4852e76d2ceb1f9f6a7c6afd93641152bb78b1963aeeb46e1502525aad98cf5e3b97299ba090ffd8240dbeff2bd77aa9ba7804b18b96a9f726f9ad7c04331ea50e8bf76562a065f5d642f4ea26ad7fc622bbbd1a550f81611a5065364eadc028b0ed339d8dd62cc0119ca4bcd208744a9c5dbcb000235004ecfb91bb6d5e88583b90ed3deec816d2ac5c33bd331375f0ee1debdadd7b96a5f1624334595032ba4309ffea60a590eb94df3f5d2ba0e888b5e00a442039c402160f5764d42ba17e8017aae28e687f053a97969c4674199435d9a21bb194e1fcd273628b91ad93426aac60fe0bb98f74cbcd887f8ab48add2e94397de31fdd53787e8cd770588829f1457a47cc9cb1fdf0ee39188c0139342a679744c6da96d2c2ee3fa8d86ae1607b2249eacdfa66df81b6bcaf7116c72e0e79d494a64c2be6d4a640d8542a3075ef3d0a2b2be19b4ec0c1c06f8fc7f3614e3df8b783969b6c2b9c4463eaf2b92cc6ec59212cbea8210128888924a50970ac9469dcdf95d7f16de8698dd73297458bbeabcee7a2a829c98c6057dfba3461dd0644086b8cf806dac32e78298696e2d2b761d94e96f3cd4ff791037a97a2149b598ce925266fd49b6f7c02fafb72375db8ccb8702167f02343b04cfea9cc025e6fd195bb3d1755de3d072b1221d7c10eeaa8f9d43b44bee0047368bbdb6354183749c0992e21f591586b65b2f66fb8b85d27a381eed3f8e0c5da7b5b6db5851e4c802fc51afd732c1878882e2524eaca7e7d7f3d01de700ed9655482dadfe9aabf69bc5e8273c8975c4a5b155bd7c1c41e19a8bec2752115b1993c5ae648082584875241b9f5ecb1a88f4f66308d0c110b54f1eede7a70ad35198282430acb4d814739a2817cc2ddb794c80daac3c6457102b1f53fe437749476d9b444c03910bc596800f8257d46577102b47ed19f5f05a6eedf5bf236e8ba6276296e3037fa2c4a9319da9787ba9f450f42dd39247baf51dc89c27da542046fb8e7ae0a0e966eebdc4a5f23455c6312277d659a410755ffd07e3ba781ed5bd3631c0cffc01e011aaadb727e7c41c92a67edfaab8c71228daf12ddd91dbecfba616644ecde490e16ba22e2a985fbce6fae2db4edf23c2dbd885b8c0e25b007bc1f2e924a18f13cdbb082e32daf7bf0c86847452e45dfdd1b66970a3f9402df4d362e4a8afe81d8f76e17d476510a1e2b14a1cf396f249ddcddfd97aa010e8fe738477b36627660d229a7d1f8c3b03e3f2e48ed7af130e37c1b3f574566db04bcd7c801338ebc543436862cca6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
