<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4305560f8ac07ad11615e9bce978bad9f30405492e083abce00f5828a8ec7838dbd09b2937ba7c0aa057e7971cb07c90295b4d857950f5a1e90d36532e4db46241170e20cbdf422cfcc9ce086e0b5901894abfa434bad0044cbecb710eca61172f0dba727ac61a7ce2130334086d4a4d5219a92d3b9fa186fa25a34063a1fbfa24f0b7cfd1332d07d0ad78ca62c53ee8e4ecf2902246432e441351d2ca3f06d996b81959a2f5a0b6de103eabf26d497e6974809539986c0802dae571b05ebe9e9e1b5d29c0641f973ed68102a1412257c861429a1f89d253b5b7ffb57db07c5b7c0f498eef0b87fbb7842a743092d7684016ffd4913eb204e2e3832efdbb2c94c36edf26a92cb9dd5786c8d4aed281ce4206a4aa806958c6770681d3fa6613891f1eec9ba2305260c728f50e94281150ad8d88c4664dc330a36f4bab76e5e600bfbc2c86743fe7ff64247ebed60e34f3bd842608baa20dea77e8a0bb792c77448ad78c78537daea8c687fcbe5da6da7c20b8919b4211588839888c1337063b024907147adca00727b343c8c60fe078c7692a69f0c1d8c34776fbc415d5bcacb6299299a35ef5c6ea3976b9e8133cb16b768cad46b10e432a5b0aba8dab7849347573ff905cea5656a740373ea342a2c63e040f0824df52c459cbff04ad32e8574c2ad70f500aa827fc3556e2c59f48e1008fe16f79d1d74263cc87b0b206fd2e292a7960c78baa202536f491c90055167362b66477ed1c764ceea560897499521b6a01c68e0c9e2b1591d23cf2d983840d187c9682f2f5db5c6241f6c128b8bca05326ebf1171fb4e70dc061f8155423ab05dcaff534be155eaf4e5c0310cb4cc548ff882eb14146d7001853e4524eb3a73d6acee80e45e8b638fd3917ca92b948354bfa5810e4e11417e8303e3ff0c0334264f0f77b4ad19d7f1038d8742b299a1cb81f0a467facae8c04053080b6a892d20638b030e459421f6db0b76a014f26aa05aa13eb96244915d15ee51b3048309d8371c1fedecd5d066dd5184938c5608ab1d3ad137bb69dd4a932ef166ef8d03afda78ba75f98c87e71fefd56b8279c4e436d9e132e12301c91e001f8f615003faad8f77d7807a853de5220279cc5ff9efa73e7923511c75779b4beec8d2ec573c1c925255540e56c91ff8ac90a263c8542a7b67ab99a8cadfb5441cd5eda70f2656407a3c85daa3d2a49fa124aae76ae659b040f4fe369b329220344f5e6b4ad2324dc1eb1aec5b25fd00985050fed80f2984ac4c17c9eb4058b04323a953916c175eeb45413b07e471cc22c4cfce3d5fbb53c68e89892ad07abaf6bb58f9c5cac262e9e97231adeefdd688d0204b57f41484a5d1094b87649dd81111f04d0ac550b9adabdd105e88f2f23de02763a8c75c80282d09c8722c1e5ae777d081f5edc2a99feb95852db11827a24de78000541f4d92ead188382f6bc8d7813f7fa83251a6c25844de5d9cce98ca9381fe9ec85785c4d154ee631299ec8444d9f6f932863f6c869544988990465d7def824b14fd3f7a44282421a09559901236b2fc2ea5da42e932dad33686cc5988f1434d762bd2a4b4a2977760cae75e856d77bd9b65b2c69b7603bf59aa6e67ecb9b383a740e57ec42ac6c536dfb0875765f5887f9ff47dc24b3cfac20b4120a38dbdf1864d9272fff8c1bb6c392dc36c38aafd52658917b0863b69dac63659721565eed694fc7f54a2848a06befc4a01d4eee350c4de9ec5b009b91adf8ad43e0747fb3612de2192c080b9ae33506b54f9cff0c09bffc98615430ba26e89508acb9345801eca54c385c3f7829ad2af37946fa8c031118a83f8ef7fd2631bc6bd3b9c32af3f5e16a1307ea0fc2964c38d5a5c7855900af46650ec8dd1ad1a439291aedd5799d55169689f344f4550e7ab3b71b329880aa3fe79d34948599e38d38a2d355a1eda08b857b1f8ddeec3a0554fe9f98b025e2f430d8fec03db2aa3a1e7ce571af92e022c48ce8126177c6eef714ac007f23c58b685f477306a6a859935d85446a70a6afc9c468a1917e2527e2e8c0ab2369ae94d90e6b344851ea2a68ce8a3dd8e65ad1c5395931576c79c325849d43abc095e5c623608ed04d0fbb3499d8d2f1588a0f78895c62cc8bfce2d4b0b2aa0dd28ac817ec852bc65fbc6400ad3a8cbf5bc9175204eccc0a54b0119e6ebab9d278054b076edd4953b0918fefd8e879ab58c53cb2d29d19184a8abc25a159f4959c545d0d0e736858deb909f26fcdefa19b0f9243fcbc1a4b8639d9f8633826afb15d3e7668ff2c32aa6fe60f05abfb3fdce582ecaed1dc572cf8fc2a038467619633c0d6bdea4cbee72e9d5acd18518c0c778c065a85861efa7af72ce52634c9fac5036d98a710ead81df6534313b8272308f35f02b0b0a564ca082dee577135efb6aed290a8e2f7aea9df7c4bcfc9270c1f37e6ed0a28c293f1d8b0575b0841489988f8167a56985acdc678dc0a6f69085537993f109402126543beb9ccf0f15b1eb549ff47bbc02d917373e1211c991b4972232a62bc8edaf6ab20b2b8268659009d7a9861542d8f7f4efaadfb05f0baa874929fb96c0bbdc01e367c8d0c8b5d058cb9d4882ffffc69cdcc3dfd75a7e69a57e1ff3a55cf49fdb370c312a4db888f87d2c52690191134bb0536430f8258890b87f3f338c2c2eb6474649ad6e3920d1d38f6c130964916506e26158813d692be05392545409cebbd3a102ad7bb4d1146907a6c3f268060a821d2790b34d64585e19afb6054f09a7883c6c95c6f30d587f04aa9905b8e71154269b61ccb6b4e42110cd4647d28316de1c2aba91d26a69c55ded6954edafd4fc93953bfc5ea1141565ff19b3b358209de4d170018f25dd8571a738ee5b8d06418f3f772aa992e114d0f30e6671f76df6fc145d5d5089129bba46a9b06c4c228f91f907fb0c990eb311f46bf2c954f597e3cd3754ff2224bc1946a7d68c36fe74b7307c531a750cad9fe54a8aef7c661a46a09ea8b7b348a14683411adc61e154a799f26864263714bfe4f9c6f456174aecfcbb57a9e5c3e3f1663f069b3afcd25f6d3cb3e062326efee00532fafb6013a7c88874f3703317ea221fe310c10351c42d53321b2b9825992cdc3521e6cb01ba8e5d6eac055fd2d32a72aa2d198b037d211716ef574807f06d5112deee6cee44c5df34d457a1f559045590f301b01ac5fbe3ca297586a204757c1fabeed1426f44148d1cdac1cce3e7affd5d365aa1476227cfd90f429dd64e19ae689beb66c127c2d8cba9676ab49318b7b819cf895deab471006b9ff09f2c91af656dec3192d097775663308f71f2d7b6b3da40dfed057e2c01f7fd181476d3d797b9ebd953d2beb39892bcf21f9c768d4c52af8e0992446b755b3e8f97e3382be5aaeb855d8410fae2621183ce649228700bf12cc9eddad03161bb40e319ca84348f0bb838838dca570277b27030ce4c1bd3c5678073212c1d5d10397b272064b05931b0a5bc200c00ca8f983643fc7c755156729f0328777aa37ac10b7a5e6ad18f9d06c1a6e042b56ef328482129bb6f4dd146f82882eb4852bdfab747bf9befa4918f224819aaa418adc5a15659d4282d4fa28bb5f5aa59e878c30b77f10c5a66a2d9cace603d7b3ec93a94d5b70ab184cd28e8e676cc1097e953bca2322d90215b1137fc1ed178b919fe103a9a082b5803b0aed5499612aeaf8e81cd1c7a890f3aedf489508076729ef366030708d28a326ad6a6edd028c49ee7e8a6f497e06b8db722d5fd515db8804cdbb9f29242478d5a9ed7661396feaa438de038790faaf64c25ad69944a0e26c412220e7084f4606716d6b7c93a35dd5d7e2bbaef05b5a8fd2921a94d49abf2af4446f41b7654f33b8feb923de97c35801d720ebbe68fdb3eb2efd4dc683bf22e037d4fd64b9c490998d383d8f93cf23470b2b543b5850b9452338b346d2de2614d252ac791e1162dba89b4ce6c151c41f755be62fa3a5392818b27412ab54cebd8d11742374beafc46ecb2502b326cea94c4636734b6da70a7f2c7e8f8740175497905b16000e07e7bd4d66916d0805787f0bf6e2df9a64250899dbbd6012f4799e0a60e3de68bd2f122f5680f3998423dec05a1fcb55355c36a8e80fbb8e95905c9eadf7d16e13632e3613d189ea89d860f0cca22f9b242dbc01424b208587109768b54c28ec8027b31bd3d643c5ae4471e9b4f1d5015342d040c15518f54ccc563d0dd3ba58614669c55cdd2a399ad86873b81c60aa18de4a67d21450513e262bb393713ad5ea019194701273b99ce7c92b97b979e22d0e2b922488ff20a0036fee189e2e1e6f2f6af38a818c80ab73d7121dbd839a34bb1117a34558fc67ff92a3b98e14a32aabd865c3b11c70834e0380d070364a7fae5407aa312ab9b8748554a7ced4cb59952e64e33a778611ed4bb9fefcb82fdd491cfc3353b68720c9a1af86db78ad4af1306fcca282a73e8b019add8a0c9e928c1660d43ab0fff94f73ab70abed5589e39a89b305099b96c9ec1beec7a7b670a9495fc9b90236d460b529e985016e873def1c4745293647d532e3af2d82cc832da4a26ff4022bf8178ea7bedb06d8046d2512c86f8d767fe2de398af80e121f2ad410a179b3770da248d4437e69e4f4222316e5907f088a89d2577b7d2aeee1c07a0a52892ecedb9608f201d5bd8c7263cd51aba1e16ed5bf99164aae9a1935e609d11e2e34b85a25c3875698e3a4328dfd811be425ef03831ed05e0ff38e27eb0cf1b1851b6bdef3c1370a6fba0499cca9d346b4d5a65611dd18e1db994083bf0f001630924ff890b3fa8c427231b0c496a3d44f1bb4be4edfa8cef5c959c604b071af730cc7ac4f4f54fcc7bffdb63e9b18c877dce51c137629bcebf829428da8772dca2eb3334745866b575f70b46e87cd0236131095e738bfab189169d5f8c0431e61b6e55af884ee90c559a91605d117e34be6a5ce3924682435c6e9e248755cb66cffd4c3a7a7a9e7a9b4fd68f5871d730d41d8ffc5b31aad775cef5559a28a87b731ec5460d566cb1e078674d70bec12c4ea929c976fd3a2e41e5c754b35be6f04789f0b5c82d793e097e4844c564a63035da37608f70a6475f96a1c63f15f9fdb700218110d027c7507ed1f41d6056c359056f574d657438c21e670dccf25c9cef1a39a8edb05ce19cb21916ce01742e81460732d369c63cf796785574001589cfbb053917ea045d70bf35df56003fee16e598cbd04ec0dc683a3b78e31c0f1b81997c60557cf0185f4a356d361db442948461b0918ccffa9cc0f92ddaf64e8399277c8c5d29849f781da7e3992f9430133885a904c4930eae57f9a9981e3079c584768a39afd18523b3ed1d24e6b820d5b471fd0bd4d974b3b1d523821ec8ff1f02ffd54fdd6c41bb6f0def54b8647a4bc79e176a595ef8e2e7ac7bfc3fbaf4d65f77156eff7d103936ef85406257a0e8cb7820626b27945fd8bc34c29a11ba68c681413634a1780b33f9fa1e96d56ae0e16d201dfca1b4309ed3a30a2df1106a07fa002d68928f7aaea7dc07d75f13567dd2fb639199d376c44de526a188b338cf0d08a73c1ce9260cfaa48a6da7bb913f74f9b9c2c0293510dcf73f02edb90ba95f0b93b52e03f00abbce17038ff46d2e1e461845c86c77bf8bbed4f295d035130cf605c3e3f5bb6545053e18b6c45a6d12d8ceca6976a9f17ebfd142ca65c39b6057d83c3e28311602450342ed64ed3b56c826dc631c039ba22731911fe5af479fef915f81fe2e2389e743aba1483fab4e553cea7ddb9cd465c2e7fff968295c7d587edcdc8f05dfac47417a27c985989a1818c866a0cdc062e6346b562e09b7d2ae3de801c5b06f34b0e6f16aa45d6b11b0f628f192e207c1b2ec644ccfb47f3449acb40fafa35318a1ba997ca6e0aa3eafc019d302db9bf4aba87e16837af50d49cac8c242efc7c314395d2f7d8eaf3b36524468337a69ac9c9cb72b08056eccff4d99e4857becaebfb6b49e73bbcc0e3c89ea82a1030906cfa72c5006df9d700d42b600d84b4c74558f796fe778af4b175898536edd89d25b05ce93738b8ea95c154b04b461df75655c03315891bec647892494293ca5b2ec0860553812c20f4578ad47ad1115312c0c633b02032816a6d4fe42b5c9e1be2daa1e7b5a159b8101c814ec906b6d29d3787a5d87d20e746148ec5dba0b72202508f35764061d3ffac5fc82002bfed8fb2da49a426a6885f29bf9abb90ddc18e61c0e61a35696d0f301277813ba8298207af475146c589a9f589b2e756d8950bcb28c75e8c10eac7439a1de01c04da2ae1bee9b1560ca3c171cd2a0e892fb6191180b6c31b0f1cb1550fa275842a07566a64dde2fe942fba20f949e255cafbda6567ce41c95a5c641493be1d7b6dbe66d1a74fd62c054b361671f3bd65e7550455463c43f9e5733fbc1ba2fe75b518d4b8ce07c2a327b7018f56afd7b7186e96c3fbc92f4e6f789d1675f3bbb69ef11a5736b76720b5d2ebe624016dee9767a5db863fc8b0c284b24eff6d73a0a7588b4a2125abdfac1ac3b4cc108ac0bab535e9c56353cf229f42fcf9866d277d0ce622ac35096f2082dbbd0d9c5723c9ec6fd613b124051e067755e6db70f16d772261eb72424d2ec727c57da110bb794de514d659193f22b64c501d1c12aaf410c63a512cecdcb8cd8fcc933d0f1899b5667fa9bea9b3bddbce6bcf612180e17920c951487496c472e84b5528e982384080cdcc095c6040a9956b42cf9db0770e924c9abe6edffb06970a9db615e86f7aa4346afc4c6b32e82f29b739c6f551d427242aa951776ec865f7dd43c6727439eefdd8fe5d6d5f3c4eda3d11cd3236b7a295c034ff5ba01c013b2f8599959dec9822a6bf597098b9718a7e11a82ae0226080c9def16a7326b6c487758ea0306988f807ee43aea2453e1dc6a0242878d73855830f6635fc6a2ad8b226237063068fbd1cd24b2b560841e4d4a03c0f8bb3ae676ede25434d69bdc192b601a15f3b83ce5f71f191a0353475b9afc151d868e0a9eab54b0967d69e3b4b196b9d6a7612574060d1aaaa8879d43b94c429a5b2e090fc78faf0be1d25423b0d39b759b55c073c50a47e1720c3be17821e70c780afc3543f870b2049d269d82b0d95fd96a8c43f3d019506f527dbf601c4f666ec466ae5334fb5d1cf36690875d4f348bd830ace74bf9ed6a4bf7a199626e62c8a04767296e130a4d0b713d79c28f6a83aede8856e588e25ce48a8c7f249f31dfc772ea19faaf3eed1134ce83f44cfa3d288d9aca4bcdc59c638632a88bf42cc44d34833eafbf8c6c685aedb3ecce4c97f1b62cb981608ada013e0b846929a478fe6ce63759ba600507dfdc4413e9613a137875d924826949f742be78d9def04ae80487065ce2e1b04f358a81097241d619304aeb70fa737986771b1926fe6ceca889228c3af5e524b792c3c186358282ed9a2189aceb0e47e645a4a73e2ef7d26da5fed9b8c2ba1212761ac701d0dbc341b5e8a22ac1523c71bb973576477402b950e8c0af6e8f454bc67a034fa2e7945b80b33edb84f492b70d25747a9f3f432072c3a1c8ceaa234f84e10c49b86f7e081ed5aa593427f0f9c530be268cbe26c67f8b309e3716e45d31db7d969581c95d97d1195c3cd129ad78f09829a707272629770b7a181685931dd59e1fe64b772b4e22f69f92575b23b5f4fe9dba19ca2eb2418df1cd8bc87c16253dbeb08528668120fc17c0c9e2a7de2ed5d592444747e355292b63429fbc05236fae2803194713f674fb84b0a5cf3c4a3bf67207aa6055839c4fd3646df4ac2cd925c372bffc9e44af1545cf5e6ddf68ad9f16e97e1c7e4c774c4db1ee14ed9f5bd4b7f3a85383b52d18d114caa0f996e5730bf03c772ef145f3eafc234cea76d36795b22ed81e65956d227e697609cd8c30bc46963bfa042cc18d2106debd1b627a582c243300e783bfb9a3e9e343eefbfd51f9172c259d905237397f59293f02362d9cab5de10a607e974ab46e323175a736aebd88adbfb03f98202051f432cd3a8698e9693e14ef7d59fbed1a841743afadce0422cf6867f7c8a5af7242364bf294063c5e41898177acc8d7f0bdbbc89e0ba0850978da5cf529a4b5abeb6363a4db1c113a7cf495f0e73a31018beb2d676a4e915262bf5e6862aee185cde2e9995a740ef0e45cb0521f77b9f9c7f4674e57440cb8f5566d12c6f5af6c083eab8df7aa03c988aa76559e019ade924b24e3fcda954547c536fb94272631b0abe9a8064e4fb2fb70b11f6da68d47d871d347a238fdc3328edac711d74f88f464eec0ead0bbe4ae49a363fd22ec56c36640cec3a07e811970b89d9b8e7ae6301317283a5f2093b5b578aa3a1edead111920c755fe40e74401923bee3c1bcbcc23871eb29c6b64625e65af301b2efcc45768af1c5d7bb6527332eb3cfa7367f86f0cf99f40222ebc4c2e844fc01a47738f11b7638fa52a839916065fe71cf2d440eb6dbb6f94934bc8a500dbb4ffa5572c31dbf6317590a0bfe2ce75121c3e11ed428e330f8b1e2a6301891e315a42add3f2cddb6e42514ed39b7b25343d034e86e5a7bfc1b3a7ea31f3b51099f60d39e9c8c87d20192006301691fa6fcbdbd96e9ff76aea5772e679abedb492c947e3114fb7277e92ece2cfdf9cbf22563de3601cc1531219ac456e8429e75b015df6df598de68d60178c9406ade06b470d76bb97d4f1ad8d427809112fe1428b8d2b27ace6b5827f8d93235eee632b44b02f19c5d944b32021f7bb799b7b805b5b4e522d69a7ff7cf5b17957ab7e5a96503a680b873c07d191d1458e53c63377f2c8fab4f16a8c14806e9d6e37a393b7797b1a83c497bfd13d2b5c46bfd78e035771b23794fb6a6db0a34cf9c950b26150070e5e7a37007f083ab4fcbfdaf664a246dd95c8b3aeba213f0139d406cd515f9937539983dc2df03ed2fda6e42062506e165867a5bb537f9a0b0b12f1858f63760a6249cdd07f0519a76e69d6056ea27d94de2ef04f8de674ba7cbc54fc974914f701b4c3e513fe10df3821cee5f81f4e8ab117f524e6a07c4567614210b54c4d6dd08aa7b5d0c4ed3db2798a6d1b963e06b4d7a9637b37f6c6c5f02cca957e451a45adb090c4e6c77dbf339639ac9882c4f32c349c74c4a22aed67c3a9f2c5a790859cdbb1ae4a68debe3363cb0c5ed218198ae488959be3dfce4927e2b447a518b1b1b79cf461472c98a612cce8b4db13418c88e31ff1589827cd564de3f81616c214fc18c82c027878c944c450c422a7bd95f01eedf41ee62f6175a16b6642afa6fd669311a26d41fdd99e82b53de970a76d1b511b841d0dbf2598c2e87080601dec2b97cac81698fa6864edd11d0d3d094288792ea06b52ff5c798c9aa0e706cdb471f582ba3224c3e222ea2efd01e6f617924cb8c39d6660c78030e4fba15c7e1ada78526d95eee4e6728b92e18b8ee623fa8d0f2ad9ec4420bc9f058b08916de84edf38b3f28b152481a3d8dddf8d5025479afdb13ae20e5729efc4b8cb5b74fbdf1223e964568c23f6fefdf7712d50c6112b85c4a07259f44962c45c9f2f4c42f97e8da41ec235cd0f698dad71e77a09f60853483cb2abf3b33ac15f55d9143cf7c0990d86dcdd3a5942feac2bdeeeafa4c1009f72fac971e0c818967ded6e1cf920e45bf9d1f107ac98f95ec5a1be7e8892ef08c7e71d90560f8feaa97e134a5b6f9e41c9ef346eb5aebcbcb31cb414a4a39f2442729e41fe3b1444e45ded06d0b93d65c15025449bd4d516e805a40fac101ee4903e5ac89c528431a888b4df856fb1244d3b568c2415a90e5d7620516c1d2c388220470400c45930b5730669f5e8fd639a075c0fc366948d484336779156ddbdf89b8734bb61f40f411f7c7425e8bd27ffdac2dec0a1ec642c75ffa09604bf19149f5882fe7b7506e34fbce403acb4af6ae005a8a069b3f99acd712de4d8249229603a3d8421ac527ecc3011607e14353782ef63d6f91b1550c548fb562374500b5cedc4bfe7666426940b35645c375a7c7dbf3bf61598b28e46d167fd0ec124ccc85e47197b9fac6070344ddceface68a0e4e6d7a3d7164567ec2169006f89e23d7d7b2f7d6b2e73942a7f4f6139c8139889cfda2055a78ac722d3fe4c7867a8f6a5e552745c05874ed3e3e21836d30f20130e547879262621226ddc07d79cc95aaab59cdf1eb90ef95b6940ff269ddca5af826a1b484e442d69c7718ff0d9d232158f0172f7ede95411b9377372a9421572a2098f5ddac6303b99918f673c8cc5e1862a1e02021b3edbadb3bc0dc3be40742bf935a08b1c914b78949b1df045e54d33087f49b9b9e707a6ae1096f81e6e67576fc249089e8b5b38ab5cf0afcc47ec3e8ff8514afaf847e283fa227bde8390534765535da7070ac16f108460ebb3c67750524e3cea646499a8bbc7b37295030d63ebf26dd5c3927498a852ca0d37d93f6ad3dd6740029ef51c84a82e1216b57a35dd9e81d0128e5a468356da4483217d1db4ffa5c5ec5c909088f5444deda230bfa63f0928f24b07938be9b772b3e6193f97b66bd2ad90b8fbdf251db5255e7aa4c347c58d23f33e3cc8ed1cd1ded533f3ee1b22008604a5141c41f7fd8de3d1cedf5849f357304b3e48b19be18c077aec7571429d8f5adf66f4a58c5e477161d4eb5001fae5057547151a1485cfb4ff3d4e6f42caedd8f6ae5e6f5236f358fa01246fe4f2561707681086221a3acd5d52694937ceabc314477e1b0d47eb0c5780b10b3eb068252b00ade0864dba1a63e4d39037127843d445eca1a756ac062e7cc149cacbef6bdf8bb89aacef5c70aa12ff3bd01a068bbcd1c7f146beb637246c1a128102f149aeb47c8cb5fc4931bc56d14f172a92dc76768e408799441b27541433c431a4885228a5302df480e515ef3e1d9f920170f0a2b513f03cd1ec3f6082aa322ed4be6ce80bf1794a5defb71fb9d651a615273580532b762c10a30c42ad9fc7134ee757b0537a14658925c918e4c8ea7b3f8ccbd1f5beaff635aed605b2946497dcffb811483efd77f3d4bf80400281402701ea371c9e7effd9e7f36d5db3cfd594b03104f66fd640b6244850c007ce4e0ec9959e02927b92c04f75d67ecaf3fe3b45ed927234df4e23adb5ec67dd15a438295181593bb4df40716f3f9d2b14058a78290363cb5350243b22b6917b551ee559c1e35dda8c9b3683b9deedab201ff74b2d2b6aa8b9df09811b9261f20cfd2f354ee4bb4aed7e47e81772c66c5c8f9d587e0676312a423396b48266308654e513c98afef621e99bb298c2bed975a7b0bf0735f2487659d712271e15dd612a33791c8b89afe0a5ddc014d840d1983dfe28e21e7f17e84fdb8fbad442704c8a1ff047be752642fbc72bfe99cfaecfad0d4dbd5b0c3a516c070eb7c865f6f3e277ef6941f77cf2836c92668a80595d1b9f2b58491169eb8e0d1e94f21c7eaa3e30ea8f2cfad418c1dc490fc73630910a0bc89abef8adfe41ecf32847fac314e442909e428d97b18ce2346e8c51555a6ef253169251b193c8cf858d7c484b85ca460b79ec1a769648e660c7e97320355621ba8b7821eb8b4a9a9d160f33358bbf133af06c13ad4caefc5f139bd394de9c9b3ac14603b0c222cce9b4ebb52a5a5681ade40f63c7dcd0cc17c76d3bd0d41142b8c9eed10ab2e7f5585bf741ef073967aecb7f3a3751e69a7668a4ecc5f77c7cc784ba8c61d95cb75682c8f64901d3cb640a5b8fda619cd354c177e51c23e1c9fe27e248a68e283198ae0a194fc8e3982684c4f4ebd16e73cc097f30505bd84dc33f74177c5f53a67a17ba7bd7936a1ecdfa207ee6b5a9e48256d60683ce34030958b495d08338b369f295aee3f09ccdfbf343b5cb55f07995c8d3cf976edc98c287f5d00bca5fb62935426356bcd67afc3fb3442e3b42a238e0c09fd71984aed6bbaa9a5f356ab9ec4788b1c74d0c13968ba58c20802525800c0cc45095f11025c402c4bd8893cd13b1f730a6e34a518403cbde90e0f257cd8af3b977b94e703a52596a537bcc9db6b9bafc6a93a83d4bee5be26861facda63c7d9ef36821acae2a6141c73e7c052431c43801d428c2ca6a6e16370006b852589fc08cccc0f908f94c3524d08a08f4bd9f7c531545d38c2bffe972bcd4d7c1c5fcf8f1d63b91449a0592d781ee6bbd1f2ac1a67ebfdb0f0cf4c030d766afaec4862bae78749cf203d49e5bb9694f468ff755ad6067ed1f8af43031287f492f6895954f66fad44369c33831ad634fe432b48db69b88cf13b0bce8734070004eb81a2415be68fec25f1a5628c2389784624544c194c553597d9751233e5e0e57c14450ab82b81fec40e727bbcfabd5fafda72ad2401b8572a661621d741053c4fb81fbbe7fe1d9c7822fed4aa0bfb6162fda6c12b1f98bc3e9570af45a5cee89088b073dc2903baec9b7bb914cea5bd9976da56cc6ff952446f77254d4db9d407e601730b6185f5c3a5e52ccca864bd33a33271e0b972e878180b2979425dcfa675a7013c7ce21280bb19694328e117a13c9deffb98fb36dc17fd9f3df6a43a3ab4d6fa9d998ce1abb02c947556bafb01caffcab5acc578fde21dd5b6b77aa64c1112cd51febb187ad444102b48b24abe19591089f60fbdca1ad4e214b48f3aca43e3c5efa7ea11df5b4de1ade5cc5e07266d195b4315508ff751c947aaf3c3d92d30761ad2b79d2f2a19048b10e01b580107b80e5130c5ff5a7677f7f7590795599fe9f537700fd3cf0d3f7e41f1326","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
