<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd49c73d177444d3b933d911e08094f015eee109ce910b8f6258db3ef92e4213a94afc98473ecb269a13de785fcf467856005ab3720342bcc97dc6eeb1e1bb49b11c40889e92c6736d7c0c4adcaa2b5b611eb83ea6699c052ed50ecef9eafeb2094de7c58626a09834c80331a8d1e55000ccef2b705a4ae5a99fa43ed7263a9d8886c140eec661b3806fb6c188d6951a46e2e0339b9b1515654f12fe8f2fffe812433cd98e1ac796f03a11c2a2e317b4cdb2d1f3369fbac7d03c5a19a24ad047ba53b9cba9c1d85a3dd8288fb27358887fba3ec74123f8ebc3c598ef2f09c8cbfb168038ec14c5de9627f91e3e9cfe6c8a2790deb457bfe14255ae4ff0040ef5c2134e402b7c578514b8bcd05195ce173ea450db1add9b83a5de670debd4f1a9e4fb74f3d2a3cd4b32fbec9e513d12d7ffac70a1ae920c67fdc9f8b5218ff27569aaf7d3b1db1baa3c257c53b7ebfff28734bcf932ac563da211cc0a8fe2bfc121e3f21d5f234633ee3f9d3e9dc8a02e48c08198b8a874b0b09a9d98def40e26cee55540df1f0ea548f6b23134a1024eaf038e79be0d6f6713c4b62c797cfb7910325625ce64edae67614cbb2b46804e99d166b83fb7b20f3543995b49713d7c2d31c966b172d30514089ee5eebd4d70b2cbd84103817b9089378dccf749f053cd11019dcd36339c6c0cad3655a14ca10318a56331b786e96256b5ae87ff4ca74dfe8cc29b7f75ed5e1d4bcd7784ce516a20130e36dea7f9740141b099451a309d20add0d5784e2ad09908d83a008e554c5380c4782ea97c019a6cffb87d49c9a78d49b0f776f79110a41e08485f511cc8f6e232acad23e9c27f93850273f552bf4e7f46d0323b601dc3c74d7f245d54dd23fddc1b74d0c6d89e01e32567dcd0f1f446818e58963ce26e2d687d2449731b865925018448f508455bb4a1468297b359b2ba3608d00633ff7a5ffcb0cd9f18f13e20a69aebcd8336a6d694250e5003ba2e9c034f295ca03a478b81835b809f330d674263ce0e070e000b23126aa7e3d85e3c8088fb7e0dff00e5889258b76bc29b69270d99e849e9768e0cf27fb55fc922c52772031446715480ff94c2331295c53bd5a2b2af9d4f2db02afa5bd47a0a021c9c1d6575b8023525490926d7c0b4ff42ecbf940ee53f726b4712098b1e0d278cb8308b475d9066d1cf6061cd02b096649f2d6076d9adec3ddd409f7bd08ff3b37f3b37efda8ddaef5ffae481430475677452bea9c40003069c090124ec4cadf26196ff7b271a97e172bf566234cc452c8c216c66b7b75e79a62a37353693338717aa05f4dc9db7599762be17fb9353753a9c93a07709c79894c4f1059c71cf88593c8453ada203842288cec60d719ed0c5d81d3627e86b7689f64447b3944f05eff38888f410fcc633cd5c5a2474b90f2984c5eb4969612a265235de77dcc85a8826227cc78655626a1b89bc10e8b17254a51ef7725932548846e49ca5505c78aba781e0aee7dd3cf8887ccccb4201a03c85af18ed3e7538e6792514be87f50c16f7f0e962fba49a40795ac2774d5ae76867b4d53797f87443537f90241aada185b21bf42d6b0edc98dde80fe5a9e81518af991ba7aeae3da7e74ca07a2abfbb6f5d56679e12d79e93447bd5f9bc2291be05c99d15056bec24d0a296bd6ef19adebb266cb7729572fac4b41cc4aa008b99ff0ef9aa2aa8dc3537d391eb55ba8ddba650d02da42fcd829e78ddb8dff9c4d38431429f33cb455fa092b40edd707e701db9aa84d6686938a5df3d60d52a440721fc7a488d5814d07d49e9c9793cd9adb4ae428b0f241527674c5aeb81796c97a46d12170f61be5778e260b4500dd22dc927db17387c3afcbbb65785b06ebcfcdb3b76c89e698b8a6d20cda025f62a3e7c344cc663eaedd98ee5dda57b9bbafac95bef358e70f90a55bdfd63eb59456bf00d392007a54f513fd85bdcb391486d3fcd3d6d2f2d9aad1faebdd7e65b55af3e751907fddae468bddd2f215c3c2946730e9f6c0080f612d26b081042f80220cff7765deabbf20d154b69bb9037c2f96ee562dc0fa14790e2b216c9ceb119f4a08d29243358dff3678273fe2cb4ede4140eb5ab64cf54ff86e1b68b996509eba129b334f074145f6b962190360779e8c311bb846696fd0d52274dfa6a1b4c919d9c87b61ff6dc0d0c5577253bd3a6c62b136040024c35cd5c4836b885fe462ff6cfd5799aa2b6aecb36a9e2965ec5e5d68ae8c13e03687b25e7cd3b0e05ba4647e3d767272360e319978b0b4755720a60bb8b04e4853c6b5ebcf52589dda3fa72e39c344341a4300fd12526512468154f90d19aa8ac5ad521df4985a0806df11b856e7cdc1290355b6d3d9531ecc34e87ff640d686fc3a50e227209b71c5968760e4548e00bde094d33334e568790164484a3e6014304295ff2ef0cdb1f0fff0487c1944957f529081b68b431c01e0792a90dfaaf152e3c5bf4065df955edb54bfb8ed054dce1685bfa0cee67060e62929cf5aa648d88175ea708cc664212be88c88ab59443a263118e152aaca1b587c609e1c5b7ba1bb1ff66bc5eb2203bb21f63e8d1177eba0bcb3e05d22989e81ec1e99817e77f44c1dd916367f4d4bc6838c0110d411bf2408f65a8d3b42640a18b5a564c9e6d0d098aa0e927d4d81625ae73796ea865809cb444c2e4c3cdb9525258ccc0af21e03aa0a9164b67c2eae266b2cca6aa7e51e35ac441569bd0a83346d7676fdc2d4a3d8985370d46b099b280918dacf36e2e5bf7fe35e83a9096023864b6a9cb6d3169f77f68937ee2d4f198edd8740d6f1e58f38ce2d8db0aaf857c7156d06abeba03d6d196d1fc83768718816984d7a38f99d0da54eba2d8e216c1fcab2f57d8d1d93fd2b82f9f41fa9d0267a38896b7b5722b04163bd73b5c8d2c87d35a82bc27319d67ca29e5b584244c24bf8cef929a5a84b8791f25a41cd723efb76ac757d8088cdb29c2bf1fbf274e8cd7ff0314b8adbbd392f02513bbee5b95f1c490bb2e358b5c2f00e7be63130ced354fede4ff14532feec4349269627b92a4a4d846375d2be92680cf916d5648be9c7f3bc737731ceb90e9899abfd2becad80ad09bc947736465c302da7bf46db553db698e8d40b6c593ac2bbd456aa1b92a18500db0d0de3d24ec7b7ca5599847790d146a3301f69d245e3448b57bd0d7e3e2f38091324377510713945c7c2ed7fec494f1f74907c135155086d8c519ae46998fb552092faf13b01bcf3fc4b76d7ca11bcfa28f77f649d43f571252f4734f38f67ed157b8aa6a9b0ee792cc0712e57cfdcb8ab3f8e1eeac3c56418e49ba1549e5613d619ddae97f07c882f26e022cfd348194fee80ba899a5e20c2a8281eaf9dba69f1c5609b1136356e0c53c70c5905817212f826d9751e2c2c093350574d0386c6244320cde53516384d34667d9daa6596d3623a7a56aed79815915544ca79fbb286f2db08253456b0bf3a56c0557f58a962433fc723f017b6fa8fa351c9f7e8929da977e8266115d909617ed3aaf3626971b5bb441afd53fa031265ec0a3615d91d78d2d77a007478e4fea0fc1064489994c609b023c49e8f6b878650099168d1d215a005c2999bd986ed75b5b467149bcb02672d62ce9b27a0e23d44609b8cf8417a23271a13aa15bad09ea1bc28688f455c74deb0cdd7fb8e08894a9fecd15cfab7995db01ef6fb5cb84ec45040bd0ff5c19350248caa579941d1e4a86481b814f2b3b30f7830eb53fafe6a647fd28ddd6cca5db94de62ccfc019ed8bb84849524a4116999cda62ae8814a5460b382da1082b2a9d7872a0488efa4e67183a81cfbeed879b05258701bd45b60342f75674766dd35696054b0a4f0e4cfc1dd71054cb75358ec6aaf5c377e34a9a0ce951a671b3a9abc02fe7b4c264b5cb0f80da3b2f5c0fb83816d274cdc301226100c3980389a85c5a506cfda45ca43fb9dac9a64dd8ec6f76c3c39ea88090a8ff1a17f14411f59471f2816f9b57d9b2153e1a91ec15895a791fde7bb33103b35f05ce957640c2ad0361bd8f09262cdd89de6439faf5f9ddf830b3b628ea36d3346f851186b9a353b95f3cccf9976bb70102b9dec828d04e06dc7a3e3260919736e000451eaae76ac91b058e25a24e38d47b8307b68062ff797408d1e4b51203f558a4b669a5086afa873480766bcddf8b86f533a12ed66c34e613d75eeb8cd7b250187e0485cb9a8241f84822515b014a220cc701ab8faee45923a6719d85fdc73d967612571540579e6c457107c24f4627529646fb2118801415f1c5d79e1b29f162473052a04eed1ca16c82d489eee2bc1038188137e85f573f694680dbb9f32997d4f58127ec2b1b5c2c255e5dae4abc5da6c111ce83012620b29b61e1f911c4451625855016dc4fe3f58377f9d9327a3cbb29f1ea47c95d94841af619d5c7bef2632dc461c5af8d51e2b17c572a687001568aa6568ebcc42dda4fc50458eb6ac6fdb57d9c31dc97ae37a785cab41fb9a3eae6f1706d41a4500703321e6a98fe55b4a5ac228d1948e2855c76b432b1c9a5de76ad3c0ba965c70abc6728f2ee7899912ba1e233dcd672ff6c5847385603cac6e2a9ac45cd712222e799b70ed52427530a06f40f356ac5066270328244338d10742873ed1e9b5f933708ba1d8d3f802d186e979df533fe908b2a1fc7fe664ce786595875effd6c35bac944f1775f5ee3b80d7bcce9efbfee2b65563a67428227e9b0efeaca0aca5dab65d1331d768fc86a778377b4bacbc0ce8a514cbcfb785060d0400ed466b176785b6ca5e55e9379974f7da2a7207b4709542af2ec5b33adba6b586a3ccaccf2ebbaabc58d3380b2b86f3be62b36dbc6a865f354f5788e83962e7f2cee391197f4191cb48bbd97835ff890ef5962e4f1b7567639a51911ada1bf3d360c2b7c4f7b9f2992960a500eb91a37bb81fe79f99034fd77b29cba1a7f77c8c4e091fe2d70bf9b50de35300afc3a9a946795567945f79402c01d8277b8b83c3cde4a47d8fc4df7596eb15febd754a1a152fcd007bca2f6e0a4753745fb1e7b0c8039ce928f1ea8633ddc2344fb6fcdd36995556e7303c4386731aaf4a5ed862d9c8a14ce417d621fca12b8f7f065c944ca78f8a8ab7885b7ef32a5a5cbf1e7d08b0ab74724ba6fd28603b078aaed9ae27c3e82d840d6bfc75deed5b2af9ba4e6898b12ac7389530aec6deeb6425797ceceaeb3def4e238c8dd702705d6c336babf04f1e57e66216fc658b8ffc3d0e67ff662cc64be631b41b7af79faae2d20206da6238cfcac80aa203dbc8173cebeb5864d35d143117109dfc7bc27b1a2912bed9e13ddcf7ffc0206615743fb32fe9476131934aee37543bf6ae58ebb008cf7a951e388d654173499da33e92f052d0ec8e1128af210cb75c73c20969499e0ae29017c02f22257956e3fcd934f4f0326eb738d2469202be08b943681fa9fe5e4bcd3d4c0f8ef3b846d348c09c9bc109e07adf8e666b137398c31364e18bcbe20601ee0a86194ab382a546c26849ddb15b27e5c4e151e7bca673e1314c842cc8cb609c7c20915d547b38dc7b3a1eaed9974144b6ba84f1eb6d53cc90fd3ab9b93f328bdc54bf3fa89f036f687e0380087db2a5340436465babaae001f7ff4fb6faf3ecee334be78786a4ab08bc3a053923bbd63b95a7bdcc0bdfb957c72eb0a80605cfb7bf1101a93ee2973811134f143c88fb8fa740ccb84c1517ce91e6268bdb124a00be6a06c91d8d42a8ad3a56e2022c32461652af64c0efa92ec80b6b091fb3f3d4d24f6153b2b98b285eb7340f7ab8fe5c8643fb6b8d75a3c2ff95587c099d2010be6897585367d4da84328061f53371a839533b89877b5e3b66429ff953b1c8c0bd0d584ca863497d54cb54d5ddc541891c37dd235a0760b7ea00edb7470b69a4a50b2998d49f7c1914b6aff2a429c5db88dbe7ff6b9c833137e07ecfe15d9fc7f5be50bca7c64e3595dfb243665d75e8f615eb88dfcfbcdbc4a3c6a6e782a9898fd9227cf7bdb7adc069e62484c7e939a3ea3b78d568945457d02fc42f087ac8ac890a96f0d8c98301b29d99af6387def4db39a0a9ecb0695460a1705e70c538c298ae627f13e62387808e2ff05d0ccc08c61673812179b757d9133bcd73da5c8872aada010dba6a38af62eb729c8a7607fafda9b3c44a1b36dd8621bec0a1b39474d0f4e47ec3c19e0c450df75f27c6d71207b7f81ce7c5047d12c78383bd701affc9f3808d7775b2b229a6a4f5b67177c9fad9bdccaa131eec9b5f1af928562db53978581650ed29582b90cfc605df8d7b155637c71a6689aab60ffd7bb8e235a6862d4b428c26adc79d3c87084d3900a18b403f98aedf10485675c6968aeb957cf4c842168a97f96d6f29ef0a2a40f69064f511eafe70e8363cac4c7b005097e379ad2931496c53156900afbcbd14ccab9b59e0103a2f565fae29df9085adb85cfb5a6dc2f421c8ed152c34fd70d04f7bfe02d53b92c4af15f7a97e36d1c1155c33fe47554a6a554cc3d8d3d0eb3d459a7a1a4dc277fad6a52fa19ae13ea80e2a99094d49d9589d903fdacd2b07d92b864664128b116ee041f219b463af7af79f5856043fcfba85e74edba438b154688d81f9d8b62231f164bd9da9cd1c330bb948400063c6ab02179256b4d6944046a2202923e1b3a76ef218c81bc59ae4bf05fe3f923f84dcf830b8081cc9a46f0c67db944065dd0115388355a66a09394f6905a8f1cfaf2c9f0d65a9a5bd49a34ae365b88c03d63e3ff9dd37b244227097c8b033b743a091e25d9c89c32d757a88f2196d2d47e397be2ace313d65cbba3c53d1ec3a0eda38b521f84f71e50e932561293cb3e50bb1e51812d09a94821e98db40e0a43fb6ddede234ec9e7ae46691692997ae140e5aaa38be20eeb2dc5b66b9a30dbb636b0f993c112a8d598a3e2a53b04afbd0fdccf6d71fbe4e4f2608c53c9d1333540486d4de14f3b6bb4f9c9d7f620b126cf5ed6ebf0716d637f44dfe5906da46b007ecce06838a4b441b55da0db58f87b9edaa73adcfea10320e5a02fd8ed935171b2cb5f64925fec598050a57bebeca994df2034bdadb63f60e4ef6632342b352311b76cc42f0689ef174ec21fdbfc381444c22724457bda8061f097ecb2a5c1a762b23dd29439fdd1e87e4ecde49befd3d17aaef64026d31cbc1a43518183d1e91a37301edeed0a2b5c5093656dd96e7ae4a71b35d80c55b8a1378935cae0f201aae97b32f6373652c1e1851a3dcfbc26765cfc4d7919c730be3e1381a649d601e94249374b5f2bca7209c7859fc9dda4b3b37f6724eab12d74de3670ba1f3646d1c99b5800185ca4cff600caa54946c7dc021f916cc35ea75ad9abddedf16d66c502ca9f743d5df4f8a4fe881ea95720e0cd5b7506ba7b8bebd0b4c1c166cf2bef6a0e7c902f07962dd3a9c20281a1aab0042fb05005cb160ea7abf358f3a3891e38463cfdb2c5a0a2d4ee07b0f1be83eeddcbca30d623f54ed760e008bf043bb8126f375c1d07df99d3b5331aaa66c167c9d62de5baf355f4e6e86c02076e88f0e119c7fed4d6032fdb49f92bdbb83d0a07cde6aec837895cb30f74fb3f71c70ddbd713b4834ac78e53b1125351836c4461b3e321418b5e14aafdae755acad8f1f335921c353c192a983255a05141284cb0474039abaaf7772fda416b21d0fbf001221579c23f69c1ba058d015b9974a135dc3ff3c408959e162c8a2d50296256a3db34a497168f44a49e8ef3bc59ae6f9cba0cdf20f2c2b92a9ec76bd967214e4d5442942298e4a13094cfce3acc42fd6e13ffaec49229ad199a12e549d4600c59280f759a3ebb2f3b8525bf1c0e39b44b644ebd0c97f61b441d1818a09d55e1179c733286ca8ec076e61190e5329f426bd15c89a57d3d72a389d3df5e5ab895effe37a89ac4153cbbbe2b09ef6b4a9fa972a8ddbd4d01bbf23d5b532ce0156de6190f3f82963c1980ae88ee9501f3dad5ad91cb4000f250bd65ede6685d5507e57491bc22bc6ea81133281f23b081d053e341dcec8f5e6eac1f6e29b5911b36f51a4dffb80c09a5e17f222eabd38bbb760b20cd3e21a49b841f72b0ae5a87154c0145da97ae70debd5db7af92f1508322d02506cc01a6a7753b2a98996f7e11f98b3aafd4665c3a6698e80056f870cc4b23eabe36bb1f5be925cf5eabb2a5306581fb17b9575e4d0db6c25d64a4d6bb06f9cf47940fe70caf45deaac2137d0aa215470c25cf363de5ece327d9b19e154ee974d1d3941a370e78a96094ba008f5f61cc2ce6365e14cb08ee933de7d15afd832462f0de0945d2e1522e500b355f8e64b3c58d085cf0b9cefa00cd0c3e9343af1b9cd874ee998eecac483eba359ff8ea6f052e87b39c1840ee92578b7b155ae8008550f40b7105320263559e57e90ebe99c1cc5a449beda8d38b0e3bf60d7e458c3503ad2106771f917f0de7cedb58bb6ac9899e69beb70531e6e07fd149b15c147ad71baea6cb15647b56e6534aa25e57e434be5c86751f21f0079e566083776d48612066341512da101450386c7a492ac30bedda4deaf00cbaef71b212109e511f6ef51c64774880402fb76bdcb679fd443ba9649cb9bfe9f3a23d0326109856cb77e59b137b42df45794fd16607627922866a86795824098ed3fab932d218b1201819673a02f256e3b09b6a021bd95954f7f556f3b34f8fee497ce90e0822b42b37c5bc80b38866d07529ecbabc5b7026dc2d6453bfbd9fa0f5a9f8137d9d5919f532c05bd32a724ed72b9999bc37324c85ac640a2e39c6c90df00ad6586dbf91c61206b271ae05f9964e0054c2495aafc2ff704df15d1491efba8f07711e9f1cfc9fdfd05554e59dbe4048cea665b334e23f9aca3c8eb625be4b663914e6b1a1f69d504e15c02541a6e2abaea4e431debe53713c4b5c06c4b125cb322bc88e4c6ad4faadf759cc530bbb6259e05aee8ae07d82fc87321c427067a2a22df0ae28f23ef01314078bb5b99fc2d60eb2f33b35951bf671df3242721dca8f189397a821a336f18b7912ccb6a3612d6ead5004ba18ece52db9abce44a17b4fe623af574a88a0974567b5d83a41ea72862168399b5ef4ba0a08b9d4804a3b466c0131443e3f7a153cd58a68f288d8e3f538730cb4fe0a33098b396b401286b4e7caaf584e17f42a60789887eca30350dfb831478f078d4720f9a3d0f5b46c4fd92dd133f6349df03b05e52c61ff2477e72de80977d180206c83e7d20646fb5562bab675cf97fb24be989ccb4b92655167eb7ae995e8504566411188a99f07848b1820c148334883984f9ece3599d1e562069bc273ebce04b767b2d5b94c1134f8d6275c33f7cbb0c7e669258122976327ec4f7a4fc07eaf6bcb836da26fa2ce9badee6eaea4fc5d0932e81539ba58289457f7686c2b6f38dfe08dab97a001f3e27709b284cdf6da04152e457c5cae7d028c9d0d69c3c2e216ea5f38d906274f064754440f1048192338975f3b329beb2607752615e2cb06a8bb09e7136b09bae9dd49ec107c5085a4ed6dede6fe713ca1baad8c82848242ce7421119acb6a1402c2365a66f113309fa847d0151d8bc4782e353b9f9eedffe75aafe4989c35daf2fa470ec99e3cc8161348ec776fbf0cc366428a56f71561279b3ecd591c09ecca339d0faf64a6bacbd5f6834ef1a9b00cf5a5a664e4ad5327b994d5afc7f7d165c0909e6869e2efe7f16fbe4479f6a8ad706a0a6ad7c91478b5855df0b49638e2d3d82e640db5be5073b8303c504ab4837a2b71a452f7ec1852a410c52d83a52ba52c278c01e428c9fc558c5143446a1a48d232e1532b167d60255208c9d2e4fd029b486ad7df7723f878e3c680d3c1a5fb0fc2ced7b082e98571c11c0b365d9350562e9372a6dae8cb53bed94f2b88314a290fddb097d4d49a14f9ebba205c5bada7cb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
