<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28e4ca4653201fbbfacd017e8e3d64fbff0697691f093eca08eb3e1693febd5fb834ad9b7e9128a27677a63d0e62fcc03e7149162efac813b3fc2b3abe4e44f0a52567401edef8b4707a59ac0b4ec74e7651d3898536bfb4d538b805bc08730fc9483e026e67fe35f00a01a4b41858e27c8576382e623ac3acec997d6f0aaf0fe07587b2bd4a6f0e4a1a6a216e9387f06f1400f019b84c329cce58a8af6810f8dc931ad7b49c32a154edb13f05628a789ddb335695a516c8cb009c3c7ff7caebcb9d5e09b15f0dd5cee31c057403940e31740a008cc80cfed92073e878cfb159810c4a16e60595bd911e6f935068a0874cb2e32f86aea12cfa45d9c86456987fab5d54a0ad8c07c8f6e98980beab135ee42ac6f6d95533ee72af1ca6ebe69bd2809d67ed2e1ce9a86bd13404f66c8ece6e0e808303be8dedad9deec302e58b901802d9810b0cdb4d4dfcb8c0ab3e17192f95e3b2e200dcea1cb00836de1a0ebbc13542e4196d4cf41b05edde0c061a30ee3a0777e451a4d68382872892c725158424cc2bd4fe4cd8490857ac3ace29a617984ac22e3052c504bfbd6867510edbf987e61f57f650a4ff3a5a75c11fad295763d2fefeaafd29481a952eeb68cdf73038c4dc72d17b8c6410273072b1dd02b4862e530b03be522c6b04d0c97314a8ca7e39f7ab569954d985802c8466ee06ab9e783fa67a948997f4778fd223463bf259118c27e4c5edd4f7595a831c1a87c2536418b51b8dda7d3669ea2322bd09b5b20f03672370587f90dee8d71b1a8c5ef50b3a9d782238016bdb1e7236cd4dc7e8afd7905e707f824ad2fab246aba1a3373f65119c0d4bc35354e59bb6148a7a0ffeab95f47d2f8636f0b51447139929e7f54b2fd9011459b0fc2dc6fdbd30562ab065335bc7aa51e6cefe4a3000d8ad36ff888ba640aa07e056b1ff69eae742a126999c1ad00b5a28467c68ddd0efa5558045aeb7621c3216b2c091178460ef5ddddaded5719defb82330d4b80fd14f3f2e95a984047895a467c82f6fc9fb39eab897b069a6aae66e31a4aeb2bdf690ff461d081fceb92e0db2d6daae0c2ea0616602c34dbaa1a9a502badc089fa61731a1d7cb5138de2a7c303a281f6d568b6a279e191ff060c591f0f05a6f0619e8d8c1a528d4a207fb9fb6fe9dfa408db9ee23634b2b065d88f95ffae9829f24a8db09b9f5184043dbd700bb3e51e74a5e6c306b2b37e1c284d65b86a5b3cd06ea5bc2fd419f30eb727834286391bb5dac984655510230fd0e2b12b6c60ba7c4c028777be99b800d37af95f17f5daf34473fddf210b3ffe0af6eca9d046a96a8b382ec14a05c170430ae7d9ed5117ea6f73d87807e8da260085589de7ccd0d88331d71b7323d0a8413fbb4b6b2b78edf50dd28245eecccc9c44a79d7c74d95fe6680ac2e6ba762e709acf31abb9abe881a3966ac6b556471245ff2db8ceed86c0b560a6a85ff46659204d6ae929a5d1234b5e26e9d5b49172f191a714b413c4347e1bae562ca7a753da0e9c22209931267f635d181f20ff9bac296d8c71e07485350dead872ef753ee0344dacdac8314ce0b41c63ecbd2d3fead8a7c6c32b9ab1ba02fd2ad33ce5d08f925a8e875fc3bb0dab0309b284bc2d0ff0115b60cc63b99a89cd8e11c7b7ebd56f5dee7f9567c54bf08292001efcb73d001281fdcdaf87d767b30b9bee9926c6ad5b53e48061d918a6017681b8186011ab8d2d7723147362077a09008ba0d917c28e6aaf98ba2dd8939f552c7bf4be79d3ccd5464ecd2ca5ecff13eccbc883fc787d7eb10f7a7039bfa6818d77862825771dd8915a9c062cd1778d7edcacb131edea0c6f0e9f4fd861ab892b99bed663ed01e00efa98e55b97efdc522ced31c2c3db303b548b8be6e3823af19aab7983a0ad0e3b08636de740f32fe8548a21063b368f17afc57c3138bcfd3cc6d0812f1c6808ba958e3246f34c528c681a366ffbe8726045e92784b748ef7c66e79bd9d4c9e39183f6d2ad0a0bf38f2beae096f5ca50cf4789a8dbd8335bae1869b3cb3eb3d4064506982fcc875345fa36727d6dca0bf13830f06600d4875fc1f6d4d1ef558b36f35a071bb643e43927dd58d6332cd17c623e815f29da14362bf416b3762539d677ec22f21d381d84167c0fa3612a0e7870ea9def5b64ed2f2fa7da2bd899963c0042db82f2dff7f517d388fdc38c532396aa8eb1e39d91dbd50f903dd0109044fd2fa2c4a8579d472e997706cef0dcd2bc0ab1c08d515705818ebf8a9ec8c5a2a3c6f5e07936508a1756a90e9d8de439cceb8ff2818565020a10d2429cc1c81016d647039f96165af76aaa4d080041d9df9e34c7ba84d5ed9e5763305a23021dafc203eb21bebfdb07b4f0eb8394d3744cb5a8d65a3048950cdb1725168331c8ac9b09e33176c8b68aaed30965237fa28e3b7067bfe5c4b626fa90a83dcd17eeedcaf6dc24728af672429cdbf90fcfd3f734679d5800d00dfc2daa4e41155bc3b397b61542887a5ce55ab5c77a8a8338ab6928358ef889d5e78498a6938959f2a85870b5c8dda298a5ff4fe4fb405b1b83b6aa76274b17e0689e2f0f78b74d2f800bf68b97633b48bc8fc34efcf196ce4a2a39e7f67710b006d9ace5dca8cc2e2c351a4df2e87bd721e0815da784c08a236a985090d4e122935525f214a622f4d37125379ad862bc17e25565fee4612a26380f14947e6873f4bd468976f722d870268637412159720c3f8bb200ab0fb070ef12cc92f2fb58a41cad55ba4365bb22936b4975f5d803aac399b6873b30c898784bf409d20fefedcb62b503226e9a42a291fad67d4d0eaa8bb3f78a415f1074c1e728db0b275d620b1d8db20bca515812bc363e94a19a718d9d38f45451a5eb01e04626e5201161010ea389747fbc4ac328e21559dd72d840856aaf16edac910edfb36bf7f9eb11100665389e0ecbf99363871d112fc2529b880af812d03df0ed99f1ae9893bc73014032442e0050508399ee6a88f1b10223cb6d2b0afca61e0efc0def26c415fe75f6ea1af270a68f54e58d0058ca23aa11f7da2579c7bddcffd1d987072c25cf1ba1b2b0cd10a9f28d0036947a59960745d98c08ac1b94d7146d8f986e5c054849b7749e0c8c1c7ef195e889beb6d6ff65badeb959c563fd9300be8b5f29880192792e9d11f81f0f6ed41bc55b93a46802a9e25bd7d3b043274a63c787b2d72e84be3f36712d61a64e52471a4a26c6c7a4cd07b1e3ff3980dc5b19ff1145caca8f1d4ff7431d77f1bc64cc0665534e38116d4a85d7b8ce0558347d823f461462a82aa04212f20f123ba26488cabe39f41b9261d83ffd3835e4d5f82b5187b429a81fbd8413b56817e848fb01880d82bcc6a7a8fffdd8142923435fff957f26455c84cb9894e30da2ba5afde04884a9e9a52b5e27ced38f6088b6206408ef0a2c86e2c1762fd28e64d2a1793a0abfe241332eb50dd99a4d7c08465383db87b41cc735c670987f8325528a65f8ba6ff2fd0331499de2566c226e066eab234578fc818be00815f1a12785230a641881713a0ea49766d1c74b002dff7571d0d1abb95323696bd84607ba7c746c74349b06a10aabc1534216d893ac50bbee8bee6d2d350166e51103968c5e8ca739cced36af500142d9331ee985235f9e63676c218f717f389e6a1c2f6aef57b1d42b1d9c471f683d5153a7029793c5cb98f1fbad43564379d0fd40c6b49a0fc6541e61bd92e0ffcb59666571c7b30a0c70be48c31f45f6c3969c4877aa27c3e46efe32f37290bb433e88d49ffd87827e3b8db3044814c9fab05eb119be52e7aab38f5a7ccc1daa4ef18921a04605370af837d3a32ab0cf9766effbd0a1a591852aa26166bb973afd7277d7b7ee8ffb7b628537bcc06b9d85f8e992863f96c1f301bd4a2de8f6ee32e4d566b9173a0700a1e436d54c6aac579c33100f2342697a314a4d913df86abb80840db5398787a45fca2f1385262c2d78fdc38fa1600d2447bfbf815a59b961419b1fbbc5068fde6e752880a33c75187786b55472ad8dd636c36238669348d31981b9123f51267a0536a90dda0762924ec49bbe41e1dc3c0768b2ae6e451eb7079d4a6a5d2ea70188ba2bf33279d2b52d24d6dde85992c20151f1f4a659828583e50b48fe994b6684d047c0ab8376a6dc3a311f7fd4d8144f340bddf03917e614808fe949129b1036644106e6f059a2be408b39b6b9845fd4ed7af84953e9ae4673ac9735595f9dff759003fa1d4fcc47ae7f18d580d0026ba52d8963b9f85f8965fd0c18bf963d34fda73ab3141b2f77f3b421f4aa6e77f9445fbc500e320fdfc80e5b02c0d9c7bf4a0efc01b5d327cb0316a7908b000accf05b4432304b9b09653c8f7196057a012c221ca7abfc97ed6d0a7eb8ac67ae1776e467d0896a6acc2ec3f316990dec49631f3423f23df4eaaf6a834802d70aa6adc3244e924727a246b556c9e93e9ec824929baad71a943cd7f7e0506d0abefb0a61acfe3aa7a23563d4f1bfabdbe07e2dbc207d9266048f7ac3786f64660e5c79a2e49822824ec71963014e1c6f886b72fda452dc5afd2ab4a6752e5682bd3110dd1a0163235ec567a9ab638af64f5bb879727f5bafe29fcd458f5054370a59bca5d7f90b68a5af6a14736dec4ad770e56e4ba826ffed8f55d8d1979653fc29512eda7931308ce9ead5ba5568223d0adcd2d3c33c44b79c835512d108729355548f9b44e674798f96935e837b24df042b03f237652763eff4a654d3e4dafd3ca2d06c64ec3271c944b90f951c4c52182c7f489062c2f47d7223ffd04804a5cab72078423a591f645e67627e20a78a10e4df44d7be416518a2ab74d869929c7d0f8160ab1d54ab3aea0bcbdea0a567e11f7729440f639bb0183de4b15e4489135bf2e7398d31a9f960e3eba3405b481fc677d988037ec4732cdd7623087e71965f4d9dad3fc3585046829ed5afc432a055679a53262bb5382548d5402cf8c162d16cbc3de1d0424487f02f18f4aa0c9bdffc3a037e70a9f9af1ee2255f3e365da97fd36a6505b693c3230390ef1f2ab0c59deeddb446b2a064359262765dc960d14a0a17d68137ba1a09ffd5c66b43c6da755b2d313b7cb9bc32fbaaf86aba387f8c29561358fdd7b870e4eadc37a5d40b407fb48e148a440b7bef7bcb87230a50580db50ef8460f679e7d24bc7265e98cf071ca39c303b2b76857f6331592250c42c06f963f527bbe2648e0601f6fd1981ea32aa12953bbca640159d7d1d0daa354342bd4e4a36d806618db0ccea9eb6bcfaa21a7cea96ce773add2b1d0ebe8ddf9a3b4d2a8a0fcfbb0cfa82e95eb01e0002c0a35e36c28be946d22f273c2545dfe5345d2f72bbc0e08e1aa4c83ec8c10acdab7bdffc1ee2d134b747f700ca0f35cbfcefc994e91fdde889f0106447b861341c8fbfc4c357cf295e5b76f3096402e2ea42079dadc6767cb29d6db030736cdfb40ef6e5d3b05254f55578b353989c6c39a9b2f9b59bec990fce7389f53029a8e9fd2ee5f169624ea2d5e9f06c4ec17b3e529540f0c598da606ef39dcd5d543d8a7a9b5c921a2cad061ed878f82cc2325530d54f7054ac8579bd971964b7ec9977575598e377a28cb457232dfe0b09e2b3f1f6cf77a0f95c80f54659ebde4b4bccf5689bed8dcc63ce47f083a5aac4868f103129fdd0ac7b77ddbef0e693acc5d05636e846a67d50d7ecd5ffbc39f989bdef5b7a3ff58b4e750719454b904e5f4f8b2be47144a8296c04624aa386c4ab085fc93f3bbf2c96d46c6057431129e2b9bc624edbb26f966e4953135c2a1866e7a81ab06ccbe61d048ef0cc9ffa1f6292fbe46a9fba61c8e97055c61ef5b9c1b0eb94982162539bda23f63b4c30be7f06e0cb3090e29d75a15542a899899d1b98a07c0c2f653dbedd3b861b95c88e9a8341da474f4eb5876b4c3bcba787589b91fa4f40cf4b39bdbd6a631f064236b2ae5552708bf435f6517f32f82591f3ca0f682b9d08395b60fb6eb177e8c461f195047098ec634838bcd87cfe91fa406ca34b9c8b6c2c30de049c0cc1556bfa8759c1d12a5b46ef774877de50d2673327e653b851de94f560ba6da9cc9c85aab1f0b1277642c1fdc4f82ef34722c6035eaa86e187d46d41f8454bd0c223ab3806b99cf28791388fc6856f3dda90b8b73486b8908566fe995f93b0d9e14d1d2b46a2b432c3deffec0878a32ba61694b8e0efdb8b814878b66f1fa7fbe5c7206ac058722dad56388bd9fcf388c71fd20cebf4e7e89c9f72dad125b2793717985887a821d2928af7af74dd36209221368dbd897ff4bb0fa9845abf1617661153050f00405e66c897e807cdb05ac8edaced140a03200e66ce31efa1cda4a538ecab4bc7f5b6a320effb9f78282727e60c0a074f3ca2f4b287b85faf1f26ab5bca60a419227414c483eb1d7a3128a3dfe1e0a2dc3cd039d8572d3d105c844cad1dc4be96c435f15232aad4c7ba95edc8ddb6797b19fa59bae5932e72ae549f51b147814a9f6e86db4fc2e662f5bea463c7bbbf505aef079dad54aea52938cc3986a729acca661e60a3263f5012c6762befbe23c668d92c5a398cd066bc49cb77581a49621caf0f95e25b89fd42fd55ff8f5c7b201f4ff7a8713ffbf2a0d537818c50bf626ebd493bdd635e5c736919e955cad2ff9ae68ce7ad2271dc8442f0bcaf003d0884fd1d92e8784356ef9023a523c31156ef83498b3fd8523eafaed8f7d91f0cfb6bbc686df27c10f82c0d538af22726093d3d29a1703f1cbcb4955038553f0dde94973d4daeaf19b6ad57e0e36cd72554eba7d859c9101984d531a5e2ea25a439ec57717abdd4461df83a3c5a60c9ff5c7ac1954caef34ca060b9270d8a2d007d31e0ecdfd3bb6f8f04cf2b8466434cc8c47ff2e033f21f6e602bd81985e37b4a43996bd632c0a63cae4b6504d048f2a370719ffadbcad61ddcc373dcc7ac7166359a8f8f1566a23dca79ed215f99ef7cb23a882590da16ae01133f2f214d0b1c263a06ca9fff184b9cde8c8c90d8c44c5982e98bfca3d85a98ccb9aa6d2e28e9a94e56d7d3064bdb8d69757b3ba5d628aa2f4516de66a322bd99feabdb8c7535ab81f8bb9ac12dd71d6c4331bb225b6cc6630d144937680841ac2ceac87d136a349c5e942aa6055bf6187a6fb3aec2a8e4e19b666ce9aa3d5577b425ad9749f25bfcc192bb8a13bbaae03b5fd7c128719823cdd3616b964d2bf56c026cebfbe00245a683047be2f6fb25feb1f5188335b5aaa098865317330477b57a82855580544fe71a17b2135f3c30daf5c95e34dd911b61ec2c7ed24a95369d6f0fc5c6c7c67c406c1b7e2b57fb7f290c5ac33246f8d52de51b21978609edb2c75e802911689a5ec49317cc462ca7b285df0395b941f4e73e7c610d4ddfdcac84688ca53a79b49568beacd41fdcd21ce51510708e858f89ec4330a5b046725736f4e7896b7f9e2328ed6552efb311274e3a823ff60539b6f01f06a250fe36417acfb997cea03371002c814c7b49d35518e902568a3190b8f7f928ba8c42375091aa7e7cc40769af596508f97ee336c38eb95176dc420e15608f63756f8b12f9069dfce0a38f4bf531e3c56c75dcd3d3ced361d52cc55df79687cf684f1e63dc558868fc45c19406836c5a5cd8eabdee58984cf907fe6ed513e2a9d64b90b0508daa6173a40410900bbaae859cc766f81f454fc0db5317841f9798af9e0edbd1465b463c9b23776e5cac37a15c767a3ba61cb922e97c7d88ebd92f5a1183b5b93d3fd3272f6c9bc7f1a77f407f80ce929663eb53a034f752d83344a19718e15163641825e85b40d9015cdf3fdb2ebe5a7c2fe3df77427f3f2fd6a16ce1e32d4848cb369ec5c9c6a2d038a9ecc22fd0a71c3a7d7fd8e7fb88e0052408a5a1204b34c9b42eb1ecd9c609b3e933c0232bc17b264d14cc278c8ea2b7d9503f1cf2c7efde56a9631667ac650378d0ac2683f16000aa5ff34fa9e3ef94c7e189db02f5411eb068330cbf06a6c497a386ffeb95df9e1013af80d796a84bda6aacbd4a9e73d2500a97afe5309757e82598670a7f31c3cb7de2e0b3c233bd498e205254b99d6780062a598e9a18811d711f0bf1c64fcf3871517b6a2aca4f3511dad81f97bdab110ae4c6f06f7ab1c4df53ddbdeade45f55c4bfb5565a6a233192492548009ccb13a8f08246a5f3de6d6407d76a47ed5e7ad34563429554d1e4e4a738285bb3aa1ee012027a0b2542c7cab696a9970c4922d278b1274e50f88df318e30e5dcf8d385ec66863fa684196230688ede230efe16ada6baedad439fb9bb1b937f224194ef6f6626f4ccfb153d62032fb016c87a29f680e75fd045c264fc71147ebc1d0ba736afaa3d1a50da10541fe1b82bbc36119e8663df1b74b0e16cc9d94baef905a3ef0e2155bdd0afaacebd4fcdc2be42879533a80c0c7af339f43d51da58f38e781c859e22ed9ea5708082e077aef67e657828ec661bef941c54e9505676e13c4216a395f6c9698d8c9e077c08e0ea671298ae8be124b22849b978fc18d0b05cbdb073801f978dbe8cb9dc6526db0efac00fbaa12aeab322cf298b71e0c555932425dacd4bad26f1488171c085f72b0fa885ffe6c5724ae0d8365e5c35295e377e67be5ebfa6a1929c08f1409c92f8e62a06b2f37577dd5b15437d3391b2f8b7084b5a0ffc0e8a5c7e9c44ac20a38ae43395bdf2397ea1eccdc1873c1721dbc7c7f363d91feeca918f6a89d57d98694e3fdc8f5a29b19afda51a85ec9301795cd55b5b9b3be219dc1f9a803d678285a4591f1e5d004389053fd16eb2df7ee96b565f9a0fb2dbb1dcca77c626776a12116cbb50956838ba1e4bfd27505b51614e3085ffe87cc3988ce326a490b574e54123a1c868e4a5084159925709cf66505688364341326b86680c40dc0e777b345dc9764a40b9cbcfc56a8ffae3c94f4f01977ea569713f6b0ccebb6fc16187943c1d4b5c7df60ceb46fb7e703563833b3e0e3ea0023e99ff51ebe2a39cf1dd6843dd5f65ebda395a09bb56af0aedd7e675b2dff1d6df25f5122337fe06f6b21f2458eddf55c073870e365f8da23c85a0d786bdd3cb079944f96a5a9add6f4bfeb0962e704c7732030cce27872bd29d00b9d921a4a7058226ef9cdc1bf7760a63f610d06a567eee2c9d88027c0a854a3e58ae14f47190ccb0535c4a4beb93351ce435190de6fc4aa4a6bc99740ee92ba4851d3faf3106179268093d833a1fc9496cb413908a6da4f7ff9c281cef82a82c6d4925405895445d1b60e089e8d7a14c4cfc301a6497fc913d044a0e5b5af3b0c8b9101e63d4c2509a129c944a6fa946ba972d71aaec4aff4a156acfae51484d648600204300ec2731e74c8f1b3c012c18ae67a1579d04dd709e6a2c318c5dffb9e86ae54289018d6aa5e76c6dc86142f07dbd6a67dccf5c4c75919a03d9ae4299d66201cac731135eaf48fdb4e7b9b5b12d1f35cec694f9817a5840dcf1c951210eefac745d8dcf7b4b6808ce6169656ea99e61eb0a2a3c0ce4dccc76c9c42363655cec00933f4f308cb6e45f8420173745559379d9484bd9f48fdeba3c4e8aa5156822f74fbbb7f7f77ab08c58e98a5dace676b602259ea4304036b43d7b91830d3b07c14068d93116ab0bd88bcd00265bb75139a39bb5703765ca04584aaf753f60df707fd6106115e98040b8fa9dcf59acc1eb4173ad72ba3cda510d7d580c83a4139ca97ad17c305e98ea078bdb86bfdb93237ad7e5a3ebb395a864d81288b599eb4624cdefe35cc13efa8ac5572eafb233b3bc338e9d09d2f7e64736a007a8760f3a8b9b4fc2fa1ebfa5a401e3f60b83675ec6d8da08b35c21b38ca79f26124477bf1b3e1989fb63bd0016e11d3126d88e2df54204283817cd45e50c974d53024a229670fc82187f66ccc9bed2542948edf256f96119c209faec0faf013c1331993cdc20be7f1cbab2291ea9925ac6d54a9e7a8e20ac197332183909bfec7ed267eb77ac9499d9d3af8a5235c395e1a84d47fee8518fb81a819b5099686f10b8e5ecd21708a3ba9a656944732c80f70d1b4e8fc15384ef105f80e5bd59ff01c9d2669632b77122727e269a2379e23722fe24ada434ef2457595a33426d0bb34308b7d4276f244fa68e4c0f9ed978dbe99009bc443e8c20fb5480","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
