<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33e44382e07a1de50670ce9f270307b02fdf2ae2cfa060d1aadb368f9dcb44800481ee10ddeea52f5fbf159f755372a35f333a755f33a5d8d02c64a98a98e7a52d56174d13b6a59c20dacb24b64f29026e9ba9eded1b878218ea51261511dc8824cec695d40c5db02881f507d8b3d9b09922c8d05105dc6c4006c4f06abb4ba66b3ce328614654c944712006ed33143200f5a38a23f200d8848f0fa3c414af5f110f230d55fece53eced845aaa9e670a983b2ceaad0bd856ccf0309bf54703ba9fe7c7abc15a0a9c192cb1e23d54a8b3c06e855326644f815f7eb3560120f3c51c3bd3a487e40e0f95753f9835e236b9d65e2421e4a14ce56b9419a9600e3a762069dd87543b3c7c981ad898b331be1f37894fcc32bc9c4b40ca5d84e583254dc63ae26eb716cd5934d39b3eddedf54df8be4f688f5b3e9c49809c6c15d1ad4b85bd99c17633e2becaf31d90e270d685baf4f767af69263cf7110d48e36a33a60946cb7967803bf73a4e36ccf4d66e7d1f511dded4e096ed21377a01f877a5c0c68208cdc2a5ecab01433f2d22dedc6d2c5e9ed07d30802a8ccf29e227ba952ea34dcd8e80fe0497b64762f79fa90e63b10e902477faa1e4b93731a197f57407026acd62e40ef4993d554161f3765e05e2d7651bd870ed778b1d591a5f18b728122597be737a3e3568d212994b107159de58dbc8a5fbc3d81348294f02fbffadaad1cc5bcdbfa345bb9af268e910637d6b35975d7407e1f917d35f194282d8070997521393141c0b8d2723493863239ee6342aa6faccaca14cb75a722fec6354ad79741746795e43048e99bf7d2c9e3e05b4ed24dcd25a8e78ff39ef89ae79d75265c9d2b82f30ae8ffc814885ea48b333f9e65f438f033e533acc7509011866c4850c98bd672936800e50fb5e40a7680d3182e371a6c8bcde8c276eccf2de71a0dde7128d5157ed43a3d1ffa1327700d6ee171c9629a9212e52270b17a90e943bd00cfee3b39e5512327c97e773b21d8dfc231c099777e37a378a5f62e5523a91a48fb9bf5a2145178371cbadbca3100e7ca223df1368b4ef6586dd281a78c50ea6ab9c8af24842ee135aa399763e0ec07d33c04bf4502e0435378808fd2b9f76693eb9e1d388b149119cc64cd9be2b265c75fc447d9cb2b82368561b79070c95c76bc29199f1d50455a181671c29b78732eb18e67f15ce6b63a346cf884703cfeb9ec83a6b56cd7277a69616c04bda56e8515fb96b6fceae69d5dd3b1563b25e9b2f28da78c3db323cb774ca3f128eeca48cbf0aa754d98d8c88399678275ac4129abce0067550de28dbfc787a38c8c8652de1401f00b1475c9f3ee74efc4d8ce3d8cb7079679f8db4771d4a1ee071466d13533a3c38fd07ec3ac9c40036df20103e02dba32c506527c0795a76ed381d08daad622def124d7f0fb3a5db9ca375e9255c449c36ba837f344c9b2b7e76d0afd874a2e55807ab61e48954055fcd47fb804d9f5dd9186d2afc81e7b9123aa383ddb56bc2462f2da07b9a5a8f02efb0bd31b0c35bf0c802a2ab57233b5a69dff6f846c8fd3d36a2f1742febed5a1812787e4dcd2385e5fa3460bdea0ac6361f2bb779b45c02d12e7560afffc881309faaa163bcbaf43a1a27bd69eb695557d91968333b310ff048552895d858fc9616eef6353037ce7712339ef4c929d75cf8afe5140c1815e7029f2393165235d543e260bb6891e7d382fa62363f6dd306dd8f2d45287314b6fe36d05959315105151d3ac184c138c388620ab5cf9d0dfc701ae21d3d90eb0c5a598e1f8b1b842039de9f28cb9a11b073adb61d5a88996f9dc5ff2d85b7bca49f1b7a59c7695b586d2905a850210e53a7ba193f28ecb25c2d55ecfe9c4f15ba49314cd0a083460b0155ca10578effef91b6cf43ea8677e005fef0bd837c9abf2f4a4cce2d706d1f9ea81526afaf4272622e1eb67f36330526bea3d1defb05f212b2b963c15582a05bed4168bf9c724ddaa24036f52c4c4183d3f9e852b4dc426a09584d2a624633a761a53c3ec1a326e7e80f85643c1aa4fcf1c189fb9498607f1e51e2bf776b8aa14ed79152b5e8bbd25f7f196099ea5c8ef8066c05b432ab0f7b78764c4c0e1bc3881bb29743ca8951474525b1562828d1f17312c9c7b3a09c0ed2f438f2441c7ba233ea932b949d26ca1e65401596c2080dd60413c3df4a1f021487ed35b530219bbb59f18b82681683d8a8410fab121bb946749c26974fd08994cfd86b9ec21c2b91a18c97270682bbc5c9dcb628807dfa0338c40f08d1bc6f7ab8a81524bc13d4fe81e4caf336640892cf9c5c2da3241bd484bf9f65d7b51b497c4f5add640761d945e5c62dd64ada33fee247fac714008054b60f85e6a294f25a503f4b7bd93ab5ee8374480176fe79a566eb4bcc9a807a204f32ce964100dfe7b34cebca0e5b96aa87f9917283cb203de28117835a826b6b1b0e7f1d0723f2aae8d61d680f3f8c3068e3396ac2b497d5dccf937f4d47c5f5c98554ca26508f9b7422d9f2df27a22647f7c0d0ef3754874a4a4ab4509d420ebfe642c78d83d7086ea28fde020ac606cc6ecc4bc581ec9ac1799bae88bc2bb3f1f74116815608ff6162783cd0cc932e2651f7b198e3f8dda71405ffd5841abee36d2f9e4592e6b426c480736166688b667a0e1dca00a49ff81d1aeae776ffbc0a50ca09b966c505564a6bf87a15b9309cf4c2f0cd28db03b1b796ec8719920421a4c77e3a8b562cd0a2ca7f59626ed1ca8129982ab99be0cc28f61b5c4554935f264848dad2edc235c5e4e1109aa35568e1a4e3acd4e14fdcebe6de1646608a71945eca09e560e30fa6a04e46769a34ccee7adfcd4462b41c9924381de19116525f9617cbe6147ed96fe35252d1ea6c8399e72329f192bbd05598e06a6921e23aa988857333d637980bd8461b6f1679ab8fc6dbffe43546d368fe809804f01191f3dd7b90c0faca000c2f0e134b1468f87c3f06229dc546b00980befaa96303f8040b8f870da618c69122a95ae433e8349cb0c719ce2cee173d76ec33822a68879e96b90c2e962d02fe029a2dddc40cd62e98dd79de73462bd9e6718906ca5265de92cd456898c607a60faeb9aba9440a7988445497e59afe5ccf1f757456a36551f7d533ea6649a965b2a928937e0247aef0c042ad3e7d43f7b0fa9ff2cc6a2dd07269c3bd9b9530c2abecc5a322ef57f0c54250592913627cbf19d94870ce59c5c45638955d3dd71fe221edc71910b954ed4f810d7d7b0f6719fcb420d8e4daa1732a42b7907ce710bfc4a88157df28a0eb0faf05ebf1e7449bcfdf51753aa6d2df13d647a12e8021e1788c5b46d673e7d41e876763081817b31e1cfa72ee7aa3e1ad9f06afdf6586b977c2d455fe2ddb94ea40d31e4f07e4382c865f9e9e52b3c779ec4e3a11bdde141f41dfdfe5de3eb163335d63b72c658e031054938fb8c6170b08dcb7b1ff14a21e80a49666d9fcee6f78325facfe8c9a98e7a9bdc0f7b8923967fa91552575353429af96926843690440a9fb7a833bfe6ff4372a2190e4902402b2bf8606d8cacb620b5fb952cda6fc0cacd72e31e5dd8a6492e57bf9b9fec5200586925949af0f18467de16caeaced1efe044dafe6ff693fc301d110a0281a0f67d1f6b09ff4594a5600508acb479e94f9b7a44f4c1c6ce53408715231cb08375501679780e94348506da65a7291fc9659f3cc8a2f0a88b2068fd4f492c29096707ae2c52bc858a636a21e309bff5cde1d2f743ef4623eed4946195fb8a67470f3ecfda219487e64191214bbb9526e73f6aca528fb22fd3af72c84332ecc6776bec6a1f80aeb31c2ee9a0adfdafd137e7c1799bf090541f7ac8750a36ef975f41e771d0e5c17fb6fb247d2d3a6f13dedda4f949d4fb22ef280b3c384da84b3e5014d51429442d491e88e21a8ba78e965e82bda34a2c639375919b80727c01bd0d284da8a6e34c66da674f5b683d401f3373a319207fcd884332efe7766acbfff5e3f65d9dfbdf239f7f89ad486486afda3161e2711bc6366bba98fcac361b76a4ecff393b5c8252fa197e626a1200fa00c4bd9db726acefcb3158a5b24b66356d0c92c75296f3c6d9d8eaf461e444a3d36ed2ab47a8c65702a4ecbc66a9d27b91520cd3c573dabb58fe28b60342ffbcea5c2bb1c86a8370bd3836e095e2a15dede0c7dcb3aee3c7c15858311150a31d7b49afb3723ed51f9389bb2910a98887e1490b58189d19423b86b497a046bc9fa5d1d332fe46cfe6e5d7daba5a07e6c334b36c453fa15bad861358abe9543711e18a53475489686712bbeb3c5c5df50976f85f056c14250913ec0b5e25d8ac7e827f3a8957ded44225a498416a87bec1afe5ae8d245c898a9671d257214325d0e63cd9916b1ec81d098d6719b69733a55119f6f5390655ae16e1a88bc318ca798a039f70e23c2f9fee88fafc11b96b7e97029e8af3af822a979e6b736ab23f1d3405ccb37ce29432d00c92c0be1ed933d81f6e6cb2cd5f6528991908cda3386b0bddf3917d656e1b9b234ed45477f3e495d8865d525fe67f84de455f7a46e91f1179c67fc2c88ae7bd1bbd68cda89a95ad85635f6426e99da82ebd3589aaa6bad88183ff9b0b5252069e90daf4a72ff72d5029516cab7c4aa9d81eefe12ab86a94660a56e4b05711315ee5877038f2dea6c3011bbeb777f5c6e07dc731e9e48c6b238d07264e276e45b110fdf5f6408e320a82904fedb8f27ae4b8785bf9fdb19b49bf2736a0e6b65de34a88b7a86e71f234854f8832e704c5c1138ef5dd00aa091d26fbb1b04995f82047ea8bdefbdc41d204672cc619b9bdc7d23627fc9fbf2ffc3be3ffb8b554978e6fee200d236afffb90e69b37c8a548f2e549a639776788cc12a6ccb2e1648e12ab883786f7be3e73a9980756da9210f04eaf0e23529211e9c04af8860c3cf256c3bf43b355d9ed60ea6b430951c81f51e5c3d3899d051d6eaee4ca22ca059e4a1ef95ba1c7cebf501f72d73e70cf408a41cd8d2b9613dc9a9a4ccc49678ae75e704a5f376ca99af231dee9e8ff7bc3e54b53da038502f64ee0d42041450475ca56f38dcda67dcf42570199c9902d9cefeb9f7253d7913905f9c616d54bae4cc7f64286911ba11e28945e7e37ab1558e53860e0494750d57dfda059d2bf1fd9ee4e657a1e631d94d4008323853e80bebf2b0e8f94cd13d8bc53c49eda57d9f5c62660ff47ef3619dc8309049d34c4ff9db239cc5c15351d3a8dac9787a31a73499f3abb7cc8ef4a37e081142cc92c8913d3b4acf67647db9ad82b6ab91e653a4ea6b791ee5dbd0529e7b25427a4e7558b488c6cc47b7b3a62040be1c4ca43707edb140d625fd7e81ce87f9f94dd9c2fa4e5e4b708cc4eafd4b675c27f01e0844ce4c20f709aa219c10ee06f475d047138a899d00e30c0687389f9b369cf9f1c81ea8e0f408ec9a8d6a78a92348352bd119a64407f3eb5f3949accf610cba59224f716878ec75ee0a52ec51856a5d907154fd14cb27058a4fda8592a25678777677610f8128696593482a1dcf268dac67cc44b30d0623ea30df9da1c0d9a55d227f0b70c7ea2cdda71b2ef3bc684c2703c9fd0774038386c2809fc452b5ac8ed52089f48eb383396ec077219e6acb3cf56745749c64a613f3a9ea04d8418ac3c2645f4964b0bbf7891cccfd7cfe4c2a23841dc3a1f1f53f8cc4a263a5009901f2265911e703e9ef43960c808aa02a97fe1d3848966f2c80c0ab54dd508c67239ed0386f5e1f3d35e3f540465c197af798d40540955200b756814b2122874e7144b85b2aaa4223d4853441a0d25cc2e1d370dc38192be0393207478d8268e3a5d4d0bb86ba944cef70db49861459c4764ed635424ef873627d99d69117ca7d2e3f4a19e5b9d2dd586b5343e557b4198fb7450d1d0cb8fcc0252cf8018ad5fb879c782a7248f7b76b3ff60a98a8f4aa12979d34b7728ce6a9a7a208da64da29e06b023f7da2855153a88071754d9347f5ddb3507dea473057b1afb1bbc7b2d15b77112d4c76a1921ae20ff84a8ee0789a167d0873339f6d9768ca8ed44e19a28669bb1727fc51d84409edb46072e38831685d5b30e2c18bd0e5aeed03bc880134d21b74239afa566a959dc1e24e9807fe13fd7d20bccb50094b9d7b96ecafe1b432bc331781b026dd4beaf1fb194a31ce0e64607a6d7193d70861c459236da0e9a3513e75be0a4e4f9ea102f189b00c2bdf2abd40e358663e615108d95d585c3e157e99638bbadfb0ca4c6d563e323e063f4a48d7ee8c11b0d116e0c11b5361d718382cc06fd385d48bd2ecc2e6f1c390d21899b58c5bef1f5cb4b5cc58fc1afbe24dee57ebb6e7e45558a2284da2aa1a793721a5fd80b3e71f25c366c227754efa2950db3c21336948cdd984f803066d8a8de77dbe2e519207c9446fbad855adac66f39ff1f611db37b61db4e99c14d198a6d0ab9ba9a5e39886530060dd69309051c53ff9bd304c902e7db9f0e0cb50d9fd049a9d27656367b57c449061d37a5c95755c01f5b8bdf460b89b6e7876af85fc17bad0e55d09eb76b8d1ffd0dbbfce0c9a86132da3ac74898ee39a200f24240b9f7535a42ae1c6af00cf1657a68dd181aaf92a3f56228df973f5ba292b0080d070cff5da75db8b957bb539ab118b08408bc9707ad2e824d2e8bb71882583dd68c56e46b0593fbf575c93a22350c524285d83203a2e998dc499d862d2013bc080262ccede1e5ef1755ab4b235f368537b8086f167b9fa8c9da48d0ef189b483b4638a2e58edcd6c41d02780a3b2db3e67687b3a0de1b93341c5e2f9577e0fa151612e6b9b98094676af981ce34021c50af7d1975d6dea42f737b830945b2721e8932c9a925f1a4f4fff4d05eb4ec2e0ad59b559680e071b001d614fcb445c1f04f973461e0be298a10fa3bf1f6bbc85849ab246e92242af2eb7f40a3391e5ccb088d4cb2337ab483a34a6fee3431e0d08ddf4e64705814fcff538cffcb8cd2a40bd7c5bb1e43e15b9eaa966127a9c0839c22a3b4d292b5525dce01cc7468494dcd7f7be092a708e49b3d5ef1073a37cb76189ab271066e1dd0de1858b777285b7b159606616489e08a15ea05864ad552fb5a1e1731e823862750eac28498d62430139aea657457d4b1f680478de7a2265e67257e8a26ec3e13c00cd5295f414019251666125c2ea3ce1cf6ef90dda1fa75898cb464789d439a856a8194ecc21ae3ab7694af781c7762caeec44c7d0fe40b701eec52386b16efcd0d009a1b8c2062c1f4bc1b94adbef48cbeaf26f7426943e85532e246a7158931a288978996be258ea7c3ca2264a8ebe40057da49cc34b69c150da11a4491f2b5e48ab16c92d18afbc55be94a00ce145a3cbd148e05253255f1cce6017844a31c7a42e5519a758194c41bb819281dbc02e74e8f2834986a8467092d176ce4152c9d1e6f2cfbb3dae67a0c506c167234b4ce782fb81060313fde2d2235da4754e1714aad932d236df37ac86661493b2b22b2e468f095f776b6efce067356b8c7198157dde846275a22e84fd90d580d69ef73dc512af7e3efea992c71337a294c5c90a41f4f2c4c886bd6ceb973f57fcf825660ec0c96391c9556c39b93ec55158355847684bcdd6b45a1801aa6c28abf2b6e0223dc747b5a696b8a72d29795a93b4db4841611ce4df4448b7c93fa418df7f2ae6e0549d66f9289d6efe9e61d317ce748cc4ca111348e9716aad8b0a2f7662ce6f5b0cc278867c68ab3bbca1903eacc2e0243c7947d1987c37a8f0c786d472680a5d5a5f497e33a2975b50ec0081318d756bed954470eaccadcea6751846add145d930e453f73dd6d39b05364f6b568941a73c9ceee5dbd062cbf342869dbe278f1761912b73011cf085061d46328b06281a8c7b4f11e8bbbffe4317427b2ca41e63de58d436d1c7a920152ce25cad166783f49c22ff19f9c2c7e14de469f8b9e3c16b68af6745b492ff2010c0b00af2bd32b90aa4989e94ba32710bf5024b758074fa2a1e14b18bb2e36724d374462671938ea974deaac6bc2b67abd515abe19503dda7b5a3131b78df8762f9be31d72eb079f6169b7f776cd8bc1561dbe343a1b105204a75c71fe5fb2e043dfa7c91db56a13562eeab93019b63ea6e23800fbbfb82f5572f546bc06f3333669fd3969801f58e5f79d8f7df6c4efd5a69dc972b58efa47df4be6d5174ad6cc60a602ea5f3325b2e137cf4b0e1b4a7ae5eb3212b68f0e165debf98e53a85ea5450fffb3b2dd059490c2a2b7111b5a7c010f4480715f1cef54683587f4c4ec1fe59358880aa73422a614193970653f7fffdb49ff0a007c21dc888fe2b120874c706556e1ca39c8b97da40eb52a46f070070040e89cef853c949dfcbffda729513a5cce0aa9b75a2e1261a786329282f13c9d23568c86d4886b47fde33185733a71cdc0122bc7383db1d82509d72bc29b6049381e7656b4cb47a9b54e633dd32550dbcb8d444eedb70f744a86aac4cba07a470214534fc03b9677f281e61adf043c4d85602a8ec101ea75151d0a05387d563a3a2bf4973acc8ecab94a49d467069cea5083018ece2a2bdfc667b313ef81f428f0ff680edba0c04f855257b9eb20bc5bc27be17de5a72fec20954fffd496c75c9bee38549911fe4727aaa837dfc2b900ed51c91cb03383587edb0b7e4eb010d1d12fcd63ad567950efc03009e8ac05d0b08be066d204fa73954238e473623b3b15bcd18d7a5e4a31b271c9215d53649045777e3e2d8fcaa2ee492d804eb64bc242a2ec46da03b2216241e6bd31650af8c89b2dd2ab13ea9d3af2b628512ec330cfab614bcec93458519692bc01185dfd186554b7c27b6c649dde2a4c6d34a60c74e8966ade6ecabb14cfdc433f51c75f95c887e0d196f39aeeb5e168a82bea887eba7be8aa446cc8fba758b229abafe7a236a9615586ce0d2586559221dff0ac843b35d390ad35517ffa31105eada3165605e8c0c3aa6722c07f06c859319cdb998eb24708459378ad1c4f5c8e2b9e3facb5df3a500ecaa111f576eeb4e90f245430ba1e4b5cfa9d18fa86ff3071f80984d7d188477b60dea2a9dc8b0a0f343e4e60b1426856f140284cb78f037d546952e95020fa822657c56c68ebb30392d03a6e941bc1df0dc340b32c0733759dc9fff8a42dd66b7b89ef5165b884f1c5e7c05c70040d7f05cf9c93c7cd80f51bb7eea021fe9de3b4ae6f1c708304c7902afbf59f7229360cf6e25ab482457d9f492ad8fff82129c3fee6055661c530e0b612d4102eb9870b06546d676d8c663629dc2b22a8e90cd52ed7fefb571381d01217a4e73b2148c094acad26add38617b79c13b067c50588df3301b3bd7703ff17efb37b807e27b9cc837f08e6206e9375728c77cad402ad05293e323b83546127c711ca0f9a568546ea9526ebd06b56a5eefde1a6529cdedecfb947943e05644637e7e0429fb3bf8c3c0fdffbc8e268a2cd563288a2bb988b7d41c25aaffd4f679a613540240a8ade8cb6dfef3577ef648db6b2f1df0d36c46f30999144c7d20b0a93a7b3ad2105b621c28b0fc285b4a5db9d65bfbac437e285257612d4c14438919626d3960ced8ec8e58c8a3abb88e13a4899ab3af1891d40a7f6374de808f0f6719765d48073268cc9f13e856e526697f3f19a2144ec62888f0b34d4b158154e7d7e879619f186eaa6eab39ae4d95797d9b84528354f9ee16aa9cf8d8d4b7b770317a2d19baa8bf3465df3e96ebbdb8e64e2bf55394e6d02f94b7e461c19059d27d210db9d0dd161787f2374ccd9aa0b01407742a648390dd72b584944990c3b291c69abb0d4d7ef96c01dfe4c3adacd28bdad9023207364c54835f2b3a6e33b398374e5c47a2b9df2e3b15e51ed325fd687b02819f22060cdb0057d0cacbbe431b6a4599b7ca37ab1441f58fd736ec82294ab51559a8c81bc65158929a8a5cbd47bb4d5f7658767b6c6a517eec974e1b8fc332424426efc6c0bb7661c4f726b52c48c496e538f9d3b474ab4f0ff361fb50d213234054868a3384e630d8572d7630e98dcd3ae04ed6a951b65e9c9bc91c503e400fa1b4a6b9d600035e672d8a52783b3a822d56afe0ffa6cf13d6d4bcd225f2fafd82b96da9caab39d0baa6ddc356d77cdcedc6c4513ab96de716918ffd8a06fbfe56fc09ced5bbd9d99e2410f6f63bab75fc64c13b52b0f01c19d4ad6c32d035fa7ed929b01c5d2b282de707b87ff2667db60c8485c916bc260c618a9aede55b9c20889e107277941bd3c13c08f9736bdf5275ceb01f2af8e453919631f60692ff6d6844de5c23fb1eec6c7a36851a82f2ccd732611ca1abc465a9e4434a948876e42533d45189af44b736be48f27f5f89eb6d2229d9fe75fec693cf961787929ecc210e8a1277256b22da38b0b4392713879464cdafcd93dd67da7085dfbbdde1175aadf61258479140f9a0c0703f6f592458aacc54253c5d746cb4338d3ed4c6e6f592344d5aecec0ffa62a2a3ed5319c978a2133ce64d439b7fc0efbb447daace9623a58e9cba62b1d25757b5c5bf9b241de601a218bd023ca64c47aa22cc9b2594fa2d23a4e4f5dd0ffbb831d3a4622e10015853acc0ee7c93330866faa40928c1c160d59d240ce2bea7633493","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
