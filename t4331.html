<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25dad083321370da8aacfd9ca7e05e0ff63bf80baeb9363c9f6fa4fd74417025c7523d2eccadb67073d58d5a1a501f7a9ac5b3eced56e0258832e7c18ccc0ccaf0062566afd0d6e46efbc11e159101893c3a72586a3c6b83331079a022c2ba9543f169e56f75126e17fc0a7f9f56e325f4381298eb0587e277adf5457442e54850484f4acbcc77abd02040c1b25dc92893cce38024f18210dfad8d4809e4c90a03adf2665e01de788ccb570d03c4efcf12cdcdc7251c72164fa2599af5f20b7ba385db2533b847b754312ab8a9e163495a042670e41f2cbaa7f72406f04da4a5e0ef0866cc580753736542f23971eba0bbeb8136f91fe437282f507817e55b878dc0db86a9629a52edabf13ddbcf2412c06586b9b8c4f1e0ea4210ac8864b4020542040bf9e0c2a74ba21d6f182c58f54988a436895c9b9c7ce0fa83a418aee71b7458d7656707c6967fd92bed28d0489f86a98adc187e1622a7d251badb4c06ee7f5c73690f25211829da427c15869c33ff77729a6f13218c2397c59aa313753b2534957bae995797a0b197d2f2d9f37e14cbee6d01af72d9cd65cc0e81ddf564b80206cea1a2ce6e8ed681c04c8d717ac6b8bac2f2b51bc053aa68f8cd42b8f8226b95a11821d76fdab4bd2dae9a0d129bc41f7a9e4c9be6556f5f7c587b7954c1107b8d78522b77a60006a702f1b000ed44b4ab7f9bffb7f2c7c420ca23d3d03b29ac35be9cb58bf5596129f0db3b851cda5e19a651d5e26ad7e442f71f20282414ea3319aabec25d21aae0df7ead5e47b28e8c0ca25ecd6de07a7344c38c3874a5d3ef3fc3ab6caa4c5f614ede7444bba2060ad2810eb39cce0ff701d6e7ba2efb9287fae34dca1bb0e6e33dc7d565073e4dafee155b84e80f8512253f932c99273f27d20a8be57dba93a957094d5955bf475171329139c38e0f73a583ac56d6ef9c62cd63f8a63df750bd2c9f083760a8a2dffdf10940d910ebd174d3703f6f6f34c4ad7a6d3ee68d8274832fc767ab0d5fb3214b183bd4313488823b3e2d2699f6fdf40a42ef375b49fd80b930be2b40a75d475baf00649d6f346047497c9ef924ae6baea0a76985df2c371de39098b89b90fc161abe42d453f89122826df10fb8aea3fd96610e0b79695a95f565a5da8294d7581e6cc31f9bc3fb5e87d14f00e0165c4288f25c9e46064341175e9585edbc7e1c3ff85feee8913c295ad0fe5e9f785f847c82f9b66dd0d9f8ed354e2220c74c6c5f1100fce36b0758732a3468b6d20be85410e76cdba482c6368beb94f068a1d077aad496cd82d5059e0abe5d80dda0f22c079f8ceb2f4b4638f608fe4486e57707717f46b6770e7d7084ab75bf69febd745221a62c02518467532b1097165aff03bb24046917ac3c6839cdd9704b5540be7f8f0f1348f3e01f67139f376a48f97f8373c2e5ecc8f2725b66f5fbd651572518cd310c72216b451014c7ece028700f602f99f6a988314109037052be0cecf64f9569d32d8549107c18059eaf4a3d2de950af54c1d108506a6f51e8be2324e401247ec4bf4796faf6bb3e1429b254975fe08d098bed90c98e74cf502946c5d9e30477af5060fd8934f74539d4508c6ee34f85edfb985317ed5c9a28b669319e353faa33964b437e492bba32f40051511455065188b50cd4af137daf361296ba60bc81478b89c44fc1e535d89b4ba5696fe9b4682386b60990cf69884016c89d989b1456795077d6ae287e1264d436a9ffe060ba9501ad6f9780275936160bbea21aa9185416f10b72a37ca6329385c51552dd63a8644a412bd54cc0e53e87c3517d67b7a42e4787caed711ed3844b5b08577401360747dd59eee968b659b7b38bab9e065121ebfee3f3f48b922c842c61a9a06c0aa65444f7046ad9fd784856c346165057474ce5f5571467b71db36c6c098037d2f1331b8f507d8fe35621eed6364fbfec2c4181fcd148e908324d3e726d53a6aaa5ff14618c08bd80b711a1f2f48129c122bf4beed1ee461b78322a1efa45f5063ba0e81c2e5d56be40567dd4550ea83767fa2010e266034affc2078ac619be846bcfd84b7c99400e975b18ef983099e61fa0abf8e1a5fa53e9b8f295582f55c030a88d546b3ba98604b768d2ad5bf241c27273f8d6e4a0bf688667f338b5d2389b1ca6e254d05d00cff69a7e4f265bc47958dec671a9b993698d06235dcf7a10e6c2a8339d9ce4892051f9609a7e37fc8b8e0b6a0dc17d5bb317bf2810afd789f1841e9434a8eb1d320ab605e580f5430567ddeb5809ba461637cc79e6340e2d1765f4764bb774c655ea66826126ccb51330ffc37ebd6eef77e600f4b7e59c5f347c91ffa2280f4133ebb9e62fc542ff6d8130377910bd957a449f348ca7355235f1e17ad82525482bddcaf9a06dca03cec516d5facc86fbcab34e9ee5b75c1fd6e72463d2e5b21782ad5f93009bb9e5feeee2ecc82ac2916f860ee0ebf0493577cb4aa17783cb8047615b27fdcb2a28d5754d3c80fb38c358b5d16881570abf8ad1c2f0bfbba7d123973696120263ff79b8256fcaae16c833904ac53e2f996d9a02d2ace218eb44559513f76c6d4fa20a7298bda03c9e3165fb7ee632a9339fefb352b51af4e10128ff8b874ec7f1b136a3dc52bd98e3a73ccd0220450540bd344201e15ebc5ca6cad094c4a9b709546074279120181744b4e20959c1708d8cf82cc894d87f5ff1cd8d86212b11012201dd15285646134f86b30ba155f59fec9648d8999ab40976e8dffcce78fe29658b93c9ca6988d860db87df1022487f8dfb3c68f7834ed3ecdb2adbf484ef8ffd292c54412878d32c2494e391f07d3c8fb72091b07f6a27fe87475053b99a818d762e58ad4ab68f5742ecb2c66c4b0441669be8eed426686660c12954a15c508f778dc97c1038d47296f0f1eb88df32cce90bd190144389d2483b04da5f866d9fb25cb5cfe1a53753d51f07edbd715285cedf913d939c480881cca2767de65d4f9b4f698641795423f36a3d2b914d45f087f611ada880ce202cc740742abcf012d85f8f3c0cb9fdf24d7af2abd7abc0da6569059ae9201b33968baef61229ce26da48eaf4685561a596dad87d8927134948609457e17f240a2a90884ef95ba69bc8836de55615954c4b10b93090e71b3730fdaf828bf6a5c4801baa9082daebdd9fbb28d9a92ee9e8a64f2992950fa9de41a0b73d26564adfca4edd3c15ff4a090dc6cae191e1b3b63c9fbeaf9f02742bb8e4a3444da02ce12c4f58a020b4f304f6c586f601e7aadf973ab7172222fa5df36bdd5f146edddbbd1b34608e3ec96b77d549ee46a830e7a8f9931f05abc1b9c7b592a67a815d9922661af451bea9c9717011127b67f59d6e509cc968f1ea3aa292897f903e92ff990d06fa96ffbd8f2b6956693e8c524c6b9da6478f58667f61220f292ac8a588ab3f4d20031623a410a9e8d7a932ac2b78fd6e0c4f9335c4601b26adf87db730d6a9c8a6f80c971e12dc6fe125fb4cfc3c9a44a5b1283c62d7fb4b62cccdf4112f30f2c28c13a9129a783a79ee12affb296d67c044710ea81ce6628f144b433283201c3fc49b6ae76460265cccca0d04738a39323495a3732314c51415659aa65f9951bddf2714dc49d3e50b1d23be6c6ac67e135d23c0f8bba2f6cc22e93303c7cf9caf84dc1d9e052ce2a95a98c6cbb5e23ac018b05cefcc32971e0899f8001bda5c200fda7d22047d86c212d932a570cd5f23bf0cbe3dbfd2447c8cd824599d11c093d5c04e6c9ca5b05b5e6e4d1fcd5308d154f3e0ee2b88fb4b1ce68bd80beee738869cc2a6e1003d5620c0db6a1d2d489efb9332ae3def55c842f0d6e05393cb20692678936e9d9cbfe095981ed5dd97a9e1ff8ad4ef9c14aa3655aaa18bc4e32db2e6d983d23c67b254a32bd9934d980d2205a26de96feea48495b104dcd766a0d96eda0ae4101c579da2d7ddc4a8e6a7d760005b96f74860cc60d09cded061e67c1cc4c970b66835d1031c4a185a7a423b6e914a288060c75a3cba30733703197840ae0d62a7ad675c497a8abcd2e4d851bdc78fb019785278ca765a5c76e1d7b9b2b030dd619510ac47c1b15562352bf02111575a7281f152a94efdef367418a514f6bf31a2a5d7676c75b0d75a99c936f614587257d9b25142ed6f2d4ea8a2fd2a3778f7ed52467f262e69430b33b2b4c6ffe6139ed1035269696e3153606b22d1335671b4b251fa628458bc22236f540b61c1e92ec1a9b15d5aba62470b0df6786f684f96fd1b1fdebb953f71568436f4e630670f56d8cfeb461b24f9a063221e34cf69d4631ddb5fb4da45307953734d95c151415f3cee18dda774b59524ef3b0a9677be2f4848f5fd92eaaa50880db8d8bd0249d950b9177fe7244fed0b485eb77d39cf1187237963990460a0eeae04864210f20ea56f463bfbe61aa9a2b270cdaaa63bda722327d72c1192129cc478b64470f5f1fcdde77e44fc91426657c0203b886742c79831f818b5d83051c29fc7655d866fcbf3b78a06d1ef6459fb649d235c92d377322baf48e5987cd1c9c574f9d72965fe2833438d369d1d757d6c21744f5e7e44a712b866124c8eb2ec4b9e32ea039b1a0aa889ac0cc3e6c22ed3325ab8e8755050e747b32ca56064a8e4bbd826d43a8869cfd56da3d39aa1c99d3d978db555f6ecab8a018522794dbc723f341f69e56e5b477d88b1108448e2e7c1cb34fe22727b45a9eceecdff1073355f214f88b31068c64a9ef7f35cc3584927fd765ba2d64a269c6c5dd500e84579e07121c610833e9e35b551f6b73047f2e945a024e0295982d717202e09fc7355ce130e2fe8eea08dbd05766dabdfd7a71bc12b5334fb77f274f7bdf81050e6b9ca1cd1dbfed7b9d04e55ccf3848b9a468c24702f15c1bc3b05780fce95694211f625a958ce997d8d153c69015411907dfe96b6c3f32e852732a5285143e14ed0e92b0705b3a2caea0bcd11d2f4f5a37708341e5a217609abc40c198541226c1c56d9ccf22b3c9a0746fdf126433d036a80745620f8fb14527f9d1de4567c189335adff2f5811d4bdc1b154661cd029c80ad2a436695730f950d5c716820909bc36c2596a90ca13654cd24e3c0360490f282771c01be57dcbcf66ddd5ffceeba1ef6dc9cd706ae8bc73ec62445204fb8777c536e7eec70c88db7f71de985114a9aba1364b26b4c5f8907834a615cbb9e2698ce40036fcf7233e56aba32bf6616df1c55f9e5932bfd31b44379941d2ac4f2f611d4b5cd73071df72e924b7f09d094ecc7394d36d155c7face4ef6adb7f9de50e0579ee2874812bdff3079558bbf8f08a36fbc4cfd881a2af5bb70b1776b555189743a5825ba744b39397a015269bd635e248c52b6141820c60c46b08c1137817bfb1483d14a6f1a310fa0e40d3f97a5b7a6e162007c5e64e336c3e452f7ef193dea48efb79fcde8acd0ff82a5014cb8c2e3913f67a6eee636c571cdaf4d26134907847496287341529b13ce80cf5ede5a15dbf53aa642bf1c447f3f9b7427dbb1e586030f70db9f6499d2b38089017232165476b03ed2e3bd564010f018d6fff3ac95f3e53ffe6109235d37477109eef62fa4d19969716277387d0b546b7f25c603e3850b13bd4e26706903a8dbe834d74235adfdffec76006d639b40fa1f180e0be9b2060287abf4f745cb8fb49b3f0436f409852e0ffba474748fe221dd642e62cc33b47408af679bd41a5fad3dbfe8932821e2709e99e968f2b46429767150ed4ba639d3a8e398e6af434e48291c50b9647ca51f758af365f44cb785d18893c848d9b4282cbb391132c73082a9d572ce433eb82aad088ee1b1608f0ec17d0d8c1fb7b6dd0c0088d2e706ed0054214ce2d80cf75ca5b36b4861f8d6f1ee88096d0017eb8f20ad0025df616b1a5b733164dc997aa2bad71dcc0688ee275606eac871a619773cc927f5fc7e7d93376df261e8e91faee6581effacd29e1d1f2111240560171fb9f6027b0f40c1b3d4bc9741c26b962286360b45c0236fc1125d583577ee9c9802d0b1b0ca7d6351efacd5c6f7ef942eb27002a07e9b297977991aaf59371699a6bce0f0a91c81fe65b4aeaee80b043efa5a26a1aa5301a11a9bf35edbdefe361b9b6a2d51e9c26c6e0d45e1192f0222b7808cbce09957a5e9ef42a9ed1ff053bc3d42b1afc1536b4d833f972662ef4929ef8134a208536ab94a1cae720d0a68a60d36fc1c2ee6487008003f0aba09cb1d07ded905acfc00661e8e2649174a7e4765fccd7839ff2a65ac67b28793422d0d147dc40f92e6c7555b40a058e1c08b5cb4fdaeb3e2ec766f6a89825a9cb65541aa66c2b5b0160c021017e7e68df1f4b8062e918f8d0efeecbe22186d40b4cb854a426c9d1577a66ba0fd18cb5bded6736bda0285d20b782eb4ba3f251a110fecc54be2e9f436ff32295e8a34bee51fb5bafbc3ff382f126da8bf0653a3caca09c044b55333e7165625cf37f37b30fdbdd49bc98b58a1e193d34fd378d914f548f6680a93fbacdea245c0e2296114df41af7ae081861cdddfe6c738661a7b7e6cfcc6b9ef435db2f1092da06a8bc42674a9bb96f91296b0bd1039444f27b98813deadd7c65f687018c44e1ba9aee25ba3b27ba586ef7efb4b60028a849e42229b51163ea07b5e9a3983bfe3b8841878f359b3abab2d4499936e2afdf3148c982c2e16c22609de54e38ac1f7d318647bb0e1f2a5d91c6df24cf42428d63df7de8108aaee247ee913d5d2c32d4462007a763e97d9246c55defe413773dfff2505b1403a8d51ef6875fb3647285ce6263190dce74143fd00f5caf65c10e15ebf206ce572ec5e83e4e39330952cf03cfe35eda205d83e1dc04f017f1f656963fb7de88b9119ec0bc4f1436164c546787d36f8075da48627e9ca27bc69e02e56ab2cb48fee9c96b47e70161e9d44bdc0baaaef69bb2c0f65ab8a837052bb0030484a3e50fa06329f5ea5ee458add306dd394d66afb5449cfab72dd07f6fa3e40a5e9b16c312b5b5c1fc6eac81c5542ac23b7afe6f30014f52cb90c9b25a395d3ca27f5d0d065d26743b538151e3584af46e59fe3460e20a84e96f6f897250f9cb43b336dfecdad300c32f32bf752e80482c77e59739bfe21c75daac24b0086f1dc997b3e74cff6a6bcd746a5c7620123e3edbb0ee44ef8ac1ae11de98c6c02362f4dc6b4db6b46ee43a3f5609c189b60f1b6c45ce2bef4cee3ff9b2ce2bd30cc463d883b559b3c16cfc39c28aa23a50b668a4c93d6af6b30ef130914b07d8abddd28964519e58dc98f7e48f96d3b16471541c100907e0e522a3ccaf9a5fe636fbf4d3f78cbad0dd09d49a829382f3369fb8781f008512986e2a791f916afb239405c062c0afe0c7fd5805dd6e2f5ca130e3170a914b43a39b23e2909a55fba1ba0ed58144940d19fdb75327d853f8a29b617c989dd2e998504eabfe01fab1bf2c6b5b3c41c01d8da8db8f0cb50e624ebc7ccff32b1071fa3afc3b4fb2932f3fd5f9238ecb96509cd465429c60000055d6f5c57bfd8c120b2dc59357459c3eeefc6b16ccf0cfe0328c3da4f6250ee4013815bbd996fa84a3080452a7fd2f7c31a7fd031684b4f560ca6314df1b7b4bd2fe0732f6db41e9a6bbf443fd84ce7872eb53cbe9836a9759a00753c12b9789f8513ac739b61767e46c6090cd52d191dbb2f9390f597e91b7354d3e04d7b82de50829d17b25670bcb87af8f0df4bc2c0f6b7c9f6035f73fba77f0925242c9c83a451c1eeee544a214ac7b30584de139518da188e11fa9067af4e4bf1df226f7588805d69ceca0f784ac0ba9b08b53fc495f637a6958e6a9577771320218c7f233ed7add0a97aaddd45f7383eac54cc499d2320fc00b494caab778e850b68fdbfcb7f583348fbd774824e13793d04f5b44773dd28027c548acc5d878e7fbb1dc06b780f98442d03a18dbfde88fa2a9c15fdd0d9fde090d15411f158707fcfefe7f5a2b5818f81f92f284d29754f91be1228462cbefa779da0934dc3d15fe61ba832ab6c1b024e0a60049c3f51d33fc80d58cc32d396454bfff41a007bc6af6cb51baf23030eaeb6b203d3fb9a5ae9d60f15d29ce1cd69090844594db53eb39527dbdae0b0ca14df994bdabeeaf914a727d2588ba8c3bd4198d15aa73a4680e7bc921e7d7f5273b5bbc156f21372f2a8bd55e522e077ca39c2966968f3c9a23bbab1c7d439ffb140e45727f812397e0337ca3bfa76b42175145040d477c1b035ca927476f4673b371a3eaa01c80277dad263e242cdfc96a49879d7b38536c3bd377de508865b0d84f43bedb6cdbb35f92a09d1584698108552c4b1f040180d6ef8a4c9f11b7f114fe853e84552e1a2fc1825c7bc0f9b3f5091b164a90f35b75bae6dac245462b0257d28fd28f0e11ca2dcd7c65c8d3fd5bed8e061b8640412a2899569814f2ad7ca925c149d50e2166da72687b1fea3e8131faa32ba22cea2168efb47312857348506a22a7f9cecaf452baf9e09dc6a3eb52d57bf019d74532bf74de7a545f9438f23509512f1b9f19dde62c32cea7a3c1ebd3e9649c0a03787459b5a80618585211c2e39e23f53b830bb5fad87e02ad4402b5c02f7a80fcdae5af633b2b665241c019c0c4968b62f955d754fdf1abd0e0f74ce2b37341184032f31e833f380631692105a5b63c94f5fb60811f3cc8e2e6b5cdae502b7f5c485bb0bb5725cfbc36126c147721571161966f701f7c3eb0b6e70f47bfa489a2b1d2f0ee382297dde717ef6518897703a9be6bc7ea3ab53ea09e5540d519a40ca55f816b615a205322facf8151a19940bdd5b2a9bf9f7fdf32206aed0f0e83633cdbc44217a879d5247b52019b39981e715f1143b571775e0b6c1e2781731918ec3359de6b56cb5cc60b664435b43cf7f751adc5f5dc60bb4155b405791f595333620db6ce9b96682799628fa37a1084a58226050abfd60d2ea1675c81e95a6689500135ec075b705449206560581a1a30f4e4c02242ee10f4a8391024121501ac6bb54d1bc6bfaaa56ba74963141f0c2f16956c8cb7bd342003bda9412b3fb6158dcd8c79b12483b2dd36f17ba2c2aeeb9d804759f6f183380e51e52b25075ceafcc1e6cf6fe43ea2533b00ea510f196b2f2a85c41c5f1163f2ffb57be5fb76255011d58f3f90f3c73f284c4790a64ca58b5330792f763a798ca28fbbfbd6f8233306bce78202ac3dfd593a1abb5158808c2db995f33a4fe4b41b0d0236429b75bfa1edd8af86ac9a6485268bd92a2a46680513a0dbbad06cef1adc706a3227fca861d7ac778c0ccc34b3d8627df83e7213df517ec6eeda360a067d151289a70cf73f619220f09109e57f18e561235b9568280e3e908d0a46cf76871f46a4ed9079b33fb8d4a6c6fd98647a0de10631737a0ea943f32956a851df55b6fbfe354ec69f973cfc792751bd81964cac3b077e47d91700a96af204647891525242eb5dc140b2cf8ee95249f6200137930525f598440c70be4c95cbc72205931fb538fd7ba915af0f7bf5f38ac60461fde04c0f3fe559937dc9040c1cfe664a561e5980d94f509ad90b19866d50233ed835ee10ce8fc06cf31de73db837c0ebb11b0a57f320e839f0652b8d6d8a472cf1ea234811bc83cd746f24b67feeecff73b3b78998528f2d126976d675bc7bbc29a1fc60660bbaaf001579b3629d14b173cde9d82c1ec50d57866f224048c96852fbd3f28ccb09c690fbba5be9bebd6422ac3b6ba898701566c8cb21d0b1453653cc66792fd669d9686b7908dcc2856ab063fe51513bd5d8669c7a1fc9a60fd2710baa3463589edf6fd9d813397aa3c0a35e7d31beb7dd38f5d9ca5aeece31ffcbf7fd7004eadc6fe1071789b4f888218c28af806c44db65f2f73eb7180cf86bdca0a99df1d7aea6e09ade087b2c20c9c728a3c13342ad16de3bef3446849e40dd9de17540ab5a39a0a8e7bbb19122f87bf9ab615a5580f4a0db47e3ca7ec5412ffe6dcc6dc9b3bb8c155c349d68d5d430896a8b5d1b32f72237eb2cf132475839c2a1a09478d4ace13ac30be1288f01227c94e19845771bca6e9981542ebd7fab46424f4c2a9622d430022dedd6ed2832fef291de6f5c0f73b71b18186f580b2ef972b4805e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
