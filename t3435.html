<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2bfdfe6005a72372b5cbadb4abf11238cc2836ec8739c04e9073a15f5b1904c35d4e31dfab4864361c378d8fe194556afc3db42937d30488788dc8843b3daa80f5f95b51fed887ad212a9c3c694cdf9e1a041e4c78e5ecbb9d19493ec627c66c3a177d106600a92c353ddc732d47a27783d3f4daba1fdf18abe4b6cb544e1022a9f7af06244367fd5d3d59d3cb23888344dcc446a4ab8b93c347c9ef59527e71883141ae4dbddc8d6bcecccafc26864b1dd6866611a63012f2d657a0c2435f405e81108f61f718c8239aec4d5c79e3e69b6918d1d9e6ca50b66e32ebc90f813ea11d0904358aa215b3eca946ccec0babef948dcafad5f8f8fcf9cb960365acaade1c3e0d970e4015fa209b22cca5f3da0850d9fc8a3d9d85eaf05ba6f784178a5964415fb5df89b47da4249343a45cd1af31626cffe58b8634ca1f0b4b0ab6599004cbf54431eae994e744cc29c6cc5fa96762ed23a06e430c69367853e08104256ef2d6600b6d727571cc2fea39fd6c4978f4ed30bef9d8fd2d768a27da50d4447631ec8a923eb6383a10bd7b528a5543741e1da87be05f61258d63760273a57e50f283dced06127a335edbbad7673c49c9203a855fdf92370c8e2048a315c5bf75717d1dae2c48cdc13702c114cba31dc6b19b2ea04ed294c67ba9c7b311e2d2bae3e4c1d21636983496bd9c1a7c6c6e9fdcb16a86d12fa4a1417a4a4204783d35814c0f4ee92d6e9970a658540c35bbcec783ee2e6fe8b2bff339ae408742ec901e27ba7529dbf73ae747de034710eb9655556fb71d5032a36042773a385f81a0d98121a1baaf85b32db13611710ee70c99c0138af31ba05f808ab457fdecd409139c3b583805445d6bacea30340257f773a36ec3d25d2fb33afa7557d48bcfbee5286f20b116810f8fede1b6d62dd74536d05b0398de40e8678f9052e5111e112bcf6e74b61dce13bfbfbb36c648ed0e576edb8483fe2a618e4e7d8b37f1c58841ae3a81d1aff7f0becd15f9bfe797c572c727428a13edea3ecbdafb0ee05dfcbd86c8a3bcf49c8e6e38b9fb74c357875f9019ad380f1863abeeb654f2ce96a9a301dfb0d4a9c15d358d3d734b2650dba75dcbc62bbb8384ca8d0d426ad5d2ed3f513730245f0047446ad5011b79a59397ea325ae09fb0055289f468983dc356da2c943f54958bedf782d4541b2e6cd735fed74db169fa7395a9857fd987c55f4f847992f0ccc0ea6f9fc445dc9f7905c397a66877d5de424b64ad42b55d906a69933500797ed84e4b3555c56f2405400b9bf753ed35157a3ebd65ba84417f76b7637ae263b14c05494ace51c1875adb51f091f5e7d8706caf7ad32a2764c6ad90ad36af566fc844c5628bb0f8ecb28ef53a7e4e324a0a7fa5e4a0d2ba1c5b4acced12d5e1e7cf960291a9342a478adc7295be82bb2c6f4d844cd666392ac0520750e0af33dad8d65feefaaf68d13f443a5ad2b6ae76c631268dae61de2d45cd0cc1f5b66dc5c01aba47530d6e05643cfb7bb16530c592d5e95744ad1a8ff35eb317d5010bb35a9b8755acb2bce98681aa7c9cbb2e06d1b71c036e2e12f789ea469dfb37bdeb93f05b27c870d4f3f5505683ad3a4e102c892595ea94e7d49269ce3a5e0db4f57ee9ce08ca292ffa60fa9c9f7cccd964ea88e9eb68f71815786dce16eb4a8db847ad485e4365340f435712fe426c122bf6f0e94a7014ebd1cdfd45f6d88283e066ef91b98354750ab6d6345b0c0c42b131b7e8444f330bbed0b51a8741fd73de517aa2fb277e3816068d5ac6ed68585844a1f527dbb10453475208a3eb8ff7f26ce81975a83d40af0e03e5ebf2e1636051c214c2f8378fcfc05bbccd967e99f2e0e00c33c8a7472fa88075c21e156fa682eb29373622436ee8846d6f727f345998ebaf6c813459eccb2468f6ab9ef538eafb3de71ad7aca7791d8a2e0e06f3bb3761eec5e03a398662cd70bac855137a370c0de4a52d25c5b32f99e581440b39a1680b1239573d4082f12f7ffe5f83f941d339c16c4d49f44f792de28d50c92f3d8f6b0e919ce5ff366ef2a519086abcefe9e1e2f36b0314ea14b434af6f56c51eb2f97ddf45bf730827076d971390e9e38e7181698f99003a85f72a539ef37798906c2b5edd37f3a7e05c1cd08a8342fba10e412392a12c3c93e6f431a775c5f2c18ea516cd10201e6ea5ac7b39f707310e4c28f66814418dd38e913cce1f453aa4ae13438699057b5da89adb38162cdd03ac16879e4dda5b1d4c3ee22657e332a6f83bea98fb159454a7260ceb639b510aa29b69f82dabd01901602c5a2661a4e28704eb26a39e03e93aa9675ef65fa111f9a009c493b2db8e9242ddf885f7041e389d476c1dc66954c00f3d0b7833a93d4294e8d4edcb1934f4b6196273dcfb779a8910a4dc7d9e0e6ede44c6815d03ed91bb2e9b808f5985228704edf057c2e3f22e800ebfb5d2c45e42a5d205a473598f161142bc3541ec71112a23dbd579b46ffd7836da0ad0612dba6a4fecc52a95ff5be4c0bed1ea9ca1d022f72de28f04bdce2d569df944874ea955bb6fadafa6a24cbfbdffb8dd65b3893e7ba63abd3f2c952257cef2e30091fbbef6c5bb2ebe71af8cd3a4da4fa42540e87b8f57cf10fa263ac553c44ecd9b8ac300c8a89e64e355a8c5eae03a64b71ee846df41e5e469c4af43046b509b513d51855f0175db8ebd493f9162b56fb6a166a1443ff8e55cfc72f74303bb7f4aaa83e73d51414cc9740bf37a1c32234a35c0722861c529a9beb43b71e605068c5c8203873cffa6dbe9cf1f2f2439667a9385b4e1d95aea9afa5cd04f66b51ab743e4ebffe26f08ac6d35f9924abc3fa419e94d3c21a10f6a803c1d32374b5f4e0b07c07b54be12a35bfaef26ccd8d56c69cb2515671d5a4fb761fd5320c0cd8f7f84dd1a613fcb58ff32e347195f1b8359854c6aa6e77d4424b443fd61bad0437e6c5805d34217637d69617ec68192e536c788f6d9c233b95778d22486374d4fe2c7092d22750fed8ea41e3d38b03deb71b8f72b6dcdddf86baf20826f75264be628bec22afb4183533a9e3bd30039f84152ba85814109fabbbee04e26e9d5a183d14969bef043462c43906ab9f09a23b092125be39072098f6a5dd66838d2be6a8cbcf09686259aec19674991b0bc58406cfb7dac5c326602a588cb6d49b2582f9313bfc68ebbf47f8dedfb3037844b151f76d7cc5bd45b2682e5479a8f2dd2a2de4153de7244133a8edc474396b0da2870178b106f7677f1086d6d286e92e4aeddd04d68e54e93388eade1a59034907c5c85ecde8f2819a4b9f0f516b0a4d9b2f116c235bf576a331a4ac557fb9f0e75c30c79bedc2a56dbcdc4ac3bb81f88f8c8e58eef2d2ad2907f15eb11c62a8835c5b61d01039bb7d652453cdcded1eaaf2024f886cb26081c9bfbe9084bbfec3933d74a4f9d2c5834dd4be09a07f967500e0174c57cd9daf94db18fdd7d42f6c1fb0b0b2078914b59bd7f29fae77fd8444aa48b337c788bd8a413e784c0198d92904f0876f875fd1ab5a928368b84d2087545f73a3323ebc1758e94ba1ce8af6e8c2e026ad35763f8a83c119d3b93ddff5e1bfb33e177231fa853dbc3c1f7efab6da6ba3d913d2f81fa46736566d64fae632a601030f4d7cee239cb71c3844a2f01973c36d0e6421e1d2be9a7dc3c4f883d834ca58359f3666252fd2a11d50dc4ae4eb4bbba09fa0bc0eaffb51cc0d997e2a9bb032963ce01abc03c161ba020a35d70a43f6294e1b1144917d28b298c323867466c9df31eee785b79ddc0363813f57a0e939edb74368d2e630eef8cfdf8f7674f7c2d350b623b2efd75813f6bc2d709a207e4da8563b735f19665e7b3f49174983dbc8fad30f8c788d9bff0a38041290799be3468ec938d8e27e1de78b677fe2a2759e5d5509c9ffcd19b96bb6b9bbfd24439db10cece9eaefa2feebb8357153288680485b08f2422245d09388aae261805799066c0bf9dd7633e8191937509161d266ec9cef5e78e2b8b1ba26ac6cfcb410d57ff33a03889b3b599d0e4246bd962dcee2f4a639cd217b56ebce2c268629841eec0d4bc6697e963c6195360d34ea0608804c527acec1c9f2da0d4c231b0b34a2c9524bd5be5f507d3e8f8951082142119207fcf408f4606a406e25202b76808a99b943710c94c81c56a684529e299775b348e2684d01d0bed838b205e7fbcb8156a69ab328e204a62d82c1133c9dbc4bd546a663375c2649390b5c8bc50b6cb552c68f352e05147a350f40cd1b3a8e4d50d3197dbc5e2bdcc15dda8f2e315ba8015e494e3511af825ef456bcce185daee42608e6f4cc7f37e9cc53e755d60820a45c4d4e77e52bc1db8e9b61cd4c0f28e6c2687d152beb2f801b3824f913d9c568715db4d2421289fcf1b48ffd437d302fe219196409ceeb30268b9669a040101ca01b56e5652a47ffac516fca8166f242d3272819e41aa37c1759a31d711f3ab97e19c4b5dca49e3cba05e0ab5341bcb28db3f9845834384944f21d1e539f81354061f5f06844dafe831f04893518d69bcbf801c4fd8c8f6cb4019eb64541da5818a489d54541e31e9e2ef5abe507076bb3b5e084ee17ccebf92b0f020de454ab763953aa9148481316e647caa7abb19823b2fe30651da632283510ec29b6555f791b5cb7f6e83be242af084e5e9eb8b4c2cb70f295b7991a432ba15c3f25406a86e2ce3a95b35f603600e71ae15b1ced9ea6e80134491be7136d7441bd5273c091fa775526102278b6df1e7e55cbf8c9d76a458e7f222b93acc70cb8cceec566f03b5db16eba32ddd208187003f7dfef6f10e311f7ae3ec68bc0e806926d2ae50e368012a6c6d1386173f39212191046e888ce51761166f5c9f82846d53683ac298fc3a3ccf2560fc342e4a8294fbc7a21605fde4aa820c909ff8a94a338e149d860b1c7dd8e21992f005c419fc57b353fe5017e184f0a54857c5157800850ae9cec380894adc7b068a44af6cde1d6b80d6dc4df54b3af86ae2052be3d2bdd62dea2318e181cd0d194774c34d65cf7dac3df4fa7a83f94ffb7d779d1ce5beee16a5f76509abea074ce436fb5733a4c557379cb92147c7d5498e4588e9bf7aad0c38cdaa4f619fc31128a09aca34963eedfa77a61d3e9ce7da9e177fbd0530d71ad5bd609b0a5873b542fd23b5938f9ee7a6e427a731ac9abb79a1789a815436084320e3659a02eeb609504cedba5ca779ca4f515643258d9d61f631f4df7d7c76cad9cba30d4ce44dee8529c8c0a622ea3c83fe26f2f58f4b3baa39277a7e62d8f50ad3fe073c15b3173cf9a4f9d1c745b9d24737fb0c2b8af4a93b0fad7d65067d86977c15fff02c450f1f39e15c028347a71962cad07933caa67c0de18f0bf52860c3ddfb4f5b4e5067b39950f7f8a53828309b30944de438237a16617ec7408d66d98f0fd3981d22c1aac25f5c1e13cd0827ae91cdeb0b664d6538638cb26fbabd498331082ead33f5dcf0c7795800436380ec5b41585b35f438654fc401c3fd1b1fbfdac60d7e7bd9f2c4b295134e67e7ae056c00fed565081e823d40016d0104a69999f21a838ae4a1a6bdee01ab713c67cf81384007f4c28079b9fd50aa04e2f7eadc5820e1e3d19358db52cfcca7c7b5b67ca547742307e37073a7893fa0b1e94b92fb88d155a1aa643e523d2810e124514c890556543e0eed78802d80e20ef5cbd10abaae06da4c8ee7f9f63da47c5be0280c509bcd462f6d3b050a8f9e282ce2800e0b0285f0fa9b1a701eccacd293f1a0cadb2d242808c9b9d863c576a2388d7144638889f0563ca0b0742819cc78445fcac02812c8c3535c885ed3d9c80cb0d420f93ed150d3cea68a547f004de9ed787238870d515df24fce98903d4d8f4cbd1c98207df550a0ddd1b84814d03f4327d786f81a23204a6f5a5a2dd08c8cfa32ad44a5893a60c615c688ea11f71009b4cc69c42e04159294de086eb2258cbbcc6c13ecc96789a0928dae5d1d3d3f5f9237aa91c0c2f94ff8a0d6c2b1fba051c111ea33be27257c83ee50b010d34d2fb741215c69a3a73ced28ab2ebf89891bd65ea004837bc8f8a4ed0d7017b739ba731d031af513d578ba6a6f4f9504a81be4aa99464b0b17407662a837ed931a4a32fbf77beff6cddd3b8723b9a48f06ac2d5e06081ab22acadac631660d452c3946d6455471e3c5d10281517a604f52623dc731d72e1385d4a3bad039a07e5832a5e997f4cee897d6bebbdae389cf498c5d3e2b266aba76fb286e035e2618b25c23e14e65bb62904788788f35dcb11ed64da611f00e05537826b8de0552693bbfc11eac9ace92d94cfd3e2c5cdfce7447102b54e03c85c33c76e3f0f0bf6bee8497830d74c08e1e688a7fe0f4809c8c72a49321eee1958edb40fd1243657414403e8067c8360a437ffe729392f15d3a507dc843e7cfe182622f5f64d6fc1d1539c10d00473cde387736b2143bef837beef86daaa0073300f8dd69a0d4eaae5e21e58a5cee805894456ab6da3d9f4e64936d1c5cf0e354585200a8a5bf37279a20218ee82b8bf9501a58c8819a77ecb6a19a76559e77c6aeefacd49eb0f3380848073b5926c862dbadbe64d45023ed57545afedc2a67e2b72a4fdfa40c64d78949686498c3bad0aca2e2e9d70f7b12f0c9c3892dc0e1c3707a4ff8d0e187d94b717d96ba07fee91473e09d4e1411a132e0d5bde843f94f41a91082fff6d0054f3ee7641433ff97edda9b1c09947aded783a91dc1370479f209a32cb2ece00fe09de0d474b6e8962a6623a574400015b77baca0d177b1299784da8cd1d760a557a21371a7f2e108a2359706ed328654e2a8a6062304e1d3690da047e472056b5d9962219fae9eca31a72e1cfa23f1b5993b2fa1a09e5ccb5ece530b7f1002a8dcb4fb819ee7f832d6b341a3b282499040b9e0cd987c1ee612574ff2d4d35c3e01f80c93f0b766c82b561ae7926b1613d71ae22589528e46850cd4d7b0059298f5e4279cee25ce07e7e627890cf38ed5189fe63e48c408452700441f96c88d890adf95f4232aef6906e77f713a7cac56e8877f1ecdee0a455af78b8df41675bd2e046b34b27f24d1ac844144d94478043a23113665ff1eccca9ebc899edcbf2115457a8a8d8ed201ada3a7f9c901d887189e1da5f66967c8ecdcd34aea9554ca6c4be27951f0b49d563c6f1a76ffb202756827c4bbc7ae052b94f203d2515d434684b7a52a351bc5b75a171e3fe43e027e0688c8b6d627e585cd5e5be9149da4f98e3767473a40ece817323d36a41e2995767dc5e476694063ffb8eaa1a25f13487a621cac79281b05f9f60000fc50a477fa3669834cf1fb1f67f5e2ab2e375e9c09f39f93ac846ffcd792b18f050fda1f6d987b9260140fca358081a7b851d48cae79921ec9341493638046efc0e861f4d5aa9532e911961d8bbd29c8f437dcab52a27c1d698438383cbd2fd9864acce2873248f411818056d9131710a5db69a4796bf0b476a9d47c492fee79c56548f360aa099fc6738e2ba963297fa599b232a6e4eeaa0540215478de55f53a87e98dfe59698f4fedd47271a695c6573146cfb9d3ef343a56a53750adfb8d6bc900fcef6beb2f0abee98e89892511c4a680f01206c89deb3364d0f5863e49d557036422e812d64e01515b6b71c76b833c2a644cfa1ff191edce1367ac32d3cc03d0b73eb731269131da60fd156fc065d4bd6332e3adfe14bc6a810c63461f3d1ed88a6bdcf6f8efddd5e1b1929d0c582336854d8d67d4a25a35c0b4fc5fafcc6bb016784c8bd7d79952b7f899c6e37d72bc266574220decd33b8e1d9ee3f901308f59f66ad6bbf93d7887be5f6da90879aba28c7b1ea9621c92d50f3d3b2a6bf43c79c46a0523536bebc85e4f1d74feb834a262eb01c69b42cdb1711a02acbae64bea0186f8edd43604ea844c9f924c0607c662112db67cc2349bc5dd6fbb7e98d15002c25d955d3731504d59fbd510f07f1c997f85eb0298ce4dc65bde06cb34e4a812190e7e732c6a9c9dff03b2338904c0e1f6bc7e4034ff454c9f9eba14bbb3e108a0f1bd6bbffaa689e4151258d795fe2cb8dc06ad02283b606e47b5b1c53d0345366c621290c56328e93c3b3786ed75a07b314a6d3f1e4abd526420d307e65ad2d7564791f7ea32f1c19b2396bebaa70372651d2348958be92db9275af2d66a255f2ae9850e818b700ab8b089170e575ca782b51a533ec621f6ef2698aa223b30f619902adcb1484c64fd1ce2235a23ebc44e601d36e32821dad6f3c323475cbdcc9c89b5de98f7b163675aad424fff5d62e7b402a0eb9e1eaf53e6fbaf670d08cc4cb9d2f49adf7bf3f84296dc2c41287ba1282e301132d2f4753cbaf74775a6506502bb898b033c24c6d7521b07f0260b61d85e277e98205704f8df9da85802149a013f0609876353b7e8430b0632199bbc3de899a17fb928ed2485d3fbd94bd61bff3c072cbc5a3d12a7611d3db5e3c1e03bebac437af4545e56ced68d68f53b8173321de00342d3a49b9ba57ac32389522576e73cf0af90a7f6873680fe6c1dc659f27e11fd722f62bf2d624d2d103848386985d987d0c90239c7761d5f149980d87749cd535fd76b25c3a2c3e79ba6bccb1a5d8b4d41bd234c8e54e350a0c07db5d45f9d030292e64e22ac812c617e72e0b7500658e9305a244a76ceae6e141c4e727db72d265869ba4a4dc5c76a460ee912c645315e186f541b6b2c89086c2727635f9122e7263ecdcbe1a5ba2d0577bd75a15f5d79a499c9612ae4b65eb31d3a1e75f24ef487564a1590e5f219f57da3c7d5b912d8715ceafdf1c228309d47fb8fc64a9cabe0f9306bb16727d8c0678791d6af6e4435bc0f8e8d41ed23b52be7974d683f87aedc1c056bfcffe35b35496befdd05f23e4c7d8508919a2db82e3121c7710fa713df6cedb5f5c2df49f90cc83f22dc1ce58ce7513fa740876691b61180b4c0aa9362617f0ef34f0845c8eda165a45a1de0c3929918b60c98ea7e8448ed93826e2d8f953e56f6bd0e2d6066d18ef2fa1fc224bd6f922476f6e69b8de092bde204834c80ba6433e2daeeace0512cb79009e664736c5e738002bcbfc69db5627f936b6bcf86ad342e84a0c7162e4812bcc8c4db06559308343bb4d20db2dcb7c1371902db1a96a289097674c8aab44991a7e3794fc1a626f20ebe0ce92e682a4e5049f160dfe79864d1a330fdf99848f1c5b0afa3830604a66789e7c0c717b8c9e0878b7084bcf9b48b8eab0b2b58a529f52658f303cd8dcd60b7be2dd4510e128d03d4ac094ed00733c525a6469ac2bd5e25cdb8d32aa50aa67a10db5de79de4e5a9751b630c841e72332cf3235027d96574131c2040989a8f03e0e595ee40c00a09fa6cc8e9cfff5b82911a695cda222af84415de960781feff518214d88023895cc2d9510278a77201c7ba82195841349dd102cad71a156f147f24910f1a51755d890cace78071d024ddf4156eb7b0627a37a1a95c339fb193454f97bb1fd0d09d17992de428272e12cce1f7d99e0749d636249ceba045967d272145e894144eb509ea2e860b9563332100669765f391f6d1ddb8e30698a89122db4fe561c06a2d52e963d2162954f655bcc713cd1c8ca95447d811df7711f4c617fba441fbb6f8f662688fa538df7d9fd24d977dd1f1f42ee3d0650ff12a833863fb8f4b855ca76c34063914dc0be5a36b1f24b35a59aa3ff9da097ec8ce4fb2a13a02c01391c7544d11aa0ee553094f9087a46796b76026cd34b43a8ba5cd56ba754c50736156648dbbfb796e6dc82ea0f90e12dc413255f1308dd9386ec7bfde8081722dfc83b08f48b17588e0c4c0bf0ac2f6516b2b9c8ea9adb21d684fcfa482ff75a0938fffb0db5af7ff96c58f633943cd5be5523055b8cc4a98a6b9d9e14a975ad23ca249effb664a8a38786da16073d4c0ba8c5025d39a0d639827a33dcace44629fa9c27e9934d97af73954bcaf7c8d9d9e6d58cc9cfd7d0b31261672c79971965aa76d787612fcb23f61355317094f1a434bd2c7bbf2554172c4e3c35cd8adcb48bd702dbfdf0c2839567e49c33ac52031a93a94bd86c55bb5d3fabe138e3cba53c585ce89422885bf6a9d562031ca26452f5c69a29a0fc2d88f388c637ad23ad6c4e6db80594ac55856d8fe65f73aa74f2b7d5810380697de836a64cddf480e9b214347fee49eb272df1651d8e5a937438da846a557ce931e2b967febf2d04889c8487e87b0bb811ed7ffdd070b2c395eeb2a8ed72c6a6f19308f35620973c358904b991a9d7eab886c8ea44176d87ef7bb1c1db9b83d7e0d4d954d393d20204f2fea76d0eb9ac8b202769819c72467668ec0e696e64d3365a53ace1d5cfb06a31c78a9ca58b96bef8c5cd1c01664e3f9f1f6e923109c39bccc0c5adf1cecc4de4a42be8709a81218976835e7b2c54aef65c6558478ecc69472146f2427ccf11491b960a0844ae67d328ddb7a40dae2736fd0be568930162b4134e131acbb0fb42b3036940767d64ce6f0d1e1f758dab8c13cf082dac6ad1f952b6a736677ebd735e10618855bdef5dd0113d4323b127b3f5822e75c9db824304201fe626f9da517f39fa4cf0bb87df34006d5fd0c3b66889f743d9f51e0d0a3650e88785a7e009254412d2bc2d93b813124548aedcf99f0dbf7ec7b14e037fa09e308683512f94052cc04d910347fa36a57732ab7516ced7ad408f315bbe34ee180e04abd9b47794225df4ef3a0dfb73de200545c2a76ceaa94603525f73c02d1b38c4a73c9db9eb05720946ce34d6c139df240e6b43e892c6edfaf7c6d8e641d3c2656aef2dd00704bb73d8426ab40db4b0ea8944cdd5e10a28c057e771221b4f8c6126d37b249c2249d91ed0a157794f888bc607fd26e1074e1dfa9e8e5cadef6fd8c76645907fa9005daff9f6f74e4024222ff41e8c6bde0ce2d3d63810b7a959fcef01f304e5373a7b5cb9b637868eba2bef189ecdf9f20abf8234548febab682b8cf4b14e5724b29991a41cb59454c605c5d25f7401c026f3382dc4230768cfd03028c389d35db93c3a7ef732410cd8b62115b8903e62452095ad165df180c792abc20df96463fe400b06a23c763c64834a8670c6620594fce120ce9ec6bf56c009a12e0be016d2a0464e8d3724ef82841ee864ffd3e8fe9362359ce9bedcd846d94cb02dab77cfba35a240690ac306e52809815d6f4238eba5f1121b7688392bbfbea9fc02404ec312ccada1ced82388a6578159bee10408d67995a8352aebfa4c588cf16858eab9bab5ee6d2e2b80f1deaf45ade872c896fd3e2b01f80938b051180a3507a1c9e239d0360b087fb7bc12a7e2012bc6d8ee829b308e71e582c33d37f7731ba1a0a2b7bafd930d613d05e8a98ee16ddef43cc154b974976a56fb78eb161a9889d7fbe648e594afa6570bff5878bc304290f3cd6de449b601f00598d4180672db49734756012c595c07bef9ad9df43ac0005a73e680d77624567acda9e325e6bb890d1fbdd1f20893439915bc9a3fbb8243d7bd834dfa0aa3fc796cb5b07e58ec5f2c9db69ef6b5eba77921cf275b88135ea4f0619fa129b92c699f50814447faaf81c8042be9d7b341757603cb939c87317094ccf8250a24670163906d17a99d98c95c90e8d6dce9b36e791246f060942e40ddd8811bb692e8ecb27f41a4f6cd84ad999dd2fc4954d55546a74049ed07e3fc7f1af59610f5dec1d6c2612a0204af86d72c61844af718f214186c8b53a3d353b435c629cacffc8c4fbcd3eafd740d0d6d38e3ed7ea3364719bf4a03be7d65b515d22dac5f32fa1559a846d21f6d43a16eee5ece7968f4bbe76da45f06f9d14058e71558ce89a3cf19388c2fa30f6177ff45fed509a4c2390c52b363d0fe6250726c658e122d29331792e622c014804c356afa3ad80eb12e1733d395dceaf30244d8a5c3c6da7f5e5ad13de67688bda6deb83e05bc8ff4d5522a67662f8ffed906624d0df52258a3472f85528425048f45d527fcfe9d48d402fe6812dfeda2f4eb2d504ad905431d3336992d4df11cf63fb5d0dbd9238fb9a733d46a054be82ba5033b0b07740b4ffa2b6de29b7d3aeecdd402ca52e029844fe3c5a4472b6a023c839133c7930d080fb0832c5b684152c38fc02885852d9d9a65aef074877dcd60e37254c7eba9d714ae7f926f8896f8cf586ac53231bc19226bae4c054fd827da703db6cb0c67da240c63b2198bffb4481ea2cf97af2de0007db2f957e93734d315b21bf1b1a9c859ceb05538077eab8f92c4491c12c489bbe7430db13b53ce475f7d56f9f40292957f18955402139f51ab0375d90422b128b49f91c948abda16758b1328931f4dc4879d8ac8adb9c706aa7712fc68d97282ca14e88d20d8708a49b53851c7a75dda1f8f5a2ce6f4510084a32b71aa4698bf39b0124486517dfdf2a0e235e61b5f385f2e15bd645f2c14cb3915463cf846685a0f6820d6769d6a83ffae7005b957db1bd7b68a618d990981376fe802f79884544ee7df7950f770728ed8dbf70781c945a607d1d7eb8a40342a3d848f763fc3649306d6317ae34a94330765bf4c9f5508159beb32a93690198e66f8af4842a3921e93e5716c887e2850968","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
