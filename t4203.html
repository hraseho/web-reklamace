<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc6bc305fd2a0d4ad820a1c338b2a02e131049f111bf75baa1c95d0891c4057cc98b34cd72f12cd8573ff8ab64b6b77e0475724b488c7b7d6937190622c87d42a9c73280b5552d83a01c0056404822da9a957fbd34d8c439f3667d3398632de420b99f66368c1cedbc1af84864c35f73710dc640f75b512d1101e7a170da18b381dfd509970116482b784c3437cf81229cdda1bdee87f9040afdc83418008a4f1c663b9055a3582023d73366d60659acfdc20f96cbcdf0819783acbc364834d1c8a5d0f9e5bfab8e532c8fa33fc412b255fc9012eff9fce362e4840e6ac0efd827af2a4f09f6bad12e4a6ffc86ccb589df7a6a84df2ec88750e42f3ede8a7590a94056e307c2bf0b48ab193a2a64d62f184ee870af1c134f994183878e9de6edd60ed9b4329adac924b3095d2ac1a8516ac978b1b67daca029d0934ec764da4d4aff3d03291f5b1cc1cc22c802f7cb87c3cc5da02c19d9d0b632303f24da06e0019ae776047e33207747f30d2cd59631b7b76ffdae898d00b0eafb56375564d6c20a337c9d73d6dffa4e84c3dbe8c3ff3efb13b62b3dfad1c5ee91f3eff55ed8a9deb7244799804d4af8cccffff6e7f498988b06a63c58aaf93ed561472d2b64c9e925084b84d7a201dc72218c3e8d4d3cf26a43a1d0fac1130898cc62f414f9309785e2786d2829084770039ff37a14ebfc1abd28221bd79c944daa435f7110cdb0476374e06f060600d327e13ef346bd57179c2cabe5b316b61869324831bfa2a60d1d78f7e0c1ec4a19c1c35daee0e9776d59ed2151c563540314112853bb65ad70e2a038680ff521c13c3d815baf7b9b2811dac62daa7321f3f6340b9406ce8ed1adf0d3ef5f26c765a9721b07d54b6401b908b209249332c50c3299adcd925bb169f4060f05a4ec5e17b39823c03afda9faebfac78a4a7835e7290ae242aba39f954d622978a54d4a4c04416be32881936243b33a90acb5ad67431f87c475901bb2a9da2014b00e8efc3e4a6e7a354538b33568742818121236b5b1a99cf4a105ec193221f34fdd7d384179a36977526da7ec789e5f3b9adec9900bb306f4b733e5d71ede3c3b3ef0b453b6f5cda8f5da5bdbc9e714319531c71844e6beb6a13a29da583a359bc2e50d41d503bdf5f2924caae9698296e3b4de33f87151a1b8ad1c2dcf69aa58ab3f41c8fee2cecc7f07ef8664e872890b5725c34200dc4f122a84e2897604f0cbf4c741324f003df5aefe9cf17075d072c73dee5f4f06bd708a41055be638d3841a34fc420fd86c5d2223140230042f0dcf7f1a05336c4f228a0b1a2f026e1e2e324853f48ebcbc78c39446e009a7328874d31825c71aa49e4277b9eb2453bd15457ed21b551d94a8b8307a946af519f7aaa1f1a3a1a5dbf5458aa79a0999366c783366b8c4ec3d81fb676f47ab62834170250f170e498283b8c2bae6f7d9ecc0f2205cc9137e02c2aa601b04b0ed3cb98e4ced7a44127c8283dd2771f46c5124753bdbc82220a0208ea41b68e5288037a1c46ed53b03bdad775b7953ec8ce3d0b5da38a1cabdf14d2206bdf097df6854b1afa68a1199291104ba9fc0c5bb8969d66625310fd7add12a52bab9ca25619bf300226b1e7a2deedd9ba271352ed595c54f065653e09c30246090889d2df2e5b73777bc1b1ee8af5e4fc43b2700595b6634f623f7b7766d1bf67437a6df5f47ea54a5752129fc6d4ef9c64ac51cbcac524320233bddf806455eb20741573e3d6699c25e6a9a44af95449887db9994f7fb7f41ee3948bd310be5e66908a12bef38ce9a4a34186d022ee8aaf8c13b04cfe6d7e5e27ada2c914b2584823d35e81b2fc8aff0352418290768fec2be98c46d8f172d835c43a757de04a8e0767f2066b3ce01182f065b9240657554638e158a56c45ce345ae5bc1fd7b436e49c1716fc75543717fe1b6613f83bb51604b2d066b7619011ef1a2096b216f7ce8f46c352eec024cc67fc73d341064188d39a2003d8ba45387d2e8f901a8489126f4b906061b96c9b650bf91ef2e3edcb23b1423d53d2f03e69ed31a192ca44a6b194ce4208364da16d4e591238412fd7b07b0e811ad83267ebae0b2792de87f316a89e18fd9f8817934670d5e4642cfff5f5c51f51cff3c9dca10dcb05cac071fd7662312c56e167ad7730114ffb5d26f59ee9b5fc334dd523990d13c91d771deb904ac4f3b1b94826e23eebe291fa5b8114c702775103ffdad1124f71754925c021f5af6f5b4bf7ee7bb786a7e0aa9df07baae0f33c2cc76e4e73ff0877e4b72e28ad6b9f9639effcd1a15aae03670cabaecc8cbc97fe8166e7f363cc378f888e88556fe60fad20e20167b85a214052b08c43b170ff13867f13eee63ae2408c0b29d534c75b9d4ce4de60423f2f3faa5edc8f7c72cfe2accab9e1d8f24c00ff458d943f19676c44943d7874f4d22f2bd2cd82a711a3665b9df940031985a5c28a95552461c54b8e34ee0de86fb1b662092654944a6752223ec9b8a103d0c94925ac529b32793e08fef57d45299c32b8c7b8a1b858068ed0822663d47fc059179f3ebbe1608d13c14efeb5e81cf852716e20ed8f7d41c4e8cf69d59abd33c125d1ca7479fe873eb19734a7820f971a77a350c99810177c2c3707b6e7283e4287aa0754ff594617233c55fc1546c5be894440ce2be388ccafb92c76a6c8022528c0a8e1a4fac9e62f2efc9fbc0b6837d58e0cfc0e8e2fc8d388d5d7dc2a9f93be165b51ad0e5a651118976a86a6769619388914bd6b0c064a8de5f4bbef32136baf9e18277a33090c5a962288b49bf98b967ba8e65c6d892add73edcba8b7634e718744299e431bdec7aaf1b56ef2b474188162b853f59ae7ca5a5552b00e65e70a338ab65cfc0a7f07cc84f9156e7d4dd2290e0f1711cb257f08978c905d93e4a6f418d69e9e9f68d20634c08f1b3d762594a6c7545b8985dafb3c6b163853bd96b3c62ad3d1fbc94237cdb24195fe142eb4f16e5db799a1fb1e9c0689d40eff76e61941e7dd8c8287f53c09d81ffbb76ed255e31ce90002e66ee08a569636ed2726678d200c976e94c86de0d5e66135678115b82656bdfd301e66709a54ca2e7ff3f8c5d18aa54d9445b356032426d7f08450b2e1cac6ca354bcbca375afed0280bf56bdd946524e8ccb1c132f2b23c12dbd8918d2a5eeaf4b1e991557645219fe8d7d38d7c684ae4a19f0eca6fa88c6d601677825be62077180e592b7b4e48ceb1f3dd70ac391f906d887a3f82a9b729f89972c1229bc2a98108e6d11c61ddc66bbb887bc92eb7b6a979a31dede4555252c90243c93147176e180c11bd83f4179a6d5a900c4d699f1fca90681df20671847b2d7405de0dcd3b5c13dbf9f1673f50c4156badd230700e88ff5314876065d6fb9cce46b9dce1dc8c159f48ad3bc60a49e2dd3ef3b54fe1a256ac6eab75fcc2437eabb003b386937796de9637c20622f223767dcac84e5791302e305a3f1ba9fbff61396f10a53bad64195e024d04e6da731f6b83fd443564dbab0a0b6c1be03f6440a62f73c59c7e2128ce3ba5803ea97978d1575c8ec86f09e3b212ecf8b8d39c6c9bc306160e8fc0d3f5de72354b0d570087d099f94304c8939698b30f5ecf17e2ac0a820032c4a615cf9eb0b99531bf0e64af2340c7b5c4161e5a15f00b204a34985072eed475858382df103c7c68eae8adf271efd17aa0f6c27fa2dcb86902005ab29a33a1e9da051c69c88525c07dd81a5ec0613248ac6e02637499993bcf6ac3369c33cf0428aeac9dec2109f3ed1646b3924608c7278b7fe26b17a672e24bf170787ff91529c452f447add06bad21351bf8990acc9e83a9b141fbef5c958e306212ea2b8cd81a97428e163da5bd7c045d7929aa37cbe1ed3ec25570b8c35ab27853adf8a5b4bb9b6931f1cac081331145828285c743c5f80bc77e8aed51cce964fdc388f9dfe8b0f1ca099b35f2f0e978066a4830096236cf4f63d880cd4d15dd95e57dd1a58c342cdbb2e5d98de7206121a5a7ecae55bc1f057dd322aea478ff31000e5392aaeb08f21e2aa49367922ec50f81d7afa7491fbc0e8236dc0deb631bad0756e50dcd63b0a9caa2a3b8cec698d84ca4434d18cf2563bff6137a4aaadff262740c7f13c4209822ba4b8a2a446fc1bc77edd4453a53605201ddc9ddb05ddafb85087d75db19c6df500c444ecb2b1edf1aee342e2a73b494549d154ae4e5e117a00cdcac579f66697c07aeac41590a5bf7a1335e03ce36948678c9f70eac8d839247b6410efc5e31d9a18a4272d988ab71f084241b344a52cde1e84798c249c915069ac6a6f97ce6746943b6fee1eac37e1edfe77fdf16f6a6f721d9baf4adafba4408b0046e5ace9bf2f49202b5495d62ab26af01ede5cc18a8dfc0fae1172e8c95fa881ee3d74719326fa4902f8d01799a635422c6e97e239f76a1ed0716b9256b44f55ac10f718d44155a5a611ba61948419a69ac478cf18a3a4c91b0b2d734d6847809f62d2df93430c4f5b3e51238b6a82e24db03d790d9dfe9393fdb2a1b544a388b9ee0cc21f87b839220a6bb39c2eaf55e51d8c7c300cc96a1342dc55b01ed7d1dc39821036ab1f6a56712cffb2ef6d25d33b68f29d1ec8cc0c4d4ffd18fbc3b9abedf95104fa3c1ce016fdf8d2e1b05323dc83c547ebc9f66f0ee828ed565dd8f4426e995285d729be27cff2ef5ab3526fdc7df191d0e5c6e2ea60479c2e567a88d13c2c33212b4f0d483c3860f4f1a869b688b75a554d595e613005a2cc8564d2b6ac61aedaaa2467ed2da77060b01c83df98114b6470d293dcd0715322a40d5e876bf90e0d2a1eb11d833c9ea19df0994889db1c1838222e2aa8a6522440078cc4efbe2b1370e6b157de2ab00c9489d7004ac3dfd3d773c63e0f6c97127282b9bbf61b649c1e3743c0258ef1b579348cb71af24d174d686b51517afeb43aadc584a769ae81ec0b440dc7c7840f1acef1aad56f81c7f445c4d05bd3386c51100574e2465e332863841d40602329aa6fc5ecc1b971a53c02b5c9b01881a8d6a3f36b263276c3e6b00668f4f5c73ccabe0a20798115f78ecfe02ac830eadbf1da47485e81d8b60d293a1501c1749ef278477ff61eee891b614a84323bff32205fbdeaeda5441664f5d2fc5f35854662f88aa0caee6443a82156391d48ce96573acca8a94f6858602f0b7954a3e4e3d57c56b03ab97f51912ddcf3d239163754474c4dafdca3883c08ec4f3b458aa42f194339e1ec96890f0d5364a566cc7802570cb219df25506812f151a4ab6477696de57b9658f23dfa98c993ed28beb7c56d446f97acb6b6a904d1067aa33943f7d7173115b88b59d6c7ec02d355d4b6bae4023b077d28506f00b1eef710295ee91bcd14787864720358cecf5234c61597148201a7317502c11ac325ffb093e600e0eaaa9c21e2e6a055c362f338dce8fe610a18557e0f56befd06a5933763c1d7c917c63a6732be10c9f6c9a3fc4561d459c0ef11e6c12820340c678a5d96760f2ed8e9ac8899a7482d10b607bda7fedb1f0d9855bc3b4103ddadffdaba1311f298030a293818cd8394c33033b263c76035157a0b3b72bf80beb95a05c85812cb5e448f6a8abc3ae11ab271a996d17391ce3a9d6e2bc6e9f1f40d555bfeb93c5c37028d8496ee323b9c6b4569ad9203748f79afae61c1f8b4414198e6c8d09cbc864250ced2a1e00630440ca838161a01037d9f66b0b11df41505d3a7e7f39a2711f71f2a00db7acf9a0c7a633fbdbc33addb178672e40af5d5471a6e869c8cd2cd902cc87a93f5cf9399926718635d82743e41f8570a473170a9a4e0822a0fbda51c5db520347f36f985817e55e559980604c098ed73b5a71e36712e1561edbc0ff7fd1a2f99bd196abfcf84ed772918428d3c59e6a53c0add294474c668e8a345e4e9eb714a7c3815ec666b4ff44235540f9e0e98a2a27761d62cca8f1c2f42ff503d84409f027e943336077ed51f7aaf9667468d91c3d15b74702fea1f5908c8aad0710827573a7b3dabd9a1679ca8848d072983277484899603b251b82f23905194071b826708706ca54d9921b5515d1f6a45ca86e92ce525482bd4f54fa93d3275800385eeb2fe805f6e954eed141f11288698e52e2fe5705bc00baf266b0e4f617ccd3a0efe2136304bd190d30f6b5fb3c445de8b670f99104737f23e434de384623536d9a7577a68c25f973a3e3551becc0a0323c47e7b8271400eb2bb8c766caf834cc1af45ed09e702903d24484e4ecf35c704ec6c1634b1bf03015927657755b17d7bc1a8bb427e47ee84c3298e483fce24bed9127d6957f1cdb4f304b1145048de66e62e560b65551ba86dcc0a5e00eb0c8d029d6b390ae5a61facde70583e9465abe56ab16885bbc97ff633c675ef14ee48f51301ace78739da42f78ceebba8fef3000e70d92a5d2bf1558a1ea1eab0e2edb59f337ea706c81388c50ee15c3c7c3f255921cd753dfad606a7d6ae20855ac7be70831c0b844a800a26fdbf9f0203696ea5c1c1f208793e428a5c80d1fca99a40c248b2d3d35358e1767df334fd7e7759da4f1e35a3b8114df1be73a652952981d25a2d39f043a96becf1c73b4713e1013b529de9c782edc263422efbfc284f7bfcacb658299f10639cab3d97319adead4fe48b88505cdaedf2b55e9231b4e577a4f314d4509fd0426266b42ed00181657ffe06c9611f0f3c12432d8b4472edeebe03a038bc3d2c31c666ab18885850cbe2e6d67aae00c66efc697151937532527d0093d61a30b6d6fd5fb5a4ecb6aceb9daaf4ebc21ab0fd187ba27cbfe2661432d9bf9cc8f0de9290df5406df3656f6b1daf1b642b8d4c8fd85e05634eaf16c378c9bf73641ef8117b7b3bb772de408a04ee415755571206845e735be260f9a830d1543456c29160849b108bff1538ea433e788c71756501e4ce954e82a28b59e4cb6ecdddb6c6426d86c344f66b86a8ff05bdd897bcf4c177b422171b27bb573eae4e39cb3d2ea96af9148ed1e54227fd6dc66ac818738ca2be4d506753fe7ebcd68eead45477e5dd67571633bc42792a2c058fa118e59982afaca5c4b8c92bcaa85262d28b72996de7277c7cc42b277e997464472baf46ceb4fa58bf79ae37799190ee9c3a5692863027d2af0f2bd1e324e71972b06d272f18d2d0c83f270dee924aebbdbc2891ced66ee57a629b21fea9ac5d9cea82ef955457063cdee4ee534590e27d3118fdf3307e01a9300f0df180de8336bf3c86610de3636757f5870c70e2d68d484934007cd4d3ea37b8b802bb7e0b7ee46f1cfe5ba72f37f209046f6968c4e08d45c2b216da6c5e3271968eede2f03532d5f2a34d93db54f02b0d0e392998feb31111fb86b8a973f8995f2d0c89fd9fe30641a6c29e32e6572f51f44b3024f056a97e3dff10eaa338c4a85b5941cb1aee4a72234c1b42834c2d71d0919147a824fe3fdf87b63bb020a277c303f8338358f101deabf8defce8e985f0ca0c15efa1ccc4ff94400c83c794bdabb9d5490757f9283e1f54c2a471d1024a6080f7cc0247eca8b82df4a97668d05b4a5d8e1d7e05dcdbda74510763e3a25c5c7898ed1a514e4f997c6471728e639f07a0d805f2379196f7eab5bf6612d0e2b54125111c6033830d2a97898ad7b7cba164122a51b5bcdff0302b7d2a4e1b51efe5ffb2890d46fca6c71b065f7e27a075312993531966d4804972de878ae1899965c77f01466a29ef72dfe1eccf5b371fb7bd77f60ca1b0dc8368eaea30c88319dc08cbf5c410b8be529f471ecb4c24737b5c945fcda25e9350d8116d8fd5608135e92bcafb67cf39a1ddfe7d30c84cedb7d3a682c682187d8480a28d54eccbcdd270587bdceabbe4784d411353bc5bcf66e1fb0f70bee47e2f195963322ad441b0bd0696695611c7732061037ce44169f2211c4b1b9150a32a82c899de869b3c48e462e350a3ead8870d01239ebb48a94e0e41fac55fd7c2da1edf2ec842d5ba8ab86b93c38f3f19dbc09d8bca8697679252bb9b703875451931e82f0cb1dc4b918a70ef71b54285d71605fd9575fed42adba0ce5359952b0a560b74d96b4ce3d6e50a4af3b8aa6630226aa43680d6bf9ddee6889cbc3540f8c4d673ed29cc39df02ee04f05cf35107a9758e3bae2fea842bdc5f4f3bb109b10eb0e338441f6640594c446b611d3030a01dd138c8eb04ae585590ef019fe09731c8b67603aac0048bb8ed1057228f0b68936080a5e11f70a7d516bf70aa0f00c831b402f6e882f5ff93f443472ab9f7e7bc6102b4831f23f914fb3203fb249729147bef5c34c73b7cab616cb22e3b06ed988145b0895ba2cd68e403fdff459a7753cf7a72564080a97df2001a86df4bda23b00e67cba6c7875f52e11d70d980fff21f0980d4e2f7e85b3273ad79c9bdb0734de118a10a2130fb1f6392d597a696af89dd17d9425e72a9ab947c398d85a7b48d03d0cadb1b738be5c9e0f846217be4789c65957568b8c712728e7f5b844632290f855b428a959bf636ca677c065ea667bc6eb6aa035e65ae89311796cd5e77fffac668b3e7bb0551cf241f2cf34283bc5b31a9f34ce9061abc0dc920173d8c7743679bae92cfa3709bbd33ce0a0c79389c1bcac97aa118aec3ea1e38d20f3dd28fbe126f076d58888ef09048c6aa39b39d6efaaec39ee3749d204be487c98be79e2b3733b0fcb36a0ad3f6042238f111014c35068b451ec606df3e5a1580eb59bb600286fbfcffa24ef9caaa0629cb76acd224238e24f2767e4b5e1d0ca619acbbefc930c4537256f913bfcadaa8fc7b6a92852303673e4b9da9ae134a7445fd97b4a6361cb025a725227181e6cbc490739e7c081fda3db0c3c373e32baf66e80808d4a3358ad6db78ef0d935ea443ae2980a123129d0beb8034278959643d277479778fdb03650db09a7ed5960023e77b0b7663d9ea5ec814e43df99ec53a0d98595202b4c6f5786775798df8954ee701462533e9c9fc9fe0a8dd7d4d58343fa25255ae1565e3f1038311601aca064cb991557954ab1f8b96d1f93904b6bc2d6285d2ba55e9d72f8e1492dccadbf070d2620c19cabe1b9093b6dce3a08790bbac72bc2cc25f7ee6c83a3c2c38dfc803319ba0f3ed0c8f4888b03bfbeba9a36cbf9ab42d3dc26fcc92645449eae1ddae5d37aa0e7b3d9b1365dabd25ad8fa17edaba86744d067b1668072cd8506bd204bada4229e7dbf864fe6d8733cff52653ff75e296b6fa10668f6b2f3607cd6d2dc8a6d1f687a154c3f02d9f1f5aa351469c8fc5b1fdf142258c31d49ee329798ed1d948cd62afe4e020680948079784570bc2d109cbacca25d8ae7ff22f379e345189c8defe3c6d2a42caa5439790d0db5676d12882b768ec018168a7beb88346157a1db1a383391377efc75f7b652dcfca283d768dd668244b5f2828b41ef0d9db0693459a8492feb8f3417484ef8d4d2a5319afd8fd47a7a85e1dcb0a4f01255d229d8b749abdcff319195ba6f41ad65b5ad5f4ec171801dda2310be9a6c8f9031b91c5d2a6858cf702cdc87408be906566ffd2d47f9b486f74682ae7d0b87c5e8e451eaa897d2eb04765c4dda73c90774408b0abdd454f76295812565a430adaef58886b2a427adc21911bcb5bb0edb2ae1ffa63a059b47eb09205baaf562fbfab8cf57c89ab99d4d8195218e17fb0c936fd86149cfed6380ac52a29ea42b919df742c33271d7901d01eff7f014f7e4121cd584d639fd8fb922f69710e010e4bb9260c7cecfa154737512214be629d97df1e0fde83fb87e031961502b5e633731ee276b34a83578955f3ac353f626f5cbdbbaa427072e5b79cc3291179c63f2bd6a7692aa1ced5c1e050cd6e40a9af21bb2307d8fe21e7b36738e3a03d8bab707add36c33","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
