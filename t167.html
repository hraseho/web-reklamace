<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b6a45433101f36954b1b9f773ea4d380a63c52f26ea0388850e62e60a9ecd06e2bc81fa2fdd9a7d4d7f3ea0dcb85ace7a8e5591a9ad5aad4dbfea1eef093ba810d7092b70179f552a7676b1f1a73f80b0e6f6abf4ef51a1f10f7c9bf5a14cc565db846e83937784fb4f59547dfe6db13e9b111fdd63d6a8bfb40574cd0f45c27bcd7219c429614d940a4040b89c6d8998531be489506bcc4876a2ddcdbd0a5a1f5436ae2216966aaa908d210b75c12d3657feab1d3ea2c8946439149625e1905b7773d5e7e072301f1471d5b74cd72b759e90e65b89586b4ff918c95f876a26c8a0e6e4b7b1863d9018c828650e18e238e8ba8bc62ea83b3d4a0ba2af365ea4adf53942070ff42d8f9261096be42ad80befbcd30bea210a70cf84a02c01f450dcbb30c4727ec35e7bd1444ab72035e85fcd019c88afe438928c944902ccb2bd50e6cd2101861390fa0ce52d3979535eb5365b9307cab50414f5964023b9cd4b64dff0a30fd64218790d3eacf0a6dbe054d666b248e076d3afd0633ba7efb1ea09c7e5113498cdc399937720d8078b51bb27081520776e3f4d66519b26921bef7e0267edb38a569316d768383de1582067747c02178b707c96479a834a1c64eaf8ad66b4140eb9e26223a7cfa7136218e25fad57bc9e2c4f0b481d3cedc0484a9ddfa1d12b79fefbcf4d235ef5d932ac5a54c267f132a51b114e61546044ddafd4c80053bd4d0f671a7bc35be56d7188a8e642f345d05ed00fd4ba9baede41ec9636f368c9d9ae171d9f5a41f9401fac640f0c97debe0d1f01e2df791b8b2c7d0aff6796925f0f36e65f0b44074223847990dc915d3e6e3ebad4952c527903b05d82e9381871696b6837a9ff511bce160f6dd76eba9ccd4221f302c00138aae2a05e4714f4e6332e3a376775999f7acbd0c771102973c1ae37f27fe795fd138d39c48e687ec8bcd14085305f8adacdeb868d5ed19e888b78e9e485ac92f6c2b23bb03ac513b5a798a105c117f8e6a3b159647970b2f4a31bfcb2db6d3a7aefb3857dec27b26fdd8531e5b8b6086340be5c98ce07f5032fa654ae8d6d8c1cbb6a1fe6bf61f3d468d70e1898ff0965128ddd38a02ca895054d1da967ab8207bec44a05ab0d2042feb5fe56e70cf094db43180861f36cfbf86954190258f0069007513fa2ab69c6d06153cf098a152bdae3a7840691fedcbb7c76f15df0005c360f6f53091d370ce0b3ae0ebc920dc160337ba7de1a6902925c28778fc7ca1b05aeaa7153efe1445f9b9f434c2f3f1d6c8f071232146ec552f7bd0fe1a5b8ae1cf600b9725bf092e96a1d163a362f76d1fa2e536a6eb3f59a4950d89caf208181e3467849b5214cbe26d4a26ae987e6d729aec816ebf99ecd15b2b8456df806c0a424c8dd68be77c225467bb816be496f85e6bacd0e2d72494949ddb7692581378e406ae98c426c500d0703054cee3bac9786474c8fad84b2e96e6c6e92a1a4e02c7cb9d4accb5d771141fc95380d5bfecdc5a003e279b20246890cd62adaaebfd1025bd3a029c86b8b2df3b3b0871394107c9dd8e88c89d3a4627ddb94c98ee27d79512ececc59e3915994fd4660146f4309aafcc2fada6dbed975245f5b70dafa2e5e7cb138032315990637499c9c3cc35bbe0214a9c5905fbbe26e0d9c723e542570303dfdab4deafad539d0c711f1e7f2bc889e117f1bb07cfe9702d90fb87053812a5d5e75a5d605b387d4722a7c67e46d580388c4f4ba038e4b0ce9d05235692a593fcb8b72770bfa1d25845810bd16706303f9170768a4cef87aebf1c7b19392c6e44c55af7151589400623ea35935c40701eb46d294faa44ebff105f13078b9316ae777e986d4653d0e4980e4fb70353f2287f5d39728d1f7d704220080b0cf0543e9a266b452939072d262ef0a8c98c8c7d473c85ca688e1c543f5643d928e697d571084bea8c0d27607accccabd0987edaea4ac6753b3d05e22719ca4f8b48de63247cc628d603360b295e4865bb1d7944c3e89545fdd5aaa20cd11f3d4a244326e4f5fd84173835cf688e1bc8d1839076a2c50b30c4991d43fa1f61b1c510171036e3dd7cfc855e462dcda5880b87d1c9f12d662d8eef402b0ce2f4c29bc429a988b5f63bb08da6c638330b2755cbe6fd9c46ba105104ba9fb5069eb4925f5af50382ba097df87a28816f0a572539ce0105474ff9ba65700e3a24f62f2041fdb29c82468096b0e32059a3dbc15659318f70e576b545da7bcca61c33bb8797bc193598b0c8df54fbdd3ded55c2f78e5fea8335cc17f3f8ab286f2ca823451abd4101b7fb6c1bf71bb1b7cb2f66f2abc3f9d3bad9192231b168fd95d5afc914bc3147af84aabb5a103e06e9446e5acb362521b90804f1237e220b0113d442f1814bd815b9021fc11ee2bb65f900302d3d491228d7a7aefc4fa9f789472de7f583b5a154d832af063c4e97e6f80e5f7c4980e8dca1a274d97dd92ba09f331ac561c8573940e7fab60659ee7ba9f4e4b2239885b62ec462ef45186000c3b9cc99c6ea9aeb47207d92bc1c498bdc95f23a9367ad2d7a87a56286ed7bbe22311d1f027fd52e5941b5e15da75a24152bb01e19d29bacbdb9fff2a528d60792e5bb8b07bf055da16a1706d58e51b4239766a78f25f93214cc3ebd434dfb1d94381c7c6076c0045dd83d1e5b6712b4aae751f4fc924ebd7cd2884860e434264ab31626f2d050d51d542aa534806fe5c9f0042bc81d2696a3c1f031195f281ba6e2bbbb088ac7abb52b19bd0e3168203c84e0e8c4bfda20de2ae66241f9ca0382c55eadb48354917e302d2368fc4cfc39b8e4c57298b5acc9056f16a44df8ea7e4f3f148c9c9d83b508e4ac4a21dabcafe02c6103739b1f8d8e1cbc0a845f9b8f9d87c0fe2bd3863d4e52b906f7dbbf380874082fde8a91cdb971250566c8d6acbc156ee9ee3ad241926fdcb727d6dcffa56e625abc22207aea239a937e1df0d790343dd6734f4909278a79fd5e7b44c02d69637c2029628e18bd093ca17cfe86988d9b082501de3c53bbb91bf0cf3bd7a1943bc5e1ca3eab215b4d4c54cc2f4c6c9c741f91e44e7ba38b07ebf1e2d00a84b8eeb5734760edc40e3da100b0bd1f74c8a74049633cf944f9c1a3fb51e9202f38ad373eaa2647b55cf794d1c6539c1c7f5f8af8795b133649a2ffe61fb5e11eb05f336379eb86e66666bdd57bc19ce7cb10c233d78b143a08d2845c56a3c52f84c0dea2cf9a600d1e1bba86a4e48ff85e8af5e160dd20c4843107d11c862866c076c597fed1401d2c00a0afb88f2afa14e8a0d1a86408f1df0e40d905e730894e1ca0a66e12b8d2271fe0a9db4c8d6cf7b3510705d6dc9329923f2e42bfddf0b6b3cbccc73c9d4e07ef3eca4d917c0971c5086810ea23ba03e27048a4c032bdf461f5e432e75474272de15903c7a1fb629dc7bce72a940827735944e84cb4f21fd28082e111ce86d08c43c552c80e2bc50964a6c7f9f3bc2f22830346b20872bfcb8beefb138b3f67ac32f6c37c152ef11350b290351dc8a5d906406adbf141610cf65fa00fba1cfe9280ce78233b73eebe2111e3da403d4ca5c1bd30c01d8eb35d825ada691a941ce81a2f9aabf3caf4b1bed0e7d25d424d666e60f5e0cf71a996362a4ceb651d9f12ae801d76d16458fab5acb06c3b8569b99f229329fb89615e5d4aca10ef883511c5936e1ff843692a8d49818755ef013b1b8d857058b1e4949640e69adc2305a5bf971cb124cb5e157da22f84dbfa2b17591ef09373ccea4a842f72f5b6f94c92c417d95b314366b8c092f4fafe743240099819fc923c2a03a347266d2b791c129a43f293546acac12bcb4c687ebefe80d2eef3fc0876e85efa021a99167b4e046fc14b4b475f3241a7c5ff724715eca31e4e4d8af4e150d1484fdb3d4b8e1db6983190233fb994ef8dbbdd4d0680947fffa19759a357bb9e6bb8ab10ef9162904a4be12b818591e395cdacdc22308dfe266dfa883361df8d06ff95a8e1e83af559b388c53288f387e6dd6525ab1ac36cb75873c4efc754b1b919f88de0cd2c1ac37c8c7a7ba61079717178d79774d9ea6da97091fff17c0e1f0f3a461a585acc7cae55f3ebef250b0927aae5ae823d73ba958559c87ace0b7f283b52e3ace2a77047e52ccf28eeb54bb6b3d2e15d13ea7d2461a4dfd3158e902db43fb6a78c4d25e130f7175296b1a5c682d9da66e7b783b2ba4196ea02a371c5d7e52a47a8d24f6c654231440536fdeb6de1a58e8b06e03a60b1de3d202f7c5969fea67f5707cc7d2839f798856b4d5a700d4274d6743b1f1a093d712e80b384ad03cde970fa3e8e7c95544188153bc12259e54e9157e1a32934820886492e8f7c3ac72420439b7a766bf31695fdd4261eb5fdaabc4ea31c79410868e7d5a5b40da295ed16fe68cefe02a1c20c40ea0f941e104fd2dcbc7934b507c98b7a7746eeac7d663d80cf425e8f90090560c9a58022d78c34c4713969f6526f3b23835ac965d8ed382d7a696c474bd1de14f94cbe30744dc448ced9b4393ef6522169505b896a97c1bc205361905a02d77f1dfbb422c3014f1a55dbe40d7c73c57cfe9e30ff6c19ef9378b954a9dec43b9bd133edb8a90994063f9235a5e315f03f230e64056ddaf01088d41590f3503749e27168d44f20e79326291b2adce7d153999dfa4f05d03f98cdf533c0c0a43f613c21c5d2badd81098446e002fb7b5b54e0f94710902068594bb013f8718e515a8d44d9bde4697970e6b06869e5b87b5a6683fdc0a3a121051dd4c6b5cf66aad4f61c1e712e76239e3aeaf8d71d27e1f47d7a82bcf7da6b1e01673d9e1218b56f5913a688bee347a7022213067501291e67bffe0bc796730f51fb6398c4c47d3ee643f369d8f03dab0210c04b44f4d764fda0c4aa822870a42e74fae6e73ef5a3fb620524fd6534bacb7ffd38a9abf54a3e6ffcc864c7482e754c71556b5f78f83c715e7a794098a5008c3cefb1680a85a09652e85867b4ec81f174872fb7303ec7a57bffd9e7d5987e74f908c58325cb78b52d4c429b340b3d8782c0da71a1bfdd1e82503c9c8014924f7b6a236173e9e669b405364ec21db0ff0d37ca399cc141c14ea7431b7e5dd764cd1eb6003d0ca884fea2ea48420dbd210e0aa6bc916c9b08061907cb4332dab908a065ca34721412c27694a49be8c608d732e7f210d971ab0414b183edb8ab30884aaf78f1a1ff5364a29437d537c04ea51f8e9cea03e3299f794ff57b5680e785f3179a3db93156f6ed9d07ec67ac690ecc21f4fef14aa17dc39c801af81bee68abc37e30638fca7403e36f253d24b7b907ffbbbe34ed47c46da4e939c2335dc68b4b3c90721b97659aeeb920feef27caa96cdc029bf473b6cc70f4a353029b7e5ebbce414723f58ade48e0f18358c00923355638c1eace2c282499220dd1d87d9fa0b390489fb8d17b953bfa528b622c56689c74b7644f047177b755167f60e04e18652da496f2500f8400e0c5006bb08ed6238e93efaff845d6d9c8622ab4a6b0c57f7fad83355d417fed94a72a830fdeaa0325e9bd29e6d1f180d2d84d666f1e54b99dd424fdcc3a33e04b516d03f4a5c059b553d926acdb367b46be71d2d4ff8bbd859f1602291d8eb10caea8a3df3645979050813412c31977a1633a162c6e8deac89c6c2df478064151a55d4ddf54223081048746dd72876b17906c5e75cf330caac3fa17762ab28dcc02cb4e91bf617a9dbf54fa90e59e71008af63d30cf328f4fa7b5b6c90901123441665e197d74c5abc22a93a1b81d3d93c2cc4ae1505f544f8333ff79769aeb38e74a007d42341780d2394e9c6e405554e727df85d20ed9750574c69959e9c6523857666230e227ad6b43187acb6be96c592df7c730ae1a33c4bc52533778915b79143772a82706395857c6447d94eb3ff1eba7be25d3276ce6d24045348c6d36a36a9a2ccf8d5c10ade05aa5ed872f0a8d43a1f631a50c1b9432364cb8f56019dc1a42806ec1d8be4fbf9cd4c08dddc6397fc0f531e48ab85abeef27a948137fd6aeba02ae2398c54c5bb0623280ef83d9fb189897d1ff84eab7a7243c8eb3007e1ae2b867b9b2fc8de50edd0a20e5b2fa0714acc2e844b61f2118e82035cb949a21290bf55e701f96e3cf90aac6c0b87d334901d0ec343cd56ca3019f4b78d1fd3cb75e741ab6900273912890e7d3d0d37ddcdde39a0511c243e6cd3429935dd7363513af36f5aab970a3704ee3d8a5d11043a25fcb467f7f4c98a8b3a4b7326f420b46f5520bf78bd8a8b7de390546b2ff051c7feef7d2ad6a6869c3088ab9346045300bb178836e92d18c04dc8394d566b1356d281a9f208cae799379d45154e260b993a772c9a0d28f30b263c2ba23722d3dad65d2574b6ceedb4d02ca99d2a0480d107632812acc19e3cc7b0f3d129bb7d5ba7e3f3be664d36328a213e2f062c68333829ae884422fe086bea2da5a264aa3b7defc989b96a922b96f52226b9403c6489cccc8378889143bb1ce638b85d7369633d3d8fc59e8e58d5eae1df3951ce44f2db5c034c25e25bc45ec71bb4cc92e10255132e89fd58eb1036f24cd9884da8519f5e4687a985114be4538d50779a250153a5397a170eeebe51e64f8fcc5a7c530dc099be9b5e4c7814531f5ef256dfad07c4d21ee3dd494038078083fa0f7a668f307b499587d07eb52092ee9ffbb563e6a08999d03faf3d571207f30768941c0b06b31172e02b06000fdd8ed279d8f87286a9e0ecce32bb2ddaf384adb749c4ae139182a76cee277131f7d7969895dd0fd79759d2ca1d6d8aa61422c9c8d2cd16832684310ffeb493464465ba58369ad7cb50ae62827cbf5d552ed4a365f82e8b9fc4da1afde491f5b16f309b73caaca42952b506c17191e1fb9b494c53bb985b476368ef9378c14af8f432b388ff6c6380d633d3ea95ed2aaffed753c6f1ca39d68d058cffa216f72081e750cfea5efd772e9e514f08112db1a7cfac697d8de7a91c102043cf58b09f4a3b884ac57b7a0e90116acf0ba39329b91465dc02b2c77c63da1b136f23abab1fab5bc12253cd6073d30efc6ef7aa8fc4492acd160391d4ddfe3a5ce199667d7449ed7ae37b6065c55d89b3fe040260b15df29b3e9e7ecd16b04e3a68f730c9c7434cd209d156f588b43a9e36d55a0c7ce769a46949753a2998563da3b023a87ad00c3b882c7dc3c7508740848cf0f7b5f81185efd0ed0211267350987d594ce9dbe66a735f6be2c2b8f8cde795e4bba818b1ecc3a4316842101f574c151a7bdb4c26bb6b02bb544ff2e32babd43e94148a133b3278da283769a1fbc06157bc47eeef3652774371de7422ccedb07adb968a440d1f456cac394f6785ea9a63754045470af2212d4867ddf7491da868b4e57f6d370001a5d20d4e75604644f50d0a071e8367fd8e2ce8953ec1f56b4de454a341a1432121d443e99b64c275c17de6edc2d9f32b55ff695ce81319cecc8933e8c8e468269fc4d241dd33965ca3fc00b28328fa05e9a966769c466c35686663ba38b3ee76521dc6871dcbabf17f778339f680480fe82d846c1f487995c9339cf10b8d3e534cf73342dcd333c62e192f3bd9bb64848929859cec4582fa2cff06b5c17758d65f20a6c76983842bbc1ed49057f430f8467a8dab0f0b8d208dd75f88590f137c1e6b20e1424897ea549dafd798b381ca8351f2a6f8dbf584ae43fb69be971ca831a56e4f7b4d0bc8c4772c46f685292999defbad65a9b443db0b1d21d80b2a584fd06dcbfff2ca74649c5d53e9d2cfcea318061c1c21a4dafedf9501c39e69c70849e6eb7c0ab104d0b175a006d2814e4ba716ffe9b49d00f92aa6b8a6f90bdc4df38b3e03e9d16b2ef71a7ba41f3bc6d04b25c5ea1bb57c835246076131e8d09d12a98c2a9f4cbc27d0853952aaa400cf47e598b5b5a15172ee0ec892f35cab7f99c01a80586b4bc8b0f9c6f0eef9870df85f0d0b7861502c214ce3228357390af8621f3048ccdbc793d2395e01df1da2c75763c4b2d6fd4e6404b691c0fe390bc3b98fc39b39a6a9539a8cb71b7ef270a62c021fde20dc401f21084f9f3ae79d8ad492176dad06494aa9bd7515d71439c420aafbbdea6108748c907b7029d9c4bed2cb704ee487effd4f9e614182da93c070a1caf1565e50142229733c989e28ebc312d59a5cf544937e9be60316bd72463c8130d1020eff18d234fa404110312f53bd615ce987155ba566f63c31131a2afd862dbea9fffe1a9b97920f083446f7595c2f95e3f7d1b301fd5a95ba2772c9aa581be274f303078bf8a9a8e114f3d4a53f5ce3d65632e665bc0d6ed36a42a55d0075d821459e8b78d363f4a83d76bb7bf67627a838ccce18b4f0b277f26701f4b75275268c91f6fcbf3470d41298e4096f97d16476dc201240575f105cbe8cc9b9a826420ea923094cf450ceda992139bec017ae5d462e34405323473bf67bf8916c16a3a282f2e774051ecb512b336837ab3808c3b15ce76f3ed811121fff07d349a3e96ae52feb2beee6566d652c316050da289969bcc0d2becd0504a0d170e712aad93b473ec6da37ad77477b8cf49393d409fb499f23c801fe931eb32619efe1fe6cd356e0d3f3a9bfc3522d2d72c15ef8a77c47b84651e745538f6852c23611c88b957b2d4347ee7e46efe4340fcb82258627d215c0369ffe854555d8be1809f1c41e5fd86c6b486b1de06fb2054fe68921962dcda6b760c5724ac0cdff541942f6fc696f63470be1a60655d4bcb032e121237ea6c43488762c20665148549bc16e4a3de64985d5a572d9505dcafc7ce604faa69d3fc95df32d3b1d80de34ef1f0d3fc4bff268530134938e71ac9fd0f344696d68eb996098ac18e4f3233bf6b8b7f206b91e0e9c0844b07160ba7ad989febfb3819711a65223cce304c52d21d0c60efa860daa0a40e5958f0951c3890a0b261ba737ffa629606887554025ab1c4fe3c9cd0b4c014bb87ec40db0aa3a73cfaac86c8b9c5e76930d0a2234f9d609794c657f2d87a550523924484c94a3b5acdd8aa26c0e012079727e4bc231eba8d8eec833a8fa451fbc9b8945803af4a9af2c7a4fa083d41edd1f882f5ed175b391773ea0b3805f0a6f03fb8a98b1dd1277bb6fa16f4e373802e46df70e38c71f14ba0b6cbc9cdf5dbfa23af60446fcd294b7fe3ef0be7fcda683f22c41447c3ffd194602fba5663faa21b3c274be385f4d570184e78d8599f9161a4e2ac654123368ca8b4350d5d81a0e85b34cfa4539d7898d9ac7cb4cafdd109ca4ab379751d19ba3f5b4a2c4f20ddf0490c507645d1e21726836c963abf9a180dbf6f75ab51356f9ce18d77058ad5d5f06bdbd71b55ce0168afd940f17ce27c170be5c47b3d8ccdbd2dd88dc270b66a8ff4bbe250292b92aab3cfec91adfd53dcaa81407fbf6503990683bceb4a19c6d3e5fbc7cd677a6abdcae9ec08eded9b1fc3c73a68c4e203869ecb72db37bfa24b81c3991657ece79d15d319f88c44853b18a6f0eae5fc7943abf85c40e3746beea3cf252f1c3e23699522251f0b9fd66a446170488af262f8bfb78059ca3eda2b5ca1396727ce7b18a6070170ff2456cc158c5e4cf1dc0b7a38ae6374aa5a17cd90104dc65f3fb7e05cfdd95a1f7bd31afdc3198b5cf7b85c471e656a89982cceacd73866f9288431553e201cc82325409c65ee854abd795623095a6d2539ddce917be4f487bae12872aa0a40a15bfb42a621ff5d51efb53cf3b6d7ade52095bcc0a274f8aa2209e01abb43db59840d0051c5fa2ccab594b7c4d954f67d7a226417456ae2b6830cac1e41cdaf92f2842ccb042e85ef5ad84feb29e9a5f63e751c0327b37fbcac4de0b735a05f3b63f759f8423665302200af95da1f81859df359b51afe2e5f856b6472598dacc0352d2890b87ff60b4008278f2da1e98288ff1642a2d2ef99cf7c7ff4e1e7a3f967efa10b990311f7f4792c76d548ba408cd23eb568972f152239b3909d9e9d28bd53f76c26ad4954f5c1e790536a9db02ea786490c491af1192739d47b445e8ae317b96c7e668caffaab0299e32e7d29d3a7657f6e12f90b77ed5342d14d51d83f1d62969c7f17624a773dd62b5398e345a82232f37c2c210dafdca032453d1359004858827ed3bdce48566aaa8b3aadda5d8a0a97fc5ca3e7362167555d50961a3eed4611d81b7c5d102fca8d365fd419d58d7f930a935556cbaa306c53432b7f82b04d188f5d919e13de2c7acb396e88536403278ad1f34eb388bda0604a3567c26e87b6b84ce654f7879005f724dbec414577c1510abc56e0a78beaa73aba18900939b4a16420b8483e78558a09c5d4c20baea6d811d0596e12c068d351370107326c88498d89106e52bdd1b8f5d73d5baa03a99f29308479098674a65578e7176c0c9745c4a232a350e3c3d2c6b2361d75f6219085e7ca807c87d7c6540569db0658704c7277b508d2b73e8b2a6d9cd228915c5889260badeb1c1c0a623cc4f2597656de9794db122538743c5ee9a00e36d4ef16d12bd6012bd68a32194ec6b54399ed0e709225252dc2fb0a0918369b19","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
