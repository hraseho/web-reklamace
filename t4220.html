<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7b8e00b90cfbecda9123c5c94b3cae294025c838bfa6c4c887485b637e80862400a3a39c4e6f69b0f981582ac6498b4045813d92a432cc0efea6f3b5e96355ba70b9120821c41f0efdec326805f1aa0c655ed4a84e5d00de5e663c7409df59825a2fa5ceb593302d41d23fe29ec18a0eac6790905bae573dc0a55ab7d56874d2f16ead3aa9c690160dbcc27b0e7e52f6dccf503b378c33c6dd611bc2283f4cd3f159ffbbd99d6e9d992f75bab66453416bd068d534a323ccec3d55663e3aca32e8bc00d5672f8559af919b1fcdd49e16eed0354480a3364029df829df4808baf0ce4901104ca0135f4310b0f8276895076382449030520436d9e24dbeed77b2f2a5dbca15b6fbc654597ba30e77b6c420908fedfaa3233d3219bd28ae98068fb9b351a411274cc8a588aa774d9fa1fbcde02ab65ea42830b315fa7e746514a1a2419a6a03230d65f2642ed24b8d1fc27bcda15b662559b284e5dc73418a83ec95486b57d472b818e2f60747548d88c779d70931ca7e64c23829ae0b47ddc64a8ed15a097190c1cff96c5ee0069a783b1a04c80d4cf712a2cd31d500d326a83a2c44ac3755a2d43f9b805be172e21fdb68ec83b1f52a89040346ff7cec13ec413f4ebf3907d515ec2740f0f9ce8b07e044f67dea63fa94072b9aaa82c9ce03cde08f8b8b30923539ce3097257253dc5efa3a7032f88043378314bd71b5481761f1204e4d2004453a2e435fec5bc35b5015f8e2177d6538702cdb1118dc06abbba85194f825dd1a9896b58c757cbe1a2e4bbc59458912061bb8e3fdd1f7715c36cecea7d81e8f30ff3335f1914c23e33768e9f190d63ff795deeb36570be48c1ba86a11a7f9dc0988afc1a40da258a2138ea4631fd5c763d9a194e9984ab24c2fe96e3eca54188110a859d01d43296fb2be5883fe6a22d70ba41dc34d0751a3bbfe320ddc9a462261e743be2c37f4849796da0770d8c7c7dd6da62d6d8b023865579e3befac13ec9aa40647eed727add9c24dbad30ba79ec32f36b40a1d6253260dbd238eaa2be7feba87bbb907e6547c813ed7b8ce99a3a8fa8f0e4df55961d164fba16214f06147732198fdb97acc8870d1fd913fdc0f64efd90e334d632a34298b4b3de72e608d40458868b9d4075798b4f956e4564248f8f07fde22766c86fec1af3b3078034c0e6da007f2d61bd1f7f853fac9364018015812afe97d0f8599cbdf9e1379e78ee2ead0b52cb28fe178b545b77adb88610c6186f7ab3e973970fc1460a16915e05124b083417079469d5f6fa8325a0d32e00cdb00fa8c5959d35b809da89b79f54aff3bc10776c23445220b1904db55e4e12dccaa25199466fa95af83f417720d91b0d5abc3bd395d83c9ac8383b66cae899b9d8b9c4e686659789d57009526227e65cbe5bd7f23c1f3553070e73510afbe303a465173c326d1c6783d1f6eda9ddcd80a1d6e0083299f0a49b46368cda0634ac8aa1bff9715d57d6338b0eafe8a57cb3d68ef64d07ca16f004306e20d39436a9776ba6cd5dd2e552c53eef06d83261fcff0958088c425eaed43e8457ac242423b865ab4fe8cb38e6a1e760b445f4e724069eff42325ce11e2323a78c82c48d782a2c4e6b610bf6899cc43e2719d40d1392d6eac2d0d09554e3d15b5e9682405ba8ccf4c9a4b005fdf85f4f3f8f814c9cb5bb23975a234ccbd43eb8b092bfa1cb6aac08063cb5ed1a8f419b7f9f85a6cdf61aca25220afa2f92ae253c8fedbf0ce9228636162df825340d5730ab3b472b857933e9440edaae785d8e181df04daa59a12a03d66c94aa46209bb8769753c2eafc8583957963a09db841b403fc4d947fbf9167d7fd1742c19c30763a99259554abdb1dbb8c870b100be3b9bd7f1f56bdb58e7007adfaa142f8e8b2fab5a58aa1632a571afce7ea28fe177fc5ff0f11b4864f7124f153d79674c75864e2cce92993b74fd3c9c4ce0a0cb140045a0580d85749d5cde41814582db14737fe2488df33cc1e53f8d688681e26ef41d9ad1aadee4bbfa683759f60c3e0163959e02dd4e82a5b036492dfba4438f0de97ee2fbee83e48696f6751c30d9060a1a090e17542deba43d06a552fa0a9bd5bb2c8c71d58c521b3b32ee09eb641b97c35e057ea634501f64f542f4c723300e94bcbbcb779adb0ccf76746ac4c2f0f9111c3f332a1fa8d767d0befec1bd550482a0ad1522f2f8d18b738b33b03cc7eaa1b2479a7b944c94e9de6365f9667c371ad57acac63b8c6b59a546af80e32896b0a9a9de83cb0175f8410fc05d1835cd4c875cd7786fdab305b98dbdfabd5f02597a3a863403390cd64d604a95e323f93321ad4bd48018c576707805df2e1402a5041fcb10d9cc724532fb5cef538d4c1729a2288ece6f6a89c49f416cd244b56235d25e8bc33385c23f4292218c73502b6c69ebd9a09a2827bb3426dd2da928f0c3b5c6648c5319d8cabf3cb99eddecc6c4deb129028ccf1ba767687569d9b812403fcf60b5f4edddc8f35868c6099b22a123e539946243d2b6a0d33bd864f4ee93e42dd54b2d41c1793db1114df318bd3b86d63bf88c262befc6dc8934312ba0f23bbd140d8c5d12c46960317da9669cb651d6949fb577b68137559ce08e6522970e0549e929bd031821454e94698a3fdf613a85ed89cc086f9e70046a6a655b409df80fd72c28e8b90e7b61c91b036222fbe17dab0b0cda5fccae13251aad6e7566ea54fcfd03c9791ce23034a6a3933c5278291fb8658492c83e1f289224857d42caf04d6b74ceb3d92c2ed0c8e614c3f0542c36afd026da5f455fe89529ef3404094d7415473e23bd0ea56326de50aac134a194a927c9ce0221f9e31368db453d8c0d378a020a027495815a50c98ee5abc18fbd0900d6c3368d52bffcd77d142e35df03c145827c05be3ef58f30268cc88fb67cca50ee6cd1c4785c35d19dbf7917e93441807addf5c0eda0572a5a9a041a7feb9a01e64bb7a47ae2b9e9841426e257c03b9aac74bf8759263add226b72907dde4a2d03d8f82ff39e611b050fc3a13a7a8fd165d752e8193ccedb38c01846f0dc81327115e12413aefe95f70d577e07c9fa995f5581f86144e261a4e04b9a3ae372e0e2d261f7293de986e17ceec5fe4ac3c2d3affe68ab4ed6bfc7473105b6afad3bd2595215d0bf099291a170d6d2a70cca2fe8d37f0854c30775396892a69be27d1378f29dc89097a266ec92084b98018c31d9f95692f1b42e85fdf08313de589ab6d305a35c65c03d3b25e04df590ab91dafcbdbe050e0cf9892f2c091b8cb1cb1c647be015da42c658b635af94dc103239bc453aa886200cde4961637326c461fcff7b10f42d62d628d4461cd9687a875e4d140f516a8c2ac5faab8344d68f89b6833936bfdadaee83fc633213b60202d285cb95b8830beee7bf1616980e73976b8866806d6b4016114773cd27cfebf3731f3c82d1f47e425e456f9369d1a6e2fcb193184b2100d1af6af3b228776adc79aa02994011ad16fdf7596c53d83d84b144c4d501aa2032e6e9ac951c7c8c2e7cbc436f6ea73908e1f88488a9b645a049cacbbe5c59eb07484367671f8d838bc3e5a1a9fa265ba398efb488d43a09fed4c1253dd7ca50e279c105c6044c73d6bda676ae06ecf4296b47dcf1f3b91827360a36afa39c13da1c76b3a6ab78e650af2a1c725cae5c2d635d31b23dff08fa6787c95b53d303b83f002603be7e71c1c8ff14223cd0217750e138e8a9407f71f126d86c716243fe9db69472caf2411aef3b44334fd47ef738f51fd08aa5efb9b01f6d5b692798bb9b70a24bda8787f28dc73f7f8d473d09ae546c3eb027c717549828e9de1340ea220013f1e6e63d89c0da9c92980a368749d227a3a0e8baa9721ab4791fe019e640b4ed0015aa59c5504222165c143b41536a165379304eaf027b378910d4474fb13299427afd0b9ce4b7f053507e3929c81deeeaff23d5a9a74412d49fc1b5aa789a0204f0ab617f6c4ea11d30976f5abc566d24cb787f254e713bf724634cab05cdbc8b4d79e38e47c4016ca98bb9b09f627f15d926de3610e2c6909993935de6832d03214ef6c4242b467bf8f65147f9736274d8e9eaa9f730859bc5b1093dc7787b1a8aee32e19bbf652fa07d790795c2858dccb604510d09ea859b7f3334f75dd1fcbd02b4486eb93f92bb91ddced37fd744ee12e6ebc2ff23274de12a9167516ba58f655410c405861094a1a2ee47d67e931b0e956ff9c268078b6288d72559b15be26b929a85e7d67e1cd0010f1bb240fe08fffc9fd1a91986fbf9c283ea267aaf8c215c74ad04e5489a568c608d62229bf3aa6776d7823c18c3f406e27511f35d89931ce60de852a6b691bffb4ea0ee778d0ec3fcd61e92d6303b68fa2abe6d84c8f7739fb910fb768acad2ffdb377076ccee1e73572885bd2d999ca48de1d39686f9b7183ad454fea555f504738045463d9c1dbe7de73f7224ddc109e9982e50d7b4d68c7e7f62c019f4da189b0f439cbff59a28356b774b79072a49855bdd7a686e7ca3b48ee9d0653061ea2d3a435a2ec1bc58355510c46ed8273be2472b95eafceb01ccf3dd8c115ac72dcd8feb5a84c0ddf3638f013606e9d0a53337f322f96c0da8f9be8eabcc32f16cf2ed37db17f78bd4b093abe15a601173bf3b8d856c1ac7c84c09d06536a1781edff6c1bd05e008b4bf7366cc0423c794937127402435f9de9fa2a9d0d8eb994f2efed2185e0bc55c8b148d259e219ac20dd87496b01156c0210bc6d66f9abd2189e2ebe3884fff5a42abb818664c66c6cf984821048abd29ab57ce7bcb8dac9c054610ba12e47e0a52413f668436eeee088910809cd4010880ff912b59c843921f5764eaf05ac85eba095dca0d0c08da5886034e076b8bc9396d5b3c1fb5a55dfdf97bbb7b9b24394546a814e02b26580ebda18e7344fddd02a4998d9695954b5496a21ebc225ce2e9b1f3e66e0794d3fa4cc084be93ad30dbf7c9fcc7ffa30c6e44c68d330aaf0d02ec2bc8619977e275ad858b91d93cd71036afc8e1ed0b17f7952ff212cfd7af29526e86a54d023d27d30f0556a8797adffdfcaa3df9854cc5174ac3e9e681931ed652981e68f0e9960f374a16b47c5d81a2c24d9ecbea0b040359b809107752e34f4ba91b2cbff58602248718bbb27ef5d3decc5cb616b411aea9f16348f26f97bef9dc4cbba06a83ea1ed2ac361d0a33a533df79e8b7de475aaf9d0d6c16a22ad332138735a1c9f4d4e7ccf7861ceab6a5be33cf92299dcc1afe717fd45214319196ad2f57300235a30444f0e9ca03f56a87eb47a7f0c36648cab2d29b68e11540d8c012976e7950d70c934ee861e51ade3c11535d170e9ea5d0ecbb622483439cccb31781db90c9a7aa294f62dddea748ad7a8857b236db802e334d90fb6068a3beff540d1376e8cf37907b70f1271e7e1ab7b53a3fa9b38871595028107d493e055530a90f58aadf6022d76222239732437b2e406923a1267177175e0fb86cb69f1a792618f10a5f86bff4f6e5b036006ced52a1c73fe31481c2a8b7ec671b6af486759211b926bb687d2705a56d06b5ffd0a2660f4493018eaa57d58a04bff34aaa0ac0f24007f0e1d9c48172c874bda54b3fdf6f3e523d2dd5a85fd37599a408bf431be2b7f6bead0cb33fa2d406726cdc35bef68f92e3e291418eb14bdc7054dfced43d40275c2461491c725473dfd17926d3cf99ba208452689e2251f2d02cba9874c04022af24a420fd756f9d2c11a0dbfaa29c61dc1f4ef4efb97fb56111c8064ac970cd88ecdcf9e8d2e4751d1c213745da7790238dcde9e55a633a02394c6b077e832e3bfb82e3e3d6685ca2c4f8c0a39e47fc5ab32145d82a7619764929e2331444786560a07d3fa5c847e81c721b0c5623cccd546d37115a81e01fd1fc0b6bca4c263643b49325e779186ea424ca72b58571e3200d9890525a985dcaf31de1ecf4aec51edfe03f853881bff29ed01e7a49ca50e604477e0851a42213990a2b408b145b25597ffe966f8814803b7e8949b0f01935c0e6d8dde0de4d0747126eb9e565aebd109d6571cd678a5ad99392400189f9b6234d9161c5dda89a559be01aaa9f387c138642e706bbf5a73ac6986880c728668ed51b8c6aec9772e38c48e3ac3b229eb5fd00376d7c2115f6b4b42b462402459d88fc04c902bbc620e36a56c9a1cbdd0439baaacb16dda0f136d00e8109cc61586941c2345c736395390299df7ff694464144f4de3f7944d42e491e2c6b60373e3f7d2114a1cbe1d39ed75b0b7e263ca0cc61e0caa41fb0fcb35142fe6b4b3af63012cf5e056ffbbd69ccdbbbed6d2a50ef9b79df469f4cf79ea212302542421283b16084dc48a6eac130ea39e0dda1702cffdb76f8a627ad04bd9beaadabe53facd230f6b99b77e2bd66ecab1ed81accb900cd79da904b0a65bae06d1af73e94043fd9ed8f178b5665c124953115cdd80798d9f22952b156a4f6475367318fb74c7e0ad4087a3bfad3429885403ddf60b03391e6c27a013dbf01961f18451e39912a32e3e097ee798c3b778965744584c30221018b091d36f96efe580114fed1c9c95efc8229bb441e9b78b4e1cbb679523ab076569cfb84e3289ef457e547cbfe9ef3c61233a35e47f09514399c20bbd69e0e841f989e04d727d62559462bc8226db731f8f94f53541b81a3e012171fe1b0d98118eb08ca5e40fee3a9465d3e3748602e8d91c23aeb9c7a4ac9e2256d241c8e8be061d2acdec3d75a4176b089d202f5a3779758500719d7c6458207331b88b693a9f3a6ec991f7fd5b3871b032adef1c55429057367d22bdb59d54eae284112deafaae7cb6330a7296bc0ca6c7bfc2d8fb0e737fbb094faf0c47b5f022168afdd9c149c617bbc340c34335f45ebd56880611e8d623c5b5eeb121c52d4290adcf612f817feac9b68924bbf692af00feffdaa027c986ec73cab1220487c25d9beeeab48696ef2ece70ea07057d5c81e04bad359dde0821585590547fda4e095ba3d8a4b9436e5dbc439c41970aea58df47c9462b89afdf1999ae87014b2682a1aa837b363ec044137c92596466742cfee94219feb5bfa87ea56f96476c81c5eaf76040a2f03a03dbcec88d455acb6331d65ff9fca0d008020db9ae26b1aa72d5828fc98392f15c51a5a2d6d3b4d86b087095e12834d7c0e8d15e5e9702e2790e35d87aade959f532302d5cf4aa9685b6b94bb9dca64f9872e075c8f57fff4a14e6e6b42105849eb0ca795258c1551535968ca5149fa29696155c58f069399de75c332137924873b7cc0afcc1b2d3cd6653c2f135c4972c4b9b2173a355ae756e182a57dbc054341fbac3b6146354531fabf0cc69d8bd381717a4a5d1444a2a75195cf52ba4c62a664a0624b94507991bad6984444273b9384edde7fc7bd1d7ee0e677e1515aa1b4ab9cddc3339d24c6e8c0b76a67a477ccd120da684ee8b58dddc2c45c7372194737dc1a50de30900334c3ccef44b47c6f69dd3552700603c2c08bc3dd255f2fd75ae9d952c6b2567568c5286a3a28a4532592a13e15202c1fb26d9027b886772ba47776c0f02e88e0cbddcb4ca3d0bdf3d927b483594fa5a79a1591fd6f66a84004977ed6e7e3d4231b60bcb4ea224caa1df7250cc560a88293be1773bbc965aa1f42373fa1d950d122210b9b71004f1e84e7b1a70ff50416294eadaa6ca686515be62b2ce3f0b31686e1f02243c2335cd4ee22d587c0409a98e7dc394e27325f879a2aa5d9d4745d083c68d970768f78f7b18a6a0b68adef2ed431915f7ac32c5ce4262cd6fac809222df192b6f2df50f62dd1b14e6736f8094303b9097d77a92c8fff0bc63a76f00be82af8406ced5a63d9e37cc6af2c70f091c7657f1cc68e69b2fc64eb3f2eebe5e6d63889e9c68229f98a5e3bd8d1745768b18baf08304c04e102939646f5ae608e11f525a8f410a5ffb791d875ee8fcbb95fd8f6d47bdab23037646c8ce0ecdbe9f8b0f3948b30c648cd687f66fe2d59b03b13369f761592e3c4ef278fc51143402b20fc6dd2efef3e3ddebf020c121588d978c195c0919d8cf74ee538dcb520c6516b17256939a0102e294a0310af9b48c94599124ac29cdb270fa39ba837d2a71b01f2c789808ba8e4f380b3a9c4e713b04ef3320f99755127067b668d581397651aaa09beb36583df6692c46b27301d5c892662fb726203c4898d0d9508cca0473689d3dc874146f3acd12016c62636edc3c52f42375475ac879fed3fb6ca830dac14c6fde191477890c2d5fa614cee73b0ba71a25d4ca3b1095945667a9c8cfbbcd789c0690ea898e7ab52e81cc97d3b1370b4d8c0e557fd0875f0d12958c21ee5a9fcfe680264cbb4704ede6c06912a707479a49a3bf81956a9a31c7bffb71669dfc74cef6e41405968edd3273cabe12e7a1ee8737adffd5854fe1bd9f7d6faafcee402d919cec7379875f4f247d7a8db0816aed539047d9e8d6e6e0fa606086bf2821f0ba5bf198a514bf0718d27c70e9c41e3e21f831aa3f990dd1b6b24f197fdab2e2e8ea9978e3b03622b1c1c0beb3f7ebf918efb71111c4983c0ce1bf3f4e58a973a8baecdca7b982a7bd974182683df779880028ed870017311f5c8c76aeef94455d4ca436b868ca63347ea855e056aea74241d3a646131fc6279092204cc936d6484d455de011ef20289306311325715824906b7587947299323e904ee311be49ae01ccea6df7cd02799b0a7196ae3cfee353213e5ece1e0225769002c8d7a8c121af6f16c01ca3729ac7251af01775da31326c95b696f0718ef616cf2e937765da02a8d71e7eacf384054cedfe7aadd765324d7ced765bb0fde8556248163e10ee207d4a273e125235533f1ab16eb698855f89d9d2cc318bebfa8c6677c29aa81bd6a2ceaca6cc5efc8f60e286a562e5866960d063e8a8439810451dc2e0ae0c63f31b81e906ecf806817b520e5c0fc991ba3a92406ed02d9f9e92d6b3b67abd2e4ccc64dbac177e6a814450b06c594643359b085b5f8a25486c40e59f71e0d849e1d964e54a4678e11177a0814c48c5a7043583c30cbf7318541e68276814571c0f7fb0e5a6088459945e78ec58783b9a50f410f6232a36847854ea04de0635396673350fa14bc72c6f120e7642a24afd48d9b4be8841072b9dc35d2a567b482e30aa24542d6f65f418c2615beeb130ace51a0dff3665355bd5608db1dace9c61cd8772615ebe434659359635c651cdc966570f1c94f36c81211d289d48e0fd07ed56f3450be5250b91b0b2a7b435c0a53bcf9a7089512b66b9945311a86fe6ba819fed92542a1fa9b82750fe81ce90728ee8a1ebdd2c06115bf77dd040aab02689deaae8b48b8c98d32846fd5998328ffab39dc92bf756cdf9d64541a354f96a232f496d5924808ca7a3737bc26f990c9658a427c764e6e8e4fa45f52fc3c74510039e201328cf8dc65379661da2d9c9913c34d8299869979dafdbe6c886c4fc0cdfbeecbd12b6601e0c1423c5d430a666ac358e00a2441407c8f89339f2272ac34ad1a5755f7af9efcad98b4e85bc291801fa4a4f4a54490250f61d49203288aa19e8dfc696223305f5197e449037a48d227a71a6fc2c26502bf14d90fd847d2a150bc9191728f43cca33d68ac500c84d830e1a5dd6186ea45e17178f9692f2fb4f784c2b3bc32dd63d28ce240584774cfb4a06234352547b22d598059dcee9847d7acde532dfb79cbd89470346cf6bd4d719bc6f5a6e197bf70d4bfe52d243954f89c0f09416232851165d3a78246c9cdaa7b949fcfc0ac7c0cf4f61eec9f6152f7f5519f1ae6b65b5b0cc2b0c67744b909c391a6430a3871e8f4bb9c4acd10134edf4a93f7d7edcec0cd8cfc55f083b8b3135cf5ee243854e8f26aa17e473accd0e879e607b63821f878bf8bcf52feec9e500bb4497709318a45ff34e038ccc03a87c1c80385b6f99b9dd8744648a9bbb8f9da721c06bfd006a77747c0971b33bb5778e2a57cc5533c67a4fe0f1142d7861f9fe9e6c854351a83c331be2a624c8619039631eb8308a6681d06a94f0642c1a7cf508698420be8ee1eb9289b0d002b15d91f43042de30ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
