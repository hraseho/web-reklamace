<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"135dc35ae0505fa04e869f481f487aeefafee9b253b578cf20da72dd802c79d04794fa05f1957641260c7a4e1f0484e460f3b27b87699bce8b3f9c30f92be3fea3c06874e195fb74fb2ccd801d8092ef277b93decff248a2430d8e2058480926b4906b56ff892395173fb1b68717c8ed5f819a2adc248724c631e34f8fff9a83c76d91a6ff3f3694df29d15bcf46c98a07a8de357cb7d06e6c9dbb57eb9ee9e6d60837919b0f52e6093c6587e955af336fdbb9aba0e35ebf5ae4ac47fa82a49bb3652ec885487708c952c6c49862afc0ab406b25b3ee38d666c3904610b1f25a54882b4916e8691d1d685b493a15d36b829326b3934c89403c365f49e17b48b3bf027cd94d78748030d79195b330447f748729b55caf38d2179b666bb99c662e5482c416caf2a6ff1a483ae301984570b8688c8669123f5b37c130b6a90881efee66fe3b7f6b2e368ecfb8551f62d5f128588b51df71f70f5da2c8e1d05fb599ff4f83eabaa86e20d787ba5e79f1c60716173badd285065f04c3952da0a21f61148126bea1c4ab7a8a69b87d8571fd959e67ce18936fb74888a3eb0d93a4a09245087b85d3d3d07ffbbf3a3396524151b671b503c1586e0c55286dfb9927e698605d886377db53864c0e9a5c334bf82c7a9b9715c637cdd7131f7d3541981e482521f2f4b91f8488b14719201e730e4a3490b5a52629c151aaacff52d267e8517efdc71eb3ee1cdc57a7cfc18ef292059eaba7ea9af065fe5af3b758002f778969ac96594d7b720146f550e5ea404f66f8139317b2ae7f5e519e725a980279437ad829019db87e26c4ffb5b07d00d438eb7d3ac09e0a812d4469822d9504d3e067cd7cc27def0599b6451afa8c0f7dc72d58720115043dc57574f80f0e4e6eb1164b6b06ad599ae12b38a3b230fa41f5e8b14b3280a1111b21f3a349653a4f26723ed5573ed4b358f3bd2d06f543d7518338975bbf3783fd1c53b1defedf8c9569e8ebfe96c8c6e9e42a199b45b45d4fa2949981223bcda303df96089b2ad05e46349041f8263e28e2a4c59e71744efd127378278dcd4b3531aefabe7f552a9e875d8067c93969028ee4ef4cfe6a1d9756cc15dadd3398fa69b48b4cc063376f9ed38dc72bf6484dd3469f66a2d51f42f9fa952d84ae357f3fea6f7300a3192087cd8020de4b0a09b94b4a3f99c135759c02de191bb2f5e31c75a7ccf8e37b6beaa09c2781d7c44f0ce58cabd67b23831a31843249ef70810bd98a93a0b16050f787596cdc587e41fd7217f000200d05f76a497f4281612c3a307a3d30a22250e372e9a7959c2af7eef62257b216f9c0126e3955a0e91f445edce0ffcfcbcd168893d28a85421af8339f7c39c4f1003d5d11abf1cecd4a9b8c4f4e27769cd2f6048ba9a0cd85a2c675c10bf9cb8a1e470d24a963842c4738947094ac706808798ff10f651ea4831a634d187c1d87311c197fee8665c719260ee3f31dc4be909c24ece8934bb57d789bdc551597651d4431e4ac91f86f18e5e10c6ea9305125c5e3f609c66b8f354a450f78ca0821756396b4c0b7bc47a6d13649e3a51f4fc049924c6e940b6349de5624aec15baa7f13c54351c2a91d7aed368c2e648db90961ea9d39a184dee6e74956764648b4c2ac906ae7e2afef2a27fb7026ec376ef5fb0bfd87d5658dbce6e0b2a9a377e5ae87c1b69ecfb4ecd846bf4ea520f159ce43ec2283a7d53f96a4b87d6f807eb41294768674388aaf45f52d35e8eb02a97187cef0c46fa26cd9a65d77427f12e0960d98a213ebd706ff93bd2fc6440fd7ac112a68ec5cd8e2fb7efe8abde406036a3692963ff185a76b135c0a3ddcb45fd000622849a18774492294c27c5f335d50ed78d12eb2bc4d00bf5f47974504e9e609a33ee66355f811b39e1348dd5a8d082610ddf44e3ca9bd8563fb9c855460dc8817930763faf61ef3f623101b1b18ce5c28a62d8fbcc599c05bb891a13750d325a93475f326d1092580ffd78051160cd5178a87041010b9f5f296a088f7de56a8be79be95af69805492ea77ae249c37f04dab792cb970a2dbe3b54078993ccb16170e6edd86725d2ad704fabb6393e9f66430ade378c85bebca77bceae6a5068e8130f89cf9cea7d5f339e43a4349a58b22978c478e330c046e10e40003bf994634085fd110c332d14f1532979b66b798aaa8f77f2720e7aa15a1c891c0a51fffb8cbeb1d6c905d5f72a4bae6ce34ab39938363ba66f2e58d4cd0330406cdc60cba3abaf0df7600f9c470fe5266471bae805bece6b3a5d38b5d7a3ad08360548edcdfefbe8e9a97c9fcdfca0b204329f05704aeff8b4e0c8961a93ac2403f81f72ac43eee23760315c3a396fb9c6755860d1f7bf4d96baa452e92feda60104588a1a8d72432daf3915692a06809c206dfba03063ae4949ab7e48f363a941cfadf2aec258dafdde08bf90e111e218abd18d5857cdd4a19a0df4ffdbe15baa05b301d9f00e7a229535eea3a42e3be2f440dffd8e12b7d5899e8bb493cf515310847b4514c80c03927fb891f16bb7970f622fd19982650591adc9df23654d46d3bc6d4a1cee7eba336dfa6b1e1207886ea4182303e7726b8318af808d1023442e874fe8785ccb1c599e0d396a4f3df15df35be6a039f3845782ae2f89da230721a2dfc432e249b7d3cd5535811c3542b4a20860905b1136f82d5f9bd071e5ede192e06d82f2d503a79422c7efb25ce36875842c90a10f7f1e073e06e4f7909808cde26caef9e3fbc17e643001be7347567bfbd335bec4243bb20faa6d1f608570ad297f57456665334578c3ab84701ddecda5cae51bdc94c0f34e01c80d6e74f576fc242a992d782de2257e7fbd5984da27b86ee53a4b4896a9b68b676c68d8a81451a6f5e012a6ccb714c9dcc8e52ead5484334957c43a20620fd850f9e13c1b504e0013b6dff9b193e2dc9d0861aa1b92444d615d6e9eb1178eaa6cb6bbc2f2126557d1a64512e7fa235d5495c1637213c2dd34678aade9fde72d23766a65f122961ea69077963616ee33e6b8086b312c5627284c5e99dede456ff1a763b0529a0e18ce4e1241b97e6a797fcdba2bbea72d265632cd395dc17eb6624f5426df6a49c0bee601bdef06f697e1916fef91a4aca4892810e8fde6edf6a4b1e943a84f68be884132aeba8481bf871309dc2b8be8ef909cb2c69f8f7215db65ffaa38549ac2072a8ed69a26c19b34cc4e190edda8d8b700209f1cb0a341219739dfb111a2bf61979091b07e0e7eea0ba3600f90e29f57ba8fa2b0c8dda7b80c39efa231e74416e8bddc988af198ec4fc53fdc6423d3669924b5b88a63fcf139c1d3baa0191081e7df7cff143188f20a4d8afb3a5e972d5753401913a8b18bb6b17fcec30809f527c920228c72c863d1c80fadbff1a51cd70894482d255bd90caab87fd5dfc93ff935db2e2a7741fb52ea3c92594977a0c691e6a786a90cf00b1225d50631e1171cf2e75adde94be164371db29fe7221448901c91b06f9ed9bd807e343a7dd03331067206d9cc4f0e6a8aa3fa2662c0da2141383acf6a9356f947e0e4c604371245a6dd5c35694c70daa3bc8f4da3a0452147329ac46b2bf92e3b0c0c7e955bae86a5e338fb1a0ce0aeeb960c585ae81d76cc68a9a365930beccb5ec5f2d30d31e2a20ca147387b3322e1a888aed702992f71ef8e6e05b01c83d4632b4d02a897678d495dbde2475bd37ecea06d00e31659cafbbafa80cfe2d7b5c7449ee36700267ab508f45977a464e7e38e7d320b578abf436ede66b232b9f63bbf8870fa06745135f47352c8607572512d789fcd0e7fd407c6210057d27968eec62e764fbd272091748e8f7f0549dc91193b2e13499ffaa0a690cc2d8e235644347fd9c42e494366a28629f8c05a1249828d97b6ddfc8210ff858ffd0b0a643b35bdb72b3723c02871796e1934e47773358d49332bb0cc5e31cf331b5f50b2973f5c974aecbdb5bee1d8cb347845d8b089665582733ee6d32b5b9f91d0c6efc1c8fd4a08425582583cdc0b966913d0b1668f0ca1d9e6a40f815a560a8c02dc374a13e9d8e0896fe3e60b0330eab3186c86e4c3eabd9df4a4f0e0921efdfb99c4f663086fc8a7f9b26a623281946eca9cd4ed718feaa5ec8974f9176bd0ebfec3e5ae5975c6614e7ae71a936c78a0083469d7a8ad16575b9675250d5ff7e925483954437c934bdb49d396fc50386927fde3ccbb5e2d8cbc65a1df54d48b49ab995fa6f7d2dd7c9086b4b128e937085c1e1f7cfdeca5e8fd522d2ee6e846f6f4442b0a22ce1b1f7d21f868b915ab566c385c60adaaf999ec86bb4f793bf1cae93a40b6f397055bd042651172ffea56d91113011a32d208cd8e3cef54eb13e2418b116b01c238d4d780e3f63039ccc51d1c33ef070d02b624cf8395f039b5e1d8803b2f39ad6b4f03cefde6498de53e2b719573c43439af8c130f1ac899e7c072dbfcdac46176dbc65ad9f08d4afee209856a9400274d396bddd5c65dbf28c48f2d2e962f558e308e191edb95cb679b1438db9fa3589164f2792fbeb72176c294e450d74c0b25835a10c0e41361ed90fa4006abe83b570535ef30af6c8149e17aafa01b4f6cda33e6e60dd5bb9e9871bae77915f9b58d87c9734c8689b77d93860e5c06b52c39af2f0697036df6cc19a75aacbfe9844a09e12a90a6312ba59b2d832784c871f86d58d593a30231eb3a213fe539d0e05757fe2c7735f4dc92e48a51e37610155105e0a09f7d12cf459a52f55bb4f293aa74ad56d6320e2b0332c84f718d31344eca95863a8989f5afd4a63d7106f957c75a4ac17533a4094745a413822a3c5941cef6afd0d5e79551e5c1d4ccaf3795d049edbc6532a8e53b9eb72d0b4a85e12d1e78057db6b3d0e97c43d35b0b7d3d46a79dfcecc4d0605b57bbb5e9b617b0833ec58dbfea9e2deea74a13e5b005eaf8638d02e93e6dd79e0a4c0dbb1cc907ce7ebd972773e95484603e8791a4cceab1af09fbf0a620b3141ed873c49bc14ed6998ea7f8069b4dbb72820d7a34f85c6ac153aeac40d8ee1ff0fafa3f043078b4aaf8041ff0d5cc5e5f301b950e12dda32cc350eac2035d960577a17e480cfd56e3718b42ae6f115c0010210b008bd138fd6133d0cec6c8d1cf1ae07bfc6dc013072aa3de352e4d48eb076e35cefedf9cd41f075d556686bdbf1e7563e3cc79122c18bb5cae41fda18feac23a737caf94677b2836d3b1364440794f7a23efc5617bf45342f2880efba1d60650e6f064ed2b4d39d493138a03f43c9ecfede1d9085e574e318e39972efd8eceb3b4a012c0f995ee9e1c00d90875d8270d9e4bab4c865452759883be9df6bc7a20b11f3ebf7518e5fa890aeca8469096e048594d24bf3886ae38189b21a3d900deaa0a75b70496bbe24a3c38c595fdc2dbcb69a6efc70e5d7a971ba90c99345ec4dd33ba31c85e0b5289ac88e325d488b809f622c093b980a52c38d8f8710bc0739e8866a0581e24d201e715794164a9a7659b737962282cd91b5966b34497686eb211e3dc0fe258e9a7ba0bbf4278dfbcaba21038b6b306fd4b85965fcb3c8df60805d23701188a40901d48686e47b1a08c8cce493fd287962b1ca877af665deae3a00032a3f6df827648331b97c16cb2d44e59ab83685ca4fa9b7b1fdff05a3bce8f59f31e0df955138709e371c91f259747c3f1776aea474e408642336cdfe3dc00abc3f5cc6e6b73841b57e9faba8eff46c2a7450f871d34b368aa6417bb0b270615d115dca447501253b640377bf45d3b25efb7696e8da76999fbb6165e4e9eeaa00e1c575c2570a923cfde70f999e9925f2b5b0cb5b5ad6186148221769df18b7fffee79630f8cf96dd0927fe7e7838c319b8064ae90600235719047925fdfd3d7d7c86521704a15e01ef026bcea33aec60982309d3150bbd4c0ce89a6ac57fabe33ab2962fd96e0a7f83650427acc0d0b59d802f889a03804385381e68955e0c585eca551f2824b11faa290296abb9d0c703f207388a85876697590625124a4dcc31b53a82805b1a2cda9b7f1d5e80f53c76207b2c09cf743ce85b131fd18456b46acc716aacbcce42f3c7016fb563adaa9513adabf67dddf9a18fd9a908f146fc01dff6d84e792807553ba70ea8ba1b45e1117af2f5dbc2eeaf28675d894d45f116d21a22d8e4f89e5fe3873c9053349ab1a4b7cf6225809d215dc4d01248f053536f2c71afcfb0321e9058c08ded319c45ed46fffb580c377220a69f14f5fc2386c27651585bfda4c0d4f783045b6157d75ca4f1a7fa6e8154f1804312bb0db6bbd9373b4bcb859b564064dd9de9e1f34875626a88136e009e32522a1307bdcf4a8fb7a2030644c04a4f5eafdc78238f47fd9799af44263becffe48dd7e2109c64fe815c396f687b3e25da3f02072b15d98b8431551c036799d3586b6fd510402609e12f30b917a973838858db2e9a0ccd2853ace11b4957a4d5fde1d4f2ffbb9985c38459b91f51cde4ac1d7b08623e5288c02a4a73190fe7c70000e0aaa07ba3dc2d27ef2acab4649f521d75071e7ac7077aa9b3355925403d8508619d6489f8ff66f981d45f21b900d10a7bede458be6089d899344e6bda4d4e802e9303a0ba364a644c70f45f38bf28e526a5da285df85502a3b3c89134b50c5a799dd4823651cd0577c7b1021bc96f911475342117fded284fae5a31058edd21e94b1531d1573eb4b0e344608d57b7b966f1fa00b908b26b7aba0e76305ed1889607458f3cc55985986f01ac203c18c7bf82307260fe31b50f82c91ee3efbad5cb90b77255a1077ddac912ef36ddc3428baffc229ad3f706fae79d9db218c157e4173c5431a188c10666d90c9ed81307ccf6a86a0ba42a1636ba0ed085fe54314d8bce54cc4cd1a426b6f4e437ae5486ad8c4ba99f1baaeae1bfd558778d3d80bbea7032c037ca2e2efbc28273b993ed6c839c8e940d34a7abe55641da7e07610a3c70fe365b3a9c481ed240b3a32dc241fc265f54cdc2225831d52e30d3b4bb77f7460ffcd88ba856a0cb6e2deb08caa68c7a94dd78f44ddc5c81bea19f57b5f4fcbe3e450e5ba894ad09123187186cf9212aaf9364ec2c098ca740ec305f25f03a764c22461d4108ab57045f056473a15ddd77d1bbf6062cb3b51fbbb53e1dcdd3b25dfc2068ea40ab16008da27ea599dbfbb7fdcd099e6aff15f577209b0a0156e788ada245029e32b4a9b260f6dd77b9bba8d3c2574e9b203d64099474b4f231b1436f43ec98db3d48ed52580e6571e01b046c1e053d53af806b0b7971045aeff5632a32a818126d53162f496e7675fe717beac05b5e5d43cb6efacec58d0a3ae6c90f38806198756f43f73f9885a0f0e8654eb976ae47e1ce66ef408570ba81808572cf156d99488674e9ff85af4fbf3e2128e4dd9b071469998bc0235a06362f49d87e701f7093b249c1fc9386b274633c6195d266d331e20c98a037191f2bac59ef021ca87e5a01a779733ff3baed2c2ae836212a1e7941f1559dd80162716fad9c65bb04aad59f71b7ef6b43f4baf558dbcc87cd7655e36242e1cbeaa08afcb74c596b295ac0230179dc02c5675c84fe710b981b09b054bff04f6478a1b37627f41495b2b55862e8ea35155eda227af634fac6f99d76cefecf7842bf4bda9d2994dfdd8c5d72d518a5ad6d8f45633dcf68dca0ade933e9edab77c8bac58f59e7b2f07a6cd58e0359b425a0bc7cf54e7f86a392995cc9064e7ddb494847367306007bd435a84e3129e27f437f446007408c535c880d5eb2a318a5c67d226869d4df31c54e997aea92e48a8125a389e7d040cbf715e198405f06d3b92d7a7173f66ce3d88ec3134066bb040ba71c1e13ae2656c14642ed27dff21a2ac086c8cdff7ed56a1bfb64a1daf3de3c2507a6de773565da88d145b5f12e0f88a8475bdc60f7088eaf0c3778097d5f555a49eaabffae21dda20bf245148e5843bf5e3222f4796d7dc871c0b1746767e4647bc8b09c90026a19655e09686292fbea6e31a219078468497f0e2a1bfa31732f99a9eaa4ea2de758bbfea2e2c87843d2ed8a43c10b61a98dba3cd43d90ba03fe77e17b150f15fa898152b62a7495b741a0f107b6c41628208b2a2631f365a11bb69c04a2dd6c3541ac1e175370b0ee620226ff1c14a58b78739810f65d53108689c340ad3321758f4235d08fb269b1c0f701d9dd5a4785a2b9d38c1daabda08b0d2e7f3cb2cc4d1fff5a1a5adc764b59a1ee7a7358133cd9ab2f3ddf3fec685547b5cfada911e06639f72a4b97c80923571a7110f8df3a0e71a2fa2e9277638dda7004e378869a26875aa768fa760818ac6332b7dc2de74e26822d4088e497a3bc2f2260582859111e300e36e3f56b008dfff6fb78f9bb98414931b4aadd5566e14691dbaf362e2a98f03f56a63a752b66ac115bcc0c8be724eda592c8b3a10f2fb76cd89501a5117bbe6fa603da98c7be3894b97c3bdea93357c90d1bf6a976c45b9855af352044a5b5098dbf15cbc8a9cb8641325a7782e6410ffbb0483ce9898c22d3e5095d016ef52563b9d46e0d119e3b38897b57bb9e3fee6cc30055963f24051ca6cd6eece7b5d41672f05f6349978af698cf0653f31cb2fcddc57f6b6552c1b07ae5177565fea5bd927e1264175c564eaa5eecf390c1146b032bcf65d3826a355be9585d4779a825fb9d1b8e3c4cc7f71e84e79de74ba4d6b99b8ef7ffc2d0b647e1ceea90cd3d6e5b9499cc8801488bdd03bf012caab369c5096d5740a11e38fc480fd20909da42d3b9001a197630d633b23cb849ca953bb0893db1ba6e56cc16c31ca0efe2e8e6f4b8ae141a02bf100cb6c4f3ded59b57d4a0623ba9493b7aaf6d79069a819c45e0eedbc1e44c91aa104e2107ca9df55889ba4f40c32dd3d94cf40c3375fea83477b6ab29d0ce880675ea37cbbbf88875ba4f8230dcd7c9d5a89e63669a6319b40beedbaa420bac6d51540eb76d2c695ac533c02d7c071a6afa51f9ba50b648d26b1abbd736be99798709fd3b5ef67a0bff526627f4c0ae7c5e33d025a952b04fb31a25bf78e68aa33111eb0fcd44ffe95065299e34269baa5fe82b180f9eaa0316c5e12bc640c46fc8be104379cfe896b0bd33f2f4a1e28c4b25f7b173130457309611e1dbbabdff1e5f12f510909615258221a70ec5eda4b6082189597aec8f0ad9b03a4d161fbf343feeed8882b0aed284f023864c36dba8a8474d4511057b66fb2e5fe07ded65cda54eb7d211b575a3a0d81ec1cdde394261f6be8943c58e8ea4fd8df448149c169814933ccc8c14a31809436fc9b2ae7cd3d06b55400ddcbfe5e29d9e0ac02f36ed73e7dd74df14a1e0a33c8c08d8f191ac0efce9f5475e2b63f275eb44cf187b072dfcf5568920dbec4bd51051f677e5a88c006c47144a0fac7d0ef81132235722a2b67d3f8873900ecd81a1565f69ea5e03c6a4fa1e460675be09b513c6d498d54d23775a3be1e18c38cef289691f6b723ef699321c1fdb82a61a73eae689dec3939c9c7af395b2642661a87f75ef8de6120930481d54377d4aeee92a8848f73bca803ce4df40bcf4557f3e8850dfc24855df4631e7a0eedbb08cc31d05cce807b4eeec6055208b49eec6a518bffb61ef6b76f14d3aa1836cb8f02f181644fe93ec098d48ca33fd283eb8eb5054d0e7795b90372474594682a5b327a64f4abf313af8d533fe9b462d5e927db6429226f2643f2199c3f385583df8f5dfa67580d962f27c7395266f059f6da124c12c39e55af1288cb79b41537b4882609696e273abaf169ef0f21f1dd9732b3e95f6715e46288493413e4a4e4039b74028fd907db420ec9b7b17dee4b3d3235ab8293671b75de8716e590a0ceb569b6d798d13b6802e9e77541b52a5433389da88a0cba082663f1d8cd239601b9285060ab0bd6f661ed08cad6c0b5a5c37ed5ed1ad88017991b5c0866b34e6094e056a9202893c890c9379b1e8ad5a811ae8fc68b8e818acb4237ab60892080eed372ee2a48c3f662837ce65a2327b03df89ccce2ce10377c93ab78bf09d8f105ed0da5032898a5ff6a7ed1d01fae62470f8de69c49c9c34847d48ef0f7cf28a6dfd369acb501434d2da920b08d044bda1f8a05b2421462568a4f20d091cd957cf9e76eec3f62d42503449dd17fe4fb5b94942112f1ab68a9ab855ecb7493453f49972","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
