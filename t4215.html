<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c42f86dca527c191ed54eb4d806c43ad1e789d2c5179347ad4df60cd916ee5b9413eaa4aba7063748fc1d8f9b2c6f77a810287c01138471ef667e4c88fb52e898596d7bb1b388a26cfdbfd66940883021aeb1187e64768020bb3d55cf2bc7e612ef3e0a5e469e0b0222e6afb5d1fc1ef2d31338358b20147342cdbfd245e2d7ae533307fec6134bffc7d6de7ac945e171cafe376988e9b7a1ee7449a2a78dc3555fb5f66ef594e8d1d9525b42b5efa98eb4dadbb320d2518e60d92a9a653490351a8479ae767d3a5ee0c63a9422b5354769eca7c12beea09a0e068d3366bc9725b525661de6a1bcae458c9c2d509c88cd251c8b51dbe7a5e643e8ef54d95f26f2f09ec208b0a68b878d39258f377061ae67a2767a0ef6a50dd647b296d5515cefa92308f2e7c23eaf69e80fdb548255a0cb774a6eeea9478e7509a4bea86f72b3cadb0a3972c5ce75ab118accdd91b00b54373673d8e8b0616cd605fd2b9986e66e33c2ed54099a9250755129d3baf7e8a185bb922abccac309db2bce49b9cee304a5dd80be30a4a22ec893d0ac5d3998bb2c485c4263f29e2d3cce040c3bb3e6b3e03a08a33e9feee77ba8b40814d334575f934267ad124fd749c682bf5b1fafce4fbe57077ffc5a6db91dad10ccacfe82f2bf9ed4a1a916b981220a8651cd784a945a0d770e73124ee3e1a361b91cb5c59383c6d1ac2714d4df6fee1adf38bf8663b060ae62795bad24f23f7f794724edd9b1e2957f6890138ea55c32c80666496ba7fe2c4027436f9d145afb423be35a671e522963a9ddbb39096dd0a4b4fad4029f326c90d422a59e97be78f56051df6b54e608e6c93fe06d85bed2539eb192ffb7fef48ba373c60c2f929b19406af9e6bae25a77d9b72c2a11299b756b7a65978c109ed53304895ac31cd30239f5d1d88cf14a32b9dbeaf5ce515531414f49a370897efc20ea583bdf35719f2d645eadd6b53098e5199373a4776a34527c8207fe2c65b7e63bb1a4decbc10b7ae202b4ad7fee162a8d74f5c3670ad1161e7abfbc797d2f31858445d898fe61a4449797ae222d08af4cacc4e6c51c3ff9c76f5aecac1f6ab14e8895349cb54ac29df0eb98e12a4610d15205e2c763d442ddc698ff0887db5897b97784266b63adb2412070c1a32e68e5312665cbbda38fb1b81f48072d09d207d5b75ae9c6a65ec65496680ba62ce32ac8e5821ccb7c2e336090141e464bdd5b656073d398248b1d2348612b3c055ac829a05b238f0654917910fffc7c146fa46e78dcb5a46bacc651bad491068b71577f287472eb4129a5e80c99781a913102e9de9a87494ced7d98cc25b6f0c6fea422e2d4e493bf6eb2b2880e69991554fe9d303ef2b41a3d72e01a6f30ace50ca2050b725100e230680bb9ba27e97bf86cc25d8178fc266247b12d4afafa18ed8f4f7563757cc620993ad6fa3f1158e136b913a47002405c8c4607dade7ae161ded8d827b6e2a8193003fa80442c392a8b282599339dade0f5258758fdab2f6462242f83c57ef8001ddb2de9c40d5bddc5cf06f9e07fd9d43af1d9f1c8bdf8eacffd3a36c70e6a846d5c242183fdd9a952e6ac8bc551035ac22701054bc02f589d9202fb13b5f6f6caf13e9d156bb6c3e12f46c00dc6c2e71dbb06527fe616ebc4fddfe8e6678ecd8f237f7ab6682fa3a8d75440d01557444c04495a4966ba660703295b05f92acb90fa0aa10b4b0affdfadf1d8895cc20a69553671a53bf40ca59dfb0f18ee03e8b28a43488d8d2f60261d762e6246707421d6a5947666d5243327451b2dc0e681f7af61d5a0199c3cfcc533de101e8fb9ff81b44a6a5e39c99fdf1a4b88ac477e2886351e85bab4be31828f802c7fae88c696d42a4f27b2535ba320492f7592db4d434d17c3e0aa072a5c4771a4746e935f78058565a072e9bc5f7000a7f306ccc792d5ab21a81dc76616f91def3160ad07cce57e17784a5ee443b10be3d1589118c339b03e15ca020a16ecdc385ca78101cb97c68efe83e570de8f0ceacb13c498be65a55b22585463244a521769c5944b51a58728c7cfdd1d459ade173b677b4566b7e82a59faadca7daa5ecb891065f6e714064e797c85a5ef3c04cbd0c62ff5b48c70835007d08d7401c4d3f0af498d0a1b7dbf0b94372a83acd5561106d416ba490a94ac0440f9cb4de38aaba96cc47ad1eda9e2a23270f0ad7bba7bffdf1b29cb15c1d03d65c7279d847214e2e0363f4c795cfedbfa244518e0212572a7651ac757f1f123e2609cae92be368dbbcefb096323acc27a04c179bd5c81da536ed8163cf41347e5b24b690e61c0bc2d41af3aae2fde170f06ed7f3ab807c632811c7cbe39d38da64db7121b750ce108e7ebf5fb5cf38c718ae945903cf92575872e84b71204c51dd9dae15149615148e6aa38f7f098e6f113f611dfda04bc4b497e09687dac180cc2b6b82c06a9235a3d9bd7df37ecbe4564789ab4ee3d2d5dbe049658074fa78ca251323e68470dfb698f1fdd7c4e52226fd62882d16b82b7442b85ed46c2fb675fba071cbc12ac4115ef928038353a0a9441ebfcf9190695154c2d1fe35f3dc2b5f47ad1d0495fab088cc87c70948d5bbb4bdd897092de7f00e70e97c2cf7f13a81d2e0ee4930ecf11fe58314f599bb1bda26932c1b299779d5ac33597c467834f403a37de3f78c702c2fd497897b4e93fd0b4da1308381dd6a54eaec6f62787f331c78f8f1c6530a74d4dbf0892280f8a61b8e44b362192912d34eda5544b5ff235dbf9cdb917251e12ed1f919fddc09e1b3ff6a6cb2d5290eef0fd43c34ace9db2a0480bd626288f5885d4c121e0b4022fb50c8ba86717bfca71e8e30bb822a43caf09facfcb34c3247f94b221e15a6c7cd421ac646b356857846e3b1cdf834778c3dca43011f77ea7911a054f92cab83f09363fcf6265cc11db174e8dcf41db62f3af718b4c98bbd817bcdf0f8f3929fb13ee98a2ce4db839289d03db034cd5036d8649829da093ff22dcc2a87ec560761abf0839d921d5f7a60756265e4600e7817c0f30e3037a2f81647b25172e139a2ed2979615fb8ce4c0b3c8c1c92a17826703cbe1cc10e15ce011a7da7499a68fc5047e692d33e491c005d5b57f709198163de4f861ba324712a02dccd1b481291277f3f861592ef4c39422fc95d585cb3c353174600e70131779ab610d3f63b004403ea7cd6683a6447e97356a68051dd033f00cf7e63a72c1a9e5ae2fea51a44b7939394c689b7425bffd001772a72159dddfb26938ade9b00f98c281921fd25af98ac60cc055b87fcd8b4b9515f93100a7824decd80e318fb11b0535900de9cabf36233a8d5ce94d595252bd5ffcceba0e0d6ceaa705abe937e5d229ad6bc2d19caae3af8906b75d6cb9182ce4756a77a0565973313cc3005e0c65eae1138ac9da04b3119b0b665f37ed99ad490c656aa701083fb7fd1dc4446a7382f4bedeca705199bb9cdb43013161fc06bb02ff11147a01d3287bea14fba052f0fd4633760d07c4c5d15e4bfa592b99ed620f0a10d0f62268aceff05b439ef871cdbe738dcbb571a706aaac20d9e148adbfef1970e7692ff34bf0cdb9f568ff79b6e5fb6102e1f2a3196d3bb4d62719fe6685135ec09965d6f7499dcdd465cacdcea7d9a6e731ff8d412f8a9303f6ece75ef257b7e98c0e5594f4b1bc9d94f3fc27502466ffe74bd4381adca2d281bf08a97e67c6cc196fb8e034247a51b2779e11548648d9c0b40b944b57be83e2fb7a9fa2228a32b459be51a5039e7abeb51c03edec8b5082787752bbcf657f2a497d30a1a2292361a2ff0e8ce1c632d0c4d2b24f2f0ebfdb06d4b054ed8dae92db19892279e50f6a776d4eeb7f2567d7d4585c68c3a4c3bfc81437715bb1dc56a698e468e64a0213fed80d4a9a3896ea37513a29c107a7b6541d3d46c269e1554b6292c3aa32115bd94d3a6948413a588eb92b7bcbffa5fea20c0eef8c9ed3019d5dc2202bca4a55a10db2e6d25d7d2999efdda9c0dc41572e3295b41bfbb16b17caff6753c21671a17c81283b9a0b285458fb2bbcd4a40c5c00f2cd32a37a6b80f4fa6045ea3ff6b6af509459a555bc1c840726cdb4017f4fc214de2b6009e694303aa03e1beae1636458c5b046d50f1cf237979e724e51ed2f8c9e005a0fe08412fe71df0f36d9d8a01ef6382b69b3beb14277b2c5ac71f2c393753790322cac894940d59fd13bd2592209b643ebae8812400a537ee373e3a861c46b67a34775523ce3cc3e14d2e7ce13a43cfeba70b50ab7a6302816237642be50a596e3d9cdccf556ae35b08f63d85abc275f6691cb808d6ba6942fd8638a3ba45012ead20ecd234513077854406f9b5f31e0b282e635ffdf2e4303e1688161786596fe2a543a64cd49f42241452c3166c33c9356c4ab40fa1109469c0d774e7986546af17eb4effb7ab4deff75978a271852cb71ca6010c506b183dd17321f9cc3383ccae47c6bc1b8221f104d3fa2aec6e87379c8bf4b4bfb80beb9ad7ff826053baf11a31a03f182cc3ab851ddf9f3e1fe8f986f8f26a2a09c3ea08de2a8fa51c6a062d629e0d5d72e8027e2925c455c8ea2aadc85e761322f2be8be3b16c6f6daf6f7e2e6f250f232a3e7c2f4f79ce09d85bf8fb12c7191b0b541df44eb5a431ea4bf922b2a43aab4f99fbcf56abe96f39206321dde1abb6d061b89b074701818791320b803dd26dd7e20381e39b218e2da3b3b5cd0d67111b46d4968f4d038c388e582e20851eb7aed3f9be7c8030f178be45772b09ffa4c7de61ba9a25b836fc1a84ce3b1987970551d28fceeb6884b01474581e741bdf7624169247ab472bad00e6277286a47d9d43ee1be2bd9824562d8aaaeafd7b900ff1e3c5ae7c9d13d2b9315505adb8323f44a2b2cc5dd50f70c2617a13aaf8b158cb858a3ed676bc2e35a981435b4be305c017c36ca3d16ecd7db7c371b28acde217b25196a03900839e10415025d2bb73c8472dfe1edfba82d449b841a6228276c08879e116978604128f1a9b285b52e09d938c41b28642a2b2a0871eb31ea625727feb72f3889cd3ddca3bde3cf1542d56abeae192914d90b7bbaf2390ca2e961b229df553a66f6e377101ac06ce0510901e92f43b1419de860d5509397bfa15ff540c3b2e573143ed829b30640442a15beb2e87dc6e3b8cd1642783d4ea965b7c5a29237e942a68478fce85aed1734e146f5ab14ee6c17837d0df94ae8b598904781589d5dc050ee26f6bc51df12f4b9dfc9e6a42a2a8dceaad9d59f69a2016598636eec0aa02da4945b6aca3afb00b1d19ddb7a1fb53097118a86fb72c6ae6bb98e7b9e812559116016f713d5d1ce542fc113a12fa3c9d7f829d082a6ad25a1beaaef9158946ff2c0d56537e22441f15fc2c0fa557006d6361f1033cad809e8c3905ef2a8a38af061acc690d7d52743d006e8d838f9a0641c8b715434a15a177dc64237fd478e8938f2a4d1bbb33cec9f6e01a0083c2841d84fc17a7c0f3dbc78c545b6f64b43e95c0755f069fe36290e71b7652c3f6ed0a90f2a4121d6e07dbc886aec45dc7a66cb3cca85712f43426dc7f78306ac53927643879c46d2459cd2906e68118fe96f1f1edc8d9a9d215f23d2f1f4f5991527f557e5b6580ad44ae70e6c2656df1e7c82d81ba17c15aca84e46981c44364b57d94586a88eeed3c444ca1828d496922a68a667e0e2daa387d20788b4405defd52e9632c86404f82e481a02308b37e1a5f76fbd4569a2b7c60c548b18561e92f0eac190fb66d21d499933b39be3e9e889b84a284a71971da49c2fd483e9409a37c40b21265783e81d06dba827938a819264ca7b6431cde1936e342b73cd063ca067a44d52e746cc84b4164dbf664c930226d1326dfadf3f97a7845f32824356cab3d1b3bc46eff446f7e0291e1145a5aff345e5dd614bd6c5f765b1c8657843057cbfa2ffd145b6a02daa666b5469facce91017632f9bb6534a6e2a924fedefe22f5da31d6ed3167791aa63e21ed77a68d4ea7fb4cec97ad12e04d88698a3cedee04fc536220392fbd96219b1b78be634f10e099795507434703bc626f3ac946f41a48d75a0f86bec4e9196fdaa28cc93f26324726bd7ef25c4a3bb715fb9beca0d665dfe31ce49756ee77996dbbbccbcaee693733c14dfbd04a672c337aa67982e7b6ef4bc6ae95ad6add1c1e4549087ba284b885487482492e7018b141536dd9267fbb3b9dd66d77e3a73ca690d3ee34038f90b102bce8b866391f6a1dbe47cc93117b38a21bbaa1aff56bde2bb550fc916e74ecae30200990ef3473e9bf5683cc83f273746de1502b058b5f5684f271844a4b53aa1ddaf1b30dcc80156497bccf5d069ac6fbc774224b68819230b6d4a128727bfb31e87e95998f7a0ad4c0de04a60c3d122b64ee41831b4c6b051187baaa55369b51d298e096f44ff982898c457be19dc70230648354c0c37b7d2088c186f5f855d6355883d9b659f7de4946dffed65e9f99c8d1845ddcad70a8e9c370117c69a476ed4a6900f1266f1f39bef1b6a41dcbb1e8017981ef09662db190020668d88c7c72eb4fdd630fb1b6e92a6c2ec56522454ac48f6a1256921a5c99de88b15017496a96218e44c84b4d5ae1a1286a0ab4b960f876cae189be2e1127cf60d2b6fd70cef9f6010415dd5c57329dbb2f7e05cf092c5db8b1417e4bf9f87b2943c9330a691e486ee20cc330477e89fb23861d9d9bff60d9714fa9a503b061bd32e9fbdfd113bf3b13600c15bf42585b75ea0dfe943e9aa34e32344cb7572184484cd4b1f6d0f7a8f43484f3e24b0bf89c620abda22d53b2b855017a80f780f401ebda95dd836f01028ff6b36a07b4a02d27dde805a65375a98b5ecef26c296fecf1d68a10abc38aebde185fe0050cae19ac3f52d815019762da8d2fe414f970f63c8ab8d7732618be2a16ff6507a349b0121f82cfc33ad0001f6893c3d97b9b44d0b4c60ad65d046a9d3d49179ceffdc1892865c293468a0454c51f7339fef394bd2ad056951394c765e7b1deda7363291b20ada76980eacd3fc6afa23221bea9fbac0789daeaf56c9a14292dac99fb8f5ad7c5180231e557ed356ff5dbf28f485dc809187ba57a5e678d770986860df272ffd2797c2cca80ab8276ef5917e54bbe9e41dc9e6e221663a7ae10c44acec29ff82757400f4fa6b48ac90ba287c4ab2d493573d39549298865844d8869efa55a30d369f553bae239fb7b066fb733ef0ab44ba714d2296a0e5b4af22646b02299238f8f6eda4f5278e2f088d79fafb71fcf06c0e6ab4e530de403de1b644e74dd278e3e42870f80dba17e934118aa75ab4b9ab7d82ba9c1ee6143674c4f41580de4751d4aac9c91a4cc3837f690f5f830dd2f7912e251a01976c8582bf6e120b3de20545ec50d7b28d84fe4150d8c244c39a287f3ce9385ec24b3e7dfd0e12f3557d4909f9eedd465ac17a0bfd99f41b24be5766a4d10fda642823b34ad1471ad88105c1b94e42e9f417a19eca1bb96d8b19c7fd0c73509b9ae768c1e556d94e26186793eae5af884a62a998fa452cce0979c9dbb659419b3ed35fcdab2e09487841e2894c0a852db8b2e33d4f1ea4f066563c3f794d623bdd50dce450ba319922a56ecfad1ac18d7fd8d5f1ea4979ebd8041c219e6e830bd7249e5b0aa7c475e16291afd77c82ad8e1ddfff130fd2fcd440798746a76a06b75589c10ba968fd451295365d34beed7cc155b1db371988865ed7dd74535db0f983aa6616d09c4b892bae29064e3beb991dd212d6fcdb092a8a21494aa4ab7a920f52c1a4457343be8eb6bc93a4712266811a1ebaab6da627cb42476f48c336836baaeb8e352ec9efb482fdd1c3acc5cc3e128bfd4d3ba493bf47180272a72fff8e47a78c6e3bd80ec57b45ae631de3bdbda9cd3bf7a9fa52834719358d26aa895338c487d704d39cbd0e82b47e5cf40963f9068fa813b33b5dff9c8b67b4117c333dcfcb505baad4dfff9809a5da69b72a1cd70de628a80af957958864f26062918ee399c0072494f9461b9affe50b6f9ac7697f24f1b1e50d5b18bbf251e6025c8b0bacf6172d66ef124fe279bd13b983ee70118e56720fa81cc046cf19dacd9ec242b85fea6457e4728433b71962390218ea850082afa461f58720c2f0694f4efdc40bb065d8fd040c2288e7c5493527ded829c3ddbebc62cbd516f5f43abf9bd8c4a4f5e1469f3bf7ea927da39506d4a11a8ea2636706f97b13cc7e2f1d087cfcf4de2d53d29b1bd40f69cac7d12b194d403a2f41d167359417a6141e1a9ee0f96d73d410312831745bc63735505a846331398c4313c4c7ddbef2ce9c1e1153d82dadd695a74ae7ee56789bacaae5a8fc68ead54251c951a7819a444073d48700f5ae7463ae0dcc76346155087c0e702a473886a3418159bb08502502ed4e35065e1df5339e8927add84a26dd7b2da694603cbc12dacb98ef907b8681d6124af6618c38da216ade30614c3d0c1145f2797d6f84de9461ce9ed2b42eacfee8cfd8d350b6c5b7e3b301aa5f63a274539a816bc8906cd6f843af427ffc7a3d15b147409193e770b40c4141ee637168338b4edc06d8469aa328eebd6b50e0c2222e38290425f323da200cdcbf3d286a4d6f01742b61cee926736feb76dd7a843293ada38620c021325d100ff452981dedc2b621aa25f2a14eb4b4e24af33fbf55705cef64d12ac68172b396abee835ee3d8ff9fe024db528a141ea1fa0686bda1d8ef552eadb8503e611f3380ba4f0218ca15dbb531305fb7e39097a80eda8295933413a7cb0bdee65c71ca64a8a0199978f29e8efff3bc76116e1c7e1238ddefa0e87df0672535f406eb15c2c3862c52a7ef97e59ae7040fec92121f7542b01cfdb4d6e4941cbb7e91b76ca907f6ef784b92f77f5a202106d096b3b0dca289ee60b186a10cf7daef7e47cc1ccdeb727073c2b34b29563ae5edc74b0f41c755756e852bcc36095fb996a8dca42a99363693eb90caf05519e489abec2d995b64aacf8173d288dc63facaccb93383b0e1887f35e8c89e1cb500ebefe52e38c46c356d57d6d99ba3518ab23571fb43d59c57df801b36723d84f48434e9391e2662bce72f443b07ad29504ae1486c6a8942b98112586bd23b63b4fd97a4f2d046dae3f0bfd04f172be57cb906699936bc2cc5965f32e6285986098955e47273d03a429d35dd7094ddfe52d3cb42a5a9c565313cb262f903eee0c47e1f0615042cb6d587b2c09583e8d83c65f1ed94deb73704642927de71ef888b61ea450fc929bb19f749028f5c1760cb54ac89fb3872123d606264e60e9151cc84e40ddf3509e7c97ea3d6bc80411fe6589e74bdecc65d408e1b83fe083a46b302558bf9e9e1e8a975e0757cbfef40ef7f44fe4f66ca3cc18b56c18e12889a12915aeb6da69e4a593efa0d102737f4924cf289a3419ea25de2f595c55002ae3d27fa3ff3ae92d34f634f68d1a9a7a5d57206c6674cebcb646f72f694eaef1eb9717c29392b53b02ee0a110da89ce7ffe9313626688ff1adb53b4f6e10c0c088d160e9c8a33a0b2b53f3bf5c378fa91ec9051795ecafd3e0ddea539fbf04d7f45394c6127b2e04a18184bfacace1c98d5faadbe9b4e31bfba1ca1a361311379157ea6dfd68c5874aa7b7b8ef6663b9a6c7c74932fb6349d0ba3824d6e793f013a8d12a6a43888b790012caf40ef247ebbb73a7b8a46f534864e5da0b846fc74bd93a561fee7161536e36539d64631aa52828d3a229a96fe4ed2838c686a24dbc2c0bcf0586601b7b80b41d7c796707a1acded93ee00d8eeb9d3c8de458346b0b59b2f34ff838ead857de69af38e73dfc9eca45606a67aee8a3c611c4fd9de1f0fe2bd31348ff58f858f39da175c839c2ed01261a406d1ec992d41a53fd4ce5858696f737c7f1596906d266d8a61f04757cda6057845f62074e4d5304ac15e56c1913eae7454b63792d2fbe52e29b33efc8a2e941daee978c0129711666472b90b5c59deefecf673dbb3a85098e149985cb035a0924d81d8a21b8985bc1924a12f6d9a145e9d7bb7420f68195635a40393e164f513c389e0106a60653b84267e9a64a8d3af6b0211daef65679b1fa8034c7f659cebbc2e96bda348242cdcfa231e94c9759b754c89b052e67ce7614b46882a58db3416c1416b637165488e47aca275fa228fef3839b0f60a8b64aa670641bc454fb6074e8545d337dd901fcb4542ab2d4b0ac8b9a714bbe08abcaf257c4af9698c19d214de99a92edd0b45967e37628b73de604aa15dbaab0cd68a2c285eefcc9bbd3a65ad046574dc8748b27b10867c0fd54cdfcecd055da03126185120e5866f993dc9869a33248b85b81a6691bad77d599819aea226efd46f3436d477c0af7c0fb0440f7952ebb2a52812b585e83b6c458f4b03501791c1b5203c33a8147a6b6d6c1cfbf0814035e02eaff3b2116db364f336e1837f98e5595e0c52f2d6ab1349cd89eb9e20e8cb8bd18bf5307036427f8a000befd40570df6a9e6676dfce7d737fc86645753ff73319e786432e635cfb6c355a856a2d618e4a430d965bcb35e6f1050ee583e6ea7374f22355bf0be4a85f675d6163a0f894cbede7c5dc1e5f3e1d7be68f1b2d0d381fb533aac5e635ac4d00c929fedc4b5ad990f6171a7f7ca814a253cf736cb258ab53a020454172e3564bfb53c37dac7987a68b77591988e49077f86e83c6267b004fd70d87d5261da76b6e32f7acb750c411a8af1efc52b235d50ab58b6601cfda5da7e6098efce1d318e99e8cf1baf2f1f97e5f1e6f05c72a5b1197daca02e1ef18fc80b3387d83db90a54e63f7578f17a9c02927e7a14355c8f39339b630cf5298418c3caf0135d42ac0493e3b770afb95420022163746c7aab83e9a303ebe500d2c6e092a534108884370a4d08d125e9e5551dd3b83c44662897ecbbef221826dc853715514f8939f82bcc4558eb8de8f6c6348f99296e10e46efd021b3b64b7f5601a722caf2e783ce8875b94cd2c1c93d34797a45e0e2d4de9db1c2c40c77d064c54fae2b3437278ef8038562dbdae874418c6427b7b2e4bbd69800753be062210828b2725ffcaa2334e26d8075a98ec2a948375bec0c9337a91cc3aed3872737b06d83f3a68a672f76cc2fab3f1aa3872521b957aa4aa9a54c4abbb4b1afe54d58110bca9f270932525f1663bd3c77c01f4c214f9cb462073c1ef75f9ba689e686ddc1ef7b468c71c63673e0bd6139c6b2757374c3ea7d9f2827fdda00829f7f49505ea3051267b28586e684cc9e27490141117016640cfee1887b9eeababfab0eca363bd79d0999290e1d7904a0ecda8eafd6a42f37067785f4edc5e1ec425e3281c65955d2e74d560108fc76471f8d3aaaa51f24900fa11491d2e264b7657df86069a11e56454d0f4550e68a8874090b738a593c4090ad4e2d4b421d1000bc49b402aab718f546320614ac986c70695493dc5b3d8383e93a4f049e90d25e149b442f0b9462d6bde1603190d1dad4d1bd8bd2d3610edd4b8c03f5e02d40aaa2774544d58846b2bf3f02200092d4891fe342df7052f50a648e7749b3837e49c4cf885194f5f8a59deffe6eaf7f759f25210fa8963647d81461a28e4001aa50f95ff1ff2aae61f66f5e055b712be78e988b42de24638ee1bb3dcb039f4b367023fae67ee44511fbd6e756a92dda221c8a0ae57851b17bc570f8c64392b8876feedf5017b52c768c2123b6765d771842749db46ff79aaacda2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
