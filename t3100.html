<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"222d75a6e19c9a8fc05f747ee564a5b3412599b1659284ff2699882534e9e8044de39b99b6b511871b10373ef146edfba82098713857b324ea1ec51e2d107c917818965d1f20d9c23d1601d208c2ebb6daa853efc508f292bd8e931f8b0823de5e23c6cb58f7af1b8b6b9e4415266d0ab05a33bbd56b3842ddcd7b60c2747f72b3487e22c1c63f016e455da6bdc34f75fca86174db2b0e2c52ddaac5fe876cb702ca6fb21bcc65d92f9778ce8ebcdbe1f6673d01ee249a0fd3ae907718f278150b90cced1479da23690328b61b52200c08fc99f3669a63d3b843e6036fd0607c4dd2cefa58b661a4e5a99aba7934afa81af6ef25b9666da6ca3259bd039b0eb3bdb6255ff29654cc7c07e11f496f9cc15044cf9ca27d215ebf14e64b917af431716d8465665d605543ddfb3ac0cf4d165dc246f023652adbf6c357b5ac246d74acc43adcebe3dad417902edb7ca7a0e83d53ae9ae0e8a855c1bd465d859f5dd0ca1f2af39940f410b4970b8e5176ab3b3840678c9cfd3693d92569bfab52a782b5be2ed2fd0b733090409d46b11f10ce115cd8bcb442d3b4a5c79adbeda4c6f9f665d2a037ccf93e7fb6bf02fb93a709314b9bdf66a8e524fe4bfe0d2eb2778cbd26af012ef78465ce1df6680536836fc7f33697c75b890a67fd740c9e27433a3c8d4bd3a2270c852913462dbfebe2b8294d0f8029445971be1e62ecb4b5b6adf9534cff989f4f8198d58d75dad0c3d1bc70b48bcdf6bc43d0ab1b580b2e08b473d38fce23d41c25d2996f635e0c003b1f3077e8127d0c02da49819aacdd24fa64bfafa1d1b1c89d54828b7fb678c1bdf1606746b57dbe9f9e7637ec38c6998a2b59bc4bc5a5917d9195e46366cee7ad4e73cab2a38e8b93e63ba9c721fdb762801de7a945442429a1107f65a0158bdb15b502d761921cd005d6771c60ac325c811e14c40d182b264de73e4e1fbe3beeb689fbb7db8a472d8cb82d0f4caf67b069f64f82f7eb9c035b3b4a1be2738cd781340911f78c8be4d9a193b86cae458759ab23a874efb781a4d52cb914194b54c0cb058c48b6ad5e44b65533cc74c361740c59ce7c1911176a77585ffad8e66a14a7d5d82b68091362f28e2aff8dbe51019eae4256473ee78843db9d7d56cd5a4ecd605d55ce2ccfca83dfb2ce3c387b879b240859518a42ceab7c770b452898288660fdce8218775b2504f7ad2585fc2970f13b903bae2c3b9904676f67c53d865cb33e839c694cb297c9a844307f0e7da433a19db31e271e2db749bb727cc94f1d080317dbc7f48ac740b46c8de38a51c4a52cdc28ec4c6220b962e5cf4ae52a49ccbce7f6bf8096954b86f83f5e0a64ac65e0df4bd43cca3632e6f6610419b4de218aaf95ce4aec48c9ceaa1c771c68ad961f36e7f007bd8ee7f14922d0dbb2a884a134e8d7e9fc31926bd620acfd7a2a89f684e244b002bac341fd979d8549f19b7832bc832eb1c9b8b4ef92870a79b1c70cf632dbad4571669202f57d70c54e58fc5b0423d0619e9007cc032c47edf57839b7b3582e9dd66298fd1eaeab3efe68cede18687301dd55b066dc96bae0d93c1fa9c394ae5e144a061927f5183dc3bae15389435b3054f4c3e2d734015371866968e93ad5a2f79719072cf8f408f9ad58741a3f8935aa1ad158ba63c8cf18c714976225da5ad10147dce3452b737d29951a1be0880e4f977233991d2069967558e9bc88d2bead54c49e80768b9b131ec893b82162473ea1c148d7a8b979448a8202b238a86569bc2b90b72cff153175e5f7088c3bbaf7f900078d91f64b483b6cbb17051297976120e48f0187a1b551ceea3e2bf9dfedead8eed19bcd27ee668a88db00b90bc55760428bc9e267029a7c347118374dd2d22af837c8475b800dae3ad366d5a26de3b3822a9a6fedb15988729e8b39642ddae29fdb699dfd1dffc96c2ce06a3249164ee75427a9892af130ed562d1fd3e964d2fe2f8f10cede90baf1f2598d085540e16ceacd9a290b557513af3237d4e0653fa95b88092ba6e8e2f444236485fbb6c3479038857456b0cf7a419870f045fdd8363786e601bdacce84b61af482cd5d281a6fc8ef0ae941161403818409515ea2b3408606c5ea1884902535a901eb1164d6d50a4793ddfed0de8ccd4a69d2096d7443336e96024a4a60e20fd98c51d21cd59e4a10fa0a9f05e0525b7b149ef49af0e2df304890d24c73123a30be4a54167ce7978c8ce7e51abc61659e18ee8df64b06fb81508db985c22a548e9102784a41b3e44330c599b0d77305a2f864fed70583bd3ef07e3356b409e55fce1d5ff41b4856680db27deab68b025fde8aa821a6f37858587cf75e5fb1004fc0679dc16b6566a3c4a0ada2e61dcbcee979c5f21cbb681e6075f761beba85cb5a49dbab4cf7f3f74a716089f67b895cc1320d67c473b89d82e51e4ef5b43074674395be96494aa01fa9247a8e7faf5519af7ba6ba3c0ab92e160223600720c1fdcca1ab80e97f429574da18851803dbc7d2affef7fe338fa06cb5eab121277e6684d80961983148ed4022392aff11f9c995448a6bad7a906bd9e8bf57cf00dc7b08cd14f3afff720e0e4577e956d229a5adb30704d62e5d91078caffaca8737635a98919b7118b3b7376fe3f2da4657d361c3e260cdb6f501445c5c115b56844e1a00484712e31dc674316461ce90ed3151825291f1aec3cfaa5839c2d9f6e348ff5b9c5623df922d5e79e3c72496524699ee9849e5de0d1d6a2f248515a2e3902a9578267609827154c088deb330cb85f2dc483188892ae52355fbb2486a9839125dee91582362263eb3558bbc5118f037154323fa44b31e2f75b0abacb763e7ef1531263d9ba6fbb260969bb691eb8ae668c0d6fa53b22cce15252e7ab7c6af2418e77132136df3cf5d5b3b90e413a2ffee36cdf1d90a89cb310926732112834889fb34e8c88a8a91f40ba0915c8b47f8b0b707d8b2a0471b2aef0681b03416fbd0b479b39a0cf1b2641f9405ed47943c193ed12e7fa7d80ec05b7b53be72ca7e0e540ecdb23caf55454aa37cf83187437a3793eec9d62bb88e2723d3520d83d055d8635c38245457ce695b977bb9cd830bdc75007dab820e107e5d4868943c3e585137dcf4adaecb6e8d76b134dbd42aebfc5dbbef203813732fc14b1c782cc083c7ae8637f89b35a48ffd7ef4e7cdc6de7ff23b2c6688515ffd57a6e52aa4abfd76d1c65676bf7d01ce27c63745bdf0769e4ca8e11a28f6f77b89ab92084d9abfebfe0a0c03b9289ff0d7dab058151309584effbd8471931b52ca386ce4da21724cc90b23a429ad97bfe10eb1a64710d8f6c187d6f30e4879514f22eb7bc808c4b309d966a19cb99a0228a71201377bd0925393b8c17cb86f337f2342c67748cf458b47be8cf7ebf2d19ecf40c41bf42c7adc834ae7c077b5f381d4d1c8b2c679964455865cd030c399329ff157cc998ff57f4c1feab2a251fcccb9cf2cc64470ea650caacd061193287fc95d4a2610b2387b6647fd5f231b85c1a3a1614633976a31b29f6c6746df4a8b30f304d30006ad1114c0018b4de581a245541138a4a2ebd61b39bca773691b846c6105a0c413a368f4936b6ea236f6956fe660371d93d7ecb12930aac4f52d1c8a3129f0c77f9acc472d5bd852bef2bc0aadf8a447ef10b72e3426de44f0c594ac20d3fc982d6750d747d799619ef8eee18d9432a042dab3134297f5bc1c841c40b289c8be455cafe5516c623cb1adb89f32c1cd6592efefd11d20cc368abb722f8b3346825fd0d7d57915f378160c158b517dbc90406c26579727591cb62937402ecc87c426d234546001ad03d5d8bf6f975aea69e48ed00072ef5950d9abc04f9fc9f93e8960ca17e7b5c18933bf9271153cfbe79f3e3edab33be593cbf17bf281451b1e2479d4a831a7cfd2e5ca07721a6bdb89643a4e300e946b8de0ac5e5d359e950ad6c7d05924bc87bd46567beacb818b61de5be2b1439e07dbf4ff562175817d1787fb4eeead765a8a8b69cee943c9f0db8a826056120e0acd160b21eef52dbd1cf91a71fcc5aec33becbb4bc2df9f58c68540ed692b0c6d4ca4393c951b322a5a0d5b6094dc01a22ad02fac6e191c3df4336f97c0b5c3b57365d97458aafa28dbb18c8ca65d6f5ff1363117a910a4648b1db5e1d24922073ed6ef43196aee8e86bf9051c37d1948ba22c6e5d767bf3d0af2c6b5ea5610c5a6759f94b3c5631ac5cb955ad240cfb4837cba98f861a64e6f27e32b7bba9b99ff6fdb3be697f06d73e5949619baffea7ce53a142e27e68e1eb25a6860a6a996d5a10dc682ea29f8b9f60e789526a6e0cd0e6e1cb9dffb9e5af6e3c50cebb00bbc21fbea3fb1ff78cff317734b9c0165929c26ca1e998738760648bab7e041c19fdabe952e62dc40dc308be60205367ccb7d3bdf3e5a365556f5d36d2dbd7156969e752fee8170f0236c861d93b51abd249fc23512bcd0fd230484de00aca980ce9b62f090ba8bd9dba1b276924a4217d6c90bb30898a22f928c7f91bbd4a92bd4c4943853858755483fa4f081bf80ff98fdac6fb418f5fabac9d04cde31741ce9071095214a743f15d0a68a9dcecce4ea5c08acdbe03d24596808a1798e91147e5427769a8bc16e919d3bce5ad133488af9c6bcf2eee5fd496b48688f7f54cf9f1b62b8e83237e351ee04a7c3a071343d7819d3c1409c3e150e8238ae3deaeaae1d72dbef99319bdc72996a422665377c017c3660bc804adefc8c0d5d9443a348ec760734891416ca3a5f222c619075890b2ef8588a6be4129f701f2fee864e35237877aa8e2d898e8b9fd3f51d190976cad5e4978d28f20ab44731aebd7251f41f351b280abdc5be822de0d94dcd571bf4749b18df3dc83c430714e2836fdd5ab6702a217634b6fc2fdea540673e19983308b8b7b9bad26295b7f22f5f1c47db936ef9eab00d5402336ec846acf3519e59115cc50e7974abbbc8009433f0b85382d05fa6e0f0b814cc4c3944114cd5920732807891ae9e25f77721ab3b66115c385960ed6dd2f4c56f302ac130984538cc9e6f4c6466d234615b297f71f791a363c7dac54cb2caf357634d635fef263cc466e8a83b4122b5d71818e737068edbd6342b02bae3b634b63e7fae8571f264bea31a600595df8599cbc9ecf0d55ce34ea4bdf197dff136f149f56699c589022c878e52254e5b902647757e7ff34f682ac239d124ca2936923eb220102f5b59589c0e01159637b390dd2a0e861e4884d791b7d3f79ffbe91c9d5b1410ae7c511d533919ff45058a6f0f877f51b48a05bc8c36eef760e6d4650d7bddeaac1bab62f32fe449c54cb07ac5f40b0dcb5d1535b12966bb91156a9d1eadf214ac88bbada690007d6a5b5fd8fd4ded677efed1bcee610ab276d62efe0ef80b7c203ca558232648a0efe59aed116e9f4287df8a592e993b3a6f6bcee7c636ec3988cae2573494637c8dafc7279b83b025bcb62cde0fc9864aac3c25c1f9eab9952e88366241b3b2444a761ae3417cffe2db587aa53194a5a4d021b5d1e996ac0c06f725123275536188c4553e3e3725ad5e7486a904aeb84c1a7d27b77f008448d0c8a2f9087ee05f7e0edf05f75cc8edd7d1f1f2a5c1250105e4c56abfb5658ee313572f16e1b000562cb46517c0e3683ec0dafcf9826067f994134b54ef6feb8362133db88a54ac3cae019bb117568ac784f4efaf509cea6fe727ae096acae7d491e9d74c9f176a074afee89afb6bc2ca9202c7242381e2b150255a4129b03caa154a44af42de903d029b50864397dd3f6c0d4e88059acf568653fce308990981d52d9585546dae111db75730eb4fe337e0f106a33e818d0a2d547e540ade24b502b22f77b1e4657676eb3fe7d4a44eabb906094e2e2a06bff3d874111e5e1af7d68b64f0407ec76156d8b876a6e7b9938bd6645f8d76ddf66c5a082b4abe1b4b2243e5baee7dabbbe9c348ed48bf4fabbac912d52560f5271ba9781715ce06dcfe26a98605eb1f09f339a676d357634dbe25244eb955145f04dbc3db8892f7b009a38ce3474d4018a7af63d3821309f1bd7817c612943140d578b25db9255ad06a5e0df0b5b9402bda05987a9a575e25b2a29749ea8a3266a35ea294c4e890c967aaa5b2b97ff54f065d0b728e9b22c34c37a2ea98041528f5e97ddb63f4907ca02749c0dd7d745b1138ec48e8abc05147127ee07b0764ec42691a2949f94911680691580d06b8b57d97cecc8b3ee9399b509f98746dc71aa186a13026c0ceb87d6b398106f2665959e2acd1d0ae49fb3a616e2378d1b274521f01adf4280487ce1dd3182714533cfd1b7b0941bfe5d9ee330847ce09802c5f9ad4bc5111ed764c1b7d821b7944022818e73a7a197ae607010337fc1c6fcdde5df66be13a1cbe5290ee8eb0e5d1e9f2f4e9a1f11c1cdb7f311b3b03bbd48cdd0f45c0060dc6280d57c0d9e282bb6c87f1fec32637907a3af8e327973631fabe091c5d35cc47232d5d274f3503ee794da32d93b29a1419de51a1a08705513655d9b62601faec005caae45ea53c63f0ca4f2cc2ee0f707912c489bf62e7364969f4207ad7d29174cb80b99ae258bc4c12174d37c100aa8aa75dcd123593a7a9e32a7da0a070e018fff89aac1b80977884554d7daf86db6a1e801ef0afb4787eafbad9961fcdf7acd7a2f32ad110679c447116fe5879f448360ffe3ca1e1df7f33368ab6293ae3a943df98bf26785c702efd8f4c5ea5ab9462ba404be3e8040da812b3a92f4875a79d162babe029029d567b10d8ebfd57f1c1c2cb44cc153e41535018be88c06980f3243f4787d42b3031c9c4c7c3ab1ed0af5257c0ea816f7f729987e44d35406bd91cfb660159c976d13c4aaf5b2dfbfe6b411b44a720b7fa388956e2e9aca0b482a333255ec552567815de5db49d4ef3c1b57886b057c332541e6c8e79b1aed24c54abb076fc93433e91c8b154c22daf6f235e69373aef0729873aa32db0c638a3637ee1919627168430451184c793e2ee12b5b0815e0c9942d83f3ee307df40ee3c2d905479faeb9b3479cb3763a6c04c7a41eba59ae6c8754d9816966aa307a4b424756e49723216b3a5fed650634094148071175d2a1fb695c857e27c734ecb12cba65bf05eea1db0eca191e9d301760e1ca9144e1910bd7ba128ee95cc7b98dcc2b863dfc6a57d33c036acd512624e4d40e36237face0df896063c3720be348d4d82ad681cc8f188619313efbb04cb7be6975b330863faa9053e8921c1475b636402189138a661e1e868d6f5e0e7c95c3b7f55c8b956c0f78a7fa484cd80654d70b6dcd54bf8cf78f359cbb1ce9ae82c2fc823a0d821acbc5b5f68c588cb5ac9eb1d58232f12edde4184abace2580acd6c4fe58416956da5ed16bed64d1a86d0d2571d6bdc89b427899f9ce4d4bd3271a2f588222a9c551f0307e5d5f79310e11ceffb93f52f2f423579fa78a861c4823c391023de22b36196bc6aa2d56c820f0c1f71f77d8d40e9853569930b66ea7056daf34c42d14d1dbf0255dbc3fc17b853503ef8fd610569e68f1ec0e4d4fcf65d579bbc41d493c35031e722dab7e43c0254391311e56606fcb9efe85e1de458d98d652b09925116761cd36e9f21782ea486bbfc278f7166a5bb2306d1e50379035cd372721de77ebe916bb8d982f12dcfcf00125489f71021337b2b1cceceac169c54d1f19974276c18c00c4e62af9dea1463f4a2d4e311974a117b1f6dac1d2ec03cd520586b8d8191ca34b4db44de6b551a71034bf2a9d61ab065350d74034a541df5d5445cbd87ebb13894832a62918bc5d081271cd8b5532dd74c654d8a0ed34e363957c56f56aa0649c8c3dcc9da9fc05e81b26616def2ab12ab5e9278403166f3866183f350b8444ed5cac9d9be6a799ac2cdf4000ab48eda6ad903928be18eae8a2a0f5b016fe316df6bf49d15c46947325c763e3f548b177780a75ec2f5488aecc96d513ecca0e28331235e2861e8a4a2279ccb906f3dd8d99c5a91694d4842c3d83488025cd8d8e49217f21305021d60a5a74a7c9db8243db5aee7a2c45e1f2dd75b0cdff437be0cfa9cf0ca0dab35cdd17cafdc798763cdda6a356f8ef606ff43cef738146b622c959c432df05ad676418525ada6ef517fd87a55f8ae4d4e7743b3debde4e01823922a98ebc42709d3651a6e9de1de0bb37a7612e133fb76b309b8b9292db6689803f836533b79b35fda9d36e3942b07e1d3286f8ebf212d6cca3376f1b74074fe20074252cf10758297e465ed03262129fce841001dab0c98ab5af544d39cb0b1718c1b18b893562edc99d974a231b85ffb071d13c5e8762c8aebf303775a0ce802a8a1b80c42cd78590f079db336e80b15d9aa0e0538f88081b954640989f355a0cb433d7ccb20e0c4bf7bbaf31e7bc5943ec131a21f9ec0566ef4ddb8a31375b133bad6204332fcf1726697a0add89e8ce64a1edbdf15edf3700e5f871f63e669a314372cacb2dcac26a740ef038569fea859f42dc1e6937608a36074d24fb1b9cba2f7e8e1d570b577e50aa98232cb14fd65b96efc3aeadc7d0403c5af3e5c1dc86461070902c09d6bf8fa622f57dc60e9179f6d3e22f345800ec8b1bdcaf77d133cf9974efe03c25666dab19756cfa0c94f12039d31d8af9018a128ceed14e0f13abab01e3261b484fe81911f86160f82b1a588d9968db0d9cbd3ad97c4cd265b6608e9ec942f6994d231b42f5b2f2674a9c2892f3fa9b770963f00a97b027654abcf991efbe293277ca65cba439262597a5afac0a50440995643776c225a9648bcdfbe8e1edc9f2d840298e3c9dcee42c2f87bb1f6704530e82bc5905aedcab08fae587dd75b9ce08b8b294fa575aab01be3b39bc4cfbd6497e23d3e0e7172955142d2dee84943e6e47a90c985e37f042f480e8ca0f8ebc5a5d433d449cd0535ecfeab870d98bec26775d94c48589f81d55292cc131dab4b5bcd62c8ac22ff1c6e2521abdd6e80a96f7d9ea22507a7031f5cc4a4e5322bf5095d64e70b9440ad6a8fd850d0786a0f251fff361f472f74ab19f6e0be902b888432aa564e2c5efd7dd39b3f4842ad88bf36b7d6137beb1adfec063dc95d5cf2e93606f62470f45121943bb9e934f961d594bb7959de20d1c554c8e9a4becd94eb970294f50a0f6e1c31f73c868b9c57a3dc2c0ff012d1b980c3c488c16d07394b52dc31863b74cac765fa63122367523688b3e77c7c3bcd5bb9e0fa86de5bdb2aa1bceb605341c6b9185edc35b0d79abd16398492b4465096c142e0e8e8732f140578f4bc8fb1aa167a688a047bae54a1714e4821c655f7de81924eab8cece83baffb0d18e607bd8016ff62f71bba98d52ce826bd18489c3faa4a8a492b434570822de90313ce6ed225a43a233575a57cdd983e043b4d41b6c179e7fd81797d8ad1892854a333f2e3d6282344928c355d6c500871eed1dea8d83e657d5d95b8091fd81f4b5d30e68426817bd0499fba080384a191be5bd06a261bcfb7910b82d0c9aee38d5dffed9c8aeaaf188b3878a9bebdff8ac8cfed235f918dc1963b487685a28a202a03a06836606fec05447c05cda9c6e74c9aae7ecf2f5edc377971907473ab83f21628bbf5da42cf10b405e96ee5339b96810c7e55e4819fa55e3d606765d3994b0f8fb0f0fa8a650a89de41e7618e78457be8fa9ca910749dc725a5893a60d15b9d6106ae8cd3ea4a2da8aefd2ee279cd2e759c1e00202083cf0cf6c9287ed2af176ea63cc049cc7046d93fbe84076b1fe79e78ab4528f40ac4e05459996e5a3effdebcbb2475549749cdd1ff8efcb0255b8ff8e2a479f8a6f38ff160895330e6821177eaa0dff803c951a2c05690f1ad48f064906e5d39876c52db3491b47bdc0f3a29e8784c43b14cd07372ca33ce072e29ac1a27ca7ba0c4719c3db45a068126984cf9afed5758f34e4a41467f420948bbcf3a53ffe6f9ac6d020c5fa8d446689284943a32ec0b2a67e98a343d1671240391a0f7cb5fdafd59b813dd245d457e8eb22550463c54d05286d9557a57b79a6859b636c5f718c8357fcce06060f1e95270ea4e5d5622fdfbd9c80d4dccab06bff48ceee74274e8b70092eb98bec7211df135f738e6b873314af1b0073b13b67711723ab4399fb4109355e399ca10b6d91f40a952c3f0a1b0ef4486e4a817f5ae4c436b73817693eb6f4bb68c63460c24d0974f82be231f9b8bc188bf794b599d55286583c1b426030fd9e333d9f821193088d9738d64b2b50de2d8db305211bc33444646d78154cb1973f8a305c4318b3fa152568f35d85cc04e21c1cb8fa7f25760183862e4ce9c482ddfb8781ff052ad90759c30aa2d5e37b0ea7f68ce6ba8595d5d3f6c6db6d21dc3fe4e3b615c066d4c0e871a6b91110c9fe1e33c34ec2b22dda6a329924a45aeff2e0260417855f989c95e8778c6aed83b7141f542be58abdd0fb65ebe394374aab42a2e3a7300092cbd1e975816cc0a2530c848bb83c789810580699b71be04be94ad0b2acc61cb5343ed5d1e1f5981d5933e6a1ea1c83b834e376590701924b4eb38d9207e338e2ac1d2ad0c0afba5c0ba3b52592dd7acdb73b5a5c8c2ba026bbf6de24cd428f2d1ded2a7c82f8c7fbfee0204786c0c630ae839657f510c1ef0541a7bf5e0471c5e0545250384e97ea98934dce87b43371d314541c13b4c24152d3c2b4bb8201cf3f2eaf21929494943aab7964b0efa60336143ca8422521d35a69677b485457b2628302318b48eb052fbafca3442f315d4f81adf96bcb373222ea50252d1ba01ced2b9ca4b6356307568d14f333fad8e323e6feb07c919e8f966d4ce20a5cd1631ccd65f4e01592f5aabf06b8fbc9d850050483d8ea0f076cf0afe1d95051650c3496137544fb2c31a7879c653ca9f10322dafbbeb020cbeb9f93259de00e72914512c7aaefb4ed0f0e11b759beb17ef4dd41ebebe845ae2cd66e214c83b4b552f319702101ea1db836d50a8003c305ecb298e40c1afebf5d081a06217addbaf2bc695492a2b77cc31345e609cc3c31c8a2b1565b7158e446ea2a1b62714c8731a732ac0b6ee5cd8857b4856630abf788db5d990075e1de873f0ac348907472a9486f62ddd8db02b87ef6134771f68ee5928d8566d5232317a1ef6fa1da18bc101f8c847c224018dba98024fe2f754d04612c80b4fbebd81958967c5b6d5a152930a71dd81d0748d50f7d487f80d11340175df02f2deef9f0f60fe3781869e492921c9c53be210f93532e356548c6c4a36f70e2162af1e869608eeaf3dca207015b56821027a1b1ba13c62fde09b88d696edb506a6f21b668323a59aabc88ef2b0479513cfd5ba902a9c7becb8db79a52ccb9821bd8dacc5676053234911bd2291a1924594187734e6397e5590cc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
