<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9c00a3173faf7836b7828d532b4db72883e142cdf70a46a68beeaeef4a72d362ed23aa1a56eb698c3d45db91c9d4c47897345d25e8cba34410f171cffb2632a92b50d5c5cedb83e22ec8f68384d4ca6908092cedba2d872825285b5e1c96695a300e759d4eb9b2deab8b246ec7862dede372e70217d262226b0348f38ad3d05de61e46b2d9596f938089b2c21a88bd9dc7bbbf2d11f4d3233bb6d89f5662725ff238655f9457b3c384529ae662f15f0d118f0f9392ab6f11c65890bb257692723fb0452370b19e67ca77b27b0c559082e127d01c675718475f1c1e5fbe419be41c4dca49979d8c224ee39ba02d013abd185526e80623da6c619bc7810a78dd223db6dd26af1a0d2208d318bc7f5eb452f8790535194a4177fc44d1d106e1fc161517217473a41493603a453fec19684a65af18a62e2e5e67866fb230535aee4ef0f2eb9de1d7a64a859901ceb0335949bf39f1765f47a128e44efffd21474a408666b215f268360a7efeacec41e715dc88f318918e4f9694728f261b8f000de9835f7355a005e87f63c5c85b9c42400216c3178531200490a6becb27b803cc95b6a6c864e35ccb9a5db6b7e31b6a5c52a9f459eac194cd656938b586baae9738fa76beb50e347c991ec47e2459dd86daf698b2329a4aa4e17417badb6fac6182f27d0421ae6ee151d21301afdce6b54a5452de882570ec1ad29b33b993e8315999a0bc50844a401447e6ed1c408ee21f0dbb7b9d8b753717f734da84ed871aa7fd33423d8e74ea8c5012d5a9c20dbd8aa90bf49d4531a7424389bd89da1979c9b72ba43fb1192662c59489c86854b9eba5be51762dd8c685a66ccd5fdcb37ff08849979f3cedc4a9011276029100ef05022b58e487850b9d6449b0142d43180aa1c3eaa7f1deba661b5e38625e297efd8af4e51fd04699d3439aecdb48d93a5d4bf55a09ec610aa7b2159b72031bea74f05de0c5eb6b5c25774c8c22fd4cd5577005e7dd9cba99eb845b1aad8f0c7d0428be87d83a4ef741e3264a95c2eca6296e6117494bac10e61cfc7b4ef077041406ae0d0d8498ab506d43ae8ebb09176fd1b30e9791e0dc03799fc7f402e350fbbc2f31fa6fb0d33a750199b7a6c05fece999a10f4f596698eea62f12a4efbf142e593d9c71581570d51683d44dacd84228e0f20ac07893c58f60a71b4b434bf3daff51a119ff2707a57f26654396376f219be63e3bb705e14a56737fab87874ede4da143f4e79378d153ba5adf8f0406d60332ba630cc71cf4a7f1447d931d17dcfd0d9ac88d23f4e1c17e1d417a3e63c2a32b7d26b39bd07e84c78930bf73692e95d5f72a7173ae03f1b033a7fca708cdb2fd5af8e4967b8f2c0d4bf04b71b4d1383d56328de54006b555e46f89db695a83315bd0b88715cc4921fa7bbe7fdd278fcc0e2f2ec0b6923ae3c67fc705a4b4c00d563954507d9c0194b10910074e84d06095af5e78009b041b7236083c7c70feedc7b1debe9d01be1291b8811f34a56a168e8bb62d2d201e845d933e1cd2bac519507caad4a16f375b563efb40d0c995251ebfbd4171bafe2945d11520c9d801736cdd7c70b0128e0ff9104e71a2c3674ea3c70964951d688f51efb953207a586dfce5e1b415003d97d933f25de594929447fa5e2c23852ded915f856486c12fd65df23f9387dab1d3bd20db294704abce6db42b530f1f320da16c8d6d95d00316ebbcdc4c544ae669f7ec773021f6978348fb9c0b14611f4845e65464a718b603719d714849603d2a750326640fdb9dde3a1caa2d02d436bee6fa868f1d324d19be501f8f68b8f69e72e88932ff47b1514e642395a9f5f4b348370c3d479d46ee0679aace091b37bf6fce23c549c08af2eb83a8e54c279daeed6104ec08061f2b21d41bdd0a4040c8e7e70cf6955508a9c825de431c478d7e21d4412d3f00e7bdd95cffaee96b00c1a7612aec4334a6af6ac9cc940776ba0eff98099120122d59dc65c21ad91b7262118d82477ff7480b9ea2e653ecea55c71dede335fb01b3da196d1ba844da3289a6bdfa75ae73bad8316de8ba63683f30de971092c1edd6df5931db8e23f7365d07e9c8c7c543fc49773270e302584fba0ceaa29004ef8a7da12a7b1dfa587accd6965f7f9d1b0527671133b6e23c39d768997c740d6acaaeb87a1b02f81c2ef9adb9349d94cbffae074623a15a9d0032c251111a3198bfe9ee10de6a05525bd44bc606a47d75bb7ffb28cf855e8b672d25c007258d91472773718d483f69c0cf76aff9e9e5af8df075ca1531b639f3f0331aaad603588a13808ad40c6de06da8d958c9bc92e40463f9c97c7534ef8c98f74566aa076bb3cf218aea08ff0de3d282c78cf82851a24f3e20d97e7759a1df48a17c831276a6fb73b1ec30de28fc00db2d8c951da26eb18826903b4813f5177cdbf12b040019d1b5dbb5d9d13c3837aac4b575663b3c1ea2556256656fe4843eb11e180cb628b89dbb1138dcae8da4d734717a0d98f737f4cac9a05c5cbea4c574d54a6e5366f07cf16919aa609ad464ed46e854ca8a1faa6157eac2eeeb9eba73579c9317e1b3daf995bbeef52f89695a81574106aec6ed1bdb52801a1ad6bed94f73c2fa25644ed1f3bd529a4a17355a150d5450091ee6e2237dbabf5da896088b3c8d2ef1a21b034ec767536786a8595f554a02ef96ec04df8d46ffff85a7b781b2886d8645da1a4ab7fc3d285275763280e7e666aebca70d952cb1130d2d616e5219908861f783beb5217e36e0ec23b8715a93136f3fd0ae1fe9c4b891bbce38b610380be2d750b3ad0cafbd167d416eccdabf09e2f6721c7a45ca8396a528af722389d1817ac167d3ada37c162053a36512029cd1047a6890f2f72c2bb9a63379b6cf0ee3e918285b30e75cb7241661fb37bbc2b2aa8c15272ac9d9d20ce31b14f39456f27b9f413da1eedf1ea8e142b73320e798ba425ec4794b17d35a684e31e7121da453e945af8750e341229d99cdbb92014dcdad4fecfe6c979068a09b15f19c9be0434126c6928b9df184969dbb69745b4bbefa32a7616ece375a4cf4cec302ea3b1fd62f986cc18e93a15a5019e05b5a0f9e3d6a5ae6c183fc8ee118b2de4e31b472940bfc2661edd2ca8ecbe0b8ba8d206c8734e6ab11ddc9b5c2f3e77778cc1f5b77578f03bd240ea6bd3d98d22f0fdcb1881a44f35f79e69d354a5e5a5bdbed1ec5502f054507c09ea381e7534101d458b2453d521b805dd025dded3ecc262eb0e2644ec642fc40305ce91739f214f59e7fcf107f3a92fa1da15a372700dbef191ddafc5ebf6fa7145c478f7fe260ef1c78b874d9e9d17f4b93ed2733c54d5bda4c1618d939fe300b8bd5cbab570a33596c60050ff4cd6f22daa517b2dad12e541fd126299646511d4dfe838dc2e8727b644fd6e9d18dab2d257970e603bab37e124ed2c0e500ead852ce45cad0784704a1eb824baa5b676043499e6cb5aed509263d70ec65762fa6841942ea25217c014b8cd47e2a23af57f1053f992ce4aa25b874cea7b24cb3e40aaf64c10acd1b9301de28123c01dd4f53b59f0b8791fdda60924b9fe3195eec6b6d390b53a330a5ed505fd4b3d40ba93a2589c018e99175c3fcc183c07027743a74dc6eaac0e6cefc323ba4a7f5c3397df76881dcd6253776e6a6afd3d56a122a96d78ba3c13fbdf85a2877e8029746bf5ada7bcf021a2932ed384b8088c0557f3c472a5d7d569ae8893048f96b9f8ed5aeedba0bd66c1940937f9b73307532e90fcc3799ddffe6c29dd122611d553c338ce13203354b885852d1176b0ebd08caae1e1b7bcf64d93952ccca10293d5290a6557abd19498c85885f6bd192f4d8a02e1184223833f973220649d8fc92301a172d7104e074406ec9ccc23664c27fd3c188e3e89c02c26a6781830d32a53058b8a426ffaac105ccd31b42619813c9b2c1ea83d439543bc32a58daaa65003e6f22bc458fe5a76156b30a86a8f9fbef1b79a6d7c4c20de7f4d4a9b66e22f16b3f301189206d496b38eb1a88a34505f55320a6e98ff59da76b4ecc34e0d626490150e00c426a829f9ab4b82628f4a53697b98e22442dc40588f3f55afbefd22f703a72db0fa20f788f1c9add84c3ff91e3e69b17e42b08ad7ac637076cf72aec9c997d2856f42c8961539b083df8c6a110b53c4d09a34ebf9ba9d662f6adcbccfa0e8048ff69ce018234b1eb9bf272804c9eb78bf73fed5765433bfe8a11db3669a60a21edb2bfcc7d77286e1e61360b662bc00522a17698c4204424d50c776654781e37d40a9b6b3501df43a299242623aca3a45a545e86c52ff1b5a4cc37731b58a5c92dbf2b5bd1db1a3549c5dc775e45f908f5d4509adf7244947d2f815f74b65a47312837b69bb7c80ae67b1d2411dac682f3faa3d1658df10b6e054b19056b443d80dd12913e8f529c2a64dca194c50bd20a99871b86bb2c23425840213448695a78227ac9e6b5b73ac5d7f4444c2f445f430c4cc48a40914fbc8b9c6a7310e0ae94a466e58dd3bc4e55d634990e94303a0283c22d6816f6c2a19f7ae8b65f8fb0740cdab2106cfd1cba9027956284f5a525c8954c42c8620b9f613bc9a0e31328b48ffd554cb4c45250c3a13307565c194ff812fcf5b86809247bbdd442124971dd6d3125a6bb3cb727e24fe9812bf32c0764a0a19d42c89e1e8a1efe34851599d4debc780020a1bc23b69fd7ae98b0ccf2ea499934154af5d6ae231b369708353e1532d49f7634245cb8f798249bf5ad2482f1d96feeba556d7afb344e393457c8bf5c727272a79f3aa05e3534578669e38a98a7daf97602cdd0bb68d6f8e84721dd2a856977cfb9d472cd695d21b4b045c4ce5fd32e3ff4209a4fb410eb1a9af0f909e974f1188762a345dea190353968ecc5a10df3ce2ff2b5e04c768fe7c96d33cdb0aead66ace7768b3643d52b1e880cd826f13102531d97764899e78fa5e5567961eca2f859f08c445a18520f1b618948a8c13e121b3789f1c84394c725eb387e23345fc07f861bcef346a1d99fa142ec2d9fbfca070c494e473107917abfdbcdd961e33d538fe52340c63fa5a4e10134a5e56be2e6dc414ed4bb7e7a0c926689c5eaa459a253b003ce5352c947018bdb9887dfeb0704fcb269c70daa81d76af36fafac1de8307be7e329ec8dcacd2e2d3b98dc675c95bb341bb85223ac434b7c78564ee5fff01e5c860477790a70d93f8c6ee7f0bbf193de639d682fcb44dbc087090f092af7fe4f2e2256e48add2c7f4022221f6f6719ef35491e3f80595f5029f5d4b6f58615f7243a9cb2627632cc14394c292fdb6b977176720452f910b579df756f468917b35b9bf015a9ed22eb542bea45c4d0128e3a71d153e34c20252e813bc22e5de01bafe3ca749090a17a2d45795abbaeebae488f3733c38a545765081991403aeee68ef97606bb5b0d378858019979501ea64ec3d758c13e1af6f9b069db48484411737c33a639f82e7d2c794568294998cd43cca27915b96f8d039f63edae2fa2bc83f8ac27ed6c473c48ce59209e8c7890e6438c0fa14757b378ad125a6b4ffd27af1f03ff9cdde48d9c1279829ffe90d356dbf782388363f291e373cb7a2a46451fb515d2de19d707f194e808fa6c2e124b3313115c173a49674e0088555168c3593cd6d1593ba08945548fdf84778c4fabd04de0df12abaaf3ba87956fdb8eb92923097167bba54d33d2a918ea4b28387b975a9c99df83282de8ce13525aa6d6e40b6b1f6a992e3c65311fb8d7f6d5897329e8958ade124f37f3566beb47a59de69f7b6bbfcf5487eca5015a63ff03dc2e0d6a69165c8df499c2c1c5bb7534f1ddea92f9e7663c3459717746900f5845e6f4afe7e7ffb0cf6267b6b3bafee3429daacb1e1c4cf2d1dc6602138eb0ac04fd378362277e5b1b5ccacd0d52320f1f3d6896f21abf829e4c895c1d54fdaa66112d3e2b9a2c77339aae10a0fa3f56bd19e183b2a630dd7ea4fbcd82c998ab3db01ec03d0912b63f0ae3af0da7a23956486480432e6b8130448c2943fa8e1a36f6a2976b56fd6a288c4506be97cbc9fc9748f9544b5e5e0bff2751c7dd49509d44f30868a85857d3db0324d2da69cfdfbdad8e8e7621fbadd295c778aa87c90e5d99a9306a38a33b13e20aadcd2db33c8dca8cbe56418606cbaa2ef662ee074abbcb1fcedd111badca7f98233e31aa4d426a86a048bef7f5a89c6249f217d114bf081191d87e0e1699c66e065e6cc97fc57a22792c67a5c323e8006c534acf33ad54ae7630a421f013c2579bbe7381557f94672483f3df14e90a986b73395e5fc0cf7d6da7aa9e560a70e3783f5ca9826c4f3678111db2c542a3f50263fac2ad19443ba4856543da41fb0e82cc76d395527c7b9cd711755e9d5709d420a35891d1825a0acffa8b10f66c31cf62480c3c153ebfdbef4181eb03dbf83b2c80f2b8cf2ee303e4eb5c5614e3fa853813dc76863785a2580721aeb8af3eb8b776d8f5a8ff5e7def9e40c82aa1e6b605501b6e6ae33d2fb13d90bc45ce87fce1c61f89c00f4e4f12c97950931a19f01946118489a69005426101bffc6a17bc08e41b210c02f9884c5a1a66edb9f9b2031ed0aa6dc41f363aa93a4182848ced1809748043a7cd7d631da1d7b0ba6f50be6548e7e6af8d3128759a0a463eb25caab2f2a50772368a5259d28b63a177fdb8d86b8a177ab521834bc0320f7cb5fbc3ac4b2747d4b67665ded3bd5c974fc1966dd552903d262eb7b886ea9d4a0f1539ba9a99239745ad78bb6ed0c5589740874945617fb56c7a25103b12bd17cbaee75689d150812eb7d0de437b5c001d2130eec83cf4b0d0a0566c4f073994f3ae5130b75842cbc4de0c6f1bbd9d80dbdd402c62696db585764e2cf3efbdfd4749b5b84004f1925135780317c1c41de2e7b06f8927215dc1d629276f83a8cfe03bc5e90cd20b1c3685ce6ab32363d848f8b91f291f2f58550c4932c92c0b69c202eb34a110ec8722b6363e29d61c81a99183fd4fec39e3cac9be31c410b390db0c1406b2670656a1ab0053040c7a4c2c7b735345756ad58fb79ddd14be7b3b6e9c27bf9036391b985b3099bc9611002ab07b6e9da55681fcfdd6a4363616e105f8ae0a38ef491cd9adb583a42c610cd0ec0d4c1d4d5dcbeb26081c514c30b5b12c3f9f796b64fc053cde34b721ba8d5377117a97f25e4c9d43a864c89f5261662d64145bb028229fbda67e6a2cc5d4736f156156ff785e20edaa635ad0974ceb12b2a2c51da9cd3df02ba0465e6078b88b6b69863221bf1801c586db918e55f3a4ae319801cc9d8fb2112eb7a6f8c18467658d3f17d4e4db99a83da1cd64b177ad37254b75e4812656dda34c9637ea8fbd2d5640de4b4ef1aa12c1a7ddb5bde2dc1081f7a37b5bc9b400537ca579b873541bcb6ee97c7b4e9c521a8086acc5586a468642b1671f03d6af6f6beebbb9a7a366bf2f733e235e50c915068c2fc4ae1b61ae67a4e6a7cccc7b01a4cba73f1d609414de1f919e182405e1888776950861eec25cf9d5ac2d129899987aa2cc506e712b8e3050d3e53aff944155a559a9afd9cece268238502df334bf69e12ed9c70a8d0c77f93f88918ee0f1cf032a6af13371ed79768133a897bfd3417f8509b1c0193dafa0913860dfe0e25c792e80d6424722d484bd6a9474388995ab76d0c6fc1d0b66fdd4dbce58874a496d0eb1ab12e85eeb6ea21a0087c8aeaf19b1d33484559e30925e67b17665b843e8058dfcd74d43aec11e44388caabff6aadb22ccc8d809fdd45a47b9e1355efb86f338fc75d4c1b04029da7cf7b78b260c4ee2528f46c490f574c71e9d3bb9ddc240dfcb0dfe3dbff066b8f7739e2dd3dd27d2fbb239f7bb5ca3cdceed2527d62c6bf7dd77abd4b454771c3a7f2601b3b3f3ac8708de25fa3830332c49570de98b8804f3a6d40543b5143f7fa7ea27b40c187ea4f4bbd828ef899ad0d425322a43fab502c9f9d6db8e050f955a8817b611bc46c5c6d7ee2efa0e466990a4079ae3156365e7a78c598b7d8818ae89afb95adbe4c831d2a33ef6c745c8d7c8d9f165c05984a02536f3c4d8c5fc6203ec21de0c2307f7ad94dd443a552fb6c96bbd4a8b6841adae191d9f7d2aa489b639297ccbb78dd9771522ac98865f1bf73aa88952b44f63fcaea0ccfccba457fc6219d76f1359a724fb00524038046a9350cedb9e23fb2bff791024aa5ab7f97dfa5274d0ef8730c89dc53122740307db5282a695aeb102aad48bdf83b68be9d6cedb330b3fb0f6647ab09047f3587e8eab7f561452c7918c276f263142f95636c612712dfd143032b68c1f83b4349e19d0a1aa306b77f298f92d1e2fd3f445549b8205b65807fe25c5d429e4ce0b2331331b59455ed8affc674170a8734da8bdcfca33d00de0987d9666c388ed6873adac45a16f00d97e5f54973db99ac1e532c11422bb37b79c11f7a67a18e8c6ac787a3c19f3f814e0a8166acca42138700b5d9fc6b56b3c24dfc505174f67358dfc9a1d6f3143c0d5258027812d704f92864f07ac2f149f35460524e75f8eaf0d487fbd9bc55f29c2c148c010395f5af4898dde021dd62fd732fb3773062044b235fe987a47ad175d0e4855d31a797a05fee534e1156e8cacb8434f7dbed7542c96defb8b4e912a1949ced4ffc78b6263de578c6347d1f23806ae118359c0c060aff551925f5a323ff26fc0580359a45afadce4119ffba0a3a6acbdb11f48d08b370d0ec0a46854ad36e6e489f294a212e595d2e92ccf246cb41d1e8b7bd31d195a1cad49390fadb38fb59df6573f8cf5c07b13c51dd1512813d81daa7f7a85122b43f812259f15ee07e834215f2e79ccf20e3e1d99a6d38761e34e771825da5b0336b2474dc72f72e930a19e59cdde2368df31d3ef6d045580f41653474d10eda127f0dedd930e34613c027225a3e21d29ab2a5d75c6637b19044fe20a63840be935949d91bc651db62130da0c5117d9f6a4dc7c14c2d42ed526c20a09f3c2d911bffef7a74850c45bf5ef30b867361ff1b8af732990c3a028533e22a67f8bc7719805f9e6c8868575153a0c1d0149c3639403821257a3b39007293961ded05e4747d2ed6dea1aee44df98473d5ab9364b98921deafaac4f92f4dbe7f51bd6ebf1032e91a910f5a64a3da6dc552d5a8d5a8ea9ad0438bdc313212948139fe3fb893d2a857b242fe1781a9eb7470930bc2e50977fb998253db8e4899a9b02544cf8f30cec1aea884b3e337d49564ff4af3c9bdb7b97f50c2f828ee8ee70f237b42f326a0e9dbec979c34952cbafbd54ece6121292fa781cd93e9079d0e5212e01acfe4f865d641d715b856afef0c3f5f929ce48b0210100d56aca33cba01790bcc93be557f6afbe1a316099f83820d9b1fd6231def8fb62936cd2abc599f41bcb7f23041125130f4b7b05d8f99ba3f98dfc268582c2a512f367f8fd7c4013dfc8185f015911b76f1f6a6693750cf2b2229a1d2cd04bb03490ff116312fb7b2aee4ffa62e00ff435763fc9a5073fbfbb09a34a0b2e308e839984091dd915f14cb30863a01ddac3ce4e0bbec322cef743ce3d3948f8b3d23915d308d715c4bf130ab68f699d009c767eb2515bc492fee1a0831746be05fff694ecd2fddee4a1faf5b18f6fc5e8dc26cd1d804e605da1ec55b6275dd5cbbf8f803c9fe0d64fecd7d723c2a6c125587e81422088d9488e7bf6abe5dd39f85ebb1ccb9d8a0d337c7a8ec84725f9677fe26b854ebe5a5b595abc2e66d6cb6b30cde3c9d3ffa721fae77d4e719cfbb18067ed96fa22ad42037f433649e7db904118c3cbd74d7ee9c888c2adf7f8b46bbd606b228dde466012ec1b16932060d80f4515f759b09b9b8bebec0bd0f40dd6e206a2f297ee18e415ef3180029b077191f0420ad7609cb84747fd832523801842756599284c1fee1e4519f68ee69b2256347f7bf4b3109b4b35b1d93c74f0becbb9a6e4847d73d9c829594b9db90e589d5caf4dbf557ec626a7a218b0579f7fc93a88cc19652f31119353e5fdff3ec3922e1435e2ff94bb036cf49850e43439271e50ae4aeec6e37962b9cab19d2277872be2a77371c2158b9baa06a8a112fd32a87cd4b7151230db9046371e661cdab3117701c235cbc55e5375a246da275ffdf53c8824e983002b219910572603d58bb54944467acfc63b4fe2961d46dd98e2f40d496cf158783cd35b361dd93fbda583bee0dddd0095c6d4ca207c0fc9a04a01ddf6be72d586b2b283c072b300309d206921c5b4b25f0ee8fffe98ec8c342744ccc1fada064b9e260b8fb8683e7754c68d22596e4ff85dd2db56c6f124a413d05f6c6480e0e5263464b8eb072588a729c3ed1ef84658f70562f3f8637095d5d8ea6f6e29727887c1148f10662fb42273e711bdfe2538d80a926f71b5950261f25694b407f8d1f98a31574012ea91f7e7a00958196ae972de6068a0fe0403ac3eb4bee33809c7b771cba3079ec9d54904f89a0a43f7920f97bbc87a2720a325a6e67364f39ad94fc547f28953347b5d355541d40b1221abd66c2c587ffb0e9d7171bf41f42b2108e8315000065dd3ca75d4893e8df4c2c9580c4680650dc18b23e9b3cb30384b89d412c7d98841ec210a25eae1a4b7493537c2f3a93cfd2cdc31698dc1b4ac6e35f658f208f93d4f016108c297ebd651ee63abde43e25912754a2e44511f3add651d00e62a0f00a9d723c6d2a4c5163f71b502d31131209e77e309a9095012b8952722caf03324da47aa54b8d22ef06fbab4c6e29542359cf84a97f91929eb17c2a6108a440a2ed1d2cf4badf1f4e6d14ea868b414ac001e8f8c8c91778d3865a1d8189dc57a9193ec8923f8533f4b3cc09cbb9156b34fef36670dc20b3ce0271a931f4857955764589b96f1f3a57fe72f3b99883bf1aa7484aabdfd9396e45e3ae4f8ebf0e8013935e72eb5f1889db429217e91a96117ca338fec37d8481b1f1aa7a76700716296ba24e6657522c92fe48ef6d32d490afeb43a62c14064703934982764092ab24ecf38be4b0a5e1934006dbad14bc02931cc9d3821cef055288fed77a67c7dd2175c8c7d709c8ee4bf7b966ef8dd5569fef4336dcd2d296bad6868d11658382717c438bb964c27dcaa6a8174837f288f3d5db9638ba1d0542695e2c48816a3c48619fe6c3562e19dd67529c335a675af73ee0db3fd7465f752cf2426918761c311ae6d1c6446dbb960c381a3b9a9a19883c672e818869b1cec6603b8438cf5a482f2da747a5d17c2cf4301029a7b474ce49efb715e21bd0b3c994bb18af46351656c111e452a69d0ba1ec35073348209cb5656a9af1fd4cfcaf03a37eef402d6eeb87ea0d6d64c0ea43f8a1869d9e3cb63bdab771072cf85ed5689ba7e2168fcdddd921c26ae570c5c00dd2a6a0a2bbd4431602835cb7013f2b09d06e8d519a767ba9abe350afee65d9d0911064487c489234fce46f28732ea6156c951cd5205be0ddf9de23c7cca61e44b6d94c6bb4abedacd3781d5d3c29057e7f811fae7a921ffb6c5caf6609b989983b251d6f745341c87d04d3cb8759d4b6092895d3745347a06e950ed4e2cec451837e6df61306a849d4022264cc8ce77f726153e29f2f77e4aaacd439606c28224a48307a2c3091f7518c98b7edfd2c8a8616662479da9334a79cf6c5b637c6cd86a2a2ecb86d47b9681dbbbfbda1d0ba4109f9341169a976eeef1eff7e71eacfbdac7ead785a6b12b2f7f7886298c1d077b4dcbdd57871a158c029a8e231ecd3e3bd79ca5ea39ec5309594f82ab7d83287cd985b52aceba6b687f91f723aa682a29bb13c836889a66db6c996cf4a24d6491a0d0ac36e9e6b9a3844f2d0bb2dce4f266d7116f6badea36920d1c8aae5962d7f61fb0df9a3561e68180057f764268a93237a2f590b15dff06d1b82a50fb1196e5539fb4aa8a2328e1d802e268e34e537dbd9f43d9947806ea88535c7282f9ffd54d9842dd0008ec64883d2c920d210","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
