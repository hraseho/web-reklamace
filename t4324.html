<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9892bf4bc1d2543499bc27da59024716aa8519a822a44cf88c3ff9806f376d5b872ff069b8fa660893805b4b65c3851aa858034448925c4dfc69c0dd595f4bba6779bc31a24cf070e14b86fc477de2e3dfb34edc2df863884b45fddccb403ebd8f0de22170061fcd0e9757611c98ca655201999e26833fec8d5aef92b264f4eb534e84710d75b9105c35cf9ef3c5a0380194bee6ff809c9edb64ed8cec422b78c4c22b07cab3dd8f5c1aaff325c4b2e7d90a3cfa6279e3a4b80ccb542c2f1234b269a4fa3b32385d9da837ef31edb5c66c9e42f7c797974e51f06494584d8cd3f1c91dc35ec751664b635ea7a4ac7fcb3a3bd9fa8d05fec33d5106e63758fd8a882516c15f5a05b45295d102922316c68b185d776422c68a28182abe0520944d90e9d7355b6e762cc83406e55e915d46cbaec32a05eef2ad2c1fb3d59415c82d8f99ea8e936f2b4d2354102cf7c27579f7a9d2593d978fd8fa55082e24fbfc6b69f83e5be6a70d91fcab2da08ff5123a07d443bcb62f3616f102a9f80528b492de28648327044fdbc327a8884a067a5bd4dd49f4f0eaeaa8bbcaceb0991b1a0f1fefe5059ebaf9e6dffb1d4097f2b4db3454a34fef52f71471d6f3c9ea3dee0b5494b76d82db82ae55069d5dd3fdac3cde9b2a9d4d89b10e0084122a0f63ccd20290e78e8fd8005fe413e9181c4a613aa4e0b3abe2588c18ada68010eb5d773e263fd9d1e4e6de929cadc6899091aa9490036f922fdc750d82e9ce9e904b9d74b63bb0267b19cdc8a9e1e4ad1d7a09b30bd151f0ae8fe0e22ee7226b4f2dc53a595a45b13e8116a248014ed755989cd8afce68b24b16a681a37df0ae31761dc216758521fdda0f3c3f13397cbf93516017657ec3d1640ef8b854f1d7e047530d0d5894d1a685d73cced0750a9c28f86923dff819c9fa957edda1e7b1323c46c0951846e4734cf31a8c11d37ed5882d673290a5ca901bbbb5981a9e1431e9d1d8eb48627d13f93cab219560681fb2b62d4b6844a61cc9bbe2bcbf26127d2eb38e916879db4ba6dbd1045e339cce0d332bd86569742d0f29450248d9e8b81a166038b41fc9120c9f93bcb96b64fce86f7fd8fcb3011a76a3df9539e859a07ddbbe54a89e595c55116bd65efff5867aaa6f4d944ccb8c7c1e781cd8c58d5986a1b415ec56ea44495fa64812a38dec638358a395c504ab68cfa7f2f0d9bc58325d68747aaf0d2438dbff518003073bd343c1b87a63688162e3efe4e5d70b98f4c77d02cda30de2b5fc0403692b960fa6c6e9735b5082588761d6b0af4e7d23ea31127e56f3b3bb03e1083671f9e4e9944ee93cd005f56ffc263f0c86098dec5d3195629e3bb4617057b9e5e7a91f98969f1a9fa0bd682dbe5d2e74d99052f798a45bf1b73db9d5582e8a054d748a5d771c4dfc2af85a4b4cb5480865ce221da919523f8d8b7a3be1c7f17e936e6893e93adcf8b2c9c58d0ac0b97848d6dd3ad0eb9e08090faddcf5dff4f1499aec200753fa9486163a24d10bbe31d1e1050b38581ee972eec561b96a194be4709f8556cfb2dd71742e0cfe9b15772cd1e21cf264fdade1671b253dd3ae67d5e441620652c12404b80508e4a8bb96dec5cded20e09e3bbd0850440afea56782f159a007d60aef360260e884052acea4c1cc5dcc38edfda83fc1653af871ab1e4229213ba6e8b968a05142d4588173fb313bc913f7c4f7c3c06e9ebdf423fbe2b475c78421de952979e35054ec7db5296be2ab1d722c05ca68b7d9c6842d8f9a33a404b875992bd3e2532293a22d89e01401208190a8f2e5b73a390dceccbae21888d2816e5628c515a6e225d4d3120b34801313db4e689cfc6d98be0338fe3d43add5ba5d283a29b43fc40f58d5ebd45cada76c34e88e473c90107d2925afe5c8a64eec5875b6d223c9478f924fde89c98900603f6dc3a101da2e6e8779a192cedab187a872e3577b89475c1d869e19f6d16735f4d38f03b9491387cdfbb441de50dadc69de399ec5d0f40ac307f06c579ff68d3934fed8e10c96733e82064515a198f3713fd2c245c0cd3107b1a8c75e40c9338b12f9b21a329786e1041ea55d33948fa83d88b5a12bb8f30bff5e62bf9caae65c4a0b6e676e697b98e0fc753c278eb5738bbe86e72b53aa47345c83d2106a672dc4e24470bc1be84a7846bd2391147e470ec125ca7d5dc6a5b585c93d4c2bba627ec76bb78d488cedb1db0ab1497a5c309d2a99fd343491bc5fc11f1f758afa4652aad09dc3bff43f9b5030ba46c320e6b1a6268dd02135fa927f239177f199430f07ea0e3bc473100ed62ef1e47826d7223f46bc5c1544952e3cf8a8eaf91195935fbf81a62bb27d832ce50e356f3e74da5080a1a90814d5420aab51add74f7cb8c9b6e8c563461f46ef123b6bf67119218f0ee6816724176ab73a2882a22d82aa5859e94c892aa137fb303bf96b478ca6c7c91033fac77478e572a607512409589af30fa72e42f4b6a4d0c560a8b993d0344666f858548fa13ccafd135c038f408db9bd974ca2d4d4ec339676aee2d0ccf9e2ac5b228a8b52ced7b82132483b6560f390c1ae7a2ebdd76d9e6a2da85d1a207acbfea926f4c743acecefe41bf6c7c51302dbddbdfc8bd1dce2f638f4302c6c84fbaf57993d4b3533e85e24e9b39fd599ab80805b53a75aff63d591f1b92a8a063693454a180c780adb044d1a8ea082af0b191dae873036759c862fc2f406c927cd62457af139414102f753b21849e3692f7c42a2e7b297c6093a0fe9cedae4588bc2d66dca43afa78b25c608da897cbb634526186cc5a441e08a827e9adab4b976f5ac4584d1c8df30f5a74906636c455201ab3ff6821f5fccbb266e03a633acdb5b6e53cb46eb3efe7639dfe37a9c49308f76fcf5a4448d7a6c81a97bb8f290912bf3603d4b4f19233f95fe143d3ce608c523fbb43c8acd7f72e55f927d72282eeeb72dbe10e48710e9deef7490af4f3c4c2a34d17abe8ea75dd19c83b757464030a9bfbc72fa0dd28072b87d1270f907e7c2b211969b4efd946425b3b159db55cbf8c6f13756453e1132500499b7f23a0564df00c2a0d563e36167096ed02d8152259cf27d75f3214462a1b05b306968be52d1d7953e188f434bc72cd0d7d11ee331e80d84e77da6c21e406b558d247c5ca4f70bb3f1c2795544d553ff781a84d24e196c7224fe1595710f2870be2793bbbd54c74e9d3ea0840e43e66272701e7a0563badf276ee6705727ad8f748a08d705ae130fcc5dbbcefb0842d92a9bb3cc6affd4f868bab66c44bf7045882f64e6b4e8af1626d88913144ad26629df978734885b2c45e065bf04d17a23185045712b32471ddb80360a0403f9febb23387609bd0618b9f29fe7530c075ab8101ef7e5f4a892a1af3089b751c14dff9a95b471d7775ab25160138f4d871c2a86bcb64ed28d31bd2293c50385f5b04b8b05caf5d9579a54540129b6b2d9baf644f62b98b61955473a21956b6886245f26db85e8d11be55b260fdd2601c122e00426342279e009369b3a7ad964a0b1a4aa5998459efdf432bcff0588560faee699a6b6493f113e024850f662e57674dccc0857139aa39e921895115adaf5604c65e0c6e8629cb413a95cc51abfe32d59845bee55a0f8e668132f5ae2bcfe86029e17c9e2b3777b6c751c356d62124c27f56dfd3a5e6d6668e8ebb6eb2e7c792dfd63c04c24c9229b166f425a1e6e5462dafc07bd79ac8a9ef30183507336ffc7085bf91e843fab6c2b011087d005c27bee0e95056724aaf71d9df059dcc5dc5cb61cc6dff3ebf99c2585dd6483fb32abf30b5a9253c02cfa13f32a0ef5db3b4376607a5c81241e489230e7a6d7a8df1bd9ff28cc03ecb3378f74bb18c9cc80d6c5e97f4cdef009691523a63805efdef257f6119560b45dd102451d5cccf621ae34dfebc009d96963d4eb20bdf8d58a6294683337ced88ec25b3d423d15d12dd408bd71181cd208c8dca07032072b9e0bbe8caaacd93c3edda8c64f96103001cf89580978892fa51c3ea0f775d4fc6ec392295584c0a67f567ebfb84b8fa894ab9e3bf8b357cbb48319ecdec4065f846327156055939e06acddf6d5bb0a89b0e3370713809e7725e3120840fed9786dd57551be8c2c0da3364f435a1314214d86249aae4b2d256ba615bdc23fb6a9733d70532c5b8420f1fd057e1f74d94b4ac9e6efc58a0cde1cf14aba97bb87125cd3214a680fff19a1f9e5352c1fa773e578a4bcf17cb5a022162399897002f0fc09b6156eda92fcdd0c615154707a3b377280e334d2e9060f256cf997c7d6c113e90d6697123896b4c3c8ec811ed0b358606f4a9e7f217ad4ea68fd3c2e72b005410c85cdb161b51462bd795939f3e17089deee0dc3c97a672df27fa7accc0428f9b7b1bdc8bfcfec26730f04a1ad374db756c353e67da113f9b34a488fcd212f1c8f54780117e14ca8503356cebc802d4ac711d52c892ee47719b681118055ccf2466a6011ef4eab66f93cb86764a6e4a23a551819cc8e08f1dd55aa9d33237edaaba07313704ec60d1a8355d8cac28a3f4e93dd711c34ca6376a6cd28f6c83ea799ff4a87fe96d1e2745bd4b138f9511d71632f20a6fdff2f171ca9c49a2be14edcd3148e9db9086e90ac4e8070c68cf7be533f9b94197177a4c3e6d62a60a0e595d9eb3db2f7d8e27a3d5dec6e0ad456fa57fc1dc70ba46daae9b9bf73abaab9426f5ffc98cab9bc3b8fe104013b0377b5ba403280162190b3273581201c3131375a8165af2d71bcf390d0cf9326824e11a6de2d9dd1ad5b6d1e0df6c70ce77aeeb072cb2e952263ee2e461eb954ab2e0a21b0a4f02cc7074cef1d4bcddc394457eaa629967591df7f9eb4a33669bb647bedba18f22f9ad6d0a145fc2a768fb1999bb860801a4f347b6b1b9060dd9cf2aff296989e70ad7b69db23923527629233f0d941607f50c777c39e8f7fcadf50e4b45877dbd33582cf3ebeedc219ed01479b6d774a37b1551e8e6f2d708affcf7f2ec62bf03ffaf282273b9857a50a01f073a689e1872cb732c4e1d893bddf20dbca1db7e222c53ca5e4f913122719125663b40c4e2d39b005008ffb99746878e26b948dc0dfd7ce80bf8a5910b7edee13e32093484517508c870d630675abce0e008d0650ec5b3f1b81d059f3db36c26186524e5779cf8b3e5f0911ad327d32506dbdea2ff9a7f773cf428000197be06500dec7dd85a131a57394beeedcc3d27f7c029b8337d0b8d04ea63ab1760fce8e05e6498be186b253c699f0fe1f90a248250b32d33a5b6280cc05dbe686740f2082405ad75a36997356514897ab2574f255c67ba43a4b5b727b155039753510cb9d6239f85839c74175dd7927d4a812fbd0b60ad61a9eb342db5f5294fafcc29128be7f063a3ae0eef65555a0f66f686b5b427640df04ff19bb672bfcd5b9a50534627875227332d02ebfceaa14a4a334c0c3a773afd2fc6191e35bcd2ccc0d71c6ea91c3bfcbba04edc83c94984344e3a7267003ab51414e0bf8189f8a6f58bb9b5edadf33aead9a20aaf50ce7f8acfd68f449ad88690792ddd5eb60baaa7b7fb5429b5bb8da16c302b6e8ebd6c05c44742b2ca93e171b2d7328f02ce55c0e847f55a0f1136849399045bc3ca9222a7ea029568252d9ad9ac94f000d4923e1d9ed1197d5352150619a9260c73530dc643b0058c96b5c5dbc8e0cb00592a158f03e5213a4e30fdd286f0cc1880d63cf45226c4f4e38bcb23e4a6c3741d751d4d83bfa29185867520b4b4b2b08a09094344e6d8175b11c435108c0182f00beb9a5546ed9f6c2e06f4a6a9af0c2738465c3869c1989f9f8503ee8984df95bcac3d8e19c88c620c9f583db8c27397e06758dc2dc09d42fb4694f9723d17f21c420fcb08d0b22c19b6f32d5b552aca51c5650eb25fdec4a3a55c44040f3d166e63e07d094b4478cb7d48fa02fd7d89088ee4193077515ed340395aaec333ba9125cab024d85a359793a8e770a5a58df4e97143a8e39d8d45e08e8042883931a066d514e719295c1b37f774c5b8df63b562555ef04bf8e58b2834499ea13cfa47db517efc0e82c764db642a56721bf97d97f49e8b3e92e0bd96ec647eab9011cfb95d2e45b9d0311102184063a2bcfb569dd2f6e220a6bda5ee32f77517e82bfd9aab954658a2bf89defc2463081f8249f985c3ea52c97c3edd13b41d7d3d5d32524fa4bff0df671f243f46b9d1c34da7ee4e7f8b4c4fd4ab58d3ace7c7e90083b9e2380603c7ecdb00e27ba04b9430cf7f923cc208755ba58f73289511853f6f76a80e77c03191246e9ba3ed5a5caf1936cd3db17361563f4e9a7d827e5c3b7dbdb4575d786c3d3fe1a61d024af4f03d0941d7008201507a666d330c501f9214270d15dc813f63da3b042d8cc352dde3f18be7c897b2d201eb6e2d913d3c8ee8e97b1c98a9bfccb52d0de319f74dbb122a7078089ddcfed37743eac39a028c0b45fc63476cc67acb2fa3b22451f505308997ea580a8f3479cabb7e36d5aa3b986b2df1cbadce08a2c0fc3d32eefc9d0529c4d487cd887983f7631c3b0374c89284e8eba40490cd00c5a7b9af471563c70ec6b6abb487a56b7cbebc86451c583ce096bea6aed922f828f4ec285392cadff6c00142c331e4a9299590fcdf20a90b06e1838d75631e8085a6aade1d8ce22cb5d19b659ccbcd0e593053280c8bed72b5bda0dabedb28f8a01634b8b92db3a79bea93494f12d96b541ccdd74ffbf4174cb729332e1ffc46587bfab349204a114c84ac00ed800f94059ad4b0dcb4c87d9e95ab9f424757ce1695f758ffb6afc3f25b65b0abc7e8c78854ab978ddb6dd2c5745cc87af64d3ee66ffca5d9cebb59458f6f77709af1e2474940105322d8d5ebeb5f7ae8b4caaa506e6a8e032aee2f1d8b22b94a998c3fe792fe166f68bf9fcf244a86d73868eecff218cf3955aebebb80f5397a5e7c096034529525e33a8b971973ff1e474a7e87b3e9a2c0923571dcfbecf2543b97981bd695834d7d956d3d5570cd06fbe708bffaa2fe17a12c2f92f22fa7a4610b1691dee2950d5b2ecbf48e206180197a666b3c5847f299e76c9edddd0b5d430c1e680ed794749b3ce3f428aefd3853f2d73a3a65eb8443adc0c5cfc2154163295c7804190c6a36f32fecb8a07d92a149699fcfa2d3c45a26de7f566c51474242933ca9be44b773f73e3830085c4898b86e1aad34e6743061697f2c4107d0bb83df6420d286f63b20c1b982e73a207a725664a6f5276276f5a20f48118e8060c8c8822979771911b985df5ebfffe132fc38a3b7a9734bb50816e35b3248845336f72b45126961417405f80b067080928d2ceccdb6f80f5f18c1a9b94ad0e4109d0aed9019db99780eeff38d68cf3e7a8bcb5da893f636a21bee3a13995496a511ac264b5cd769f51411cbd7392e3207f5018a8c6dfc1b24d46afa3cbceec506bbf6b7b49e28ae14e1417302a42d639ab2f84e905a87011297b276681f9e305c06e03ffdc434d7f833bdd15c460c9d91c015a7cea566db75842d79ee917f9a8fe7eaeabd055323ccfbeeb56ee22fe98cdfe784bbcad7b1393aaa30bb9fa33d8248c1f8386d5e7ba1c1c0c6fa02bf0dc7824fb728db6362426eed394bcf587e3ea644ac61015363c8671adb9412b27e8b9925977b083edca78c53b29fd3b3be1478dee71f60858264ad3863c77142c9b01cdab0afe8ab5cd34a586670d38530ab95d807148705107d8ec7ee08698a5a97a48d206107ae7226ab1b4bbface5180b9271937251ab6c85a80709437821fa036599cdb1350d47b8a3282bb9ba5d7cbbf67f1ee3383eb410400549058c992ea13f40680d3da43ccbc1a804c89ba524dc06064f5eb28a4fc447ec0ada91ed37364136b610ba08a8b7c017278a769b6df9aceec7935943e2bdf47e0de5a202747015ff31698aaaef9131e209dc8e7dee25e21c527401f81451999364eb88891af4f1fe1733c26d283b292b2682a112c6ccbf583de8b4cb90ce795411acabb360045d9f2cf52917b44fbce4259b1d2209376973be2540465c243fbe1a2d68356ef3ffc30945fc65b920af1baf7e07effe8b5585c69366617e8066292130fb7966837535e150fb24087a675e9e193debd42851aac797222c21b5cfda92650cf1cc4ef89bb347f101add5cd9442849e36a67ab209cd4c9accf1f68844a32209b63fc164c5f4cc49d61cefa7f55755bd1423ce584f80a4ac756fd09a2a5080bd2c38b5fa8681ca972b67ca3831c13b3a7a7dc45d6fc70fd1c93fcb7632ebd97c1b01d1f2377371e6754372fbd3896bf0f982ebac3691dd784e573a260e620662624cc543aa542f4de08b6806bebee42c235570bd74ce060543c862820c8895346bce63ca362fe636d33073ba1c66a90f4ffb35fbc3e1ac74306da2570e49e285c9128b296e5c428a31cf740dee7efe7bafa68eeef0cf9a5b02dc03bea09d0420d5a89421c353a2f656f06df39d5b79d2811e3785cb8aec6b4082dde823f1bfaac8ce94665e6434f4d5bed4d166981c395328aecaa2262420a21d5a3dafb9f34f2e7640753486a9155e7afbf6bd70ad2371d474d1bab1c71404a332d6ae2a075b1a499083b3c55cd7abf222a7c948e854d8b2ec36f48c76b8e66c3fc11b37a2177037b5a777c683f6132eb506fd3b80ac91e8b254f93ed4ae89d1022238a8b2f21a02756626c78b8fcc848686077f379617bb6f3bfd9d8aab9485f17f15cd16329d18a7e591075b572c81a0b8590d667768c981e871e727d8a97f1e3548d4287517e662688d02c38437ee40a99ba43527de18e84e981d23aed53530de8cd995619ca83ed8629b224266df279b4884ba9ece9a77bf5b302464b4e2c425b8c01be1442241277f133741a3f3373b9c68d0290b243c05d1986be753aac71519865289578b89446db8a12ae5a387246d2bc03d8303ae8d9e029107bcbf9a506c7d54a049e5ecea3938a324a8f88e64a2c077df7456403b8968d353f31fb38f00b05f3db8fd27ab308cac98b15f3ec8fafe1df4c6a66a610bca57b834aae01552a509a2f54a3b2272eab91758c125bbd69608f731dc3ec6d8f8ce57ec13daa6550f327523baee04377ebe2dd10d28dabe39e96e4ee8d542bfc403b0ced4e63764723b0e4df9406abf72effd98aaa663280099ae5e1205bf7b20c3ba4fe4051b07f1f70d66b64d8a96d5a0657aa330006cf32b34fd172dc9cd72d33e558e0566c8460e18b715ce4fe3dfbb49dbd222e3594239fcab6d133f6bc3cbf45facf0b66ac28c427318868449f37de7182b0a004998d8c2d1a726bc4d803293c63c6d85f18d1c944521be05983ee8a6e1eb8dee7b846d16bdc8b6e5862b6e3595b3f74a94946958c8c11f3dbe6aeff035b4fe89e4cf6df83f918c41a91978bed5bbb978bd9a220f3e41186fad0749d61c482a56929968d6fc21246f4a50c695b8b87150f444a7ec72b8103b919b401ef5284e0934e803997427c8ea3c0bc68e670180448a1ae8477d842573435415779cb29e81ba411665262baa38dedf701c60b09221d276f0d4e5812a33e1814bbf0ef8ca6a442ead4a848a9f2d28a94b593c02bf0ac7918bb94e85ee2ef043f04be89300693e4231e54f3e48a142b2484c2b59e0637d0319cd471e70667a67684dc49347d82268b083cd54a32ebaaaa2780147b6f693581f9671b995202126c92c686ac08203e8e3e101039e99c36c75bcd7004c0985d5e2e61937485ffc48590e6fd4e2de9ad24c6cd28d95da9068d680fbb763cbaa17944bc08a5f5da5027d2511494c0dcea7ba6544cf284a4e591253ec8b747ba8050aeffe9448c8202a6dedb606ca3a0d5f2866d6bcd281fe9e686e7689478cb95ad5fc0a64f75cbcfdfb8d00f995148561184c35d18fe78e03c28820cad7748eabf43c45818785380ea188f0f476a4632e9d6b693f23df5d4ff9ead380badf1b8e443abfb920c30a07b1adadd9c4f9ca94d35e090aa1235535b9e138ddcae4e15573f8d77ecba639e469e53dfdedd65cee0739c980904308c5ac44d4f2c129467425b102340947926c4f64660bbbe1e6dd8ca2b1319de5fb70df4468891c8c306c8036c4030d617b7dbb776f58e02fb77f78448ecbe9b951c2d62b020fc277d107bb632968292d279bd8085075803d8577cfa99d14ee0559fdd70a7e3cf426d51a313c157335afc0446a07097218744d4f37004b32197e0a4f06cae4a29c1f4ae038a2e93ada0ebceabe6cbbed5ae8ea3092584d574b191f4eeb7f1bcc1af7a81b32d626fefe01b2796657e29dade0ba8a713b6bfb8f06b2e6d2eef4f6e17c752072ea4ccaf19f168d87d1ab5d62e5ef9afe3d134417aebe09e66e129f81c47a5ba069e14e06a78b149388e37aff188d78f5f825f52b422e4b41b25a2ec48031b83fd89b37391da80fc55d314f57b1e587b262e58ee7876d206964d5904a0c68ffb41b1937a52c0c76a2a0abb0a29c29964727dbb1a744da22aca6070cdc75da05994e069a5ce81d51c8d570deb63f9c185f93c3ff8a66cc9ec76de1a28ea6b1860dc0559be1a0857a095ce91b2fbd0aca3095b9611835b394c648ef02c65a61d612c6e43bbe6af478f0986bc565fb90c907ac3cc80b255a6f4a9c7b35702aff28c6c6c545487fa577135ac909832440bec39f1d8d6b64ccb2f9f1c758f7179b1cc8e2524e5c68509b8a8c9a98bf12a48354947de336d2a3b503bcc9b8ace3b42926e14e356656115ca006dae70971dbe1fca620d6a6d6db88ab81d1acb1b9696f2589859808e134e5981b588b59e24e420d17228cedb1b6f77f3dcd79ca61e8dbed61a3a57909d5c796a20194b1104af09d9a2464db905ae2c91c08b97bed3336e45d7440efb62dea191d28b2558c65440292a98101204de2674ae55c5f4f3e552f19f670356e3c72442449c2159a15bff9cac8b501b57532533b8aef6bae874c17e29cba79ec1722360fa4b092e829f71b95b2fd6d584498a236f50092a2e83853e5ae41ba160fe76d73128364d507a553155b07b912c2c77f2bb1205a9b038b9711394b71cabc1ccd6839924e7f81cadd9b5cbe24ff27dfb9368380be559010415340d7bdb5d92ef88301c007f3cbb101038faff0e7d7a5dbe7523b903e44fd14bb4a9e903459cfa29581186e9d80530f9418c9b4efc19c6b1e76df0f1b8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
