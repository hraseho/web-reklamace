<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9610eabad68918bba069eddfff1e26a78c519e605325f4516c7d18e551914dd3b6d212716d6a7ec55d176f9cf481c4cf73097af9741e36dc2a856ee6a42a0cffba35f2028b10e0e20f72716e1a2e102182b81c45c0678e886c90503eb4c19fbc61e4df5c8aebce38a3247772711d2565de0559a195481c37d81d46124d1ee31a873ea6b5162c54a881263f979d9967b104a8db59a04c1d059817dcb3cc91dfa0df5741da5e6b87875de3903d71840371e107310faf1e71c22c7b048834ec40e73ee46aa61fa852f2fbb3ce6b9e3c8296160bc569dc93d217d4827cb7a427be26bbfa26b4c299dbea1adf5db643e4663c29167a013f5754df0facddfc1c8d47e7acdefebee4a5f2fdd0025b4cd4bb61f34c5fa608d57742a3bd132ecf56225cd8fa46515514d1a3a0441fd4391221b6970d6d005f7a19d5c905229089da923221364d7e158534793d41d938db70e267035e2017adea08d0875174d0b84c0e86e7096332471983cba18651491a9f983ad4b25512457d0a73cf388922eac4545c7a70086005b0c2bfea5982f18fde9298db0dcd6ad7a047908a8a97c8ad09bbb39c5794c1ca38e3351f74a3b40b9e170bac26f3a3ea74f2aea23237aaae952f8acf1395106f3d199c6bbc99c495d092866d139e56fd394ac69aa863c4822576f11d912a755ecd2a7bb2542e1a5af6a9a5a30dfcefec64be0a0a2817ec531dcbb41bb436a444bb44b9b1753c7d533b9249f82dd8e2fccd036120a12da34810183749ba0483dca8929ca3d69e9c8a2c2dcf1523e9a1a4a7088651be0e903d6f2f347f0c45b61aff59ffc79e2c845b25e02752afb6e3e044d51a16a14d8225f92f3f74266077906fe393f256ddcbad1672bded3330f2255b819ce3ea747ec95a21b8bb8636f85468a86833cf7570d1b61a0992d44c6b28918a3e78f29d0b43c0b9175eeca2add62aa72baaa294a1d7dcfcbe9586d1e55e5376ae64fe87392a9ab218121bf7ba97b9de42f14ffe8e97f32b423d6c32e83343cce0b31259752861d2d6147ee851baa4b680f10d6af43b5c7cd1dda37ffb43e291d9ad9c794a97c762df7af6b50bbbe1f18f31200b8c05628923d9ab59ec3f35bf0af60f51193bc6734e23eded2d2756f1606d154cc4c6f13e90500cc1ad31bdbb96d088d4b18ea1610940179ae9aee7bfe7044de88a0a38171a40d6f3280a5b11842e90df916bbd68f933cdcc627bd1704484e90034ac5de39f3c7454e3ef9f1851dc4780150fe395261a36b11c7692281d123ea57cee14035798e9502f0772348acf0eb39bd8835570e0cc3c6fe0fc91f048eaac9815905392649910b766476625a0c7e5ad93e3af8b2908d73426577566347fe46be6ed5657417c20802ace9f4f9fb71f1688213219cb70e837c68bd19bbd00420206984db40b5b017c4b1cf2486bb3dcb4c54ccaf3708ba01e7ba2d66fe3a80f73695981225e14fdfb2a0b07cf659193e6f18b9abb64a7af4a1534413d6ad417d9e0628d8487b72a576f405a3d2fb5a3f17645f715b461e670f85a56dfb7a0f204db18e6163a469ff168b1cdfece80adc64fb95b1dad713a26cd917cc4a0a37ca68e48b050c93f92be400a245ea0295699791744d02d0cd3dbe118890aeb113e8b94cd060c5d0d94107d8f3401e629e75ed5717b94951eea6e3cfd1ea0d7dcf3cfeb8dd373086fc772ecb9823133cf73ffbe9b9a4807895cbdb69d14ba5a825ab92cf6cbc90c9e58a581453d40776fb1398a7136f2c9211a9761971c2a7e285d0242acde30cd4a5b440aad7478819c405e4b0e11331b35c2c77ea0b47b2c576f0480fd6ce192ff86f9be2d4dff9ecd5d17471cd88b61fae6e69a72433c464f518d3f04f72523a1c31ac16b63c06c141c3df17cee1ff0bf529ddaa282df61e7b8fed988f0b6e5a288679f177eeab5ca2509a0597ac3357ccb06a84ce4edca20ccd2ff8c34cfa1dd5a45172c9f4d25abf553424f1951ef7236f4a3efacf5798157ed5b8305072bf6596270680bf0d2e2a0fc0fa9ea702aa04a1f87b817201383245a2216961b0b94a63bcdd527fbb2325c1892ffbe504fb6ad15048b4a10b482dc80ba7b808690e475b3cf5430c8693f5fd021b26ead515d0d6bfc0f3861aa80c8716b1acfcdb8609a5fac763f025f2b95933b88eb8e68e974ab29e02552a4d4acf24a0a80289f3d3636b5bc7f384183deff82d8849ed5b3b9593176c8ac8ed4db0819da218b069baba2afe9055daa7130501b1b4875c26cfeb73277ac506dbeaf5374db65d56ce0a1c659830bbfc174f28bae140b6221cc831436044834a619d23e91b68f3d965496269324fafaf759cbc4db212d032d384180b88d9036357a6394423687b4be6084ed4c6d4019699eae2a026805a45897cd56771585697a7ba8e663649fb40c1b52e417f26dd002694e2897af706a33a41f2ee823cd3255c1be351366d3c0776382de6b57f4aaf0e318555c3fb60feb39dd46774deb9fabfa84f50044700282fb48998a5a67737d892be5f7ff15885ea2918f34f2eb104a1158d42af85563f71f86a0c38135e64b37b1fe15144d3980fed4bbb7242509e9e5f9d3a2e3e8e9a69cb806dbd920e9da250f7671e6091e008606b18f03e6d19c7216fe35098984d279732d18387b57447e635be5706c68eb622780e4d7de4f9fb3fd1b2afefd0609c54bbd4d372d128e1e8566f10a4085e98701aa0fa94e1a7a89ea2d378b591e79e2d3530f7b97d5c5c0fda96150db5f4d3f731e3b54bfb6363ce36bcfef654d94eae7d9e17408d710b4eb78a0da98cd31f3d3f4e8ea3fe2f0a5c1e3dc9d0c8ed978c384addabe19ff09c34219c426c5b68a7d49f6cc4f8f031c30e346aec187cc3d1b1c57e3be46d7897af15e48931c5699edf42be2bbd09c71b06b3a26c0c8ce36e63505383c3125b40012ec2388ac52fb9d005c253ef7ac268bf3813e4a3a9d7802b9dafc5bf8d22aa9b90f8e6c85bbb88dae82a09cb55732d4b78a0ca923aacbb12e0da71dafeb4c74874a8ce44fe508e684cf69617e8affd0eb9cd3c21071b6722d15bb521ac443b4d7ddffec2721cd0e02952e9460f54939f5011f0269509350bc20206a3dbc674dd0d1206406710fdf6675d5f29c827efabcd1de65308f1ab3d4ec396b39419dcba3101636b114f960e6242e55ab5cdee35e81390565f9f2263c5a0829389194af0d8ba190029274f6971645dde379692b5f0d98b21c4fa9277f941666ffd929a7b760314df241908f04b5ec9a868a82ee9383b1c631c90336aaeaeb0a730471d2178bfc0af116612654fd4b3f470613b677eb3ff44ef5577c20c61524e95a6f699deece8f37da501a235e5a76aa6c1050f21ab030c4306ed56d1164cd93372dd779942e74591002c65e7ccbc3cdce94b05819e4c31fe6d24478370ed3a29a05a3382ab110fa23425773606514c99be1a91d1a6b590fc37bb986aee0af6ec8f979002c83552bc4ba0313b2600886f3e7ba64c779e7d4fe4f198b9a37a7cc35dcf5ada554fe754b22d75870613f52a50ca99005485eab63776a8bb9d9987fbd4b6b72aaf730d9bc10242f9ddbe548492bdba2bc399a024964eb1945f129c31a0115c6381b18cf417b317ff2e4f87193ce8d7b90c2cedfc166f30b934f789246cc652abe1330f457e1b27898482d3833806e2dd87ca4c5cce2b1b9f3cd15e5070cc3069e0f243ae73a5530a64c97053b658307c244407ed3f4f62705f804ff489f56740832d8ec7f250a26712361b34f49c5025fd8184a28be67d1c2d4ecc0bd41325216337057d0e6f4900ac221f1800b1d2f56faa463b43cb5269d10209ea308617f1b7d242ccc044bd17db70180d2f3fc4f233c8c9d75f8ad46538e27258c51082f44f831ec53549e6a416ed9cdd4f9f9898a1a1f19e3429de76de3707b62c68c8d2e21eec690b4fc7429c465c494ec652899d3a25d31c148ffdeed36942398b6cbe1d1d05b9e8bb96657c3e8095ac19c749ab0bccb9b30a72e8928912fff2ffaeae5022a2d8f8ea41e9b6bb3db40e91f2653632f0b402fb8491f1c84c9d3b673f93854a983e0216872f59f3b39dc8528f548402e27abea9617de7e3983821d8f3163d8df17df149a59377662dc8871a78efc69a8694de74b0ce9d6563768d29af491f37c616a47e883225eb716f3c2e3d788b8db0bd0eedb445a45e91a7e33dd1680f92fe68a798627aba10f305d70f9f07ce312a47c269c9e9aca5e6a3c57dfd47ad6dab19348d70e3a385f6d0644630dd5778f36b2f5c37f4dda75225256c7c51f57ff43d2ddf32eca3bf6e7d5eef961d884477f9ac5d838a936681e1a839f8865d81e99a894d60338bd6c3485ba6fdadd8cf546e70288790e4548223c5070d842b28b09f7ab141c2ee056f307658e73d040e4bb2a581cb0f6b5d58c0fe8717bb811d3300c0575539ead5200f892bf6fad2a152f192aafd36de2b334ff837960be663b417d2853fdab98920126bb626333a19c7daf0078d95351fdb874656e5790e0c1041a065cb022540c4369518d5232a5d463251f934dea0a9457bb5bd1176ee92efa421f6289fb312bb4aca917769c23d7040a902ce4d32f0ea3c0616c5a882fd817893f2e20d522188358e691bb3dec7163e1edcc79a5a3974a6c5ce7e523fa7de0980b160742c5b3de0eaa199f56fa70a9a4b0b74f1da00a03afa976a57007c039117909224c5f520a49e194d177ea20cdbca0b84b584607c18553b81ded4f07d8706a0d4bbabc01db6b77cc01c69bc4f29f200d7baa34b2bd0ae65cb32eb0386395f472872a4807f5251cf368934d2a23b960ebd8070ed4ec8eae40768cd2ce0e5b2b8b03e5bc0e2e738994477201e950f93640a91dfa49f99da76b632d9521b1b2859927fcfa2fd5f62d00f776cb96871d2e9eb9f7cf2966d4d76e2c0a3e6c13d6faa0b3801481e16290b483ecd5e63e4254455524de2295582438a5424521122f9accbb10c054d34c90a1e2ac6d8f34f0dbbadd15a08ff622605e8fa84dfa43de09bc0cccfb75015b3de2c754c8ba2d5d9f67d5e287d8bf033976a86259b66250701d40a329057efe0eefd5269edba800970b0e1a15cc30824614bcd8e5005c9a8b0dd46bdbfdb2f9b7a3faab1b9e786deb34a6d9932f0091cd8f88bbc9e57eef61aacdfb6ced1a4143d27979cfcf17e6c517267bba4e4b459d0f4bfa3eff414d39e24a4308a42eff8668ed12341cee5bc2bd609f78553f08e7de3b23f9aefea920ae99f48e75abdbc97be8a123d101946211ea6875d6a6b4d47b565512b54bb7e3f6fbc307e0d3919b898eba01b75e5b66ef9901b4df2deb7b230a21a1eef1816c990b42fab39badf172f1ad3e7ac952f35947ef68e53b89d007d0c224fc75aa066a2a89b001e0922ad9b64ccea265193be2a86a55d900b7de1f2ff79816f8d27088e5e24e19bf65075abf135f5ce4c3bf097ae0a1395b0bcf3bbf1ced3b32317aded5f9efabfe6a229169489d86313c9bf400a31c8f1ae423121c776421cdde2ab1058f1de79b222c2df164d5a5617e936e47fc90fa8f8d9ff01bf862afcb60d844ce76a988dcc0259cec8e4f514ed0923699ca6e97b042c83842fd3499a5b88c3cf1d773772c52794a4d873d376f529e72f4bb3eeb75b773dc3608ccd3c4903a93221224706ecaf07d7a06930b7987b8485370cb6a9909119e5bbc108fae597af18e56b8b6dc20aaef1b484d8e305f80db3270d528fa95b11403db49d0eefa09df7eab09666692bc2a27f642271b8a098f2587421f373345cc96ef2ac4a208d2bf08325716d008f45d6bc89b574acd36e7d6fab507bb843e910c50828f827a5522b7bf3552005c05c34ad31faa46c63d4370d25fcc95ff7538d59907ad25ec51544b3ac6c3a42f00c9a478628d0852d532a7f0d0d6bbe9666dbaae1d5bbfa7e0569ccb2146d9995b34e8c71836863a208bbe884a141d8310315594f4b4529c91b714f572580eaee27f57a3bdf18ba5269335b0cfa44b06a500f68e1a03b51bc7d9aebbf2530fbc7f8a177050f9098cc197719b9d06ad818a9dbba96f0ba6bf1aa0f06db6d9ebc97f41d55dd5ef26cdcffca2a214e0303d1ad3b1b186cadd95af3455228b96c52d79d774444b85a705a35a2a3aed498a3209809d38c35c2d001e08d93a297f84db30c9cf7c95c7afbd1b1e17af0e32d78858993234de6e2d07c592964aab5f16b92ce250de77ffa7a44add2cc3678f1f30aefffb3fb028f3a4c86e2845bba7f28e09b4b43cd0c1277fffe36c23d6455b5f770e14c3640a35746c3aeeea444c947a460be65da31386d17760e75ba06450cfe3aa1234d4ea79f3ea19a903b337a44a8ce5eed7b4b36a8b4db2b45da260cdee89010801907aa2a2e0049092b77eab096864895c67913899e7b4cb4395d0c7de25035c221c191b187efaf0c6b94e4a5bf2685218a4e369c8918c1d2c4003d0cdd0b0f7a4df66b217ec531da919ffdadd2cbc964ef64074d4251579c8be0623a5b505748ba0ae9a5270ffe17cc54c94b7e4c83ce98f9bd16965548af5b55524c857ab797162ca299d25748d7d6ac71a41aa99d4b5eb387cfab74e17ba4e03f018f167b34844db5e7348245388f65447dcbe9796f090adfe798003651830758908e8e262e298776f65ea0a96b653cd32b15f841c67284f908228ead4f277062d7b6125e9c9477434a9165747d445a9b62388faf0a90d0b638d39ae13f0dfef28e1a808cc989b8944c7ceb35ce29ac3bf2400877ad84403dc86bc8f139f9d2a9b5cb976e7597687046e2624755d68d00d86ff21810dca7c6afac83b39c8b927af2f34f19f63a7f1e5cf1d723e25d1b13c2c0ba7bb1a6c9ac8f04d5673c6e14e14456bad8fe0d1a4afaf453fd85bb34307699eadb167f9529805984acca221535760c038beec43c8b1f5f41bfec83363a6845f87e58bd4614babcbfd7611eb73edc1e620cb3504339a44bb0d4e1accd59523a60ba9ead587b51c3e0122a408d73067eab432ccbf94ab522dd4408684b55b6fb49c2b125a8ca0295f6b8dfc3d02bcdc740469b195b8802af1bccc56046b8b35f0cc6185a9831c1c8ec3e2597a42844cec6925a6b37fa34d9d5b95207f92f544aa3aa3c3a3f90f6b8a811801290b81cdc139c79b2a2e973a1c5aa95ecc5d5102af5ee2688a33223054723a521d589f8d94f66171690b943a7f3e76a1a2c143e17cc0386ce4fa06abb1336aa15959d0cadf9273e25430bc44fc1e432fdc2a5b9edffeae8b41f5de6fd3f0d5f688c8d01a492a11766bed5efddda41f64f4a7165727206a9b0572c5d29ffcd09b005867a5037d858205d7ac136cc6f1d6d3cb019959798f422e45e622173456fc00fa7bbf48f00b582e7c9c2c093de4262a02fd2799c8a32470b1a59c71ef8746b464c8fd6b184f873aecf3e8d6c600d87e329179d4ae3e22ef695b419f5bb7f658bbde273500d1ce7787689f0e0540f0c95311c835529b740313351994011d4f11eb0f924f72a920880a19c56614e4657ccd96413d0c01cb3d3242e81001077a23ba7bcaec6a50956d90e12a09eef6286e696622f3aefaca40689f4ca6fe064e358da6644f3a0b39afe789b6960b2c439dde15c50bae11bf4212e062205f876ff15cc5882c0445d2ee687dec590608aebe9a4e76e409f490b9dbaaf783ffeb07497b93f5fbe8c43c56e764ed124b604dcdf14e06b9dad19aedb4dcee0e51ad8e147ef3070ae26ffce23c9e7ad82d1ba9f3497170b5df21f1653fff10c0ba729f91c0c4f1659b2f95d03927e8bfaf6c5bad180f45b0e17f1eee46b8631b7eae1eeb8281c4a3275db4356880e95758793d146587db8d85dcea74044514e29d3a790c3e6fe5fd519c63d4ac5b6288d6153a41509dff9076b1e27b101c60e68bcf6375d563e3497a43daba7c7e934016711579a56dcd0886a7ef1beddf99b4e2e06b1844118e61ee79573980a2606fed24d2f8fee2e9843a4d5523cbb63323cf34592b52d76bb8680a522c060e659fc8c6e1381093aa04808015dd105fa72dd8df99c82db31c6f9513ad5c4c6b9f59a6d66a64c19f84027f455d45718ab1380d87d90cf7875489aaddc7675ad4bebf49ccdd0b743da7a6f607d5a081b48b5327c10d2bffaf893e4c262a10d5abcac698c49428f853f8c20613f4ed1eb0bee4e98ec7e83b0aa5c0b198978dde81659cc963a9e92dcc4b402efad790635b1308f9a57a12922ae5e638f563a2442167c1e3d30f309f6146feb4b5899d218498436cc8cb0db89f2b718c235200e099e9cefdf160dcea72b91857cb2fb5b5ad59a389e76cdcc486c60de945ce01ca24da90272afb173b5beff291313cd644d8f1e3b066effc36b5acea7f8f508edb5cf6cc290a379682caf86218459461b5a95bc19ccc9cf6252bd33b34b82696171bcb5a0b102b956663677dada97b4ff3b9f840002e3f34e31a8de909a29dd5cc48239a66261e27448c4c3355440a84a387496ad53adbb02df20ad92cfc8d772e0e0c5c3ab9eab957f9749b5ff11cf35016911623ce682c2deb44816077236115d0c27f648976fb96322f5b5f71708da9af41980083c5720bd64c938729aef158aa549af1fec428d30b0a2facd5924520480bad6e33723ff56e3928fcc873e31e22a1dd39f1b4f2ea3bdfa8fe6043a48107dee9fb0cd0baf5f00dd75b4d1b81efff1738d6ad8a5ff87dd8678f32d32fa050b154bb39933910a04829217a9c2bb740df96f154f5ea4de6b8b45d1b5132d0026eb89b1c51d839a70ff3f4292240863355683b6603ba39674bd09ca047aa6f0af25e3e5f169c74f76b4ee34a8dd593ac965a0f79c5631efc2f1c06c91f72af0e0b9a9f3c4b369a9608dc595597a25fffc5a2720cb5987ef5f9344a2f8f5aa220356c3c9c650b6a7bad034de71f611581e2820c70fb218050303ad149819d5505242aa3034c4547c6de687cad3dcaac37ec6f48ba113757869017a56d89acef6609d479757a86f11a71c3f223f3776efea448f302b35bf7504734bacc6aa04d2f3cc0018923f0f31b12acc9cf0e933d0697716b5a21b3c5ff2a74a88ca1b4d48d4d755a35a53f8864d07ca2af0bcc904480e92c2ecf913df17f6509787415ad38882a410bbd2ec6ad35f4e394deb4af0368a4aa191aa781596d5aa099033e7646e34c1f6749bc5c238252bb2f5220f93d302b4c0d4aac7e094273d98ed49cc54230f49fbe849d515da7a06aca7fa4a5330a3d370ca06e161e52acdcfd827a6a3321e65d894f22add70acc058a5beab36411e9e58e62ac1e6814ef28b161a74f408ce41829dbe71646c9e6e299beb99441a6ff64aafa5aad43cc5cd91072ba2893d1bde01ab9045a630ff605bd679d542e73f90cf937f8165f892bb579c1abed1d30ffb4620376dab5ae254fdedcf7a055acd805ea026c2547b9e803495bb97f79ab5dc9cfc9d3126b4afbcf0dfc876ced28fe1e9c823ab34c084971b99028c7d3a1d99ce52d1700bfa9ebb1dbc9c38b84b42da9e1701c04aa3f8338e8b7bce2592b874f2f334209c1fbde4ab18b50ee73e81da396216cadcc22da60b6b6c950712e2701ea62c1601f25ed7c2b97fdd0fd9c8e69717145a1b884ef7ec8ab7c06db8269c4fa2d8c6c072371b918f41300f175d78d04df0db16f3430a8750cd13963fe01d4d6d4f8d893168cc1aeb1ad44e6ca0ece46b78bd5e4eeb44a84aee50c7dd23a0fd9059ecc26701498550e06b36903175f44e262878cdb3fadfeda65ca4b29a202b34b5328b5f23000d889550bb2d00b61e288aa96f8e34af56e8cec6db6a6759a9875b5d901325fb3c55ab699f6efe2e1d483b5134c2175b7b2fa0770caa385c91db4de5286bd033c9886c3a434a7de50b4b856b29329289028ad39e0445e1e3229fcaa3d043779e67fcaa8018fd701dde4a4a70e6ae4889bf36700fb06596e91cf13f58c756082852427b239795263dcbb9edee312f7e84325b83b2a1acc15d1b61c26248175920f155a2da54fd7ce43026ef249bd9e9997a7af110808560bdaba3af203577927b3ed003c892dbc48981f84a6f803ae3f5c613d97cd9ff96f3200ad2cf150fc5272e8cc1c894a28a64a306aabc8f08ae521eb9ba01ebd2a373c91393788b7427dec327d70e556c1358a3ab1870309b38d4646d104cb9f3feb0216b2f69b8ee18a7793cd05263b5ac4931ee8d9e21ec4498dbdb72b8300c50182a0cfe8de4e7d50790d4ffcd096b85311ea2f93ead68d81356090714352bf8c1f43732837da745d465f7ff95bf9c78f6cfc293eaa971a6a3f8cc98594683b762b8608fff692f802501b123f52ac0ec50e5fe7dc15ab876a7b0dc7d74fa05d1e39a59bd5c960c902480fd1d215f6a542b8916cc14e61ef05772a1bba5931ab813fb078fae759bdcb1fbbc7f473ba1632792a77c86cfe493dbffa864c42e088f07811180a9a854ee8b2ea73efb1d51f69fe6ebf0fdaff10c41bd2b343804e878fed345ecd1c731580b1cbeeb47d1ba9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
