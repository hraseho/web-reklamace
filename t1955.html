<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3481c4f4fed52e4eb503d19b8d59186c8098fd57604b785b662bfa1c93191f912040522aeafebb2d0c65588f4a9cfa153937f6636d43c9478092dd5c151dfb62825f44c1fbf4b651a2782acac4b234a8cdba2d4322368f34f842dc3a33b8dcb5fb57bcd663aabc06158acf60d8599d8503ae7025a21cd428c2497e5d2db0aa3a5eedcfdfd9a36247270cec8c546a2a01794cd5817f6f16091497511943e32841471f37c899bcafc9dab0428124411649d661f5f244bcf74638a49d0bb59146a734962c80ce4c8caca2bd6004b9caa96edc2fdf502ca1b3536dd5aede85b147d7de88d9077fd13a52de7bd7495c62fd240c362c9422b0adb63ac883046062d2f999179d3915063ac3f32c36339811fdfe336399989e658f8e5c0d0590aaabc00c1febf991653d66a8e1d1944f3e128dfbaa5427d0c2ff4a535d41e31687690ab37dd11d9dcd6ccf43dfd9fc92b38badb5813cfbcccc4d072f086a309040ef55440002fd802718988e31990714e81c754da002cbfa1767ad1e0b6d92c0f26afb315bd2b9582e8df7e0d87799faf6e853701dd8edb7b71f38dbc952845acd6acaa4d8dbe1b7e4ba99d6f9de7935307645c81ad0c118845a2d4ae36b3600970c26f515353a46d2eaecef0ddde045cb382318f838c52b9d94573fe0080779850b6ac866352dfc774a298d00b557c910ad950f0e09a9eac1b49895b77d4173b7b8efb5c427f6b057a95e16d05ad8d96a0728450dcf074633f41635f92ea75dfdfd1482ea967e2cd2a8f5df17b4c87ba7b5f4b0b331e5642609bc231cf65916f96d8aeb0f97db2ada4418d91e6a6dca303caaac74ff6e432942d1ccaa93cc5e157ba1b9730838f7b331af2b3278fb552dcf8043cefe9f88466e85171af97f94dab157dbc37665e32ca72a41ec5e53062a747f1ea834a57ecc8b3fdf08579bc2823f61bcb12b6aec1eb94e18e5ac27d405f62adc3445de690be9302a39ffc58b0117769b37358caac1f3695595a768980a2735003eea5e40df0f7b7c3ef8e674512b9e2bb22115bb21373d15d4cf9ac3cb9287fbde2d985346d6f048ecd3b1878af0faa02108e0422f1d51820c1f866c0fa1456112c4925d52448b1eb987acdea9b9fdf7678bf1703b521d862b32f30c12a4f35f1076bbf8cae2be8c07f53f062eaf526bca79c5928d39bc62cdc05576059f9721fef7ab3207ebefb1e2e69a88f4d670a7a33d1fb076656c43f19c3800a40d0060d5b37395b70be126ce902213d09de5ea414f4db95b938d360c8d1e53f5c022c10e1fc253415d0e1d899781a656a83780554cd7c2b81a97d359a0c39f45124a3935276e53cc419bc73f9a65d543862f6c3339dce572fbc68bd4a69bdce1ce590d27818a0c1e12a5a565d0029d50f4955e53717a800053db8c26ddb28d076e3f212c8a15ba35f7f62bc93143065690d7d9213210189af85fc585825c92e77dbc18b6ddde998ce6ad2c82b08bcceaf705e1adfe08fe08e1a8c8acc78451da6817d933f790cea400dbc5c1f27d68f0e07ef7d226592aae27aa24fd87dd69b9e142bba0ebb8795f7707e0165e9f699b325c71375d1a400788c9f2ac2058dc183d2127f93ffa0f81af634aaf78e1603ae7d522e9d3d8dbf8a094aed1363f6a1e2779179cb5293972509f2e756eab8816510fab5f560d13de08ac290065523c3c29741476f8b567c9e2b1f481df6c8860ca0ee033b76eab302a8c46c7f8c2dbeefd889cd1d6f356a003b3728b7ad8ff9afd27d0fe197b60b626786fd59754f8e9815ed2b36ff7e799049add8a73b0ed0ae9e311434ec75e2a2d376f8e6ed26f8acc4a6a88a0bba6c4db1a76f6205acae412d38b9e547d1597dba977314f9d4987332c7988ee16eca1c14e12679a06dd13ce3ddda69941b29d9944a6bc2eb862e1dffba1bd66d8f3af9866aafe50f4b7c9401514f4a89e8112553f9d32d105d5f2d7a906ba33fb978e54839412ea9c9f9995fa4c18831a4b9219fa791d3383239ec2affc10da335bfd1444c6166b9be46c867362c949bda8a24698b64246eb29dcea56de96e2dbfce659204eef44e68e223db3db5078ba5248bb38411f01dcbf7fc891fea861a87d06f1e0b33e3505f0cbedf6b2da3d5080f128c9655f241a581a56c2e684a0807d0b2b977f05d82cf4866ba257fb32b769f9f0e96b7294f77aafe9e2cb29bc21904e8460f212f51ec38e77a7116706040b7aa5fbcaed497c4320187d1ae599a331ef49012c346ff011e3a0bad9459faa5ea4d34c2dfa361d7c8cc352985a256382d9bfc6f8c85b83af7a33d04461f1545414b9e7aa217a34969e103c39acdef9068b915f9199ec06428ff6077a5548f1dc96b1f7c126f27653d6865a30bf2228b545882c8747ec52a00417340b9ecbf9b4c57eee13245208bf90dfdeebd7067d0b64cfb9fe11dbc4140f3bbf0f98ec2ff884263a443b6d683435e0ab12277c727805dd61bab3488498c227d15b478654ce45c4826f5fdaa902f2083fdd6e42b1ff7450533e7d3bfcd401445b27dd0518ed4c84d5f0f945a41d18f600d220917cfd627e3f0a1c406a9040f54c77b9c548cfadf4c020a69f620d653dad762ae10e39ced62a6484d4b513658a55ed5ae2f26586d9c5a3193f68757ccc304c378e1d564a724d953325ab97d7845fc3f33b1befef970afedef0775bf29e7990f91a9f6360aa0353633a7218a4b5f0778eb211fc15e2d538ddf43fb9b2cd9f3d12ffe3fdcfad2bd80045de8528e3fa254781d5b168410a76dd1613ba56ca5594cb8542b19ed6e77db91834b61e97a02225cf2e7fb96403305101475d34d6f34a2b87e3ccad5d870d4b56eb7a4d4518cc0b1bc057e403c9cedf62b50815631e2deea6b007ff1b71efc93bec0c35328657665f11c2b0c9483ec45efaf9c29149ebe8df60b666eeb1a891a5c21a540ba0f86fe109c8d67f6077e17e07a532ed7e703c41d5e0daed2edf2ebff083e5b7d2f796d7883a7569d2c823690e729759e3630e51bb1ceac2a42e7033ce27b25adbe0f625d78a8082d1646ace0ddb0060f1ef64c4005cb9157ab8b5ea67900ebba1f15c89e2bcca2e0d3e58cae03e1d903dabf8694f26181ad372b732f8985fa92a5a5ac954e4795a1213e69614926e8955544106b28b4b6ba4fb8019f7cca2bf7056932e6de2f2509006fb068687d83dd30ab9af7e8b399b16ddce2c1bd3d3db3d2633e40633eed2ccc2dea41aee41cc0d4594b06372b80c46470e3736d14760dd2ffe39e0efbe9443774b205449683ae59f032b6979e5f34ed13da7b7a388da57b0215079b3292e0e23524b1a1c2d540b44585511f86f4c8272ac353accf9bc4d37b0653512ec6944a5ab448972cc0323aba0949a3c16a75184be9480f3404c8c9bbccada40b16e874f242baa96824987ef5f69b54346a1fca608459aa50d06ff06bb423b379e87a506153b688de481f9e02a0b57413246b102aee69e075fd618d4d601a6a1d6817a9c542afe5ac0e20feb664db69225377ef57de18d8ad5000a2ba631ef0bdc2d74bdd02c96034599e4dd07dd0783d02924bc1772920c08417c0cc6a7a6daa42271b353647d0d3a8317d431810503bd23f731f7c4ad851b6559b70c1460b66ca4a7593bf56f09625460aae7b9d5c3066815f75774ad3de9fd88f9a6e3d4b4514d12ffc5fb01313a615dbbb12f0001fece860539d67fb19ad48954a24f7b150d42177fb6bdcea7565b1a9ab4c7b0fa82dc6e1626655f49adad4e815f1849969582cbc7be246d0e9a97c4f456c6edf3e91e2cc4f3fa7e2fda6109a4c1a4d0200ce263118abb0c8750c5c05668dd4027fe4e43d8873d5843563584adb9a3793c0435959f8be139797062a3515cf880f7bc902735f5654c7066d6faba10db2a16885c4e40ad7e57cfeb26df2d340b87ce76c04872ebd70c6492e582a495887bff12219b8c0e97d6d8f75ec0f976e569b461a7c9f0ea0298377264fae795e7b28d062bc9c1efa34b1cb77047ae298fa0235b519cf191311e6b5cfc385e3a0fadad6becbc02fd6b8164c648b950428f5a0d4b4cf7bb7e2a36d24ba3ba02c095996c34218ad9c184f471ea68a957f25a2e6415c07ea2566421da457f233e0b0fdbbdbce3f809d68ba159a19e1a6c4120d7201edd00d42c97ad4918e4d6d9d23ea57d416ab7a24a0fd7a60ead0590321065005de4ee608decc1089847c65d602e65330ee95d746a090f117ef3acde5d7fca753ba6589e17f9ad12eeaf8951ddbb0b2fd09794e9c44022490f140db62de4154d96c1a2c9c100fda6585f241cc9ca83c7eb1d0ba1627ad2b30b45e6ed9650950378824e6b0fb21cacc4f5517fd5afa92f9a95df97903f6c83c65a29c607aaaa3396bb281aa4b7519db4272b82e1515cf0806e7e9f59cf8c866058fae7b4a6a3651d5a6217412c39fe0817698b1f205e20b8c21179567eb004c5cb46d4722a01a9513658c5d0c467cc96a9b0a1b60f769b3d3de15ce7dfdd36139c45bfb7c846983cf166a2409bcf674ed600462d14e2641c00bb75737c5ccccb951321ce370bc60f81a79470fefd2f00bb9588b58d595f4a8769f9563075fcdee9f216b2af41ca33529a9c10e0efc441cd9b48dc7aa0114e4242e137e101e782a032de92eb25438813b73c920c8ca0cab1a9000b22624124589d1f1b952634bee06bb6a2d1899143f738ce9dfc44e45c1ce7c4285b2d173047a2815e96e5990390d0b0065d4a35fb6fbf7ff35d83d517faff0ebb8eb79e7bde1b778b5d5296a8016ef3930a32cc2a80288db2f7830d55870e14a46866ebb2feb95e3493dbe9e7292d312c42a59869a0ac29fd1245540a5edcf4aad79f1b2cf553681b0f5f317a2a757a8dde4fd763619d8f93308e89fb3b468d7689fb0aeb43ae3c97ea2c5c12f02a09b7be753321a9a37272a892899432c846f1ea3550f504908eb4cdc90a29b48e0ab3b875f769b390106042860b4d37e3c93557590efcd7fda504f0f7a5228d606e0ed889f3f8f97cd60993f998e05a82cafafddffc63f6ea6fea6d0b346884c2f5f2527cf382e37da01fe80d8f870ec900cc0422c08dc762adeb2861cd27f28baed9daa4c2fbf1b169c9ffec75ab1a5fccc531e8d607569c16b7227ff92525126eeb8fda704b0d494257d76231c3247ecea47e4e44d430ddafb25d855452ab96857a3f99e18db3bb02562df4370e9827be241cc9412661c498a4f9055fe79b5d38e3dcdb68e2887c8deb3a0f599bad44784783a899a74b5c6c54b0b9f25ceb8b6fd90c72a8b9b98f4080305612b8030e1930813e80505209035e3396d3f3f411e2e1b241e6547107a199572df1ea185c0d5d0870d5d6d62f77b11366feac01c7973a5d29daf3be017733357447b0cce4e1d7671fd46656955ea9877d4cf63997479f01218b218a82db31513f6661aca65e6c9d604c4423f328f0a9bb3e9d0297fddd14de7c659fe40845a0abe29e5e23ef3e0459c6bc2707ba565a78afb74c2a19083f8d9395e2ac6d2b1ac92369c0ee39e8fb35e3fee766a3849b210c0b4f8b747ebdd4e97cc1c37f7fc5311fdf531211193ffd7b902518a05fedeb69624ef93b0cf1cb774b5f392fa5125acc73ed750cef224afd0dfdc4e13913764c829fb81841cbcd8f83b8dcc36d074b05a880ff9d89ff9bcf8fd50a7987fba2b635bf1a55466558bb7215849da4bc56a467ceea03618208fd0d21955ae6846c33d7189eefb6e8601550a0a9ee50394c38af51fc57feb21cc39d3480c71dd74411d53e5b29696b14bf3a4c1668bd37366eb6adb78a51ce5e63daaf1e64116c175da3da13de8e1d490186ee082784314968ae958dc9a7c801ae993d8be5104d08fc906c512c207127cbb0daa3876b44984ea0a7cb2b8b8e3ea951431e6255658e4a332832a735580ddee8af54c2cf652c0298d351fd1a45d66267f2997c932bf9302be2072a904570edb16c5d615a697fcfc91161d0adf8835976901ef1fac74c8dc75d9e4e5b1a17e6d6726e2c7cb2c335ba9fc96a5dfa41542a12dab737aba0eb84ba5fa61f4e927649deb2be9a6a0af0e6cfd1af4dfc6d096d97c7950ca0dcc1a5a3390b0945a9b3181e0decf7aff9074d1b669175ef92abe7587884fba1f398d9e307d9cde622c4c89d8cee45698b9151671e31ff35706d76bb77752f967e5b81a0c60d3e7e89dfab51af56878031affc52690b35c1b8aec484c0e64d419bf4d5e810006eaf2053bd0c56592b05079f06d393db0a3f92a26746c21c02ae68146803fdbccc0058ed857b7485aa3eef795bb67ec56512e6c59fc823ca8dcd36d0f20a8f019679601f88f3e9e6fe324c1a0c61ae3adb6cbd2d88481c51eb737c2ab85db2a11d45d1634906bebc0511e862a912d5984956175cff8d94f78ec81153282a1a3fea048a1baf7c2a6ce1d2bde5b9988abee6510601ec96381b974c28ea772cfe3cf8c6f81333cc2a27fc8e671230b184a6ba1476eae4ed54a2251aebd34ea499e603055db99f9b806289ea0c0202466f1a28d84467eb249f283f9501a65eb09fdcf295dfcfbe1acf01e1aa3b54a88e5f43b2ef93a22a4cbb5c3dd9c141ee8cd3378e41e9804550db41f3f0bc82765e27c64f655b850d9b920570218806ba51b0ab474da9bd98fbca03a1adf92090081b4d2b245dde15a816b365043142938568de219f656fea91ac42f97e90e44ee7d3d412adab276cdd5e13bf1c04e33e6fef2bebd33bb2de911823bf03bd117880fc0242591df441b0eea9bd96565fa0b36e080e5bd87ed6140439e64e5d25836280656011f63358a571d9e29acfc877b199cc51ea6f53e9ad3b184bb2d7819841f117618ba09573fb5eaaca044626d33ab56e05fa88479d9adbbd85da7cee50e287d8ee9d859aed65f8e23eb7e37c8c598d0a51b125e04aacff0ef488a44ea3c9e079108c56689dd7669dad4a10e0a6625fca2d358cfa71342334f6f6ce450aa74743e4fbcd955d0a6c3a8bd62bd7bc19a394bbbe400f6bd2e38ba53a7b01d7e364014b4269583c69728f3c9816562a69f6530205ea3aa32cbbfcb4d7f308dcd1cc51e941a873de7520537f648984aeaef2fc3f092915f79ab10efd8769a1cd1e9d94b29cbf2257adf66e59749d380b1dac2870e34a2329776c1f9110a4cefa47a062cc4fb0b57efa766cc28e5dd6cf4bb77eb62cfa9c6f29c03bec14f53a0c48ccf0696d51bdf468698d7353177d0e5c489361eaaa727fbfb65d3b45bbb4bf58eb00768e55e48807d6cf7f7ac17717bf5f528e0173da0454fedbebb36761dda00bfc1c7ab88f2705dfafb88833cd2da1510d515d42781a517a05ecd3bafed021269053a0d771d71852ff8cd6a845daa4caedb45b5e38e8c1a647073509c14181b13d6894dc3b5e7de448abaa0f4625f631dfd6fb7eed9a041b6bc4ddc0b28fb7387fde6938b9e57c1392ff56178f2bc2be8410df98c38e731d356b87838519a8183dab739548fdc0fe4e16517f902e75b4afe2d41a6d459c95eed716e9ffc46268baa71c96b0305368f0840e46eba22a12ebd4cd581dc982720e8ec3ae81e5dbfdef7155643d4a4a510116d38ce309fede4bfd0d80dd10b5e35305463926279db01b136f25b511126855df4cb156801dbe311992d2c671baf73ddfab21a95d6646c990b39272b9ddbed6b458f4bbf94a1c426f34b772545e2d4bd5ea9d7415d3655a5dcdc90cbf66143dca1922e79c1f09a53375a50af41516f932157dd95424e9ebfc8b924ab6e38684da4b533a5036fdb0feb987b2fd9014964c1525a81b47d8d7225e6335e1152a529260f162578c02741e42a0f5f8d3260b3bfbd6add059d0603fbe21e5a507f16ca9d5e70a62b05fac96cb826698ee1668270d68caa5baad119125efcd2997d8590a7dc9ef7855253a533a363052a689a9ab05495ab9105147e202829342247c616ab74d96b1537fe478fa6f5d87ff4de1be943542f5b4e9fb0986aaf7b8f18a785765246539db8e2538d1d68d99db3330a8c62dc2b5c856cbdfe161315cb59296f10570467ff763160aa7c826ed590c8a43a22f2bd6b8d47acaf79b79db1f3253e1d473adf9820bc0d73381153747eea7af5e2bf81f7bc25889e8a2bf40d2add6b9f4fbc0dbf1908a3e88051414c673aef0b7060ef82eb2cbb062279d2ebac2bae1318f14e4d57c6e655213d8ea6dc9de84b09b3a5578c5a5f3a673e4019a3039e1a483db79fff1d050bb823964432c4d01b6094dda75e08cb4edfa56f93d8d2bc1510d3dc9c74a9beddc638525fc0818216d116dcd5ef15c7303fac4eeccfb1bb4ab293f6a6087a07e9fba05720cffb7b43837849e25edfb2e9e4a3c586d54e60f4ec53cced4c13821c378fd0995e3b3f39260d455456f0597c47c87486e03829df71993ae2c6ab38cbdcbcf9cd23ca9db3ce8bd94f9ddb1b60a0b711973240f99cc1d6ac16cbe50d1a5c4c9d70720b6e9580d9794786cf0a167dc63131a105c209f018648f9d99393cbf5c9eb1599577fadd0eeff9982fc41dc11de6af78dab2298b77d56ca42a91b91bd6654141a8d4f5f05bff654a1b846272907b1ea51ff98df519ac362e599e8aac1c748be2793d2abf1be6e3c07bd670631128248129bcfd023a3eb2ef2ab5d99fef9690760d7620c6e06613258d7b0bc5ec2669e35e88e5acf1b602d8509364feeedbf39a50e0d9ebef90d5609b8739a4a527248adacb863a86de12a56bb3af6607458f663992f11594da6496c81af25f7fbc4a3f026775b8d8275f3f799afd120636625739f9195d2c5cbdefeaed2b87266a13cc7a7ded8f36b92172ae33bc8fa588f16528b91fa4075196d682f1aaa3aa86f4c0ec292f2a096e4f62f52f4dff5df04e87ef99c59da25caadf2dfd02a89c8c2ab744081b468b73ff87805aa5cc3c2a30fc4287ad25f89bea698285ab28d7d8fbe44dca46492ffc85798cd601e51512a5c9aad8ad0d4244f3cc69d4e5ae5e1e11d45a3e5c275c8e8a3f9b270eb9dd41b5524a892f230657d6ac3aa6f6aefaef65a90095e0f1636e6882f0a90648ea3dfbb19dc0d998aa18ec2b6f181be9f811b657a2f3557c59bfd12bf92a55ad7df07700f85a28b7827451c0b2e5f9620266040449cb19de882bf0970f9710a604605b1e8344dd23c50a88a19223e42e8b58c82894b9acb04921c7972a9aed5a5fd14a67c72d7ca21cc744151712bfd9622a2cd9f561f51090c695c2e405e7e90dfd30adcb582c0b8eec7da107bf9381afc0b21e25fbbe0e599110567ca48c403d45e0ccd3669933c326211de70c45d1555d8efb10243306a8b3371a875eefac2a75ee1debc748d37c278dd296e186200e4f5ee9db872300e1c4bc25d78e76024ec61b48903b278c60d5a6a48f7e881e11125418c2404de654727b0629f646a7fefabc355392a437002efe44aada396b4d36b21be19ffaa5e4d3b98827c04869e938aab76ecc83679f554fcca26c937853acb4e7cc12aa41853bb6bce66d717b4bb069042ca3355f187ae8b129ef56eaa3b39c64057926c4902b4bf56f18c9dfd9ede6d3cbfca2362ad3aa0b7ca63746a9eee246ce2f798035ff480467a12617681bedab5ede1322e79045606d11c07bc8c5fbe07dba4136541b72c7eee0281111d5bf52fdec48cc2da5adef81172610404f76947700bd59bb4d11df59ae1c052b740b371ef538461ef667b981c3cc73cce18ded3c1e1957cf8f22a80672242e0539dc9fbe971dcbf251c525c794fca8503aa7fb5b077373c95109a9b81158d488438adf3bc21fe6503afd7f0d18ae8f16257ed56ee2ed69d449544b424bef59392a4207856771f28c9e5c4771a2cf15ab9ad6637296da38ca224448c9cf79c4223caea2d75ca8cf355068f62151ee5e8a8b1ac718ed7e973c3e4693980c081ea1643dc665c7a989d92030b135f2b21c1092fab8465096c7008d7e38311038141c8e74f47d43ddd77be32a71052c78b86690d1cdd9310e2c7ee9af439b1f58f5c2c290c41dfd0b5ce9148419a1d662d7edffbd3aa417a05c361dbcdaeb96403803180efb9d0b6c671ba3f431b1db63d1de2beabd21115bc07f9e33bf64c013bbc37ffdae81d46211a3ae0c63f8ba78bfe3ffc9a4a9377b58f8354f29cd09492f651cf704a664654601a48c26f291bbc3206d6fc6172c2301aa2bf7da4110daf7659943309762be485185dc03e0ab4fc3cec155d888be7b401bc069376e27044c28a780da3c7e06665aa15d043d6172c69384d34f7b208d662905ccfeee651895fe9f5a0c34590a1a2c6fdb58fb9d0abbc34e24f960adfa04b650eaac3fa7e759eb714b97ba9f599c0c151153b9d2171f628c49f8377740232d6e048e7e979e9ef5c8d3acd601bf16a13fd4ee9c35b3b0913b84a249ff6cf46c10ec8bb25e2f311098563d688331e2c4907d07add195c97f4e73ad93f514f4bfc4ab96ca0acccf856b52a93861e9b1dc4b0b0681cfdc87278d4613f9e209e524321f6427ae200d02f7569452390639250393f93f5593814605ba517d9394bb879ef674378d4db8718df57d7cbb769542dd2fc0b25ea45f94867e5222c06c18c95b8037b205a8ab6dc3f24ddc5c740e2c644a070584b0047597c112037a4e16424a2d6c8a842c88209d550417611cc36397f60de52ad08c34a347a0642425aab468ed0a9279cf95a8d7381f57e99e3313c33ed794f664b7393cb410e880b3b01525e785c134e935c2a660ded82c9ddf21762061b572a666bd2a50cf494a65ebde3ee7b2be55e5e5f9d54d49f8715658c8f2b9110e6e954a1e1571d0bf1944951b2098a6786c254a092c955fd717b066050a5a06653911cdcb93e95a06055f0d146d9a9edeee20a22f351d244a0d67dfb10690e5afecf30aec9ac715e9dabb4a985e459aa5a9b041ae60de5f406377af2a0e9db62afc40a396817e9dec8cbf0147f4d4b0f1471bc44fe2340a796908beb9f78babf09521476d23463b1550aa3e019c63c5cc239df2a18ef294697848531da1fc75d5e203b327b5088216addb5b622d58451bb343927a62f3f0db83e974c6a0c4bc8ec57403908b05468a9460a9349bd59dd99816ed21c1ffe4e471f5c88c7d78ad3950bb5fe38e2d74bea46a39dd57ed2aecfdb47e5fafbaf553d135ab040ea321b500664e0d6bd03f733f6e4d646bb65894ffc69393ea4419e26e899120ff4337e3a3cf8c9d7a5b2558783506a4cbe509c34e7832e97d956933e781e0ca9cf1c96cfcc0b9f82dacdf127b75830583749b599fe12b99ef64cf48d8ebed4b730e5636ecc205ed5dda8557d477d8e97f0fb50a1340dd5fceaf180b8d52a491f9eb78c4d6af3e6a9a2d94a6fce899a3925fe75c5846e1554ba988e2fc8e52bff60ce9da8df6e840b30da7d2b78b91142945baa6b352f11137bf586140bf31a0ea9537abc3794ab309e2f96aaa497eab5b90bac290753d8fa64597f0642ce905ada4153a50e433781e34d1092cf00383237a294968c74953b57dd16f0c3c802f814da2f741fdd24d197cebac56fade520e786929b1a66ed316080926d0c8720e182e18d6733c769b2d5b8c59d4872d1d6720d68ee3089d03e508b66761e287974216698df3d0dd86f671076240a8abdcf5c0f09a08494e9a3376b914968686d70f7fd4651a9fe76baa473c268b12a4d83124caf2f553297b412b1aa40eaee35fe847b4e19e14ae9fd5b9f06e325865e2470e5ec9b21da9516f8de5432c13f5e292271a7c4c5b2a3ad2185e165da72b4d35bc1cbb729d78f056ab5f4f582eb632ef9cf44da3c3cffce0d89d676e45c981793fc54afb3d3271aa171220c68e4b11770e590278ae58e5071526e8f88dab2e0dbac71220f3fa28b07bde63d3541cb0965b3a308ed35665be9740adc2137360a3d9544495708fa2924ed0c1a3977c65245d4dec30582358d33f0b03bb9a8efb6b7d2598c4142b6b1684144588230a4716aa04179a47498393e7db48462918a648179875042bd51ed39da697de600cff4e3233d25f366a0e7ba18923562a241325a8855af8ed8ec7c089359ec685044285c6f4197e0df9715eb70a196d12f74a57175ad691c0c6dcde41ac4eadf4d1727a515b4dac2077634cea506eb4d33299e91d6528065149394cd33e1691a6fbcd9be9616158dcb35014de65141b6c7395ca0a63a07693eb4fbbec6e7e379768d90064af527bcb715a0eae6dc6efa5099cae93ec7c580ebe5a186c4beb9b6afa0d81b691c89b55ae80743815a06c2f174874c37e8644f3018d92a7d0aa4c079b5d57e6771889272e67937db6187ed52ecdb8f317c308f9cba0b8a5b1cc1a277f324edd8ea252ef3c8ffaa7d387352957f8af8f3f0b778e03c690a7b28a2187ba6fdd96341c785b9b2e7a0f8b303645149c37d57062785f2ad0fd9b60710c4ccb8d0b7493a7192d79a0a6d98b99949cd924180400751a5e4edfe1133732fce31da50e55ab1201301a1fe24249360f0b73dadf876d33c12421fbd94fac9d967936b9d2a3d73fb68ee7e273c90057ede426c2efff488644551f457ddda9bfcc258a258f87bd5f22c563865a3ed35c8abd008b8384514438cc49e9ca70d0c3c612cdf4d259a93c75bf4f8df69a5a8d6316f9d5743c23dd521de8b45d8adce88aaeee123feb8942c225aef855b23f604127614785bf1dc790d96a7147279b49db131299092769194c03efacc35cb47e6439140a771e5baa7e87f41726c3063be02ac599a36cd72807d4c49cb86387aa22d892da97d542e665bd58951a250d2986ee118a15457eb5ab162c771269cac46afe6b20f13cf45af437fd45f8873c90aa3460ffce36142832ad8b471d8057dd7ac3c1ad8039f7a7a17d345c4c1e5bdd84ec98a5e5d330e1283380bf7b63c596dd1f0caee91d44f073a085df1f3cca831dbeb20fc559b75fe7e1473c6d6fdc9faf660cf0963f5908938e540bde4dc65ac49329999156cfbacf706a64d9d8ac3d63c8ae0653c1e9975925c3dbf4fe2e84030b40d6ffa245bc98039f8a82a15f57f65e2e6f2e74dff6fb7e46c77934766365ace47bde6639362bd3aae2edf3066c0249aba7dcccedfc3a245e0bdb68b6a8428a14f52731d2beb08345138be113932c820f254ed272833aea7f20c654343812d95ff2b439419912517db3730f9ba93c42b0dbc865fd9db4f403af5e40bcf0dfef7a27f88c89c2e18c7cea2165ddaeae5e2497ee03976b555776492dcd9ff1b3d6ab00c38dd02b802a8bf5d190ac6168ffd9802bb54494dba2a35005c6231bd3ccc1db5139d72550854a3dd2f9a2297d08ebe5e09275427aa221a50f6157edba69bcb3f675ec26dfdde2575a1ab306a3b75000adf21739aacc44dca52173d12b9eaf2e6069dbbbc50845a6c23681c8783ce3e309fe87961d21e0b206a9ccd3dcc96c3938d196d7c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
