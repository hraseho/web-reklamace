<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"34f054dcde892d7ef174142937238bcd081f484c1ca041678e686128cf77dbbfd5091708bcd255845d1c9df6c93d09a3efecdd3add723cd577cc65c46369858ec7cd8d21be20bfdf8eb6170e141822e7e92858c627643a43f9d2a6f2866c96dbf99060c288129a0c51fa0adfa8807e5449b6a1766c5446ab0757f050359dd94a28e6431932cc4b96fde45407582a0f771590a5fafced78ab919064cb6c9bf5f6822fc3afadfd25dc7ffe89a9e7c02bcdc852db2046b5c4ddbd655e3b200de9154e9ccbf6dbd886ffbe9e1f5aae42ac301351765a653a9a52d811a239e8523f64d2cc0b7f80d3870ba11a8aad6b7b7bc32579dc003749ac1602d344f4b5f1138cd6206f432697a9ebbe0fb730d280e08f704d8b234676287ccd51737ed379c4b58bdd09a2d23a99e9f0b2869686abfeb4219685764326998a6e0b5844277f5ad2260fbd73ebea2258e6e7bbc1ac4569fac1e47751e1e33186680f3f3bc01478e0edfffbed977fb556284cdcc63fad18bf3d13a3350c9a72bf4d0870ffc4fd8ccbf7a60232391c7d962f00a229af5bf0c4d4d074bc51e4052275a2217afb415952250272d16df888bd1890a6409d6d00cd5d91074f87a790d15bb873f8510b36c11949efebd6b1d508da62d85f9b413c25cf807805ee7ff09cd76cd2bddd41d408f5f7ed75617dcfa9ca50babc604c2151d9bbe2187603254545fa8cc7039375dd9ca9a5b5b8fb1269f9a4a1f8e672e650bcec78bfd4ca66288fb05ea15144f1954d9c5a51a56dbcf3ebbcd71946cf5833a989a0050a671ac57dac6f578559f7cd88392bdcb812854c2e8b62ddc30c9af6a4e00c779a1d6f527309014d1936f94bfa4e42742a8b3de3162988665ccd042beffb091448c501866a10eb27bbfa271bc2985faf577367aabecb6d18ac54bb2f2ae80b58899cf59536217576fae8affdd2aba46ffea8a61bc2579b2b7115a8f291c48415b75ea76a322de5ad1c71e92daf043510a20feda482f2e0c075aaad2fbca3391123a49c00023b4091b956b54d20ce684487015b86ded6d6e955e58c2a3e7289ce751496e0537a92ba8ab1f2d1c1ce5a9ceeb460da5468f5fabec8e8a72953469314ab0aae729f83adf38121fd1f837271cf0cd9ec0c17ed9ee636e8d6632193cb75fa283f0790eebc15085415d9640a44c453c990329f8488c5cda1641603244b9c9f459c78c7418578d5a4b90e257e2d5347b1691a1fa99420a59d68df310df3572a2cbc4f58f6911fd957ee4092fb9ad3abf6d6df2f2108a36e79b1deb2fca4147bd2eca9df1c8adc8d17d040ab87368a08b55758a24ccc2315465b880dcab5b174b36e882b3e8c0427d6d35bde1552c443b10d1bdb99fc37bf43a1d2c45195ffbcdabb6a140cb14e230fc63e77af0b04628929c8d035d9b552bdb5ae137f908fc95170149ec2fa07d63fbddd8f9fbae4f6f309cf6be3ea29479e8fbdc5398e824a23eb20a0c25206b65bcfb7762354fdb815970717689834db4b02684fd025e1dda0523fe35ed5dc656169d13a440c616583a50f1115a1dda442e171a39757b63e62dd2b29dcb2ce3f11d3455d9aee6f6f3d286e48837088694cec5497bf315bcf5c072d22669bef7dd2e187da72d69c1ea8272b20bf1108593631da858046bad442ead8752e3d25a6aa78e014244d62b82786830761cfd2de86d00f2e1059ef03cdd89d55f546f5d4f016717a78674e451848320e0466e47607c7703106bafc1bae0bbc07e36db5af0d45c791023e4d2534454a72d8d39c11cfdc1ec6448cc3b4bcc4494fd35e5461bd8eb0a6ffc8d2f3195d283bce68125351bd3dba849ed05d867541dd1a83248f273050ffd452cdaf3bd688cfa73fbd6639a764189d01d2e6e7978a463102792bced6f97f96badf36c375caa1ef5f9c51fa8b4725f1107a2255ce66f558f385c50169cb5298e7a2ae99edf27aec26ce026ad0b9bfc35030dc7ed8439748a64d797d9178f08e90dbc79668700a7740a8a8137110143cca9b76ccd8c2ce436e15bb214a699595876250deb843058b4b311cc73b7d7b9797346747fa0542785112c9527fb4d2fdaf991c354cb01fc461e2c1352b7d3cf9d9bebf26b0b3def8dd368c057ac78ab66f2f766b0a6c02669fe2f68e3e44fe04f2bed782df5c1b9f57a49af1cb60db05a9ddce1cfc2773c8a387cb69bae1d80b75570074241e05b496294f72bfd50265463856d289bbc201e0523b444eb499cb3b3b949b24530b76f5ff2e0fadb5b4a136336a004d0a7d79eba591014359e1da13cad2eb170022be949e6c8f6443014d39ea593e0275eca5d34b157f92bcdbc7df0d3a6221f9fd3490fa547d15db9ba931785d1fad7b5b51f9be9a2b7a352e284af97c3d66c3db7b6d6c598ee14adf7c48737c4744470e5a2421fdc51ccc260f23b7d3e30e33b4121c64c5fb8b14d418b9a8e06b4b12851775db931dfebd217131c2650b38bc5f52d44127b0a477447c4e5ac067849ed27bb48a3ad53080b714944c2082331a569727c905fd1bac0d83b86b188196f3284f3e6b926b095d10189a5e2bc33ea93b6e6bbfc744306812524917cf585bfa38d0e488c1f2d95094f544f8d1571953889363c03c147e7e819f13db17219a6a7031ebe4f3e571adf7bbf57a2575b9f72c846f04515ea371647d83a3dd81ab7452cac4aacaa763bba6cd3f1ac7ac36542c27d0ae36c0dff521de80f9d9f6a8aa1cf895e5a77dda2e5cb49e7944dae593a01cd70970148d932ffd1e431e6af37c0fa901ebc8361e2d340d2d14d27089aeb1d82233eec2aa8ea7b9eeb682f45b3da2fc3f54e2cca7f35545db577d7631a4adfee7cca8bacde4bf223f67a30c63a9ed0c5b58806c3b17da64f28d68fb331c1f0e3df05ee7e5646b8d906fcae9d397199a5328cfd074fd5d552f4762b8a56b8505af239063a20939f0f3a9ad37b99083aca6249ab2d87e21e105b16796e3d95f025e4e9b8604377f1073a1f1128abfe6fc3744b5ca97a29e35a315b1d2e19d4eb244c88596dea653a8607707cf433be23a1638f2617f2c92a10186729dded0f4099cf40697a962df6fbe99bd4cfadc32b4d302055bb069a6f15a2c01d5e6d7f2aa70013a78d869496b63991521b3863200204b376f8239060b0baa94b954921fff12ac0c367887e1b555c7fee711f8b39a4aaa9774825741732f4b4797c6ce33971b76b3c85795dca69d87f0b658064c82d91d1596ed6c6d5f230dda633fba75099c781621059d23e674f5e76022d237ac17448f5769616f565e0c72b4d805ca2eb4b09f76417070dc69ceb1dc3f9635d20d0ac9a2aa73066bd0cb92b91a9ae3b33e71e79adba455b8ad90b582abf99329e6b69b5ac80f051c42013ab2d6c78876ff2964a2acb6f200b174b7ddcf25c241e66f72a0a9dea398b9201bf7f9c67cd51f926e71ea7b1970435962d337b45852551caf8b37421ccec3e33beb7c4e7c21917e8f52249d80afa04c404ba7dfcf228013c14a93e30acd1038ef38a2e4585febb229bce71c2b593076a216d9065670376d12b3b48f0478bfc1c5e92cc59928c51b7ba356f47c589ea1c4485f1608225a7908b3e7a3305d6c12a35f33fd85629ecc74223938c7f97c7e0d7c683d816bb9900d57c929e4d7e6c8a57a91a8ebfb3db09e7378a52d4a6984fd10f548e94d8cc6cd3aa976425b7da73497d7b4fa8b7e97d46c4094c21977abb0efd0c8921a242d73b8d9b0bb587b2bc225575f977a7e31fd6ea028ea7cef17eae2567f5e5b31d975af547637e75b66a33afd7d4cfdfa1b1d45ae5da7bc6af50e77e782b1e7ae44a0ca6041fa8b06d5b4101591c9f7af5bb156cab1b026cf4ea9628c183f87524569d3d9274af6fff6bad872c98d920841f10e6753c8d54c9c8860576670c4b047e2ac7e5ebc094a6121fee79e3baa94800e02f983af01dbd682399fb1bb9934cd5048f3740199ac5f08f17db4624c61aec24dcdcd50a34be5c3e457591d7dab8e5ea4661ee94bfde9ea37cc5bb205e1dbe0528813f402e9905a1285bf130894619dd7424a0d7249d493d012d676fdaf5082d8ba49bab96cd8d49e10e0fe42a317979ff7e389e372ffc834f5f6ced7962b08b06bc221b0fa1f7dddc3f98c0db9e165ae974ffac0bfaf38d97840870b9a0a631ce653ec91543be0bf2280bc4ee80e6031ec8fa0186e2331bb8dbd81a08f99ce0c41dad07193ac5ad7fa957d2a7f7aef9b2cf978ae0937821cd5e3f59df70a46837f099e7246597cbfbb7c07d0a3c9ce8a0b1ad92a6a589e7995890bd9b65de77483b7e96c7291c50621378abba9e98473f2ae204fadfcd7e0982acaaf05d576e5f904b3776ac76490d152378662d31c88748a1925b6c1bbb7645b7c061185cb1ae7c5406dc80e042a21a04d5fe4241b859db14e8f4c6df01e8f46e419f9507ed1f4a35f852e60962debea6570761a9ef3ad1fb81f340d9a5ec03561bb5e76900853f6d2b3027b73d893768e04ab36281d06a32b7d4d727869bd0631c99b49e79cd12b2229543a12a18bc589195d193346d2896892cd11a02c6f5e2ed10d0227e29e854ce8a73e176a21fc807737d5f60000dc0920d2656d1a1989a99731e80b59b45e805007894f93dc89bf75640c045a366d6652587218c1a785915ad0b9ca605b89078f76bbc9ff423ac65e34f908283540ab321760864f923b510643e46f3c70fb690f037fec31fbe4250dcaf338e2e40a4c94d49b0f1b8b30d25062770bd3f93a82b7bbbcaf8298e002ca214cf64c094acf383373db9d6c1e02ecbc3bea03eaeafa75ed85fd8652cbbbcd7c0a89c309b3a721a034dda775771b8498eb370b4fcaf5a3a61d72be5393f7b61c27d91cd328fed093709a20e1e82e762d931230508faa6ebb8b753d0bebc66166cf1c90f411c590f82d761b89634acb2024c6b368b1ed22e7790558ec8cdb7bb8a5c0edff277fcf66b398b9591c964deceb085fc723f0c4ce77301041f28e7bf76676361c8a4b8477cd111ce7b8f411387aed6af77921de16cf45c2a5060b86762f60d8090f971a92cb9056bf27c5045377f3e5de3cbbdf45495af3c7a3d969cdcc52128875e2fa27af0dfe58754eb42912f87601a4dd74764c0415eb7713335e8cbb90d9fef1497926480f83de94db283cb891babc2ab61d8fe6750428225b18bae6d531f8f1a69187f413f6d86084cc4c511ae61fa7305a93c273da2ce8afec8a31f751435b0822c4f93167a18ca8edf11e42705814d171f2b1e1d34e93593662f07b72e7ad80f115402ab5f5977c2254d0832c012f93916bbc2a725e60d407ca683f26069ebfb94c23b34573409fdb197fee509cdc7a140154715c2ae79729b3e6de0765e003ae702c85ebab27b4e1f9d26a49efbf7ea4e95632477420911f0f3e04c142a1a54ded32348773bd4c9c5a0c158318d9c6c392247cf91afa00c02e2ec31c2d6b3183b5ba6e7303014404f407e48e1dde328f154dc57df840781c3bdc2bb26caf0f922c24ff00691c3cfd616487ffe7561989b7b47907528a68dbe4cc730bc0b23479964e372de6990f28461c6f0e7cdd727d39487b6dada52875b3841da607db5b85efeb9219f5913e2d3a841f1acc6b120e53d92a077af6612d57fa34195986f03266a96de3b6d3d28c515abb474eb079d3c35b3b1d5f16698320dce44d6361f2f05c42fac37f5d3e12f9f0629e2588e21de2356a64807506b97b0a0adb99d4d7320218de439e2ff9218d7069002b9eb79f81c293a7bee0138d127fe21b40e5287dc67057e7f84096b364efea257c229901225daa914f19feb0383eda00e1c5213302cee245f315070009a93eb6c2902daf46ab9025981765b3b405b67cebeb1a7fbb5e362abd5ae30d3b821dad97a3bcc6fe2cfa1637e9e0c720459d4e3517ba20c0d6e734134d08e849190d96032c269016f7bbd8da3543ab53b9232ee258cb5d0f014d9a22ed92641ff1ab610cb08b42ce6fa63bffe8d14bbd9e662b74ae06291e47f8d9d455d02ebf82a200e22de3f8c23b1fadffa437a515efdb067576dd7ae645f44486949964ab5c3118ca7181d51893802c1d0692fea4109e96f4dffe17f0a7cb75b8d69f69c15038e45796922380b75f7d0d900fa9ce8c6f4d67dc648c316a3de13f929fec33cf7f710a56df4411771b71e64ce6ab02722690b282d3a6a45967a8ba9cca84bc5a9465e973d330111858fc8e2aa9abea623d567a492c90e3e1fe095ed38f2382581dece036aec4e8b29277aa4afe16f4a3b2ba3e6a0475f39f3e99cf6fea14ba4ba03be14c611e93969edee980fd4f346e2cefed6b28666daa73da489053fd62d6491400d24d8c2f762c6183eafcb0ebeed53979772b1708be688b69843f8702815a19f82485735841d083a12b0e3e661159337411d188c5799e6eceb8fed92af4cfb74ebd27b31ad924cec96c972071180fc4aa298ea32601d3c42d0dd2c9835cb0827af27e8247e8f697f3df0acda3d0c7fb960308b8d8001be5c6c335787ae5cdcb7318384459a2362a9bdb38e12a89e42317538981adc579f897fc363045855b9df90f07f34fad560f549d44e0bb410f6779780bc1d51d9ee5c83bd93e63db418ae730944c42b6b9fd7c1febe69a0adde026bfdfc23ebd2a5ba79f6c3049b4f3aea3bcf8b51c16f49486a2e8abfc7873536899695f917a706d4cff567dd880a21e09e8fb7429ac74e19629eabc3a46dc4be66dcbde2b39d39f7e98ce188445860bc517739cbb6e929b6ebb23da820d8fd9bb22412735f9bd53b94d49c8da84df171199baead213f75a897a3be6910cca8c2647f9a544976958c31abd53ce048f7d227198797db6ece99f9a58af66f9827464de468ae8d3fc8d59e8886730c6e4e05c0c82f234b6f6c0c818296808850a7887b3fd6daf1c76c631da81fd330e312d6e491badbe15daf7f484b107cf6709431f58e867ecdc12c5a4f24e123fb667abbbf67775f4b0e9b700f792910db7defd56d288295111d5b61dedfba425322bd40f17fbb4af3ca90ee3f255046b3fc3deb4edb6957a05bad57846c88dc66d958c31f8fb95b656f1b26678b171b2cad44253585461f36e33e90de4c1939692557a58bfc296b65265a3b2b9e4ad8b15df059358542d96a2bd7026b0d1228e8053ad6dc733056fcf567746fcea81127f696daf4e8ee14afb9b0f5eeed23e2d606754309dcf999cb7208ffd4fc6b7f0833c0b419ab9ce17e378785fa99986aedbd0323c0e350785b8db15023758771aec1300b0ccb423db9964d81351450756ce3d107c8d152a58bdd745b5e460ad8e6c4770f0c97d8312483f29da412b4454ae4449a81d24bb2aab76cc3b078781f3c6bdc5269b39d15d0305235d0d6742cca2b98d433d720e06e4b44616a18e30380932a7c6aa7160c7f0498abe152cf8b69357c26b44cbccab96c09cd0a60b4dbb114fa55a364fff60c3c3d8b54d871fdd28e5ec2c4d683f4e715f6544d6189098c3cb0fdbfaaf5ba92dfc58354ba24b08ecf0685acfc8a593192ee95a2f818323c57f63b866fae5a72449ecff59c58bb16abc2c714c191ad6a83e139bb48eed0b467b3ab340dbb78c332e0c5f4434564f1d18e06113e0eded862106ef6eec383be9bef5adc3e3881cee23764fb10598f5b297d5ebb3f560f970743bfb460d4002c421da682ee0e59a85488e3666f56f1e1c8447a1ec6cbb8b397d7fcda337fbe50545efa9b3a0238dcf49c92c829209918d981a4540caf147d12131705db1185c7853499d9e57d5fbe7b3fe4205eb2585240564c5674c516e808f3420260b0f1eca0a4be0167900928efea97b5cd23ec0c63f127fd54f01f8ca231f1d59ba627658ce8dc0db98d00a592d6929f7f8f55ceaa4ed8c9e662d3e42bbcd3fed05f1584100b63cf23acbab5e7a119dc3e3c3c64b5d5b3dc0a3ec95a72377bb8f98ca9fcff7dd78718f0e7353b45349e6549b1d9ca0248925b72797b887b5f0fa207a18d08c67f84a6f1525acf76546be3a554b069ca3ed47a185f43b13169acf9c3f91693838af27a8b3ed1dd21da08ea983f293ce9bd3d9a1e190dcc2748dab4b13749ab073ade40dd36db033d1932c7ff0c55393c9bf331eedb005783097aecf039942c95cd6e73be98d7a4ade621e0494849ad71af622c7c88e42c7e16fe22ed55f256ce7c8a463cc067fc71357564514b521cc84c9394a0b572ef5bc0b425a241079e6fa062b42db2bf1d6a8e1ada8979a9938089cf3b690ae053116dceebe7b8b17c99479526f4761cfcc1d27233b4347ed8c9e69471ff120cabd8372d3fbe1d5cb912017fdb86309109a74a194bded01b2641ca80b95c5a28650f17cca34359111880469911eed0baadfa333a5923af4a5be7403c87fb0ad1aa31e7c6bb987d9ed654d9169c6943846c720e24db7712efc6762f90b6520000ee9146ac34654e550ac05f49fe1e60a50ceb9303edb6337c51b51c69a5a721e848716d5d2c30e44acf90818bbb20e4864a80f3f66cc58b970daa75b3a7121043136b211bc20dd823dec8c06c70a4e7fe10342ce72bdd017b98831c840c3009f6771974a5ff972830d219c415a0449803a449b5c1544b973797147a6084e8e187322bd8b7f3f26739f5107a9a7ab2e154fa30bd1fd8e0f1f7e1ef6172800b23781ed46904e0a1ee6eee993f04bac6fbf7bc328051efcd690e9628ed30e50e48c1e25d3413ae7b1ddae9f12ba014ec7919eabadd162ac0e98e998920cab5a5a882044de04b5cc5292effffdf17da1dd347dd7a3a443a267132244ce055f7dfc57d288e48f3681f63e9d9f47881dc52e481659c9e69ef8b6597df43e4ed616a6b07d26a872483e41fb40d6d79e0e17afc9ce4ff518726ed8a1732a040a9a31ed260c51ebc3c0fa6ee74acb76d348bf9b8911ecf6736c08a0b262ee2f8bdee6f507ff4962f2f6f2332e962cb616b6ace15a2508e74f4afe101b759359b44099d28d727b805d2e14d353010495d026816f36d64c97010a7d0c18529014a8c4e4c5948547c0b4b79b6c29604f66d570ac6f49f32b91eb412da588c87eb734b1e4d183ac1ff235a593f60bfebafe2b37778c933bcb2424f5c11199c818e823a2b664e5f68c3f11d5c198881657a28bd576c745ea936f82d77447b9d41ca6d5fbe6a27bfa12092b0fa33282200eb89c2cf8a3852380b225ca592c86552e2e666873314289b46b2c56ddbabd2cf00049063532756bf3051fbef2846357081dbe66b8822ee585ae5dc935e538c4323141f9bcedc92497edc90f49bb515b2cb4e71e90d218c76bf938ef0797d62438f733f0f9a8cb6ae9b38e27ee5e8164750608ee6d0e4510da73fbef4da86218c401a9e02d60cd1299493e30b0cab161bf415a90b83af4a4f65f38ee5eb6f39804f2082130abdb63543529eb662a4005d354d5e1be180da2e2179bb973fd9ede2e248ea59573cf156333f1bca97b44aff57b3178574bd92fea9c5755c1a6ac271cc9730b49d360674c9a1936ef521182bac31e13c8e0788221cc9efbe2b7a29e7a4fe2da9e8f84f2c3ddeae683775eb7dc080c6ff55da05b6ef2c9cae055b88a1ec46f2ecd118043f98a17cfc81cede7546d34bf8d0455b3c8fe93ebf0f5950d5ee562b8759686fabce6e241451d025d7c5de960403f10e11f1641e883465bc92f7651f80b948975e7b57e77784a3b3e23e828c3f56a48747a764dff8f4f7313900c145a6df0515dcc0d1803bab76bbd5c9872b4ed62fd13307d36d60008111ddde87624eeb545e2211e36edb553f220f1e51a1ba07b8715e9af41c9582fabf6467ae162c130813944542af961b3b5f0ca09818a0ac9ab16d01d39be2718aa91c1f3854578bb56fdd30d0ed8cafd4746eb750ae1f3a7c815142b8e441948169a8175f3423d20efcbb4416671af22234c3960b2b7037a9a17231cf0667c9303130706f37bab638ba86759b0b5d40d1eb9a050eae74a7c034a0dc2a07c2c856df92e5703f2ca9ad92edde42fdb18ceed1c0ff8905987cbe7d79aa64bea2c83db36c010dbce00e8bf09a45a6733b0c62098ef9a7abaa442f824693c994448d94ae193d3f8313f39de9430e7c56746c355b4e210ac95fb01f6293aa6cf3cdfe967ea76e6c46ccf9f72c95ca8a3cc5e3b8ed52834b520c5a24dfc4002518fcfb311623e17377c3aaeefbe2e11bf39af99d9a5c715c17daf1908faf4e87843b2119ac5d75d3ffb6f15872aea84f391b7bb2520a84fb10934307e94e212f2b241afe72432da10deffecb5d33ff35caaed428b804f5afc3d190e96a81c98577f06ad3ffe926bb6789311805aa60741529160f338fe5f1bdc31edf0d5b9f01686112485a6e0fc3d03aa9d8e627e5012ef6454ac874ac504e23c384f380b02e1507eb94064dce61ebb054fbcce0fb0b932d32966ebc83748b32f64b264da705317a10306b64fd52116ba33778faaa73dfeab7b631b8a7408393744dee5a4eda35c215ae7588b002025eecc5b64e9cc1ba0a22f578a4a329b27456693af264eb3992661bc039d475d7901736fac5aa57247f9d853c3ad5c7bfc28b601c369fd46cbd4ac0500bbcf2ddf74bf57029681c5e28a31f278e7c401831f8e24d3dc098cbf6131dbeb8350a2381cd7dbf02fcdac82689772f65da52ab383e6a12d7a0d91c6749ddf6343662fff927c30039f5cf8b822068d165c68b4620e057325b6b01e1821ea11dbd956c43601b37c3c7ce1dc375401f00e1978aa7e6676c6c23751aa0d6f85d17ba4580a285c51fbaf942aff6b7b05d7e7a762b38c2f1322809d95267cd707f9c1e133d267423d0fa3cabdeb3c5790fa907e8fecb3d1280affc832a2d45c369bafaa03cfdc135f2acf06360a15f9cb35b5b472b7af1e9134848d2b0cfd8dc103ddee0be34938ba9bd5df02a69c161a7f360d23ddd76f0ddc6099b3c8527e8bbe89ee75674f47592a07c9ab7ca57767f4e75e30f54092b0b558c04ae83dc42ffce5f49f66ed963ab7877275b05f31d22ac634c3db00b7a9cb2e833b0c2bc9e7a16fe2e568e53102d37085f204e727280941f9c11c11e528ff19a6ab24568321d09857dfc2f2a0c337e77cc3480adb437d6819d0a140abcc774ca53052f4648803f67c33b6f7df5dfc9dd6c85abd92d6f99c702bf929995f90568d4127fe6827483e36e703991bd1761b261ad3a5a04468b6f2c92f5e5f3125b4683eda60db9922750191f03b50308479dac6c846d7107398306403f704ee1d2c028ddab92593ff8440f49ff76253ee2ef226e1c30e40b7f3ca4cf2208ab18fffcfe7e8caf552f9d0327a9fe74091fae10b5035b9afc08c0defc3275fc0f44c322ed0b4869ec3585cc46e1360f243a5d9036df153aa429578cfa1fbc027d5c2ff09943259efdbd16f765e518c4e8a6661956938b0193a2137fb345f69f50b9f7a408b81f354fb4a8526dcf0c4732a1ffeb680db7e1f7c88131095b6f2e65c33f13184aca157192e0b270d8aee05c1fa00fb382540770fddbbabd041f72f8f5dee9f587154744dedd52d6d0970e35a009841c3f36c2df498a6564af4bc16d74dfb9d390008d9090237787aa1929b578ad80c12c33e0c522589b28179ee35b899b1a152858e8ccf3c8dece41412fcd5c1de30c7792206897d9f4c924cd3c1f2a9f568bcaec1767db476ddd520dfa95c69291a7da201b36a72b16fea32d8afc8d472bd72cf841cd5de8c06fcac29ca06100fe021cf58cea2b97e4bdd4042bd72f09fc56f22a3cf85cef07e70ed7d2d963f21e2647342989617661657b22b08853876060754dfc9f77c848dc7f240c87796e2e460662e5aa016650871e056bd767e324d44eac73d5462d702edd147a22d05f7d7928fb40d600a7302e7f669173c10449064b8027e1bffad59591bb5f0e9ec7f05db18975a0b3cb241f002c2f05e950693ce736c3abcda18a715e45d16b4083384cb0adf00664b46c34171801c6834bd2f72e02fb9ed8478d20a5cdedea7b7676c106bee4d85cbe6f3729403e04b3883c690b873b28cfa559505e92e4c70216e88789d0466dcd5a0555ac63b629afe70f5f96ec7c9ef6491e0da660b125eaa552d8e0c7f279689d1afd2c0617d936c05861502b61028a751bbb2e0cc0e2576c5ef7b08f4655c06ff861020aa98bbd28048521e407c7ff00b9f478e3e1bcb76eaf83baea9a7e0a91b679aea3f7bb18c54b0b6e8379acf128fe474b57b708b2fefbdd9c3ae855ad6818a73125a587d870398111e08a2ce8d71de532073fc02dca898d715141fbc5408f75cf457397d933871bff0acb4cc286fc9324169db3a6d7eb2d9d650eeed0b07d473c8b24c944601ea0791b1c9603583eddd74f444a5784e2ed4e0009d85fa763c342781b1ab10c09baf65183173a88eb13451078b58b498bd2fe44d04a06bdc2344fc72bfdbb05e273210698f3a4de60329a4189a8986d3dfd88ffae48bac17bcb717112b234823347296c76f74257452814f5428450b8a6bb09558ed034cdd085994e6f624c33e95c8568142d3e8cf588d0795003375abe8623e6d01fa9453bdda7da19f88ab117a759fd7085519454d3db43c2d693598dac8b873533347b4ec04790c14aecc230cb537c76c64ff8342e299d8c2fd6cda1f8a18290032b4d8771ef2c8346d7e9a7e490f05fe9dcad18beda216c30e647e153b0415018adc5b59f103e71e168b9a63ddd84796c57a835d0629f52209bacf61d42d8660caac6f3cf4dcd0f41c784dd8d91a250da8bb93b3285c1ad159f5e9154454fe5a6510f9d3dee04cf7ef94abf47deae94c3a346dd9e3dd8ff5b83ca4877a94b8a60a72027e4f547f7f83d9f4563719bfdf17e12e01ea65e391cd73314ed01d271c4f740dc3171b6dab478e41b87f8a7fb9dc39f29e86b8fb54391f4eb4085300282f42c6d32a0796e802c6ea4253dc83c3e654b094ad94e67ce24b35331e16a671540041eaf697254e096510a43ea78b3171eaf9ea4f06096e50f94f56bc4c0fb1f5909d775e87f2a1e6cb752bf03fd57dd946949627d77605540826b72fd19e359b269529a2a7c5a6d8b8e6fbbe42a9cd88eb963aa61ffd40963a2c0aca4ede50c420a5842dd140a039895d52857be6967e855d77439727c2a45e9399a734abdc30487f9d90e85dcfe8fd7e089469351856957ad4a7de159ee417d72848fb632951caf82bae649e46db3f5dac10999e40bbb68ec89b71ed1650114957db278d6e084ad5b8c72074b0d14536890893de17537557f3ed754f715657c4650e84dba0b012f320d2a02253bae0566b6c6e47d127450cf6d2e2963d7ad092155b0b430be71dfb40661251872633221512f1390f07743da349d4b299721fcd42ff0869c5b57562cf65d2b367d4fdc520c13bbcdf10826c5a986863c41d38ac1219d268eceb7b1440b47653ff2fc85346ec270cd2a368df01b04feb72f732090438628c3bf34282050e603d777d896907db05676b84f4aa6a0fcad5409c421c13fee47ebd75f2e1dcb8ccd349fa39caffcaa03e69dc893a65f758c5465c85ea761c3fbe4bdb52f70c1b6bb48b977682117f720fb286b8a8a4357d4472c346eefe05ebb43970f8b0961f747ddd58c3a2f085c935f0ebaa9463aa0f97b2686d0e09af1dda16aeecd5fe153443bd800d04c9f1c99b450c62d560445491b7aab8c6b7994155d6a083d0ca56ff1d0abdb7598d71eae110ee525ec837aaacce319e5ee97985a096ac91b35630d537bcadb408c53269e43d5d7fb36f34f5de98160c492d00ebc5459f926d2b060baf4ad4c7753a5be52bc2bf3002f21d92e51e7dd4a941254b593e26019277a7c738c0f5d38f1a199bd506dabd412a53634b9b6629b2168aa6b0afa39bfa87f0a90737009ddc7e145a72c50c162e25f4233064329ad8ee7e914cfb38beeb20142d2546d322c04be367b3ca8517ac2973c6c59c028eaf0974a8283940e38a4b51ed6030969be52f3294fe36919f77a832eb6c34cd3b6c0a5ca9a26ef83f35efdab010989e0cfea3a66d9e111b599a97e24a12cee1348d908ed2361c63c8fdff39a968d2bee8c4ec11767263317c7728f4bc4d24e2413783e6b85ae377767c903ab1a37421b283eec162ff41045c6c5e8f4de3f71370730cce38bf85bdf2b8cbe9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
