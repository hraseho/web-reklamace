<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e366c51a4af2c12f912db8a75d729b7dab22bfae20040c29c7ddc5598c1581eb87daf7a2ea7fe325f92586483b63291af574535db2f0249aeaf1e864c82cae7099fb82d53217c749afab900e723e26503c6fe8a0664b1a9997b0c2b06c567465d8f3a79a180b55dc3b006ae70f11966fa2cd6538a7bd050c2b0d679376e1fae2d9c7fc7b7963955e0d98b57e25531a740b45534b9242fdf4778a76357a7d7772111ee9281362cb2d6a099ee80aeaef78b49f836ea577f7e13691aa8d367053859522f29a1e31c457b865d894332b066ead1ea718aea388815fb2b76669885851043a11ce429612ccec4a2210d948b5efb2122e7d64f7ede440f8c85eb9298cb6a8844bdf8cfb690b8838f4f18d9876085a85a1424acee6a19cb890d23af91bd71a9c85d88d1c232952b378b1f85ffef88b327c315d849049c1dd36f5623f6e5611d43267a54c73a2a383d2c609f3953530c3b2b13095b6120f5b7068c7605d33d545f2084fe8945c50681dc8692901b975822ce8e9bf1c54af7d78b7dc499bdea2bff92911e2be72a0da7934acd87dbe25dc0fcdb20d7ed6a1de7d6df26a71bd2a39ee266cd3b72ca0eed0fee7a8e06d6bf632bb13f6e5506165ae0a4c2f32f0c30d29587cb0f1ed4be3c0093ba0d8527fc8edccac223cf1ffe31a2f651a8bbcb0510943f7e168741c935fd8bf12c6e14a7b4d5261000929a99996df49d377b9da9cf37aea4cec1475624ad8c212a2890ffadee6a38db8227592fcf7018cb7b1e918f1ed9c08f3828132b10eb94b69043daf049239918c75669aee69b78e3abf8975514b67f248eff2786eeb39166c37dc2a736ddc4e61d262d48a2f0374a2f7410f1b08b43bfaba882f5fa7dcae02dd4653e62e53ca0a05c607d5f08b98108a36e9b2afd487adcbf34796b6b644a0f58f650b8881af52622cd3a561e5441bdaa76c9803b612a0e95e23725de741775931f1f583ffbe4cee033b9d77f6cbb801ad3331c15a4ac513d8b11f858dbdf6d90ce873002ee0f7c597417c75a21aea5bcb1286e13663b9d261656e91fe85bcf91489e22a612e369b207612a442ce4a8f7297d4d291d3e64990bbf5766afce563beac8c3e5ae9d853c3131c3949ddaa38f30b9c3e05bdba5b5561f09daa1a7538ad1355bced73e0130a08d5e435e82818ececa5ce1a7484b7adf68f71c6481eb6488b3d50669acb623091544895446077fbfedfcbb9de2a8084e89fa0416d917e864b23149a35653698950d1bd71fd77328847fcb50fc3ad55c9d900d449423ff2d22475cb0e230e408979dedab4d199c22682cd2c76dc54ae8eac44a4e2d2a2761d65f064e2688a0c94b39bd91407e1d1c0b74739e05dfbcedf093105b47b8ab757dcf352476db588b3b237b3998e59ab71ecb75279dc1a07079d7760d3569a2a7aca975e22c193925897f84729525f22ea43f0ca48062b202500bb0fac24bad495c596483ae63e5ef8169ab0c92c9d7a42b54aff501b2f946e73b69ab762f46c758c29739cc9229e118cec85e18e24fc1ef016531add9adc6f4375538d2ad46c5543447da10a6640f6c4bc415bbf3df887fc7cc138a329ea1d94ae25eddd8a97595578aef375bb474474bf7248a82fa4dbe07c67874ca16696255b47c4acbae70127dc2c942122aef9f42ee783a5b986627a4fff74ecf0efbd227aa89e0bbecad3762c909ba486cc4014142a4432125c60977271c2721daec4fc73fee03178a79ff9656ed1e8a9481897e78398509e2b4a9aaf58b098c29d495f11ccc39b2a4ca4a6cac2a4b225f000ee9c73acc8341fe5112476d714ce897f3cbffc981a12ae31e6593cc686a0e64c22e388e286cd431b52ed5f1a0e4704502ff3adb3629d0e79d95ad448148a26222f5cb10f49f4735f4c393ca99f99f487423df27d2d240e4f874ba1571737e8b7c6cdaa9b0fdf10c4b5ad926a18d24b9e39cad691e2117cd2af8dc1dcc6f273c4e36e99cb21aa0f162d7856c8ce1af4221f32fc1218c56e92dfa4b21d9bd8d028c9cbb858407ef3531959d42ac061f5db146616a1e555ca7d6493e05ab37c43d2a0667967837be577c5ad2300bac02a789b3485446392272a57b4d86eefcac4d7882fac1b47612e9744262ab9288f7ab851cc2d25e70fde84c84fdfbbc5a74543a848a2db1e111f51b5b170d558bea642304007d60dca2f3122dfcf197efc1dd12906d8d87a472f982bd5a6960c61f0128bcabc7cf4c8db80b1c504393b7ffc18e26cc814bdce8786e7fdbf4a1586ca6610a82c14e5bdbc01ec00bca3166973cb5b19828c0c698bc947fcc00031be4680ef1a6255396eb04a50ee87b4dd7b4267b5ca161957ff416f3178d8a7d606ec7ab1cde3cd4d86200e5fb14c5619aa789444d0e393a8755ddf06b763c7bb33d03c61762aca518f3dd2b86a3ea62628f03f0451f18500eaccc7efe898b8627ee173b6db7f77772147ef7e8b0509eac06938613ac4b7af5058c35a552907a198a3fa8999e7083cfd4e418aac7a0771181ba145dc0bf1254ed323a612bdb56206a79e62900c41717013c0682f66c1fa49c333e5d3944baa38ee4b03c9109e6554b41400163d55743e2ff1256248d31dffc16a47f29e5486a8092b243b5008826d4c28b0efa49b81ea41d5f92afdca260540871021e90aa55b63fe986a60101f0aa314cb8ecc8b5478dde8e6c45205cb1fc2ba8788bfed855bf11bbe28c0564315746df45528cf2a9215447ced4a7115b1c77edee4d0bcc5d2b17be917c6d2c50f42ba1366b258bb7cb7fc9a72c4dba4a0e6021a35adf709e6c41dc612059c1d2db44eb013c21f11c2dd04f2486f3c18ea0c20b1c0c48d36d999fab12ad8b0712f3b3b0389d7210bc83961ab701c6b2844dc7855e1fc250665f2a81fbd0db73f4d88bbe67db80cc050ed1597f946eb2a5bd8bfe3bd447690fe2c24e17fd97817fbc2cdec8310a9f279a4094a1c99cefa4e29469ca64d17ada6696e0a0f9e72031023de3cb45d067d81b23a9664b2ecc4756f5b75f5b76331f66aed74fc679ceaf4bb9ebd99e3fb940f479f56d61d69e81d4958d444eb8fa0cf4f102cc553152ddb68c0cbac2f14b0f5973bfcdef1fd4e5ff4cdd9b16104f3f779bce2c7e7678248453d808bd1f208ece568e2868f89b467db49845b7fe5bf873275c7dc951b01930d417e7dd8275c4e799343aeb837f5e5483f2f88c504dbfa1b28629cbb72b0834c1dd39a21467462fa6f8f566e05417cd45a5f99bd579b489faef9500d18d551b9c82cc43ed20a347f3cd756dc0df5160cef6d2b2923dc9a08ecdf7bb1e6b36475a3a6a0a63953e1d8a5bcde6b9c9d91d0f394e4adef4e486c5d7d58b92164ced025a23b44ef89b28f546e2e74e9851ca1606afa7428523926a3e11f755f2327b3207834ec3f4db9db06fa5ddeaa3fbc306eda5ab9df8fe1381647fd41c01bd43aa9e18cbe70be40667d2b070e9e10647fabdff5e5ece1a7a08c94b643b4daef9bd6bc1b389b38463b0504026f52511a3145caa9012ee8158e5124f58fd5bc3594ff68915cdafe1f084401b8176c14d06ba52fba881c6f949b8daf8a4c7c723b4939c7f110ae5430c7d9a9f48135b792be66a5ac64586af1716b1be49a04b023004356aaad268e7a1aa9fa2d5f950fdc13a9cf9019b1769a4fade368bd186ecb2702df3d2aca1e9bbe90437aa8c6fa24379296a18d6e8c300691ad81cbd0906200f378c2c9a7e7ffeea88ea1e832b849d6d7d93473bea2c0e5e387bdfb02c0bd98adaf064f373fba4fb820e6b37d15a2476548f370f16ab9d85d1eb40d2e47196836f6d131a73be5bfb2cb1de8b45d81199a869fc1d70368b28db19e0a45198b053f625f97ac70dae01d0ef2df3101863c681f66ecb44ea5294ded31bba467beb3b1a4db840bef2ae65596b884fca8d1f928e3de5e4a8e17112df9d1618082dd6d970a90fd63e3cd9bcbc949f42215bcd8c6842a833d965c7027b37599dbbaf8c6a5ef77bd72b64c7be51f204afd40b5731a10dc086fde40053e10b03bfad1828957c87b98e57947a6f263bffe97ee196619bf6c5570ca0ef96a7432fad464b04f41fed02b153b822a4e15e703a304d4a853c192a5cd9f49086d8c242bdf664f6117f8243f363617f422e4cac41b508404588fcf55dd3f53708f473790fc8080153304f276a447781f928ca5ae361e6fc5e478c19cc62890cb02344c89c36aa79ddae1180d3344751df846a6e787271a4226c0ee0216d11cdddb299fa004b5efb42ea9edc8b491c8b56fcda3c72a53f4a18d0db02db51001049d8ea4cae70f949ae7cb4f56de81c73954615c59755fb8dc839a1cd251e99513a471a81a8c615d584e2a1518ce7f1027d434f354934913f657740e10dad87abe4f0d4920388fc96364bdcdd751dde6889270b0b17a1deb0bf23a4fa565fe05e267e40450672074b9a983ccb692c632dc4ea40708ce5ba3d3d523c3e994b335c219b02e4c8eba9d2b9d4257186384923562d4b7860a5a41b0d0117bf9e34ce38b45afba5023b4591df2d078efb9723feae491f2039ee6518c4b6ed2ed5138e1760367030d1c0d2100e0a77938f4fc93e947487f1dc5eb306daec8e27f77ce5d1a856d100cc678d93fb07fae46c0be3f0c1bb97b3d9df29d0ad33139e915cf8d4833cace2b58a328af35aa697e56f845f8b57bbf8c4bd72d1aee85c2a6122ee12205c59d9666fdcba1704b835ac9daa0c7e5f2db3f3f1b35cd9fd233242a6232df6473b0fb47bc43256d26c63d0cb09147c9950187cb850de18a55d6d097128ef2dc7cd257f4058ec21c40bc8a2f7223ee898cb9bc8c85688ed89247cc1351974c40070b6f92184ae2c9fdeaafbac779693bcc769c7b2a9567b63e8e81d1dd8681954540c2cfb25b0afa051e7ca7e949ae6cc924a3ad064cca8de2afef36de220fb8c204ef68316bfc0973f66ce09fab6ecc55ee467268df43cc2f8ac001c4282a5ebacf818fee5721cdea37d37156a705edbbdee97284835e977c1f4e4dfe87291f2994a58d0f319a9f42d9a485df188fd3a11eae9f8ded24cb5589d22d84f9a08dbfa1f366d9d90bfabb425df507f8a1cbecd78261f76b720365a40035b17b8e79c405b7727099c5ceee62b95d55acc61132b5c18f38c46779c3d030f80a2871dc907e635aba783b1f59d689b68405e853f26b77828108695cc74f6b0d6f0f2125b8f8ad342dad6fbd59358f740d79a92dbdab088582c7d437ded3a969dad979211eeb396d5790c93e5b367dab7e42f57adb8c303dacf809db96d5de0f07a4fbbd529b880e5a46a8e23868045cbda942f73285895da776e5013b0a2ee3c4f09b06d8fee56db3d22780b190ea2b25ba32f5f906dd21144d08febe872b1ab31a8f040bbbf73fb08b8b91620c49d4ebc1fd9b9ac4d2ef005074a14941d9ff359f2a5fa04f3234614d09fd8de573c639337958a86a0cb2c5c1543f41519358f90d58b268d79ee5c53b31ad62fd6915270fc2366fada49de5efe2913ee56417ebe6dd79044e16f81e7ff602e3923c29015071ecca21eaa90d1040435305ce6c056889cf4ac75665ff7d623fdca389b3167eb3a083af9fa5c3fd55475b5c50fe867217b391c68064e166a08b1e8e86422f1413043cae08ef4c78e9fdb3e6d611d2bf176142dda73c31db91470185381403fc90ab69e1634d0b6f8841f8e99ab502bc198424c83f3c37c3c91462b727eaa2b42acfaf60a07bbf41e279100b4139a146159f8e5d508e321758e835d1c4b7167f58763b5cdbfb2a554872c3d5a0d872b1a68381f5176b94d652ee51dc05c9c4952e76432599522ec4fa5d7ef3f02ef06095e3b6ed1b2129e57cd50afe277cb1029080fcd4ee226701f57128c1ec85fe5d0fd73cbac1096cb44cabf21998761532e2fd7df4896c3a70884380d519a27cc6fa70ce6b0c96a1f20a66af94ebd7887c043ed09bd505fa673bc12a292da920e51aba90444f3dec3224077d6bae0acc94dfeefbac7d2f25d007e61446a38902ec465ee1173d244b2e7b097f06a89311b258a4cf922195e0286765bba9a6a89e934ea6da8182838c6cd17382ddcf0ca608ffe82bcd86338ff7bd7283b494dc1d0372e38d631bead98c58c85b858777b4db0a0f0cc2cf9f54faaf1eea0e9f299908743fc04e3c46102c90395c723fdb0774cd490fb5a66add4751054f2b4168af948097b768e2182e22154b316a121765445dd3af818046fae48d6ac2a6b225d6e159e90489b7ea80a628d7ebe074e893a71ae6e860d91d7f208573e1557819a4335b5eaf417f66cf320482df5e8ccf154b69e954b48c10ef2937f26006d9cb58fa37f6f26bdd86580ecb9efc2032c39a7e6479c84d5679e6ddcb44f2d5a8f508d7a197ff77680a7ed52e444924d70ca361d87da702676216a72f09ef60298af1001cf425b7b4e84fd6c66edaa98c865775834fdc11bd17a6635e764ab78e8c5012ef318e76918ac3d4fe883f9d170039faecfdc4b2bf3d4a1f1b4581edcc0aa13ba30ff95758a89c0d7b7674c0889e8c8e840c811c278956563e9a2bf39fe2b6e178ae7dfba8c3799a705794e8bffce5b866c3786822da91a29b96eeded675a47298d23cbf48cf4ba7f5824e69bbc0269179d1e4eb2a2eaf5858a5a3ee6e733e6627abfed77c6eb4b0f78293059f696ebb4f822931cbbcc31b3315839be8c6e68dbc6ff11c72c9ec8b3a01f58482864d9359f49e9b24a8f6cb6fb6608a4a6e59a960dd7b053bd9906c2a4f60d108fe383b2ae10b8f3ab5bf50df823d9d2ee7f8a1e0f7a87a2f1fc194c9fc385895ba5a063ec2ee894c296f27c7726fe0541d86c44a6164fa828e7ea759e73913baec0206208d20769f76408de25a3cfbe3b39e39cb674d0bd48efed17495d689decb91cd461644038fe39d98dc8daeb1fd2c4078140cf23c97647fa2c356d3795b4e397e5f0186df0df52f1c7b74884b505f5ffc97f0dc88018cd23a241d0a81e3864b84695bf06e6a0ace67a8257860b58ebf5dde8a6e9f717a22b45ad0cf079945ada6ec770f6adf6b837bbe37eba31a089f5b6219e796c93037ef70f0e725a364d18b255800c3814cb9bd38d2e8b4761faa355105d71599e272ef6b35bb9a14bbe69e61fd580c3f164018cf247fc84502fba102ed17d9661486ccdb0749b05807a4d964b789e874c6393acef0740f51bee51f20235e166ebe065bd13b4022395389abc4d21f7c95ee693215965dde0b21f0cb61509ff09db79505fbbf2a7469324cb3a133a603013718cfba1f25c293e6fb9a44126093332fa97f488fd84f8049c4509af864e73ea3b1e03cc659495b978867fa0de5fbb5f9e4364ec93ca717386b8a95407147d86bd4e2d52b016cad925ecd0660e7e1ae3ac58311c30e3598d84bf9e33bbce672c527314775c8231a620f81eb3e6bb82aae216ba7396574a308f73f56f0181ebc9fde4c76a8ec406d6d2e2c8f5ab7564fb89534fde03f785a4f9a0455e0f67872690676a5db365f147310025561dd1f56883fae0cb05ca1d870b41387be67c7a43ad18e87106683476488e6ac3b024ad83c929e498d47f32758b054114c455e9b935bdc05f10a870e638738be401fb03680615a6b7df18d772adbfa6acea352b227d071208b607ad8996b878a7a68cd2504c6abd69b7967d3e28ebedf942c83a2f0464bd9fe054f69f08f3a6580fcbdb3d50bc06225f9bf3c83ca7925acbc03633f5798c7c0da293575e3f6f47c379389f3b89ac59dc06f92cf24f8d0c657ef00f9c083cd8df8d82e8cdb5fc7dc968e297c07b7089599c5e70a9ee0fad07c42f69287ff49926a5bd73a9b9decd2fc8e3df623055800c4fce5bf534e503e12135921ebed42b01cdf3524966b96d2a487e62713dc1467c58f646787ec10cc398aebaf2f474ad2008a7c46548dda8692f2df4371ff7427e7617e1a0f31a804393d64516dd97f73b838026c0b2202eb1b7c3e2a5fbc9fabb8f1538c9754b3b9f9bb0235743a7bce242e042652bd411b854aa966c1ea1c62eafd88eb49a4d6bfc18026fe7ec3221cf04a915f0a5073ce8dc460bb5e04b568097a5e0349a6ce4ddc159ce6d2ea7e6a178736671cce25f8500ff5e636fe1a0b3c4786af5350ac449edff5d3902ad496eb2bc5f836ada94c08a6dc2ec9a85a1da7fb7919dad36c78cd69ba0e86298009fbdf2cc12efd787406eaa9e6ea8094768c69dbac40a29b97ef135f1f6265524a3ef0cd613ff44a71702852371e06ff7c2b1cc7580dd86e86e40587ee9caaf276c5070616fa42530836aba71b371d96b43b1aea41cd969832c00e26a6a98a87cb8676e6dacb70a9bfa4fd30d4f096ce9b2a9e85b76b053ecdd751de41d42fbdbc57f23c9c9e9682d85eaf32b417dc240621392b7b7eb4ada422663fb9cd495c4eb36dba407d8173583eb9a7fdaa7d9d9b291d93dbc372865cba27d7e57b1ad59e2a9ee35a950bb10bd8637556b505ab93109cb4c21d6fba0f921d6920ed666f55ae3a5befc3cfb49fbc5a709430765620dfc548752f22397d7de1606011a3ee899e56a06aea67f39309cd8aa87e8808eebb2ba4774aa5731d3b13fa27546d5b387f3b5716b765ca59cd6f9b1db212034f407633d74294da11da335a332fcb1d66a23b95aed2d5ff52b47d69205d805539474a2176597924ea8a188af787f1aca569462f6b0afe3504fff29e4caca9acf817904e46d95b7be95fecb5450dda0119288056ffc6af9e969360e686258e3f419b2ebb8cecc2269c3ee05a233274d3eec559a1a58bcf4df424697dac30c43c4cc3e4fa715ce22d72520207766fba550e8c9e15021c2a383bc10b8edf0362e8e36bcb0aad90b17c05b22765534a4ed7b03f4252f65fa68cedb8012adb78a3a793327311bc817c2300772f675b260e0cf5397086c3597ddfdd5dabbfe6f21289f8adc69a877b4d0242ab81120235f75e1dfcdf876868bb00e9059ebd1ded91c1266a5a158e3fcd36442664d249d3259149f674c2824c148edce2897929a44a7e3683e403c3af77cbfcfceb78bc693360ac9e8959d35fbdef40691036acfacabac9642dd9a676e3ac3018493d7744737bcdbd98b051dbd304e20c97796aae5d895749d908430ff8ea1607de773c501b452140dc51d32aeac64ef3ceed5c43b04dfefa9b83a41c828df9cb5528946915571556c838b11a858556cc8f31a5f9f0c14622bfc55f60aadcf2eb7c844cc16d6282446ea7057ed1c3e76db09b5fb38f1b897cb5703c5451e473ece47029cd9ada67320be556e07fd14f89cc27576a32f4ba8639b68e7d003c0dd32a204bddd299219f20f9aeef315c526329ecc4f93eb430653b0b1807a9b9998a518c4086c1177ad959421c1e71560a23f9cb6e842d6b00984bbef2c4361","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
