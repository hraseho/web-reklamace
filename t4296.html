<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ebef8f5c3dfd64eed6914a3322ba916c56fabd46099e5982cbd5bf1640c859d3a572bceaa8ada5c52c47d9e866d17984b31798485da9cdc30c15a919db1b9cd1657b9b369d1c808551b670b17436b62d2c3fcb1e86ca4c12cdd59d3ba4a784f71c6d4da4499ebec39635c310c7302ecc5104a3c64617b884b2bb73c107612b757404c4b1653554999e0dbab32a110384f763b69774a985efff8ef0ae7e940e5e603621a6cfcfd047b95ac09fe0418b66ce6c32cdcd7368726ae41969b1357498bd4beae9858695721c924c65bd84af71a4de0638db72640a82a9f3a1f7995f3e36e39bec93efffa430f8048a3b5b7393d41c6602ac8a0287661e3a3124cc9e25ad4214f94d4c4748a0c7f82e83cab6ae4eb523f5288c558ee8a0200ae41320b57a6c0994a21f6201e13a37d7e974eb1da32a4c6db4f70d347d8ce8b69fbc566c4aab980127d0ec55551279a487f68f5bf5402266ae29754c9b146d7c22cc9b23065d49086d4b08f466014a70f374b90da3bccab20feb4fb10238fa7b5775ca1024793fe2ab3c3c305065a6c05847ad38ccd9d6fc0a4ae8202cf39ba7333cd4eda8db41f38fdaede5a7e9914add7ba85427854978617615b77b4d849a67c89ece1a126ff91f33df36736258c4eab2d4f312a57e60d06542758b768c67bf0c320aa4c63f03f425173e0069d8aff09124dcb674e1497eb2f29a7bf2e8673efb9c7cd723db41df2c254d1787c084df2769c0d236d1d90cd7f10c81af5cddb3fcc1fdd7b83ed1da907f31910890c1f24ca4266e0fdc4a4be8e8903e561966123ac45a250e6713180c082d8dcfd3adea2269525fbad11a277a45be053a36db7fbed1cb76f4bdc5e50c23a2154d51fbfb2e00cb8c5557a86996abdfbc2c3d3e5036b171d0b7f291a719f3839daf5f4bd2f26feea770b59e78186969a1877ff9c609c5d51493799bbf0268f716e5b3ec2d8a1f7e74a7696cea23db921769c43b8d80d69d0301523af7c5ce413af9178ec5959346a65fee76e9a2ed28f86a120ca638dc389af06b984cd21e4e14ff208daeb3fa65456364fc4de9922bd9521127a8dfdedb227738e96489614d8bfbb1dbca864355724e9e1fb801f5e82cfc5835b39fd92f82140e730c36c77b160a48cecc4c5dd4df7947105a242ae585279dcc487bf80a160b8bcbd38e369aa4099f6b251ec6f9dcd061762071e2e9d571022dab16bd750ba036c0db2bb2939ea5a94a164014132f3280e6b82ab55d6fe869173f5b11349f674d8c1b4a57122d41056aea2c026991967352f5025f43810df4c8038caab9a87efe4dad733fd768daf961d6a99f8d21d7da603626ff3a6d79f54a49cb62b2e23c1d40cc0305a7b2d54cf2210eb1714e247e018e132160eebf05f16eaf1ccb89e1adb4054af3c82430cd34d11f1223c04241789ae8367b2fcca80d9d05392874f185d3b7714254f7732ed5bb9f228d24da73c0fbd09a12cd064905b54d950de8cb25dfb410c24412a41c4f1f2d8343825c52721c5c1aa2639d0004d2d28ca19c41fa3a33eb9f1e978488bb4858ee3a55c4beb57921e0dcde05263f6bb03b63222093b330af1faeaaf8132356b2d545b881073ace44ab07cc193fa39d1baf3df13b674a1331a546435bc0f3c8d39bab42924b1704124ea871a16531d87a6d2b1b46455cc59761f523e901138669bfcbae1fc21135c71be6acaf639b466d32ab71762bad697551515b00c6454c91429c442772b6b1dd24fe6ab22127e4e1deaed2f919e44cdd3c90fab9f2d06ddb4f1f054b257963bf582473e8017e603233cc8de9037760615475bcddd83c5fd9712a899417cdfdc32b3639af84eb8d67254b06bedce07c6591f2cba71ba0cbe2c5d860faff4e8f2b73f8d06dc55cc67bd87622d6a109984c6cf539682cb6a545fc87bb4a24d7127d636f8aa6740cfa102bb76a100f7b876f6655b9ff7ce3c6ff5ce8756244ceea1bc5ab25cd1a8ad33f2dce413c077cd44cea0b3f93aeb20a2c5119bd0a427517400b58032a020fd9454758838069efacd053c3bffa738b166abab583d8b631887e52c94d4fc3d1f7efd2e108b0fd61542bd5d6cb113d97dd66c7c7b2b19177bb168cc3d38e32224e9ad720b2c4b0b4b1a3ef8ff1d03375798b111329aaf1dc62e558c61d6835d7c2a6bb0048434a3badbc18f1ce8de988b7be455963af497ade6048a0ca1718bf4e7a11c79604cba63f3a12dfdfc4ad96a1b3d6f60b6e5060e44d8fbff9531d8f76cc1da71e6428bda5605ec0e052c5cfca64948e7b293d27b4370b9e7e0465928d67279f404cf53a28c78ba15f514ce657052657ba1aefb16c9cb90fafc813d9c6bd2bdb06d3a51043ced7338da737a3df9998725b1e7252f8ba06ba531f54442a9c8507c30c28923d138edfe38c423c2547f55ee23fa6d84ae6c04821e9b0b35418dae55d1f3c830710e0041d713895a4c79553068cf4cfaabda39c05eb699e883bca08dde84462a2043948f44a030a5d59a6e8d0fe24435038ec466d51d4726e00e2e64dc408cb92162f72e38cde339029f2e23a204da72670b5f1d7f3b0877eb693414304fd85fa1ac030b6892c08d615b9ee6fe32f49d3d385cd01bbdf18bee02b70cc6203b0f947362187e0b94319a82988bd1a1ce234010510533896b013c5c28cf9f1135cf011840cd785228ea3ea8fcd935384a3ae76a173c333beaa63c1cb86e4d98186fc540b92a6c4b79cc32c69e2bf8409b121fe71cc3e66c91f19fc1fde594f7b7f99bc26c1b0746d1f1aaca0119b471856c53eaed4da590dc0ce5650e729a990b09f725cbdf01e3cc0917ebbc19c725dca68f93e87a1897c1433adca816b8f0d10a964a7002dc925dbeb0caf2fdf185bdf4296c20987e14d908717a31dd05121be9c240a65aa9bda83b4958b5db2b5cd1765488712880740d9ee2d046d3dc0b3b311c6d3940f5bd3eaa82573865166415091ba9e611b4bb8c973a32e2351e8e53443cd14aa7d44dd6c715d1a8597f618a501a8f9cb57e28a021f7c3b1cff3cba6b0d631f01f8be69547cf56c6b4cc73e9074d2d7c9edbc5f97c91b8ed16f7103126b504b794ed6848eeab3063e870aa2812b835679eaee156f65683b809ae46c1aade359bcbc2e71d89f38f7db0b644e907d01290ccaedffae4a6f1a135f8ab53301db254e6327832535c9ec0d1ddedd7668ba5f1c5dd1a640354662aabf7e0b8e7ce2f9c792a1cfc860f73918e022d395a29c461a77e781a54c69ee66a537d7649bee148b03220f251b3a18d46a2033bdbf4ca5a89ee600f4a5acd074cc0d7998db253cc43dc17ab8d36d8bd8ab7defcf1c67bb98dd091ae87389c84bff049dec517f96cd00c1d9d8d1baf0467e7390213a3f11c5e5d9195b673f656af04e90a8fabedb7d15dbd8d059cce79a42b79b0af0d509a85692578529b30933dbbd1e995950d09bea91899e24cd8bdf4883825ef29d32a32cbb6ecbb95c57a351e2a4ede17cee2b7d593ec3c562df2bc5e296969647c66c4884f7627079d5fd5abacc20f87e772f06e2e5a21647e49c16347e171185ed30595d30fdd742d8f81ea1175a8324f3f71dbca793e2db33a08853d3b19b24b1afca8dc0c8917d4e7b7c7b4c677cadffa62d189a364d90e92210eccde4735526126149fee7487d02ae194a1d372b2815c0a0bc1018424552aba9520908d0665474774df76481ed1613363cc1d4569c123ab8c53846237425f45fa62408925ffd863f51d4181ccf79d22261df62bddd863ec09bda65cce1c622c5681d176e1e484ce726c9321c7b28ebf75536c9816b22b3b92145b99dcc11fccf7c1be4bbd10fef41c8871c198ea2d72803d043d85386834d21d34a93ff86a8545628a46ac7815a155ed5c519a073d8c4182f1f28e502844b85c3d604bf23d229674a9bcd89a82d30dbbd7bb2ecd9e32ebd61fea5e7e21886a40d6d58f3d796699210e0fe94e262c1aa6c35674d60b96b8298d09e09133eb371ceb7052cb2e4e7612733ab78a541a8792b554279da903f9c314de101ba9db5ed3afda4f426384edec78fe73a1044ff8f1883736651ea7eab3190c2d900c9fd301067278dfedb2d86ac6c933a400201e8e4da3192f92f622ea7257c4c85ccf0c61913713e10f945af16b98f2092237cbe76e1255457f5882d3d0da0f54a592b964b4fac59cf154971b62d4706bd80599bbbf0cb4f3d15dc3c135e2020e7ee19003ac8ab04bedaead704ce9395afd0919addf21a8ccf4b977433eba0de7ff7a15aa9afbdd625da693217ee0a0f458421fc173367a19c4611248e1dba3f991eecdd11185404e28923d5771b6aa099e0d38780948f437f7c715881805686057e3f5f6d104310325bb140dcbbaf3c10e9293fa3215a631a19f515161fbf1203efc6a9af41b300034c58453b74af5c6afa0640372feb866c9ba655d3d50e3dbf9bf2bbc7968922e189c2393529fb84edc0d0865414d500ef06194e7d91e5aa2af891fa00d5b549cf8d3e3c90364f49d57620c2d6e91299c16c22adb40c36ca2ab01dc30b36ac4391cce5e9781c4cb07e602db49797fb7af9ab9df0c85b3b8188b62857186746eba3aa7618662420e982503748e57cdff417abb7e2350e399d8d8228c5515599f93c523b949b81b34a6a5f1a3e74e069ff47cddd2b02136d3bf6b90acb46fbf6cc8ea09a4580e83908f5689d75c93aceb3dec758cb87e6681024413e7e928c894c93d9513cb9beea5770c445c2e69329112e7f9d1551a9eacae9c8e9c6b689540edd91144f21c6d5a29b007ae856e66688db92791256e42bd338c01906a2ef4677e2c5b524598b377b3138486c34207a2f01d5ab294788eca485cc69d6fec44b47c9adb5c0d133ab6caf6d9221011c272bb967a994965d6b34d1348a49400c1c8cb751d2b24568ed25cef647158218ab070a0bc1cce5fed8f594dede7e9e7cde4c5f2bdeabba8f182b648e79b5fca4df4427c4722197e31e7e9271da706e70f3acb2d3c145c612a32c52dfd1ebb1dc452f2ed7184c454ed86408a0d5d40b4c46b2c0d90e2a154a8777885289980054d85e04ab24ee887a4c55e7a7f53f3f1cb8b21f588fd5862591b53a60517c3cc6161fd8e30a27abf42840d84c1397e2c2ccc1a44e2821deccdbbf58fd5e2c36cdb9672dd71832712c13fed2e0892f9ab5d926e35fe4d4ee9d4cb2dade6ed6c38c072b0ea5456695e29166cbcd3db56b8af6b47de4a2ee959aa52751f8cf3215bc7281fbab91eb8ef47339d35ab5f472cee0fd5d043a04ab8e076730f6ef90628bb3a51a36df3feefbcce22ffbc0bf1293ee15a64c66fac2e5ffbab9c4f503290c3b194496c3bd2ab00588a7b9fb0094a23793a05f6af746c97943148b23cecc23eb8849f28f00c464a4e1c5e39e13822d6dc03aac1739250ba9fb98eaf7bb78566c44bfb2e19cc44b8fd803581670a0996e7b7866d3906e70256080c60caf703a75d2f9c7fa80ac0aa62f7b2a3558372dfc763452490a7475701c2091fa4f31f7ff5b93e3e76294dcfc53e58a05437d0b17783a469157e6a35054f5fd0d17554ca0bee15455c3f5a6e9e88339da3b809c6c8d3ad41d7f322a2c9e966a25b2ffc75a2da102999c3a57f00a06822d7add73876b05860a99ed4a6e09541f5e4807700467d20c4e1a141eabe0b511a7064e94caf3c6e950c79b245e7552247e77cfc17cdb1a068e17492f83ab7ac3aa51a6eb515ce983262d8baa561fa7f2a43d71f84a9b90aa0fbf8e4eac00cb12a117b5b643d8a0ecf6f44d40bf1590ec2eeb12425d39f0375fd7cc018fa330f5678226305c552960f46924a5a65d0bcea71cb9f19ad2030675a3abdd0260ca38ea6555e74251c2cbcaaa181b20bff6e5a89966720cf335e4a013e431bded581b3adf001f9635c43d80ca89c60d7989e2bd714c0d2494fc54091b86122b54d198d08375c8bdf149f533d3524fd9e8186703ac2902624cb04bfaf28f5c2a2cce795b500f6a0027c30fa5cf25e7ec3d6e51cbf8f5da5d6c76e470b37f0f8fad446dc42cfcb0e479009539de672daf694afd17aa9c67c9c9d85c0e27b26f96128dcf95223bdbdb45e1a1406723aa1ac7a4f591f866508dde6f26a717155992a04f9366a4cdea4d91654531392d762366545668c3694a4bd79a604c4bfb428341c888e2ac33ee105bf0fdd2b49da73caadd67c5b6fbc209fffd31b063b55f9764bea9c1ebf9faf050c8b920328101d874e80fdc7df7d9ca928502a3e75a7b59f4bb5c19d51e1b122cb876c01b464707f530c3eea7b1e4712144ee207fde602d87307d1d6db5ff8e4d6d59c6573ce4ea4ebdb21e9eb6a6f58f23d66c54e197567168992ed150818316095dae8e474a7272c88b250e2bc31af739d006c8616815fe34b380487c6a7502520f1c8e4b2887c4d7a5958f2129f74e91e65bb29f2ab321bb8be1dc0aea13915a0fff7a9d167929e67405e4a525061625c7856551f368f3634fa1bfe6a098893b1e72e7f2761557d4d083bbc20539ee1ed1d8a47e4f9d65224e8c0c025fd6e02793d2a650a2c72a1464727c645cdcd6e9273bfe9bb94047ec6cc5ba8c1c590f5cc867707f944cd191147693a9c739adb12dbed05ef29577e7c9995350fea663c4f87067c8bd5366cbaaa439f998bc4910184d4a2aeb5d93b807bfd88b9b734c90cac1022c64b83cb5088c833d4b841a84a67e3fa6ea366e936278e7439335fc4504a7c17f1f0125c8c759e89de0bb92cadff38b04f8a58748975f3102e320cc952c2728e15e3feb808121e9bb1b773be30c6b573f0e871593571d76d948aeb6f66d4a1d6427b26ae39b7ccdff69e51fab41401e87561902069793230b5274dd85128739cf0f8775890c55879983de064d1999c451413fb5973f3c10b3597163759da2c7a0ef5afc407d0b899078970a40a2018f0552f5d2641e00ba0d4e04acb32a55620d5d1804817a31136a720bf5cfb9bc6622cd2e145af61b93b43733f8aaf5812ed7fc72a3a41ee93b2d31813a94c4885b5b45ccf70a00e61cf73d4bef624fbb219055d82f933142b3d8856e22e47ca25e6852c7661463f9cf577d0d511ca5b84b02434e48debceefe144d678ed093559387d530837c1d60d85450e68051435e0ab257f860576c26bd8ff63a1845a913a1b54f8b2b5bceab5fc19735a5b3302bfec40ee138fa760116df66fad90b328dcae102e3bae1a2f2244ee4df75428beca04ee2157e9ec4cb74ad97142e5973b1d913a813b092dda9c48d7c3955091efebfdefe12daabd8f5bd3bd8c8346086236f805711bf63e523d836eba9a1d5c38b0ffb32f8e508c610ff50aad9d6f36721ad41c1d898284b9454c01bace86e8ea2e3a6b31b143ca280bf9025d20d4ed313e216a6ea86768ffc3eb18f9650c1a203b5b711a52e3d5f14f92c7fbac8f13187704aa629a9a6a6b157c44d9d9b2ae06b3e69f6eb793ae2f3c7430934921f6f7fa622955f93eee12ab101959d863256dfbba6eddb58f878965d54a6205a706514b32e6c557a99418596a999f108e718bee4a5bd45e6db28076a346134752b68442482851b21f957e4729659027ae18567e18fed86912a2d2648a0da19fc39d4a26e81047a2b07127481b6a134fa4a6961bce880d8dcbd0374356953a920e1cde1088ba4e326fce3a58694c778d2dac8170e44876557f16524271d9aec465073ce9de5bb0cd223cdf569daaa1a6356ed6a3000c6978f00bfd227fa692f630b51957ff421223d20a30e9d35435491857a508647ed7d4c12e767aa7684971a5ac4dada53fafb3a2845645dc98dc877b59c2e03af6f43bef1e317af824b02531cd8a1504dbcefa2153edc8b32eeaed8c66c24711bc8f31c09f2bea3d533b6c986741bfbdc383f56097824e7d222ef68785f7944afea9ccc2c2d3d85961bfe7e7aa37324d4f631962c0cd4b4e212056043f9ac05e579df31ee8c26a2378b55810ea14ed7df7b5d0e2e77a0d53d7d7d08100119fbbf95826aa41ebd6ff0ea2c8f303a160bbdb95cd8d0c2bae73353090a2c188e2aa90ebec91e2435bb0d76002d7bf563bfcbc92a4e993c28297e956cdbde45cc4a5fc618333945a11836ca1882d918cbb7b0e884c09216ec41cf57a8e609ac66d2292fe1ee544e80d67f9a79e05716083b6efa2f7af8cccc7f445a9889148e55f698a8a35b19aa6c63b46d4cd0dc6493ea0d3c4f5f663fc8e5047dceb3542684aa79d2396486039576ec910475c2ad3bcb863bae2ba3fa80fd5efc3ad08d73e3129c92425f31f251a871cc250f582212b62a874a0e0545447a4724b7481d29f5ec5cb0cc1a6b7588ee0bdeb2320a5c90d53f392cbaf389597bf9905fb8b2eeffd7da25ac1a7361e30cb4f78b7467876782ab4bee280f1df9704abe6c31199082cc895b05e019d9f135289efb7f10bf99dc3209a68d640c799f4830c9d07b2b4e1202ff80be5c9bf79a835bd42c459c2f0cfe1016a4961a9d856e3a949d989c3ed52b39ce263b6f392d5bfdb7d4a8b0aec692851961ba6d2db484e42cd4ec9efa32115a9f1a76536fb8d515eabf3e2083aceb7abb717743e40359d653e718f1ca901c0b2f37967d20e27855c07fe6467f85464809cce904349ceb1249642dc23b318ac4d27d7d3998100f83f75961656d8735935d380d759ec0d58928ed0bdba05cd1a2e9d0b0557c17249fa1cce744bad374abc8237c0c46e16faa9fc967e74a9cee1b031ea86053d0665d18fd936ba1ce802db0c08c6e4d49f70ea60685d5e273d18b3528a3ef6d3c486d07fc23857cde6a9ab152a54e971c28bc9134cac82264a6f8a3084fcbae9affb7f6ed922b0394171ea8baaf8d42cb4cc13817d4d9e528c872663d732d1539afd006342dcdd0b8b3d556b465b0afdb1abfabec7640c02cfdf97e9907762b439d25c94b70bda4de3e54d10e5029c429e2556ce674fd59761b0946ee3a158e9f3661fce95fb586b58cba8f1e8300c236a25ebedc69f918a3894d462e828d8688d92046929605df5789e9df57efbc637a564ca4a37e0d613e58c8d27d721d81d72b71b6a1a9884a260114c0af12c0deaad5421f28d316f44b526df5f75d90e87c420ee98564ba3776a0805afea69ad7cab1173a1d63f4a32225549dcc873b8f3f91472a499f90602aaa92f078619676bd8a218f7e911b60e5700a5b1bb749bb13ffa03de384d184ac00c10490a926548d8a3c69a74c1b42989fd83fc364c1580080733f8aedbd1b24d95fa5aa968830f30d49de5d730f71817ec2e43ce616a442f926e8f4fafc936b40808f9103e76670103405c44d981facde71e6c429ad0c2c7ab151d6f8800c4e4aabc725b24e6a83bba612d24d518bed850d0fbf3ec72ac378615a479a2dba9a0e7e7d967aa5f61ecf3176f48c6a9d668676942a9d93a46ad530a8f54d91c70385f5b1574763aa2af2f430e87e968622387dafee73f6ee7ce618e1e55d376b620095fec1b7496429ddd93caea792e07605ee9f3e2bfd2a5074846828c70a218a19b43eca4ca7da9cebeb33917576f668fabd64761b62ba1f28d3af9d11ca06d833a20f9c3affe737f2c760669b19e8bfb1bce640a02a783bae1e4dfd9d9d17976c649c6bcc58cd65cdd0a5627f78b6ce23e342aa7d01924571b57bbda2c1147efec45a3bde175f60cccec6c7a9e64c0fe76e9ce327149030e2eac56127c1ee12b8e1889c6190e41ad9c9ff9724c62ea543bccfff6afb115f4f820913b22c50f9b6c052e82f6fc3f58d62d0ffd802da529724f5e233a516b0a92274d50533ae0ff66c1d0f36a344d02de7614521f68dcfc1133cfaced87d17474c1bbec3821c3bc35d41e3dd4e453d36b2a51720fefa7f1277ff892c9f9db408f551ecd9b2660311475d4a8e1d9d618abc0014f7b1fb8138d5e04cd2d0ad28c43d999f0fa93e3a1df8843694bd0bafc9e09eda5ab911e349ccd4b85f630d394889b6ac03de055311b0190f08ec9ec0062c6556132ea7964afbf1fc221978f04444aab300a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
