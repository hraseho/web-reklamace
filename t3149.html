<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f7bb06b30ff2bb73424da53f76c4a25d9dab07b38eea15e117d7efc2a7df728821935da5b98aa7145fbb3611d7d9b30a7ae93d7e63010ca0dab1b875cd2e7f104b7f0dc06ca778d7f327fb4fac26c346e7aa43209ff31d2cf69d3768372677e7c84f1ee08a807a8462d1dafe1afa3f42adc91ecddae35ec10d9b7b8eaef39f27768ba379e80b0b6b352e653ef032107938e62427c5051d852f206b2e26a55b3d86a80cc9e296319cbde7e08ca1f0126460ab9c9bfc2a0b90d4a26405ef5fa2c643e112af7137a9627d0245f59050b348e2282571cd489cdf2143578167bf38fe5c9c1f1e751beb984730364c20ce5f045641e70c83ccbe99017ce2739241c9850ccfe3140555dd21a14c05aeedb50cf7973b50bdeb8f5ab9be8f368c5c352937bf11865794267f75518a1ad753cda7921ec3e295b3d75d594c82ada01d602ff86aec32007f47d2c02c57ac39fdac0fcac802ed925b961347270b5f4f4a70bd9c9a7cd2b3a0848f6c78c8c9911d7cd2b5fd36d29851f0e46b7e4e9a645f256e83481749cbbe16636f18447458a74e7647fba7361522897e077c791b6f2fee7d2ebe88607a6906e6a6d05bcf42fdf0522fb12380dbb30ceace84c4b2c9a9b640417ed9b5653a27eca63e40ebfeb21362958ee80e6146c8f24939513d72363946d392fe8f4e32de4b036f7abecf484f3415aef9cd911447090bc4b1ea2faccc148197b515524e275f7f81a421456015f7b06773d828a7e228daf489b072f1434945bb560849c5c2b36192b50d2219e4320ef18dccd8e9ba998fb021601db70aef5952a6596d12db9b3c3c8fc5e1923692402efda17b4350ce4055b53998faa860c329268f2cdcae73c4c065c2323eb10cb98187dc4904d984d6fc2a4738a72073d870b3f4486cd4137df159ff5b23665c0c1b2456c1c7d041d775bf1107bf89fd956b29f0fb0415627812bb7821f2f09cfa3bd39b1c5057f6b1c91784831003ca45013a27cb9ccf4ca1e00ba0433b9657c6db78f6fedc92406c59242f9b85753e7c0073b9d864a2f92a29534c0588a9954863724696a1fa30e3d098d22f1c2ed47d1dfb060d3822198584dbbb994aa5678003d45f919804a436e2beff5b005b5ee35aceff8d3c9a5d61d06e0379646a3ed6d89d56c6140e4704b8153b2de0151e95370de0238e24020474b4a36fe16f8b2cba75f7d0ee1db08800f695da333d41059c1ac9553adfb699dcc2291c60eee2657c7230022352c887c9bbf8b5405b2554311dd5f710971980edd55ed45e2258e848f5db352771c9cc32d03cd2bd1900dd383e41de2eded1649e2f4e7606a7e39b8bc37203ecd10df09662841183afab653fdf79af813509f2e50cc7ca3c166634d4b0ff2011ba8b4f4c600722db9d029a2a989d086a2315bc2339c5305c505daf308804a957083fec28c448fbde02ff35512af5749cbe963df6aa00f4e7c1f49fa752d8920a17ee1fa4e47bc750b19d6eee83246bc03c80aa5493ff861844582a1b69992daccc0b3b5892a177b97141a94106e027c55d922154f61ae9faad31eda6e98dffd68aa44375c3582cc207cbe10919fa52294880507eba45970ae97b6465bad62315b805e0ad3741c6ee4721d2d54a089afd3c9373d01ec9a04308a71e95346b9c9eb9ca6e94973fc3cef5d72eed059bbc21e27bf920f2eca344c112379713ea480d430122c73dedde1fcde2909590481b8912ac59a0a9d3edf0e73e3c124d10205e7584d110226977572f346b6bdbc8ff87cfb6a985c6550f2ec02a9439cc415b26cccf7f8d4f61595b7574f15b9b72154d1aabbed536f800a9f37e20ca96380b6894757ac587e1153cc74161773e7ed63d3c5bb835419d004022f95821eaf5f7b6bbdcd0b890737b778581681ba698528da7839b815710221f10b8a39a7a8239149e9b885805affa916083ed06dcd579b86843cecaf2622bc5b895b9f84431979f686f915cc47b0b21f114a2198dd7d609bc2c69e6b0bab925879638023801d1ff0672b05ede30ac05ba372c308b9ac562fa0cdfca9bbb8b82f2312026ea9270a971adbc7b1137ea122bc931366af4e0b41f5239e91fcaebf10873b4699d6d13dd27e943950618dfca5c69e1ebfccad2c333be3f470f4954cf6e68afe9df36ac9b0f4019f6556ef84a31214f80cc4a3ecd33227d5c5d6c814d2c17a08ab0d6d413c16b2fb16d1d4fcfbc3d157a713ad0109bbd73eb2da574db1c2045011c64ee852cc9aad0ab503e4b6060515a78da5f3a7e5def2c3b0caa68ea21c22239798b6372eb2df92a3fd698eae0e0dadc6ec9fee9e0cdf0faf3eb710107da12750e8c94a2e78d478227e625bc4a42704ed5e224a0c7c6a32b319c3c41042c715e7abf419a2c3916fcdbf5cc10e5564defd299730d18f4cee98d63d9737b531f8b62a28dee815f4b5dcf0326921f47fc4c9a87c990e75b7ad969244777cc45079ca544297f5dd61dc326bbbd752377cbb546278c84109595a861a2e947716037f4ab939bab5cade7f0441534b33121970fcc362b5076cbfa20b379fd0b3551f88f4f5746161b79f948e6d383515c21bcb33d4347b2f8f7f6abb4700cbaf9b295d5d9f5511e3e5404ba5cbf3f97a909f036b62e7104e17a0ece77e3dad2e68e02222976e05a478088f4f4e0fab0214dc0e7fd3a8fb1a654b3730f6facee4200b26e034f25a3a7d6e7ad7c18a104e2fd3417c99277ceea60db0b892943e6087ef774b4cb5f420f4dc211fe6bd3764a6678aed107721943e5dbc0d382da28a2f05078a150becf3b1e5aec13a5b93aacee1f98a2580a63d9e5dcf4dc5b1eb291621b94ecbc42e5f194a908dae255e9dc533b176afa2bb0fa792c2b0ac60dc3c60141b8df764d7927e4bcba557450cf55684b2761eaaa41aae8f08248842c6318227139444b4711341de2a8cc1507c59db87c62790cc5150e3b3014a7764a5ab89454086e345e014b6ce9c98a188b60ae1aed90d82f74c500b2b4448bfac8534d55fbdcc1985ebb24a65120b0dbc4c2558d040b3ff4c0d1bab6720cee68c7094a837ada818b0c25c2ed2b401302bf3b49b6fb4445cb3949f1aae0ac643b932c9be66040b1e3b7a80ca6fc2dd2f785bc03b9ebb56f8e047a4113e7d900d16315d8a5b393cd41392740c42572aeeb692dd3280f2b7f9d1a2a047cd58dcbc8876f858f7814b12dbc7e345b64f0532658054b118aa33f38e0e25b3f026dff2610c2893ecc0a1012d3b21ea6f4ee52124b07eecb44ed49b6be29de95dc10c20a6940030d80a60c832a0d9f94615878f709b6e232a1364d78e176e31f07369cecbebfa0744310bc4c0e774c4a439560055d9931b500bce1525b64421fdf5542191ec0174d62d23c65848024d12c5e17692f38a8f28dbfa8fc8766e384373bea73f339b67a69ab2a987bfb05f5b84064cfb0478992d8550a7d311ddc987e7fdfec37d1706d4935e65532c2400255c1ff87ea0bca55856a2aa1137029a81b70a66da9493be56456b2bf18df40c150261ccd67c7e83ff9431150fae852b5d7479e1576d63a452b116219916d54019d2da9b8da99d9f65911977d93060253d99d0773be4391c2a6cb6e01fce4bc3c86d8ff7ce52970804888ff99593cab4ef655055d0f538d1f5a9d86754ab8c712a5df4a459bb40ecc7ac5a7c6149b75e554dfec1f4f4c955f32f53149eb01397c30a79f8db2040b8e10d96a30a3d42f5cdff74e364a76763014ed4fed47111a5717bb6c4cf8c20e5ce8db7a604d50353189d08640f661aa8dc78bff7d1ffde0c3ac910348ea14c320f3b5ba06338cb65c15e3a050eb67e00ca86363ceb45c66d5a7cf2b00551b108fe412312cf25fbaecbde7a030b6f8c986f6a82984bb7e3b5c371d067ca43b76802eaafe1ffc0c40937f8f3df36f98a171dfe46a6241bd2b06159cedd0ecf5e4dae4f079748e86c37c3c911a2fa9b688a7fc54a077eadba82d86fee83130724859374fa1888ff0d3a147671f156cf7ddc004600567daa28e99d0dc65c4a25c0e55e12ca8e03a165e59321f3ebc2e9e1c611d5146201d1244bdcbac2e86cadeba8e555366f040fea49413b7938d5b274f058401f08df85d8d5c632a781235ece1cccbf2c193fe92d6e1588c293d4dd1c5fc6ce839eafc508ca6bf57669ca70965e9dde3dc2d3cc13cefeef430772662a12281b4583b67db20f416851aed582cb309f0ef5ea8ba9a48b50d8e312109d2ca5877827b182b0a1476e6a68d16866818410b5344ba4c536ff252e9b4e6da7244e650965769e35035bc6394fc437cfc2f95af847171bf2876354e2bef8b8f1c56795be0e6b9b5f859086d42391ad136c8002e3aaa5628502e2948429417313f0d0d35f729dcbbf19426baf9b2880b6aee4b380ede8c4616a98a5a8ea3f67754776346fb3e27ab00725ffde5f532ff18244a2bf30e45b8d7588fdc2ea7ee91508f36e84cb121ccc929091ec02819972db87a53720c169b759e5e975697788793be912c5e69ab525346af4c24576f6ad456557b2a78bcc2bc7908f3ac23379eeeb6cd6ce408a87569300e60bb1dcec6257642413d0013b274ce653656d602029b46c65f195bcdbb10634234bf17536cee93c0ecfcf868dc18d8a93e9dc8e7fc3f2f38a2d8bb1c3f254f4e28cffe200a5452e29e9c6fa5563afa3db4c3d1aefaffd8cd52933a04589d4fe880def6f782d44c75e6e524e400ef21c249091560940a513105dda6235f18b132f859c0a2bcfbca102578e01d2de6156504a06fcb4610046891edd657384e8831742b7257e292cd6a0513c14f40a38f530867e75b3c8c042e5013ef7a4176bc00b6281d723c54c8dc54bb680d20e0424c1cd6cf00cf3c64a41131e6cb453a1c67329e056250d48006b9756d57b4b7bd57a75b0ef82db3bc3045757572a12300ee0691ad4ad1afba0835b528b4797b1b27edf061d4cdc0e263cd735233548d4f7dc1d0ebb03af636c3946e009fa6e678417098dee085d75cd6b16998c307ada8b5f37ce7eaed29d8fdd819a23866620bd3d7ed512644aa13811726cb5af4ac841892ef381c1182d5c2542b9fc9c3de87866cf137e7238083b94efc03a2e55f81659cc78ce890e65fecd344e3579a341cabb0920b1e4b9abf0735f5b09b2ceb47960811e77377cff4f00adbc2bb12cc89c7e89a06d517707477b226b54ac05a6b06b2c0c9506b0609a742b114808d348cdfbca30ce412996f05ab28b4c405e8f517e7082e1b388c4b0f7636bb41d7e128a97f00f6c9fca012365f5735bbb41eaa36d893e75819c9fa61879bc418e3937382a353946cf1adf03f741be5c3d888270e71512d18e8d3bf4e258ead103aeec6e2418ae8e4fc2c1f71d0b05f3a69b3515e7a50ce7f7b437cf30e302590b5f9bd91ea9103327f23ee9c91ad04743daf874703add987eee396c76332d5cb071d183cb48cc4d651d3d9c063d6c235cdeceb40260c083ad30b324b2ef5ab7a841cfd1738a1c23ad14d9a5c49a11c785baee6a2bdec668fd6353eca9b636618015e16145c73d20153a6918a16c907cec850ba97e9943978fb884906579910ad47fda9060181261e385ad9f76b18171f5f00902a126d680bd388f6772746133252b2c0f19e429e279d747899d1da60c3d82e821d20bdf26618a15470322310109a3a981503a3e2c9321ba44f4641c98172a1a872c55842e6283c9cc9da772a9f3b27437807701d437a9912f91f16c42e11ea8d912d9b6d56daccbcbac40ac8a5c30f8cc2d0dad5766441f07d3ef45688200af8f987bd23266f4f730e91feb3e93f237e25d651dfa7194797b3c5802655e6e14ea2d43876ce9c682a1e86dab11960b857a5450dd88616d4e80f8791fcad02b441afcc86895dc39aa932cc97949a126232e9d8d1395476dae68fa8571c3828c5a2aca7b21273ae830d8397c5cb030f489611bd6556e69798d49ec60b8293fb11bd24a90a1cce6400017b89d29b24ca30ddc459e33653556ccc1d5ccf7adf3b06535e4b8186b18ca011f63507daa77d07e72986eea59f4260147781ede77ce7696aeed1681ea08a675ac7a32179fa009df0e4a3dc92f2ce409892aaf75d54367fc1c9710b9ef0b1602951f59024d2d6ff5866f181663499dc70dcce9a2f3e7b67165bdd76e3fac254cb8a530a76a80898d4ea7f867ee8447f6c6cd9a135292937dd6ae3a0f01d740f2fb19f2fb228c3c69d7d837a2dbfa1a530e16777776a9b60a605be778c34d332afaf79583c96b482ab7c8e1ed9f8cb35f9ecdd8f8e1b609d7b64a9af982ef12e14a2e84a651f6ea3d6644d5314fdd0441b45966293dd78df7f2f7088f83bdca7aa87bc05eebacf917f502a7a2ddd8e3cd75edfc345f8e5a837e8b81b000fc78e7c94d837fa78db4940cf7b9bd1660b096bc190edd06137065b3235c9a215b118cdfc2dec7cd348c958d7d34b013693b22d719d8585d14790a4b248ac1bee52557429dacc44e3e545cd4897f9f4872365357ba43162f0905f55f2c84fcaa0d8cbed08f80a32409487fd8af608a789c829eb3595740b2b82d86c5146fd50722851234407313b740af7b9114ea4e4e27d0de49f30c255e6ff4d0af21355ccede2c08a1575c82ab25b65cf16425f8af06511de333b421b9ad94f3846a3249fc4580f32df3e8e9845ed860d5f56238a2d00bf1fb47f1c77417150045d5b2c2f53ea5d741f6e7cc1a0611c22c49f5b07b8b7840ed0e2f781aaa01d31310a1335583151fdc4a205abf38e729cb2eb5398c033594dd86a6d1bde8ad044826dc8744db9f06be195b9c466b7d816562269201498e922d3ee9b5ff98deb3c1b224e0197cec6f2c6ebaff271000c7426a5a754ebbf18da7aa3f5a5bd6bd5116e86ee39b17bece8fff3be4e7bcd335e16e4410e3740e5c2f2b5f6e861264d5ec58499e5666d5d4349cb7d774e3dd3cf70750b10b976bbb8a97f7aa0dbe8e07723f882c03610f11783ef1c9a2646d989e686c135ca69d9371d03eae0d580f3c41f23fc9273bc09c070e1fbe34f382eb39dea692053eab996d9ef4225079562468d95d03827e51c68cfc58e6d1420c63aff2019735d0473caa1b55709be1d3d496467a35b44f12dca2f23054fa41b70bcd8846170a26f7f0e2cb10d570f850d018022fcb431318dee3d94727b56c26a83c65a03a9299e80a1b0ff9382d26e937ccec2143f7bdb33694e465f20f7ab6ccd4e94dc7c659bacbc3285883452544b278fd68f8ef2cff6f97fd46767e967f822e4ff4976ccf60dfdedd7bfadbfc246cc3c8188503f7d9ec9bc4b961495b94cc761b9d4a81186e78d82e58fa40ad5dc420824fa9b5ea48b9438cd18178656026474f6779c39ddad1055e1b3f28006c707e95a96f3e3a6382f31880f243c3c767781d32d5019741a974633dfe06694fdcef0d184c2953c866090b65f0a6f66b2f4a63b09a6636e9083a23bdec66bec9b89aba503dcd7e9c9fbc5801595ef1c04e768ff733cb01d145caefc0178fdb50ade5daa4402d6e3e35fc14b8f1b0591b2716127d80bc02cbb9c839edc972b796d72e89c83efe6016a6ef78459c4126a86c058b677f4eb3dcb871cb17273c560d6978b0cc049e745b4c355888a68b09d997fffaaae6e2b63fd89d7049bd0d1e2f2c0eaf7e87c7abc871643ac384d293d1febc13e8a1af9ff9118608213c5ccdf14661b95a77e6e309a3e24634db6cf6cabf378993bc7b1240080221a845caa16e8cba4553803343ea3a828c78f5bace8be0792bd25bb1a90ee3365563b866f268f993b89e39e501363ad4265799790923183af6dbfeac3ff3c598a7c4e316f0f6431370640626f7d6d41c173cb8a38093d23ef6c26017e7052ccdf078e47079975e02b912bdfc452f0f593a657598bea600b3e9f3de1f7038a99f1bb94409e94af7e62b24908d6c2d77af72b592fda41058ead06c0e58e03c172ca91b91b1c309ed4fd9d44ef1d7a6dc848a45cd1053434a5fc41cec4ff3ca14fd5f948b7cd507a472cff81b46ca6b2f2bde34378ac1947889d00f154678ec3f52f29d16bbbd87b4533cfac21249044a7e33ceb71a3029ada14bf56a84ae9027095fa8f75dc719c26fec2e63604af2ade9301e93167b6426a43379733b19dff22b169cd61262243593a9520bcccfa3bb1321315d94066556c51dd586bd01686593b246be1eca681ec113541d37b0007d431a122ec9405ea59f796a629ee8fc076f6141c5101be5e098d8160cba5d8eaa33265ada81740e77ef671a00268df6c4d8b60e10126baa188ed50534c83cccbfacebb2762003285ce11e1cb70698b006d5eb35e1b1b923e3f8524e1e94ff72bed82c625e820cd1d0dd56c75723502880d8a413c26ab436737897c4c65b5feb035a2e0bcc218ec8b643272e4beed9b150103b589f986ce520397913d2af2237a60e1c09ce66374a6984546caac2630cf79dad981797fcde4fdb406e5e1ef74ca2dd39ec1fd3b46e1f649674ad9e265f9fbc43c0ca5b65d5d815e7e459d2adf561a43cfaaf147178ddcad500cef2a867eec8ba66cfb583b405edc2e1c1fe3d1ecbab59c1e5b4e2299980f5ffd78659344888975caf2e90098994aa2545e4190d27539a3cc893f118609c446e51ff774fb83cfd14d0927f8fbdcfd713c26e660f12851ba5aa1deb0e0f276859ddea49e908d2dbc498361a18236d5de5c1eb3a75d5ada4da185697833690f8e122be9c2e69c38ace87e28b9db35df659a6b8afa1012b166036dd1cd3e6ce5a3278a532c70dda63f3858b0f71fd64cd52e0b92c6e5ec38f2d5473d738afa3471aec3facea1cd3dead086b0a31ed6b36bb19b249fc2b30a57d7d3992009d8214fe9384b0e55686acef73d71bdf8a9a84e59cb034e54a16f1ff1bc926f2971b57e45c8637c222267b66f2ac1e9142eaba6027d9cd52b1ad143d247847c9f34c4ab7a52ebac541b780ad8bb7d010ed3dacd528f953c6a23ed1a92dab0abddd28a965feb1b3f8175593baad3e3ca8fc77608ff9a6ae4b22bd493b705cb61addd2d56c099a7aaccf459644d49d388794c854085b64dc31fd8bc2f7abebdb5af29fbf868b64f869f2a0f20ecbf1b794923107499ca55435280c489b88fb9fd7a65b5d37102cf432be377b7a5e2ba6d611dcc76e97163cdec6e9496463fe1a97db3a38b5c7ec28b9363341ae69f70eff928e06bf4d00d0e6e53cb37cf172fb287eb9e2b7b79225c8284c405ba0e2fe35669ed11c12adec54cf661d84bcdc8651682c49133361c6e7af20f94124e719778bf0ce31b738bc4bc8f1889fe8285a8f29126e4ec681519be07fa2cc168d66b21440ef312b1c23e36dd00b7ae9e785013e646ee44fded2e19f02835f2db1588a98267e9e5ce7777c41a26dde9d012d1039ca9cb862e3da66ce84f1120947b344d119ca7842238584958a4506f44f13d6d42fc5b3c6c99785e9c970a43664ecb4d32ac45526ee79eb4442bc22e139f8d175ab5eb415416dd7b584995c15d041d97b714b90f5ff256757b310c71b0dd279f29d58b4ca7b6b32483d3e214b4cc279328a53f68e878f67662ce21da46f7978e796ff5454cdc681b62ed0d69ae3798f33999318702507a0da7606c4552f6bc706e9d6966479a8b0f76a458df70923dff09f3004cb032d140f824613f90be116ea39e81820dcf0c3bfbb6f66ee048fd3f0ab77adaa9aa597f3a57e3a5763efcb2c43ea2ff99c51008077cd03b53b8964b7a9393dc08dee7c657ee31d44467cc59d0e8d83c6362f61a270d8dd4a9cd10fd3e29c4f9d8f4b74b75bc00ec41fb53e70dda344e73956e0e424c7c72befc70e90179473c818de2ba4c6c5622e7ee59f43cb2f5c14e09776b5076cdd33cbd079b15aeabe8f617551e4793e0320a141fd4c858537304b733e394b6a7765661df2fb81513feb4c8e346ff8f6cc196a5e0a6f627caa5cb9e505ebd492a6319739af7ebf8fa5e336253ed1eb54f8779a3f8939a2dd772ee93d06381f493760fa8e459947c142b24f772c536ddd45f991382a482db3e2f4298f91b068d8658774d93df0ddd0c2d35e8476fff4301456e4f7b19bf1b768b9cb76a7a7b5a8dddb0d24f573652db4d3aceb9b2912ae47e47bd42256cc522f1b5af9ead810c1655321861f0d27b726c748c7bbae35da41f0ad13f18db77ff5a28ee4c17045d25a1c1224475074dd6a6354f9dbba26333bc8c437df9116d8e384c957955fd41d17b032a9941b2d7765b60df87094187d9437dbe5210f4ff5408f140a322450773b30984ee18865d00267c6f9c246888a7aacc1e550fd9444775e36ba367c9bfc8120f932e77c2f62a17ca88aeeda86f86dfd3c9cc8a88df57ac96a7ab1b042ba1bf76e32f4bceff113f35a368494012274abaefda5a44821b08f209865a844d6d03e9f9b41d7fffbfaa7bfb7c3485057c9d4c22eb83aa68e4b90ab3b9a4b23434d061b3266431a92c9cc68228ef77b19ebfd0bc23cdae53c0e2f86dee039d1b75c18b07c9bbb292a847dff8d67365057bef959965a2cd9958856e3fa866ba18f98e8a9dc9bace09f0dc70fb314aec0908c3f9c5f71d44ca75c72065a1cf4101b8b4e66c9afced2a3ce1b1ca1b3cb8dc88fbd87b96f206f6cee6a9a47424e2c28adceee059b4b22e68e59253f77563b2c675b239d750764d2c424f19970aee826b7429476586388a30e39371f084cfe54378a8c72f56b011d5cfc0cb253098e55321b13ef1c883ba5d3da2bf62e0cd0f92a5690b3e93e3f785e37791528872fa01e0a95eb03cd5fd248a335d03f44f9d392fac5e0de63b36c574a411faa4eca21346c52ea8fc195e4bb3b662d6b9684311834b8060dfe4b068603cf7b127588872a1195fb562519c2275c7f9d08fed7093e1ba420525c249f75521dd69b21ae1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
