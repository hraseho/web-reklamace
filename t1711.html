<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e2d0c7fbacd3d9e51df957ae4011b6ccd445ea7ab12946b1d78a3f8ecaf0de99c350d61914abc7c94b7a39455c9f95b3c60edb8fbaf1ee28b707abb38680e633ee5e863c14c6b2c0d80c802051f9da579f9ba82543754b6ed905724d75514d604ab9ef8a146f287f1b06012b2eefbcca913563ef5b973568b8fe00cd58bf37312a4a12a1618250ecf7ad6026f7cffcb68ad652b4d17c334f090dffac71cb650cc6016f06e1b835664d9bd26e824197994d0cd773b9640e1052ed6e963de60529e8a88bb1ab3cd0a48dc96c051145b94e9a50130ea67418d60290577c2172430c33985c081c2006c8aea37a05174c61963d36f6c63f8a6d70abb1068cc614e0d2611c2df6686ccea90d0ec21aee2e78d074c41cf39269a1081551afbfa4371a475b8b7c6d5a48bd68aa1a4e56426a565870d0653ff625b38b16cea09a2d891e2ee57b7375ef03efe04cca45614b0daccdc13063db52e0ea7ab9d2eae52b8241b417666b50c60f20135bfbd0bd01708d8dc2180b2bb4c28c2bcfe0fd660fb2cfb4c9b2bc641f7da4618cb998c54d165c6c3c3bced4d2fff8b62a20b1e37cb4e0a228d86616103657c4240174f8f2f51f9d9e5b3b1481dce379c0dda4445249c2b84b53a5a2cba6b13ada2f5d5f991c60158317f498ee9dd108a14ff79a22c05a6843aed78f23e0552c4c264e7a09559f69b1029a269c6241f1cbc7ccbe3411d025516953d49f0d8e954225266c895efa96f0cd538516689725ccc02847f5e4566f6b8224ee0fbe4586bc42fcae34b4c421ba7447d608aa282968c5ac7213f5d10a97a649adc8d9ac016f18db605edd6beb067026555824485b91f8dbe6f444246d3e5f5436d69378705bfc6d71eb522abe32e6e4207b228c952b42d8ab1bc50f09abbee041d615e360d74003b99ea3eae5287559a281f3654fd3c5b038a2b194311f124c5029de00014db4b3c2192c70f6db64c85ca529fab0d134cbf4cb1158ce295fb93ddd2f03adc4baa5e243480489a5eeb4f3e832812023c1515f3e3c7900eed94bab575ea5bd5eceb68cf4170f099d366309bc4b12a76d0703eafcba30533f83ca8e348fe7c9a26abf452c231945adf29da0a1412b618ff64901060b8c649cf8741ca9cb2df72d759c9fd70e02343e38d1096d29bcbc0a15dffbfba9f72dd17c95bb25fc0567bdfc597696b4718c3c89eaa8f00b961f846b0be6dea37509fbdf1d22e69a26e0836bb1d8dba3efd43ef95287aea42b1d7cd01c10905a8ff02842646c924d3ba7e0246eb67e1f908860e2e4d3fa6e0425b9eb39ce870745489b4c9bed3e88d6084257e4a74b95fa79637be190caaba59bb1967ec604604eb9d9a43891b0fd1e7cf30894f1ed68d8c8d2bb278e22c28f6ba8883de72506ea09de7f642643a947ee7906fd0ac1759fe36c97184304d0e26880d1c18d9b72fa6dafa1f24186166db4c9a7a491cff0a917a6e397dda05504e2c40eade66d8a1cd238de61808b7087978c924e463f9d374d58bba7324b89d79b4e35e7799ac161b8bc99df7e7d5d5c911723f8272c64c4dac55c8133c670940c72e9c9c872822469ee765d74b23747a340cf30b16be7877a56c2dd3126bc36cb88993dad1dea05d14b185771723e7a1fb90d929cb8de03111c9ca953a24c33662db0d9ec17758f41f493a25206511f3e0d5f50d0a3e9567e6247d98a5979d80b72ddd47c429a20b3dfde195cc8f5c554c01910da23fa4bc9e7cb80f01af0ff0f33c3b720a11f618ecf2b8f53d3997918b169eb7d49174c028bdbc9b9e45dd2a3b6d0f9c12f17acb1ca41b0bc972279e613be8e302cd6dc9da0bd4860448102a0a6ca4a3766ad205fb480d1c38206ec564781bd30f3b8f1c4f04f95bd0c11ccfe7e8c1d0bbcb32fc6129a9d864759cdf9004576c0e74d3dafc45ad2b18fb22da1128426009cc801058a76c81b93dc9407abd13e0c1bee202970f8d0c33302394ff6f989ec0b666f9eb692701a0e06241151adff39b245a6f435546cd0c746234734e27121faa8fefd3d16bad38aab86a7c0120646103657be7891e4a9f20f76b9215839d1ada4490f40c09c4289689d539c318a3c1a5e826b3fd68763697816320e76acefa3878aa3de9115755d172b8ae08074fec0973bb55fb002447626b29b57dceff5604bff064cb65792b7c38ca0fd3691542f73969f6acf7d980d24baed975a2fe2dedef0cc0da52126d832bbde5922cf84dbc61e16a9db307e254da250c3591c3ab5e2289d203014592a52f2d4ec617eff6ac9a3ea78ccd12ddfde941c9821e64ac6c6ada9956074f06003a9ab8d7be1a57fa4d5fc80bbaf34f958340d6c7fd5ae3c0ae1fa91d03196793286a421927a4d6910fca5873fe17bed5b9111da7d1c8261c28fb704c916249b7a467acc33d2a6609c95ccb32d882f19a9340ecfbda968f5f6cd597ea8264e10f92f20e32ea5aea6ad23446b52437b23b8a0df5e07796832576acdcbac7ba2d6ed51e098db2a0d9a8d6654b1add4a5023730afbef065b6af06a4d0d9031f1a1b8b090dea6c2f62faff7f18b02e9b367bd4a368b1940c11ba9a3facc77d42687f329356f2676372c0172fa6eb7a6c2e1eee066b64fbba56ab53e2beb38b2f2ede6904c847945ddb2dbd821128fe7461d46bb6f5db42ef3e10dede93f7fb2e5648dc78c145a55986ec4be5c9282f36a229fcd33bf405fdc2534a6cfedebd684f45d4c873dac42c4d2f55e6f76506b32618b3a04fcbe6619f796565524d40debea66f349929beada5f6034d2c3c22632cb9ffb0fa33ee63fca5686bd64cd20aac358d4bd9c021b039ba7035930966fa6caf35d196ae45de0edac12d65a56efa7ee50eec978719ce80afd590881767c335cfa72521ed26c7d7b12fa1d3dca5db1acda93ca9410fb66e935bc39ee60ec09eb6f266eb39cad48eac98dfa9697bf4e9b7c9d005f438f52525896ca798540628fb2fbc7d518b31b46b46c3de8e5609f19f8189d8b45424e9132f8c62aba40f4b7e496b800aa62ad51f9e9485d9f560c316e1a7e0131729e1c1e7818f80f499b9200873767e66d984ad0fde2df621227ee54956731473ae7d86ff583b570455062869daee18a51b214adbe5952503a14d468c6ce25f9e32772cf49aa00b39f0e113d47d76e2c9920a1678b6cb1ce2592b39feade93fffcfdee122df9734b16de44cc9098f90929702141554ebcbf85030567537ef63c96f9561b8b2c00bc89d5b2ea22b3cca5c0e46ea90f76236f94aee053d427335dc96171275e7e892c5407608e81594ef6047434523bdbd1e68b222808f461416eb977f4307a89a895ee2f7c464ee79d8555e3b98ceb59d7d48ce228c86043337e342a32ba93c5e8774b15958e8c7000f7801af3dbdfc522556de9bc80a0cfa59fb7703bb1542b58a2b7dc73306211c53a29377ae008147b4ea648203cd567fab520f8f6713eeb85d7a2a6486e8054e5ee7781a95da733498497cfc30616b0495237c33241b36ae1c228ca4f3ebfa7761d56bff2b0e429bac5c7c544ac016e156fe4eee32c700762e253f3d59be8f909e6c697014963b6c911a043c5995eb6219841ead2dd8ae6afd54152918e1a661190b2ba8b4e59e98e2680fc2ebbe36a90ccbd34827deed74e480fa2a4f7e4dab954e6fe19c456c0575fd8f28f32993e62c89643cf2157ebbb9f673ba23fbc5826b811e0ad73fbea35f982edad076ef02c2e37bf735c548e1522c23889f3cc14f5c0bf3de5ad640f4766a68e75fa3bb6958a88f7e084008191ec121efe43e55380bb78a651bf6d6554d9f7d72a4cb97536557e1dd3169d6931609f8e170750a180323fb51f7c72455b7f680671bb2db591507140101e2a680667052e74b62fe104cf90487d8808b51a4b9f1e9cd7aeecc8f1797a4779288610b1c705a7e895c18e1dde946c40e35794e830f148370f7eda871e3f581507fc3f16d53a6ea4573b9a801071c943c16ec85c599b5c1a249c3d1db01c7d26f0109f32ec1a0bf33cf97d621fa7f3bee80c2053ebeba8db536860ec7f112e86f7433d362e89afe64ce61d44091502917a7c25ec9f9b2f92b6bddc71754b0a8bccf540a15f5107794acac2437ad86851c7d0a042b2fbce07c357bf2fb29212078d7129d0dd93f956d4f54e9ab6c1b6a07ee2a5445bc40092792258ea09446b2bc2e503436e512224fab14f4ef3da8d3d0aa2cb6be5f2436fa0146a0ba5ed79332166269561163553a49eaaaabdfc5cfedecc05020d7193b09984eba2f4e7c541123b6720a90b8f8c1283d945d2d7de403a7e6f68a1d884e7ed2d01ce6c767b96fb36a4b037066bac821db42298c2ef6cfa199292228acc1229489353606b92e7f27e26ae0723018aa7b73a6c7cd81ecbabf1a6b406a423f8b2730a604cb5b6a6f86e102026a49031d3cc2d25aeffdffe52186d3487ddf72784d0912e248d31abd2fd7dd9fdc5a1ea588f2615d4cdf8c7fa10f7e6425cab6852d24a15b38dfde9d6164270a4ad1adb16213eaa773084b83ba1b5c807fb28f40e0c57d7ec26122e1fa256aef611d92a6430174f3920029f0eb4b271e72c12cb11b5166fb1a92cc2a4545dfaa2d9d5a2bdfae3ed4a35e6987255acfad57f1ea0b5393df3721dd0d5c08f084629d3ea119ac45860044f38a10d421c23d7cf23e6701947dc28a07f7a9f69a569df17d1ebe2940fcc7ed3f79c2aa08a0c1ee319e3b76d8bb0528046cf655cc5b2a25660ee15d4b26c4120fcd14d88a0b5e956a37de3f0044cd2b18b08e94e0f964d10e7146f9e62af7c81861a195eb5ddd106caa758a96949c36fc6d11c7344092903a86ec3d54ed03c51450bb6be18dd45996adf2f986653b6f11bb47b691e5210ba95e4dced3c6b0d97fead87fb01a9ba7758c1e2f6a69d2c0f60fd0c9c369f0934ae293c844d18965fd1ec7887cd478a39b3cf59f85bd68c5ac7447e9ee5ebc07a6adb0c7e819527ebf52e624c6b282a45182195156ea64f1c703e16007f0c7ab871b5c53f9965e0753edc5b2fa5a7c6db1af6723b700e013638a058406e2d71d7d23d1b43d3e4f87d0eaca09df2b247e07df7814825f4c83a06d5b7a02f3bf20ea74e1eb55574122f77d7d6b4ee7c77d77e6f1abba6d0c2317f746c439f251f34011a20ebd58ef4242152a05e938c059d75d890dfb220dcd0d3c0cdea6307cda10cdc3546a2fa94397d77196ef8b8bfdfc56dd2f8391c6c2ada3fe717d6477637ef1e4a5965f3cdf5557d184976a7031e2ec10a86c3c43b909f71f5dfab8021a352e97b9de6ad7a94721ac7e9dd52040624d14fa9780de93ed8f7a0cd85152b92fe7f94f63878f75bd58b71dac605f931cadae01e6556916c0add27b25177cc2057b652e2fe1dfbf107e6afcc0e841588eeb812e45868123ab9fa4b431822f271b7fd350536d47a5d04c53edb2e8126c9442c21402e0d7385672db5352ae8f5ddc313e7710f87c30c129d201618c03e0132b654ce418b05a2502d54e2f0f8962f9090649962e6a2921b8a8c9fdd1d9e2ff3753b2db719aa50d73fec3714c0f01f45f5f85cb84075a76f1446f0c0671f1d5044be203651dd1689c66ce1bbd7428e11b72b511949d4d527e8d10b25e190732570a8ec6aedff0b5583bb3cf2122673e9c9044ce508f29c4aa804772c9ba9401b436a89b923bd4486509746cbfd9a18974ebfaf37bc1d76cf4dc01ff3a015275abb44124958ff566a6faba3b0e7bc168ab7525daf1f2270a6b66b7de34319b0baaca753c93925fe266cdb56b67ea19fa423758d7dd70f665c12ea1410d67c558eb805840691030f5259981f176a76cbbdfde4dfd6d84587d7a1ed8feab11d3390a6d0840287bc309b1291a856dbd6b47cd60441e901e4cfed85249b6764868c2423272c19b19e95f14f94605c90c049194637d558850fdf69aa9686b5bdfd122147274b88f2da6cbd991d251dc62c2bfa5d6ef40f5aa9e592b8bd94500ae33c8e82dcf1c6bfe72046e31d03e238505d26c3122ee703c4417c2b0793c062089c05039eef647f02ece6dab584c7ecabbc097185996e5a676c13b9304f44bb64bca0ca066908750252575a00433b9a9b40d1362ae4eb7c3ff78c89976d28cfaeaa3df78c06f9647da869eaacfe13b8dbc6ddb3b32016cf4f7496653a94fe5987d1c9d2a4db46956f7dbfdd3d6308e39e08e698db9e00d727798c8bd11e662aba1b15f177198bd779e35c0f5dc1ce25e0b9030cdd67d47b5fd2d78275e9cf3eac30d3591d698812558648af9bfcc1f68987bb9758acef2981fb8046b3fbf77d6c2c450aa1781c203dff520e6a232ace4817e3bb21b859bc2338768c0fdb46958c40a8f67078585c25a95c9b5b42034534436db50e94b0469e42966cd710b59920bcac0b84bf0552dd97093872e12ee14cfc1c6be2853930124f4227921563482214eaf49279c27c634b462ea1009b88d6c1620c4b475f0d0d59ab5fdda1ec3b6c853fc6ab98482305d76224e9f8301fa4b3543418fe12c0d8abc5c409994d6f25c9477bf9fc29f2854b0131953528f841d928c8bec205da5a9dc6a0d378e53ece5613fa078e0b4414aa102263cb582b9fc01449210cf0df492440004c34b2db004cfbfb885ddbea75f428b4f91d74f7e74f9bcb9516e672472d4198d8e499e20580bb2cdd01fa95c42c8a6d7a8222e6dc6a406f31196d3f64356186e9e04d2b262a3e7b4fa93e70fdb487b9dd847dc665eefff1a805baaae9f2ffcb706b00addfbf0242553c6531901dc625f6142bb6d8aa00f183218dcc7132cdf99eadfe29fd461d801929dfe1dbcd4899f5cbf5759eea8b95bcaadaf79c143b8b962e951d02cc4cfc8cdc03cea82674f34fe27e24eab1448498506219296c262a01624dc23242751ac93bfde1e4da77bfcc52825eb777d7507e69020ef6c7395732d36f2dce082a8f86cb061151a79648e1df0a095d5fc12bc7a378c41536f1fb0f6b86444dbc5f6ef40bf29d4e8b6cb6b5b8944b79749c9d7daf403a2e2013debbb99e914ff1ef64a40523f2839d55f71ad24068ff5de7b6d9a4038145e2d2506017bf09d3501b886ccfc0549ab72c4ee48a50cf4f30f64830332b6ee8d2c2a883b24edc458ead511effa8d777e4e67c890ba84c2b01eeaffadefe4f2690b52848d9d930451a9cd7600200f94870e0e6571cbdbb5c6684a6e9a1609aa4f1700b334b9774d77351f6434b1ee4069f0359161f262e71689a38b3ba130f6a4129676d37a4fd8478d88368b629e0e7d692dba00a676447a2002a5753c524a99657d653a42c57a6aac9079c13b2665284533fd22797e954e4fbfb268d7fbb75365508223cc2754bfecd9805957397b042729716d08d991ea3233a5632b7b9d6c69727bc2e8b40279a639168591c6801bfb7e3f3f031ae7865a4eb706b5d1d2f949966f0114116a74edc9973ba0761cf3f36df35a0b742df51ad83b0a5dc380fe77e70618007124871e15d9937815ec2ff25c5d44fcb293c7e6479004eccf416aeca441fae8e36eb0fcdd645b96e1cf45391c5603e72910a64b02c484e569f5bbd56e13e56a97da1db0b29b06039073d3270ab0de72093578668368ab647bba2b43d474db783134cf465759f1cc2a5647e48c6857434838153c4e78c068000231afe8f90f22af7ffe22a2ce2f97d792a765613c95bbc83681cf208c41e4329b5b188d7ff4a9de576a730599fb995e0dd476968479cd3764375780eecfa37bcfa1b03214ee3a95559abba89ca2f43f702f3a3aee40a487a8eb7002d0f8538470a45be572a858ff372dcee1004eff5e57c69c14afb99bb95f63f5ca6af66bb36c5cf9e579b6ff63f04c0d734c1ff837e52ea01d9944499953fe29792838ba8f0251151d13d00a20a76f4e42b46001932824e67b21bf49bdc8e5825512cc4152beff00018d9afccd3761ec3acbd9af2e3ac35d1fffff86244c5484a1076d31c5c199a8aaa4580e65ff4936f2d0b326b85edd75c5625b7e6067c8e347be0d73f766388215585752d55d4b08be88e83a69d1fcde9e303234e2891d4360416ed8af61f0a04f7a70b5396f90013bf6877a2d4045eaeb011a87467282da54c4bfaed4175d469c68ddc6c463021049fc3322142b221b2d16ac11db7c09adf4ee83bfa400fac67c7b385f150a036231cd9574e414dd5d52b0b9d9fe962178f23be20efcff6dadb4444debc54d232cb0c8e5ed9fdc1d1a5d952c3431132b660957a703505f3d37a0a2d2da7364adaaf1f65484d6455846445cd649ddd9775c1341e13c31a7e296f13ae1130b9f227c318acb7bd97ae51dd3ccf0bf7840ae8816d37cf0b81961a179c3030857b6fbb8803773729c0c8c5f17595a27df045effda6eca3eb297e653d0b35e517b1d631d8bf146311c2e71bca2400c877c8b7ed0f0ee45b9842595591e0a4e11716927e0835089346e3633a14459c2e4d244e70374ec62c6c727a1d9fd140805b3691eacdd6b2dd15e325c6ed2e46003240b422ce02833fa922c9acd2f0dcd1e1fabdbdda392bdcd0296d3e68e1722f376d7c93b048dd713e8e2b5a234cde952b7984ff59137c615374a94ac09689716b8465a66df4def142dfe84ad5209b6ea510a8d47628ac3a8ebd7e5fca8f8944b898ceaf6367dc54b4aaea6bfceb4055115a8809db9ad767df3aeb56282ebb5fcbe0a3704ec5f7399d2fa6b3bb30a5a8dcc3849d5a67fc158675d09451708fa9eb5120fab4b36d1de3267ce0f81f96873159784a47d2004bb8193890bd68514204b68a4c7f329b07e0c9883e0fa8c5d5d554fcd246f380dff81e01b8cc372aeae526bb19193bfd921c993bf27c3e89f8efc737b10b1541fdd3b8e70238f4d35daec69ec88a9b4c7a5cdc57cd2fc95992a9365179b068fa3741d1b7be5be09390ac066669400f3f0e3468ee85613844da93b997294d34dd02da7e6a30dc1b3a9b23bfff9e9b7b2e1ef4f3befc2bd16de6f523889f7532c94177e97f2082cea222610ab6c0a80e6a7ca07833db1f6fb41da7a29a703a0bfc2ad3889884bfbc3b5a0ddbb66372c47d816496b46efeadb1c9661b582f7f4a7e1a623c6b737cbb87bc960c290eb15e1e3f7434d40702927986cfb674d21be5b606375faaa8a880bebee4249f84fddf7b372af5d0777773589a39d12972988c8c97cb0e2051207c6ac320cac9dac8a0642c8df34d4cafd9e97e4cac85a77c1dab563884b528be0a88566c1cff49f4a985f12afad4559fafdfd2de4d04ccbc4a1fd60f183db43a5ae4d613181178a4c1a0c85abbbc353061b8a4b4d328cdb0232d58fc4c7efc64375136d09a6fca2f7ed748cba3816243627dd20167a930e79c31d56872ed52f79781418fc28cfa451245b683482ed6805e5d750b3fad5cff597c9d3c540e8a9f7cbe7f8731d5f0977dd1e93372dda97c494552debf6a8a9e9ae6a8ba84a70a6e27bf6af4151592c91be6665aea88746ac0815f9ae3cb5158b10f77adb65c2436f815dab9bc824413bf5f53da0bae65079fd2fd04af9ef2b3e99a2a08a7b682ba04d2388cbf8bdb42f603e01f07a1721ab30f834ccb2c601ba3b78895aca62518f13bfd4df5879759eefd371daad0e090e4406de01ac31a9ed2e219d2ae95e442a430f9547181fadc176f2caff7c4d030e59dd39c90e444277229f4bf765532e2e928d55442558ed8a5975ef5f637ac31ba61b94e921847a1d655c00661445ea83c2bbef6ebdf9d5ce6415c1d10823f278c99252116ea1d41a5d6c3ffaf438af2e582dfe06cce61b8133b514a532c788ae652911eb0b2c2b7711cc55ea4aa6549a902deef07da866f621985275e02ed7e4de2292fbb90ab3cf19190de7d23711a9d5c8009871129fe92a873aaf2b185f116b8b48b3d157fdb0880510a1c102333ed1cda9845503c52e3493db590a286e26d8815c58a43216b72e3e9a4e617e98a36f7171499c4233b093b2ced91b6c33f69562bc88dac78e387a7530caaa58bcb06c7057707a92d46bce51896b6dec04e9d6b05b639c6e2f1edf0730d6402a034b5d500db002d5b05f929b2aa1e837494ceb2306a4d998869d717613496ccccc3c5bd3f81713aaf1545ae76101ce181e802e08f1b1a3b3a44f6f831a764f63796c641f406da91a78b9875b72c6fc8578775eb234f6424ff200b246f35e5f5d57997ef8206b616ee83e2ec4a2ef77634d7eae1922670a0825aaba6380c6a0b5b46bfec82cb7e957504a525466f716689711ac71d293ccca8e55b11428bcda556dc4afc9d0e76bfdd85490a39767cbfabc2ed6443a5e18b4ffdb580ca193ebc029727869a981d7759c6fcd004c57a1ad3433139c87e5b47c814efbf015bca080e383c3aca6fe1a5dfbea292aad9d745f551162df5456faf1a3161397925f5f906debd6e430239aef8588a6371901f088bf2b38e03c591653ab071cfe09b181e0242f24ba63aea22b8a790f5b7b7e4597744a4c4df941884f8818b0f9a592f482de6a77c2e2bda4110ea1001bf14103897a8acec4d39b953bd5221997e634e50275ee6b5e558cc4dbf157bc89d0664cc811b96a7cc608ff23ff166d0d63088f0a852ee550180b2182b0746b3ad0b41a5be0137644ffc60f9e376dec7237b454416ed8d4ff68f860e7767e971350e1a35e5db2470f2d9b040da7207210bcec4ccf536ecb54250a6a60100834663bd2e4e1d6265e5ee2b413bf0412833734960c76d66de0665","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
