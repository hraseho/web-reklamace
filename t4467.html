<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a175704ebcc6022ee6008096beb5b3b72ce1a4b452a7342a3935cae73afb273f4760cf3d572471a0522c031fa8aa885afb59c41b656a12e7259b6577fd8ce45ed978e8b9494308bb70510dee08900cb8326fa7f5b093c1bfc37d5a347c16eafb6810bc6b5094967e2895b352f9ebefea4bea6fdcefaa580684a817224b2a68e7007998bf19dab877a22e7ec5858c5cc149c8e08b399766b7cbf4e3f69b042d49f6efcebd1561485a8cbd51dc74d61fff94235260341ae6e412da549666fcb31f4ec00917c629cd3d28a5a1f645b4bc0e96ba8d6eeebf2177a01dea6b2d97bc7e26b43ec3c6c17bff11586fc0aa62c4b1cb97b0e5102ac84ff8cfa9c6b04d94e414eeddb5d19d845720fc4c80290ea889a8ad1a2ac990fc53159d86a8c9acef2176715397ee50638a39a58386c7ab811fc687a8785c5884b18b0e2f272071fcf6e3c80a5c401b3b1419167f9e5d2ae76da3d1d0634a67c7674d7adfead9d659ee7d74944e31c665fcd7944e25110f051771ba862f4f9bbcfb0e799a22851aecae3ab586a38eab0e6a8ef44ee83d4881ab324f9658d225c0cfaed1fe1c6e349ac11e5b89750b383b160b48c89635c8e5c90008d88393195d2e1247789a3388df0c5774f3376c65455fb6f7e12b6134e4b9fc73c9abbb1f9a746b850bb9aefd6a075a5340770880ee7b51a04040baf9998ed2fa57270a1e8b49a25e18697c3d24bd2c16db6acc516da8aafdfdc5bf662400000cdeaab122c0d9ac9029d39c1ab4a30a4577ca00b496428429f9621f5749ef612c6fa330955fcf34f7f22f5c50ec9162117701f194759f798d6a1d0ab2b2e72cb7859d939fcb3d0f8b64577aa13f3a496a1e8e572c89fa2439927d3c3aa1dea75bf968ac47b2827469c68bb55f014780634510b808f7e201b9e9d828f72b926db0a90f4fd40284483d337eb0015e55641895ea1f42f96b7631fc64df653d1df0c55ca3a7cf82a3984795e546a20c3d1a40e169eacfbe8f40df159d516420897857b40ba0aee384b3e8a7000c5295fd18aed944aa3117352bf94e3592f86f441106caeb959f411ab1d94ed36d637e3d88c09b7ae0e08954c3d0783d60c311e37d4dc15a12e65da0c69f0dca40860e6030c152fe39514b84c293138df396a0ee04cda57ec225b5068a720903c466931ddec76c38a818bf66d67340b66121e9855fc38f5d5886120ac6ad98132a9b1e554e6a6f81846427f595920ed4faa5628fd1a84f205f25f34104e4fd5f2923281c34596c797537921fda45eee5489367f55b698743a66039bc8e046d0dd142175c205b5472f3469e1ffb20a89193fbc7908a4d63e9cb15f7aad2287777362f2512ba03de5184419b277ea1b48194e07f391dfb517423265785f52b91ba39ab08e5996e39f3bdcaa13bb6fa5f55bda2b3f071552b5ba447e80caa570eba2cc454bb7d5bcb6c3ccd176ff1c1f9cd646c5f58cbf358986fce6bb2ffb09df846a46b3b970a1f2f218a2b85d32ca965788089483481bfaf0b9ef2307de53b944fa172c045472b3836aec3da997dd6b9c23dea329fa1189fa9d45953dbff0ba49e1e7c56ea3e35142c5ed9fc303ae0a390235375777d74b9baead020e09f595b5e364a1c4dbb217b7dabeeb8b476a5f9ebb97c59ab7cf40cf3e15f67dcc2bde20bb6e4279434335a74d2698e577286c1c6e570b7407de2ac47ebbcc8745f4db15fe825654498dc7661feafe02318fb6771da54f37363edfccf3d97710d4a5369554428bb01be6b384c950cc2fc6b3b3e92228cfd308c95ae76eb42df38cae5021d244211a78e2eded084f28d2d362ba91ab90cd7987c1e96a0b1049be0d230b1f3da9618f78b87655705c29d2520211e4855327e482219e9a20d59901ec3117f3642a7685d364b47aadedcdbaabd9383f0e0feaf6ac76e19b0e58ac90bc805338427907c164688e1e7f662b2d38f1d157929012d9dc204c1a5b8ae119fd98218c4817a6f54cd84edd7cacd7b3c132c64e15bab7bf07105c42b3cc002b170416f7667b082352cf8b4c0be8fb461e9f64661a67985000ff21467d635da57643985abbe809cb3fd579b745a3a37d78793ac3f19b2d3b71768d5d6cd5664d688a60f13b8399a0acf60d9c88d580d87c01c362412d64aef1793750a39e6ccec434ccffa98b067117294d42538edcedbe3f40b71901b323893fa9e9405833fac7d6c8132d642755d431ec3134ed8db250c0a11b618696c431c50f214258d014b688502f45243ab171f80bc0dd7f94284765f844de4390ad08106bb38ad8c5d338b5c70aa7b7a20328dc8d7dfc356a1758240075688923c936bbdd7ad7ecc92389208eb0d4b586ea4d37e35d1b09f4d548a0a9178e3d10aa36d58a2297a753a222d8c89aadaaad5f49b57cfdb68e25d9b2f72837205751dd873fc32a821ecd5539c808f5a521d04bf1f83fb981c58ef6fb765caaf366ed4c65c12bdae4fbf32f3c5b210d2c55cc02352cf82e36155d90893c4e6dfca2547b8b6537124b3315cc4992202202641621f958b2af1fe2efbdd03a77c052490ca9c953c46bf5063fc496cdcba624e7c50aaa0a7a616903455d77b6e150690a8beeb3ba24cc971dd8ed2738d5ff9516c19cd47e5c5865df2ae6873a23afd41e41d631af50b43a505cf0cc258c53ed3992e982f8d077fb60f22870bd0b77c2247ad9bd9cabe7f8688f2b5f8de6c39244e1125be933a312e360efc67635c65197936077b6e69b885ec3afcc90737309b275f5c9c7224df1ab243b670630bbf487627a18a7e61874815f1c342894bafd38c0e3f146eb8c362a28a0711ae2d5f4e8bc93331968a4da511e97812b237bce141df16b166b3af8c0de80924f6fef53b5a7db8220faf083f07f7b6ef1e11ec9d6b2081b235701d35681e2b3b49281d843f528ec1dc8db2c420b3a807de8d3aae2d02fa6090d4f5b4a457c8a833b21be5aa886f7f971568e08e40a3ad5de7ef16e83190fa9fbaccfcc678c7e76881aeca3bb68e8485ac57721873f45c5da6cfd64df07dd99af0536c5d060d1fc739cf6b3142a7c98a0bf0c90b8c1d077c2cbed4e8e7fb69e0af6ae9ebbc075203b02b5c9b5a60e4dd76e4e92fd1bab80daa78282166eb16dc3155929718434df9e3c71b13d41e450b44af7a627f9ee6ad13c8bb6a7625846af9bd9a7af239a8f4fbc7b979fe274c0433a1c8800fcd38bf79701d119e71fcb5ad0a4e7d696c9cc880a66adcbbebd53d15abe6545a71209db6d40ce0ceafac31631221d3e84b49f005de5aeffb02bb0b02af6f9f38c86e54a14798e46f46154fd3b47bf20e29b668b63bb9b70f650a9e0875ce133b7917ba28531b75d8cac764fe5e003c5d35fe3270d8f5883a222368c10ffaffc6564fecee742ba8c57f6bfa1940b8f9fe88f36de531c08307e7127c35c6038d9f475255f1027c6ca22f3f0ce1e78f27f4cbe1a50b1542cb2855cd8954731c6a7a0a38470eba614ff2f0bb2fa7eddffcf1cfdf9e14c1f1a4d0bb24f22b7e355c2671a87d31ba70c1d2aef7320a723d494c86e09ca1e5d619183dd94173fd55cf85e9f13452d50c45385ca0d172ea88847bf9f079a0b08410e86f4d04159e1fd4c5362fe3646d04f324aca9b85bbc6d16e9238987691b74a5d0495e5834dbf486e3dfdd49a291243ede1220aa4fe21ba503ec59e705614fbcca435ebc37845eb2abc53ded38ddfebb49986534f6fbf26a6ea442c01808405362ff19a2a1ce7bfd7d90d984bb0c0c03c6d7ec3d54d666f6c265bbfcdb0945aca4f079d0b58ee9b5b9d7ed4789e4617cf243addffd7828472469eeba2c98f2769d588c4e05b8f92c5d9a7e508ac917791c5b9c978aaae8c40ebe369e58a2fd9a2c0e2f53fd184198f9d9a20cc56ca6b4d06eb36d29ea3c112b09fc33ed23db92f88b2c35d8739ac60402a47c87050c595bab2969a2dafafafde510987f900833ef9feb828b95d35d1b805fa1d4ba6b904f88fee5d7ae88b8d1b1033517607284f1b9b253f429d25eea6e1a42ba87a60337a191eb98b3fb52b618c257e99e01760aebbb685b4b14f3619c712ffb89581a37992777900f23e2a350da5ced2b8dbc61881d3292e471c59982d76daa2b48c828a1659ce64ac286f829bc8625ba5f5e316dd6cbfa56bb59413447d25e91236a8f2838d8fe1192e86f43ed14b046ce399b400edc3d415a83307da7e23af27d80d21448d4c2962d477e38d281aa7bbcad89feb9dae8df87d2ceb2c47ebdc9d17928b42176a3f2e26204493a82b53254a4b35aa5bdc5edc58c97b6bee2b66c39572a57ddce36f1f38cfcbe9368e5f9da52ade087b1b6721028093a795fe16aa37f129bf8b33652b5ce90f26302b242d598a6941620aaf7315e5eec7d7c1f217ed25707715b1f438c8ede00ba0a014e73c41de6e8eb1e7d4c6432f5de6ea08f1267fcaf2b3da780c84d61889d2aa9dc6131edc6bc585b4bce85e6352edeede474869120330d2aece3f043fd6f083bb1b9c425bac12110da45f02b23aa52d2fe0db1451778c8bf28b53e8e17d031cafce7c83083d67a7cc7482d80e2e47e690d2606bc06c54f55f9ac0e83d5cea2620314b4d4dde156c6e53ba17cfd2917b7f5ec554ae83de26878ef4319bc22440e2703546d7effbb41bd262f03c2cb5b1774a927dc34c72d0b0237c4c98452b30949e1a16a0c90ea9a9b74e268e38030cec9c3e9f4d6b6bb4876ecbf0fd74032abd123df403adfa6aa51c035542a82c983f4f6892dc15afd0a0c1cb4df492dc888cc5d282b92d17ec42272590169177d74926af7720f53c81a44d30f488848f136203b6d137063108651a115ab018138072d82f2f647c73954dd1cdac4ef9eab3dd3aa9fdfe654ec0674a0ebd09a9ad41a608f1ccdc0753c8afd4a5b0a226ec3e6890808f821e4cf6951d48f71cc791e27bd1aa6b5dc42a7f51b9d1b9b6c21f7e9b3fb4268f4e3d7d6e96c0d3df4051745a297b2b66d92a224ab706d7646e8b7c7f19c50dca953f12edf533af2a25004e1c2f1759d6900353c40e6a6e09527b8bd766e7909c54a5be352fb4f95a039991891b7e858ed049f62a1d51ae080868a62f0e59ac51baf435a70126827fadc119ff44dfa15e61feb7bd6af5d86802123f238ab924ad21adc45594070993df4cf65a8973c8d22dd4a08e4abe778db09179aefd075ec1ad231bb96123a9640b300ab89751edeab129bdb4c7e4a7768d7af41880f262753b1fcd00db67c91a9e4b535c06a32fbdf1cc81690d821dccdb13c456973d7d13d6df778783c7ffa3af9429018651aa3b4d581afde3a66e63627197807a4824078a56a171c7bbd3e6f98abd82d34174c4931dc9d6f71b98508a64ea46276540faa880003929c62e194a6fcdbf5e344d28ac0312d05708d8847b8757302567be6be8cacfeb1493ab181a00847f15f8f836590c4525eaee517edfdaec7e26a9c3f05df39c6f88a925f51dfb1e44f93592708404d6dd4c7f8274366a2a719a11db7020f1a5d8262f17f41ac0b798f02d31a8ceacdd0f9963be653fcc3cc8722e80cce424e7d27b9ee0b1dd1c2a48aa50aff7b9676de613b26b6b2c2f518f1878073d6ee8995e0135d4c40ed958e5e5f6d4e08b67ccd4ec743ab434d5da0dee235888c17aadbcc278638245e6589e437146de30a978be982365bc89466209f0a7879b93fd989e81b6d14bdd683faef6aa630bb4fe8cd665276c05d9daa6d075b3a9336125718517ae1f4cbc996b0cbf92288ea1c51dc0f15d33bdd3edaa490be1a13e6c66b9f5cb28158d640964802e421c5b80fd3d196a5ee860c3934ee3b258b7358fcf2b7e4e4426705788dd700ad871ebb882c1cc18921cad7b294dc4644ed3cad2f570dcee551b7aaf5f38ea9c07192abb759a28b7c81934fbb1488d8674880857ef1cbae9f16d4f8a3e864a30d98b5afc2544d292a7b40b137eb89764d162df46646f70b395b328c4ee6de44ca72c2abf55c2f8951b5a12e9b0e2310fca336457853ad05388274eec17684a29601f274e118367089564a43a164a0e502da78e4d7ce8f3eec15a899241dcdb858eb08fa0494a1e4b98ca05290422688713b9105ca9e37f6d7762e5b79ad6c74233d70920ddb2d2710608ac583ebd61f9673bff3c30296d1c84b857e4cf8b1e2b0d0711a40cf307fbb5d0791b4f8d099286b590a6902d75a67be62fdd659480d3636e1b680392f2a99b6fedee6669624022a21c90c2aa05279be4a8fe8a6344b9c2059773407d628891daff24a2525e2985b910d8e0a0bb7fddfbbff0b56d589d34d7a8e01d365bb2c852ca65c6b74628d3bc8f9513ac546b63c83b8fc133f1a9caa8d6c722a95e6ec15a1b5502da4e694bef60afc972da73e6d36e68926e1057d54a611be4b62b0573dace9ab983bee89bd436e4273f9577b4a0f44b17b1d859b96ef6729993d754c2b2996aeeb41d860e784eb76f94f9fc4f78b49842f792b192e786cba0957c5b89096884c483020995424135688344c12e23f69027f866d3ac34f619d61f4cc5dcf40ad5e6e8932affd47e05439c9f2befc19104d1ecfcdfe388fd94042dc2e8b08c1a86cdc09bafaadc5cf73da351ecf1775c2630df4736d68563f7f0c72fba37e7451580a65008284f483ac2d21d8344c3e1d16467818ca138f1123d62fbf36c497cd0349d41aadeb5fa311d0ae9b9abbad595c7331df7fac0914242c515d2bc087758ba892030b025da335818dcea469c94310bec2b745b8786c2a2fc0a37f90295c62f65e5f2c5ca041e4ed0da6db3455564a7dffbd4f157e88bd3a6af77cfd4cc6391edc29b92283c4c996ad9e1b75eedcae591d60d9c4e7642af1a7a7d270d8d7e3e7413b20866456488726fecaf7c84259b989b2c7a6dbcd0277fb7a1ec5bc1b51280191c34cb6a921d642fccb52bd1863c904fd4eb90b6ced06b97e3457c82321a396c8abaede641f2afe11427a67198cc62af7419b408d6f4cf850a2ea91eb3c552fe9253f90979a387b6b6664f47b446ccf8f388965c0e6ddbacfdf4dcbd25058ad18f2bbd353361bb6f13f39edab9130d3b021df27ce3b08895533d99da6eaa81e959de1ca85471b5f5b13b015760aaf39178c57cd698ca16348108a0699a7480331c19be1f37fda5ab5315ff8da133414083425b4e0995a8da68a07f315e4646f18441ea73d869ec1d3be7f072773f8578ffc00df39317855bc20c4e6113157156e616b5946c4ce2b633c20ead898c84380d83850e11b51b11fde5ff2fc5f80cab7cfccb3db5c45302abdc5c20be858c05d9ae5221f83f2b4711a31344fe669d630371f4c2e0cb8db9aa65ff696d884e766de7602b5d0031eef0eb6c8679b71d59c2dde0f4f6f3356eb9df042aeadf6100bf85c6094af1cfc84c1b4228b3bcbd70a9e4d44bc56d9378552b7f3a3803df739d330da6eda8b5a1c03f7c39a537b811f0a7dbdea96641044dcc1e0b55c32b757c1349e5088490e245c9397f1502646fda73d8e38833cebe959f6971e4c03c14accf86736e0348f3b2ca835158f11b6986f5c86bebfb590ada8832dc1e8cdeeffc79764cc07f4c490c2f9c28bb531087939c86ffb3281554c0b98e822beb9d64ff26654f2606385f0add72a46e3bf87c9e3eae872518367ed8deb878d0bee0a9010dbac55eba0b155a09c3e3ba24ef8ea75ceb783cb9775f32be9bc39a4e2420e688804adf9995f4e276e9c382146e2cd4692c55d0692eeb0b89072b7918db5fa38c654a6c97fd5942d715389a28c86fb602a903127e10c3840695f78a75896f9602ee36ab3081752467c815aead9ee9f830232bc004545ec533a5f9bedfbdbe9a0a1f0969b95a575decc93931d6cca5c95c0f2b5a0c891d8a15e2bed6be9a1f1b24f8ad0ff0663f2bd751d11a40227ba592ce6e8b58fbae892c103a8c9e987b7130457d9619ff105b0640fc592cd22211dca00049284b6a38669f6af75e7e04850797772892b21477bbc07622b2843f7b180585ba23d270fbd7d4c6f842b3f0a51c69c3957a0e38046e6347ae42acb1ef9d4e95d4ed3c0ad6d319049a1ea0203fbf84a915baba8aaeed94a91f6a627f54ed4637946656a3745a828dab102cf0f23df6f47d4acdf4814444c615d94cd3e10c0a58f34a7ec41346b0d6d6d6decc4d69f9ec1ea3d1db97e07bed4e6b58d3c193485537d91edbf35860d27712a4f55dab835abebc8e0b42cacf28dbf8331c5544922adf6d8d0b852f79af7c0356a74ddb9c69c79523aaf87053f32c42b0f9c7de533657daf689002c7885555d9efdb96584b61d406fb7f70b1770132e03b386be5ca4b979462a5b66aaa3250caaf4ba8995d0a641687528708eadc0bf417a8bb4fbb550ce8ad96882f5217ab658f1258e5bf04f493b3b59f71de2ceaca96095c3c166b97f4087476b30a324f2e094396316556bbc4c4a7f745765d9ec8910a03870ee8faa8495785c1f4e30d7194bd4f608ff8a79ab392a0b20b1125c48f15ad5c720a8df95eaeaab2e5a29482ea9d21136f49029e15879dc534fa26354d195c78352a972dfe984ce24e826ecc5e8d14bd9096aa6c9a72abb11406670941f47a5238b9fbdedf9cffb299cab27deb3a4d1e8cea43e047d44e6f3cdb071b0806d4d70c1a45fb316dbd80864edbae71f577da8e399cacabf8f26ea54a3b5acc7b3d72b24d18f24dcf4f65550ecb0a034481c89344619cf6b3be95e6c77f50cc48dac1d48b827020701be2ba6ebd9a09602d1ac9d08d9206e1337f5fb71874583f7127f13108d823e1563ff41a3b7f27473f75ab82cb977d58339d38871e65dd2b9d62d8e81130c60b0b47ce826c4646acfca0e2e8f73af97db12de7c952efd3de21f2966e2cdba3b17c8efc71f02afc368297f1884b20c0501437fa7a2436322fa27cfc6d25678e4b04c5f312a3c2904eb88f41b5d6c72d5fec994f00e3b1c90dd370ab0c9bd7e47aedcb63b046a1a34f639ce09af8804b4b389c773a54156265109cac3e97da0342060c147f205c1fe50d702a274dfda3a4d5b56369bfb61f86babb6f68391b5f293438ca39ec868111a6f45e4268a29862ff831363efe948432c7b26d75488a2a69a57857ded185fb8d8f371f795ae9e49ae394c1d242222a18fcf46d80d3e07c3f0fd5264326c2fc33f84a5bdb9e816b249e4887a92f63331a34fe211a0e9fe9670ce465fd43ff4284b5fbe391ff0f28eec6dbdf076cf2aa0583195ae856e0e838058e0ab988736069c340aba1441e23ca3028aa0aa0970ac8524c4876f5e06b4facc2002b3c8b04ab2efae1291df4151b1c1640972d7250c40355ded43580151cbaadae3ecfdf25f0c91f340ae7203900c5fce758939c9d8767e543f9e20c88d7b4430558154f91d2031adc2edf36b8c292d98b7949ccd9e052c112fcb496ca581a16c87779297c9dd1e970ca826298ade7da79e9e0228c1e624293daf03b39aaf6813f17abdb25d4233108e91feb97236408c26a06a9c850be8d8f711596945ac2c15c36a3fea2d3b93f2282072b719f87162dba29e0e66479c13173920807a218168bd334ad1e26cba9174a24032390fe5ca685ebfa2debd6de2a35cf2477488f02afc7154ae108b32d01228b1cf1b6b567c2526c9cae430e23944b062acb9138b571f568c139af964f1c6043fbb27856c609ff94e8b1d42dd5f0b15d4998fa6ed9355ef20814fa8658c567c5d5c69b20ef35a2b3bf4a7fc39646fcb2aa43db9f4203ccfc3f251734403c1e66010dcb07f43df8e222f244d9181b4877af453650dd9b22e9dc15cc29028614bece63be3d844a95bdd787d3d733c79e1e28d89751544a882e51d45caff3f04f98843f721eb7fcf3aa4a9e802ec944a2f21e9923912ffc9eca9958b1b9608f0d2a92aca5535700e6794bcbf62a5bf2e8bdef0f1a284dcddf253dfb6d5fc13154bd384ed4a31d7bdd226c75e33961badb72b491837784c25bc387308e3d7d5a5e11a3e55c4e5441e27553ccd772255e381ec1693f62441fd57cd61e2fbb2946176ac881efedfd81c073921bcf817b398aefc7f426d7bfc5796c9ff520bbebf71b15fb5c7feae8183e1d230d4854a579322b48772c499b080c2617e223ae0dfd25ae26a30ba2b7761cdbac7c07ebec501a51a16723933d2c4b82e193cb97f1cf38c4ea28dc0042818d990f90bae158020ac04a51da945b477f13d1716297fc0255f6e8a0e2c264dfa7a298ecea6e4cc05fa4fc4272557ef84a0cb0204db29171d4ee3db0db41d6b7d8481ef43429519f6fa4b49d3a2077d9b3783847627051a0d70d2fff57e322bc037be194f6162004e14c4fdc5024d61b7250cabd5ebbb75b5ecf3b2aee5397f7e991b8a77a60ffcf9091c84fb676d8c72213d5fb2000628bcba0e22149128b2db73a7dca0fe74c1373fd2c495be45485c14f791c7549671b17e4db779735210173a341f9d1132defb2fe13384cf7c84adc529ef429f2212a95b395ea3f167fcd8a2cac34772e8d07cebccbb64a58014a915f48f24fa46597fbc5c3ab01844327d4ff12081fcc47c173405c37324425a420fa39af616cf3699c0f10f634fe1222b96105d4a609c9fede8c2ef370667d238b1f2f3f0ccebef590af63d4b8e85571d2beef76e06ed0ed6114a86651fa562694c25b1049302096540ae972d7a009a66b4166b450b0f9048b6dfa6bcc04eb99f78cd0e58153b6db75ccc5232b3228e12950d61c8fb67b5d51f3d7fc69cc16dc59acf29aa189ff5ffc8f528e580c6d9929ff856702ac6a3fe7d461534a1d86549fac20c1bf23ec1322a116bc5564f3a3535ed6a422743d104b9ad073bda40a7f116e0e170abd4228cab4167bc1f3a8b2f139479c146bb82a2c11c04dcc2d4dafe614391977fb4145c0f94fd4db8d2546b9164cdd806b32c47acdddb39f7e1753c0f61a4cafa9d5bffb260b7fe500b71d68643c3f9d3c5d4a2292200ca2fe2851dfa365d87204f268cfa1ecdf2fd2a74cf604a6ab609cd82cb16b9c85d966bf240166475827e94117aca8abe165a5403dbdfb30cee5cb22570f42cd20d4e9ac1a689baba96b9f2dd87969cf38821c51767ae2530201e73fcc7e64d37810e7173dbecf7c0b2308b4912ac2583f1c828eae11769576a785c8aa02e196c462c3c1ccd354d8b2ad86145d29d036b5deec0fd2409d73dfde4a5e56d4a78a62f95d87f02862bceba541954c8805db4e44e568c39475046f96d751bc36a95e6bf5375b3e80fd5dbd00981073a7e73577eb5bcf6f22706b863abef6462729ce90ef2fc12e3e9e04588d4cadd3ddd3308eaa1e94f1bb62ddcd357af00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
