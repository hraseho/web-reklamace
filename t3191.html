<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"865f7250d96eb5a74cf9dcff4407c4ae599c6af4cf88d3f0858ab13328085e022ff77a2938281970569f88a1f8144ed5f736a0de618704f461c43bb915c99c1855c02174bc928d63380f7c8091220cdd625b81de98b845e5db751134ff37005f5e5c16f51f8ed5f51d30ba470d416ff77d8600fcde37747f4c8070ff324612516d656212f30d90e532f7e30819635725a1d9557cc6344bf010c52d26f14c7537ec4a3a1b1a97bfd75e67ae9f3bb6dee5416559da75d75a2fa062a179497a694c95941104465ffcd967f297620fe9a51a9fc98845e7f5e40062c36bb1f38d6e23d073d8cdbc90694456de6eaae06c1c802bb3d9c21c3696494c9b9a91cc8668de396c92632369ce29ef75d36d661c5e72da242b3917a96156e1f3a649028deb07f70cd692a29742f979644115a332f4c67db533832d8d76fe7c4399352b9c53082440a89e198bb0aa122ae2a5433aae837da36d03005d4727c07de74c6948f4297df6dde10f4a320791da2d9deb0095b4f3eabb7223f5d3226a12f2ac6b55a16499983c9dda81c8204f0d04260751286f572eba013633da439298dca800bd96c74dc6eabd105d5a801ffd85a723cfaae265aad7a2c90a18ac7785d5ce587ede7e77bf4a54de166ecd4d250e52da99bd49ae35e16b1c5a830e4ec336721d409b06bcf028aa4f8f9710f8abd16fe4c87b4ebed2be18accdbb1f849daf1771d3d29db3e2947e4294592f85b19233f332d5e9703d99c02ad4836702e2b1632f44d5599809b67637677694ebae2f0f55d47723ccac2f9d337fe5918357432adf44ddec09551bb3ebb24d7b6f4566bc142a185e0421093bf782f1d8d3fd9c1f44beea3a132a1b194e23a4f5fb52f39cc6a43c80b6ce7f5f3d59320267a2fe89cef8f2a6c8184b5a0b451d73e16afad5563d0c5b0764fb38b53f8d633f1671b3f7d069283624f31fbf183ec049f939c2335ffb73f769be7c4f9ad08033a2c5cf12ae3ca4df1670781368d4b589c72eb5a5367bcbedda3beddc3de9d477437d96584196de7ee36dd1585009baaed3563263531d7c41711e0eb34a76fca19b83597a2a507cfec3fa8d54c0c849caf6859e4e849f168dc95d0cdac85326039ca84ecee97d33d5ccac7f7b582cbce95e6a5247ac97338619cbd20455f36ace6548e45e9e8b317ac2f80f4b8fb70498703ad4347b416e1be4ad857d7ab2c4a2fa7356f95c4d7f9b9dd21f5fb8e5d4e7b0bc77e5e11aee6bcb6c3a9021b0d519f5ff2179ba0d6fead4e3ace9bdfab99087eacc86355e5118f0ab3b998b7d2c4114f42fcf46c95110e568148372bc49b479f3ee8c594c9fb3f4b1216b027420eb3a794517dc24d87acc78008a9e456a08c7830529ca1ffe30ae9aa89713f41cdd5f8a45d16dc3135373dae18bc0619861e56fdc744c0a9e7b546eef4efc2e83bbce4be55325fb062bda007fa82093e4cc814b66b9ed5446edced41cbf1b05598d26a7964742b6fa44973e0cbb73e2b01c6f2a48fd49c0b21f58f36323ee3cf26d29f74c755a653dc1d042e12a29f61afcf8ff070a5e9aa8b6e9e69908df3c9e091316db00c4c31ec2e83c1864c645b0799e98af6051286bf3721817b736dcc0eb35e7e45481fa7c954d23c210456d1a7d9a7cdefd591499e3dc72954f1b53849a66bbee239529e1bab4bbb04bb1063909475d4909576afb86ca9d0c656df5f9317799468434b7c392918615c55b90b1db9d10f1d26b938074a719b22869dd1ed78beaf8cc9e853ffde69fb542c9948662f69bb786513ab2a81c57bdd69f91c4c3721ec25d1afe799bb4820bfd6a2b8d7e603a79f2078692ea3225f1d59900f924618f238bab9766438620e7ce9fb7e1ac2a94b2dd4d2847dcbbcbde2f9aea5d8b448c801841800126b8d1fb9a7aa3f4cb17eb447e51e3e15506bf5719af5cf3f0873df74c917d68b28500def0c79f28b29e06fd21590e6fbea5713fa9ebbb6f21cca041a73fe462d06e83b4614962551c128584845e342d1a70a0eb16288b271e4be36a5e974c0b6d907f07470cbf1f9bf996995fcfeb9bf4a485bd5b586bcdce1a0003158ed9f712acc7e90d97c0f350acecd0f04687866887050f1ed0d6f7a9b92c02a8968a84d7cd74795e119f50bbeb40d4255ef9f67bc8b4d3e2035c6a15da27c66fdfd65861b38fe3d61dae92970be28be561924a1d397b42c9df978cdf5604c72a86a5a1a20d98fcf15c313819a4c929a12b5a9ff2e8628183da900fd988c8c62485d06b3afc713e7cce199cb36a59f7cccb84875fa882da51d4d206552ee7baa41fb945a772d994ac655d60e12a06e67764e719afa8b3d8a64a560c8e3c6ac78a05f3b4393b1342a3d6ce1e5a6c8d8d28dd84a3c61204d15f9aa948e22a38b6b599f6c7165e4d3c68eb81ecf019c06b985a80619bbaf16f9d917a1526a9f1eeff61a0b47f31eca8272214e778343687aa12caa2b25ceaf9632d7e86368463a127403baf1e7e2689e582165d38dae96b73c3b2af20fa81e11932e15d6e36ef466100377729073982dbbe238b04b93ffe6c468f3d2a2476fb018e3ac114c8f7df5c83317e32deb5c863ab3c4139abc136a1f1eea2c9796e7f24cb11d6c93fb88f435199ee637ed7a918c9783736431309995a71c6e3a7fe1f85b41667cea05a60ca5c0f2a8b44f591d5c69aaf3e7a538c81d43ab2460f9966da97a23932e829ed559e9c47902c956aad412abfed2784a277570cd0c1e69f6527fb33f2405b42d4b8c529a84e366287adc0bfb4a3e9caa7ed7cdf387c23da41eaa80e0d2c70ff537b6bf75e7b78e8b1891371053c760855ab3fa47a26258da7ed1916bef0fff2fe30ed97d06b224824216b7c8139f001175aeb1c12b981587b628cdff4c1386a788bb06367d09c80e8dda8d8c4cbb638cc03f129332de094d3a0099eac5c4371661e42f29409e488a688c0fc11abf48e9fd0b995268a2b8648b6c512844e564d21ce4a44eacca42897bf21ce1757f418237404f37051f3450c07a2736239b0d1ace33587914556ac3f35008182fc5ffaf1845577dae6efe91d5ff03a4dae861432142b7977e51d546531c346782c670b400dc04d10facf96826a66ef69420e125f5f231c37a62617933bc84e95780b92637a36e3b1564f0c9ec213f939572625c7f44c823f9e1860901367e72ec542c26eab152b315940f82939a30ff65752f32d751fc62b1e3729a370b5a8e575f1462c6be586f80bbbb42c803df239fa443aa99da4a612ffde5fbfef9dc2701224f5bf34dc2df9724301a5acf6dd028b4476e5ddd22960df75151ff6d266386d08cc111820cf51df4e5dadebd7712856f1dc16cc350b391ea274c94283720bc3a1ecac824090f54eab7521b358affa0319e1b13cd777424708ed7d2870c72404b01ea60caed112e09c493e3435122429246b6484560a0ec406decba6932777e7ebbd6291d27e901740e59fd836244a91859bffd1137b97532957ad507f68bd08d193f5c5ea677c9aa64b18a1cf35c3e45785918c4cda5c1878683d0d7de407a4119315244f6d80ebac35bd5ec2a577acbf0bf5276fae4ccb087830db76970017c42bf188470e13a20f4449eca8e0eff948be3dde40f410cb42f4ce33ed59ca363734ab88ed5bcf8777fe7e44019ed8b1b3320962a9f99b06750d04da14e6a6943be8ab378024e65cce683e20c60c74efe0ee2adf168f286316544edf4a0759800dc8d10074ee16219a3c350aaa599365d1b85f1e88534cbaf7a7e8d09eee310b14762744786f76191a3df499ad60aedb2a1d346cdea7a8dcc953aea99bbf0e6c131ff40fa7918aacc31f655a6fd8ee2a958031d7cd0dd6d8221470c4a115c0d2efd6d079a1e82bdb9393aabb66af7d05c5913aa11bebb50d20a06872a4ba39a2d94d5031d4d6cf867082c697e8294ad3bdd34c4208bcfae7d036f6d2054b9c12c12b7fa6272ecf0630149a945404f893d2a7385a782e5d9a52c0ee7803296dd3cc1c6febe1d88354b400083a7a2b764f98c2a520ba53ad58a48c520702f750dee7d394555d484cd57916965ec3364f14494ddfadc9b5088b915646de2aaa0dd208aa3620f73dbec62cd23b2e0179536ac96b46784c54e0075ce5f08166b743f8d2f5ba399c7f6ecdf0447cec75d3ae81a9704095799b706c06f1a9f74e37d8391c525eb6de7a0022e77e6ddb66d8cbf892e813d774d42a1b333ed51a68a779497b067ce0d7493b000ac64a27ef6250127cfe719abc4cfe10bfe12e35ef7f3ed02341eb533eda6c9bd72df1fdb7047712aea4cdde3272ade04f568fe6db6a58ac8efc5f0cc06847970a69132a7a9d8afea0de99c52ae2b366f00b9c1aff1379f10d51880633b42070a364ffaf95fd2575905477a9d7c73f8d8193a8f98c920bf53db1cd67e2d9d5f7672300fdabd70e5d5856ff08b153cb8bef60b0152e87e597a13bbb6b871e02573986f2cf7d2ca64a88d93f236ab9a314bdc8dac800bb165c12dddac5fe13c445e82449a22fd7d281d1cace83a2f4bf4a1754d23c5ee02e080f1da7e6a33b5ac5fdef62fc9785c27a4c4e5216cdf09fd37268822e140ac5d6cf55a9ab7b112f8aa1efd0fdf1d269b702f0ea6aa67a45720ec04d082120fcbfee87e8e240d1776e08044307fba01e17b2360b79c33acf4b42cdf4a78e7055183219cb612b3849a9f57fd3456a752dee6cc0e3213de9514ccd235b5389647a3b2ed7b55889d93456431f05838a4f9b3c2365923a27b688eb980d718d0c881be63e6994b9935aea2dbe51c2cd5f367533e9d66411d28b7d11af68466081cd17e78a90d284cea6ab66fdd3f9ca75abe5320e905bdaf47cf3cf47bdb92b5e26bdca7d03a9037fcbe955081803763c59d397796b1aa5a949d458d2d23109529edafd049ebf2af0a1a4624f39775c7913434e6e2f7cc3171c171e7824b0bb416370db05179271640259317d3b153b5f8a2df746c330746635cbf4a7bf7b749f591832e18e7cfd432a9dcd8d0df55ed11ec56b5de9971e1c7c664a11e645eef3ffe5512240ebd60947c058136bc76d4ac4a62c0e31c17414e5157dc3a29e9e92f0ecd90d9e31ead7e3c6b26e619f3fdc93913f3e95602fc437277eec6b4c708e4bcdac685c3fb6be360621c3854b6b1b57561828217e6cc81e91d031d76efb43786711871a37d7f7e1e88b0a222ed1a2e03b2bce716bbacac1012ff06b383830b6b45caa289c46027eedccb38682f301c2ca60316bfce16ac76f82f6c7e3c8045cf3cd92275178a5ca06c0d166fc72d43e7a3c6e5a7be813f29799c872975c5e69c5bd72165c3c4d2defca84003ef9e62cd97d4b69c9770a42fdcb149c5163ee8857fc8846dcff0eaea048712a52fe7963d5c1cda7bf4f907b5a672096561cdb80120c3538ba679c45ae07bfa4460fb48fd36afb0e8ef06a8366d843fe811d0f5f7e5b437a98b935208b8ea426384431c9b5e6ac38d7810396d453b4b374bb1d9fb1781ee4f4dfa1441cfc7f6781ef6ba244085a7f7668ab4f87ab60cd8fef845ff7c484c7aca8a9891b1393d2762883d97f0628a526711361e38d7bfbc79e6fea9edbe0fc3c3ff636437864c707aaa1df6839ff309b36e215c1c414d45797c1000122ab893fafa80f597dffbd2297f355ef1abc4c340875ede37dbecabbd048d6eebe35b655abd47d6039cbecd001cd032dd7767ccd1897cb1454f8509e7c9a166fcf5ab09484a821e8fe9533605c16f024a3bc2a3c9385b69a220b2d5b7a45cdc4c3efad117139fcc57dbce731da27e25fa9cb3aa674e09ec087d39fed9bc1b96c7b9c3ce6815c696c79179c4cc5d66c36a581a1879f39fe9d21b449b1a964ac1beb6d418a1fe55971fa6fa550d733b21a621a0e4cc502adb981d6bf755027c25e798cf58c8a6d5dd5e09211597a2bf3e67878e09061a38b36d18c1632d9512a6e44fcc2aac007d339458f0373eb8b10b9bc903e0c7878e8b8cc2286cd179cde2b9c106c199cba0c3f89203892069b4fdbd68ff0ab29a0faf6c018a54e5774ee1ce30eb49183b1214242fb0308695694adb21b0edaf30295faba90ca5cef7e82219a1a89d076c59eea7e4f7939cfea1c2670654cee977862c15e68b95f8e2ac9a98e13ee055fdae071e2bce93da8b01955ba7b02f7691948926426aa3f375dd84a3839b74d6869b8712b75404bdd5841079aac07c5475aa006098676296b63e4d8e406422020ab80455386cbc55ecf7e70e6652296bccb8d1f4bbe3ecdf2e5d00efe5fd28d9247901c968b9691ee8ab37dd26eb1a73cc392093442d9f960b3072337a156626c443ff0c97d9767d0a22bf5bd0ac96cba616f18275b289ceaa56d31239f33937738e7fa7f1a6d41e6771e64caeadbc9499981f4ba94f197530dde0116ca03a8a202044ab9b8ebd2f116aec8f410bf004c90a1bfa017c201b19b6b82ad171410d059ba3fcdffcae7f3303a6e5e1f7a3f1906cd1aa9b5d38f3b7be71ace25035584aa159d2e5814753341a9533d837a341de179fa4d271bd55db6e28f12e5a91530e759fd82eefbfb0b5e52d6408bacc731e78bfc1b3e8666729535f51b9a8125c5ffa5a9cc6960f5fed9197c0d554cf989ca7ada3c2986da7e405a9fb914a84cd0cc22d990acd175ab8486f6dd6c70ffdf9e7686b52a92580f5317467cdd5cbf037bc3e31d2814cef7e5b4f5e2f38f8819a322df98a887e089a546bb67efc38a82baad868aa19f70af09d63ac9932cb743fc27187b61719a6496138caa5d0de22c79fd514c648e06fc8ec7856a08a545b66392c66d926ca3667542457be943d530f7bb099407312021da091f644e119af6298c797f6d5c6b741b9c62273d6ee6f24be5dd207539c0b8a75b350fef01f8782c1eef8ca957ad42818ffdb2096f91db5c071b19c907b731627cd4bcb0f5145626cdaf81321d7382cdf2138b7d2a801bf3eb37d8f851e66a96a9f23d2b9ff8d4e55d2caebf7e06e8ef4a597623cba982fdc965d94701755c39de0ca7eb9a821918f33cd06bb639ed1c34822c7939409561e89a3cf1f3ba470ada636b2cb04c8abb392f5813c07767322fee534206230662acc55f867b350c286e321677836327a655a8315ed39fa4e809272abc4cb55b54f8edf21205a5ac953416e4daaffcb36c70992f9a24d8b77a8950593bdbbc3513693aab98ebf9efb6ea79dcad8ebf18df40d80dadd09b7f6fef5c018261d547673e534e1b378196bbd18ae12451c110995c939c323a8293c7852db2533954bd2003eb5591236e037e3e9f50d6c1cbbef7b24a798e1211f3fde98abf9b06718d7499f0ffb7aa732de01914512dd27a9d80a7528542f8d1cb041e56b98ad9f865ba87c3f4c161cfceb82f10f7f83cd5e787d452c1903121d216223d8da95d4fa1cb56a0d871c7617203dfca3c0a353e612385047d6fa4eabed6b0579c9bffb496b8c4bd24b84edd36e86f01a53e0094bb2d836171bd39594947393c351903326e44ff007e0bf5c3e73f3bbe383ebd91ad8843115348bcf04e575b6de9998ffa24f3b86b539965612df5cfa0ae950d8577113f721ed0f4c47f9ea7d42bf281fc02a46796f5dc8ae2a8de40f397f782fc2c2bea593e8d23f89b545f6b53674db0c571ec93aded89ae6e82380e28deb6ebe69a7033d75e944667a56ca58605f2c295844d99ccb10c9a852786802d1a5175145d24561ca92c4a40a6547a32d58abd1dd0b594dec51615edb0f645c9f45fb8cc922b696da10ee5ba1f12d49a5a02fb5d402575fec7bfa634ff563d8c2f6a41935c8ee53a9561ccf40077dbe9fe93bbdcf1e42d4344c8b50c58bdab31934a3b40b06f359149da506f4cbbd496ab4438fb65c770fe33f0e6d7b084d8b7b9669fd482e8c69a696afab4afa4bff621c3262a9c88455c0cdbf897f84c14f14ec2ac14a702dd9f22c6cf588ec88967e5059d4563af0f09620534327fcdba7e5b7b698370a9930aceb1b4a5d417b49e17b530909b83e54238aadfea458657ec3f4aa242e2802e15d51e476ecb2ae25bbd483aebbeee66869f6656f8cce0eac2e4eb22e9e1840c612be3213d71911c11cd8cfc275ed561b06b226478d770ecdb7dd0c60c8107736fe415f681951a8b892d6702a9055b9799d839fc71efcd35f961dc7c3f3d4474f4cb088743d7763a79c618fe9b336a49d80164f4f6a3f9414a32f50756ea411814811090398b69c3947015f665f1b5cb789a1bea654ce53a610aa0b59ec8544a3982aa3a178dbb0bb54b4e451abfd60ade82c5ef7b8ce397897cccfd5b34fed107345d74a227b066ed0537e0e00c066066fce989d6723c85422eb7bd22b6379b9782fb11662e93fd341dcd4944e3ff3d0c3939bc868948684755b51ea3df469beedd36788163b5facdf42ada5a437e5ceb922c75e2b372f54239559934b107647d6a24717e268e3a6381e00ea6b7a0060cdca56b9c91fc11a3bad2e6b6ef75ffa972ed6a11beeca493770867a0a88017995f127f37949948e03b523c0798fdcc56014ed14b9e789aadc009e47f2071d48a5a18d2345ebf867e59e1bc09479048d15c698659d1d0d79c7d5bb20e3bce1d80794094f02a978689ba7baf8cfa38b88b3cafdd6a096b1d8a7cfaf9dee17f37126a89abdd9f63d2de2dc56af66e0c549b04de984f774f042018e6b8c01098097f899a14a8170e0327067eccfe4441975563f25ba58f0819aebf51a5d240959948d04b664947f363fd16ee09af14d8688a0caa72e1844838b2afcc2e0d5f5013e50fef5aa6d1ddf5acdb364325a94e52c4786114207af0a8e13666f05f6ad531488bf9f3ba26044e5a2ec350d943ebc04db568c6357a94303f900d7563c950098830a6e36893510b0d30256d2b143c96efa5a7c7e06c136d64bbe0039a33043ba5a864053cd796d9d6cdd41f86a9c7b3df5f0c22f901a147a720b344704f2cb4e271170737c531fbbd6fd35b536ec34b26ccd7d957a514c13ffe1b3ddbc4a2fde14794d57ef95affefb834ed28442343b2b60863afe8cba9bb29d71c345b9d96aff5e8fe807e19b00095b4034301ce492579c9aeb1bab81277ff227cab0e641d1d06b0f46fdb847030a14d26ec013de8a2f38a059a98ba9e062d342399d51adae0a425b8b256ee05d410a77cc7536570d2ccce7bb5e4d56e085d13319157113eab29f48e701b76d95709133f4a83d3c577d236fa3ec50e7d9e672a8c817ca547a8bed024633427a6b40a34a54ec973644dc4e92dcd4ba06704f2cd48c47147a893d211a2d433c78b85d84796faa6a9ed85f227826ec52264994d087362ec11baf8a6944c47ccae43ac493ad8cc3cc026eee665403ec6b5089bd0ee615e2d60317198cbe1a6aab51127315636a1cd15d68f446b5ade3b7f360c5a29c94cf69cdbf277f0dfaebd8b6a4f0b016de1020a6e570acc946d51194f4e1127013cd5b702ddabaaaa6766cb9e6adbd932021d0370375454c3fc52259e6a17849445ec6850c37d614ccb24f63eb305f056b72fd6ff5f794c6e1219c8458c667bdfdf2b6a1001644cc893b8c3aee2ec38aab5864c20aaa4e97297f95faa2930c2a38f8c5f8c8daf20cfe79ae4e2df9b6213879b66275a3bfcf1bc4a77d9c974bbffdf0e51835018c1aaefe99bf884b9dbec797d610bdcd36b042c04220efceb608e86ffcc4db8e62574876be298510519faaa09274a04d6070504226e5a7eb0cd38b541f5a05825f5931b161465dd5860d72b447b1a2a527cd4f4471ac8cea0a1948d7798ec3a6131ae82cd84c313f57b6941e8dbdd1cdc465fad11b5f9d32ab8d285167e152a5b020345407d5cef4655c9f6ddbbf1a1f0ce9c04b22fd9fe56f0a16310e367aecfe8c2f3f60beaca47eb2fe907626b5acda589652200a16d252cccad8a6728331ab4081487a750127f3bacb193743d243ec9498fc6739b22a40b95842f5e5cbb1deeb2ff4b01eff566b35a3acc48da8d43c575e10abf94b7d8329772b4a87367d1db19e9ab00935c59ae8eee5bcc352debda5490b2db32570cd9ca3e4f88d927b75877f1e3e32a155b0600bae5c7132ec63ca82ea385b5b504ecdadfed7af2a888018355f3027cee1bafeb431ea7617c96818d8d5a2c9883211950000a498cd8f57efbe6b3c667202c5441ab8559ab8c1f1256fb23e365f8e01a78d7e4f14600c4a409727c1937c4acc23b82633af0deb78fdd3fd526a4ac0049cec5737f10f9989419900587d05a3b96a32a50ed9c6363152478e07fc09faf32035af71ddeb72742acc57b66cd187f0d189877587afd48995d10630cb10d4caa709d5b7dba6233e34ba75e1fa843d990d4a77cef3a147a49117b2095865ab454a0750404032a7f33d536c69924675fd323e75ec14a7b59e5a7fad8891902e5a7b62deb3db3dd6659d0b4ab31802c4fdf5871d5edd3c99e9d977324a6bb6af7f1b9624b0fd04ae8fdad318040d953ef23a538014d8de1d5deca3dbb061db4b35efb1b04d233c3c46aece9f6962ecba71c90309eacabc7dc6ebf1f3f91482fd124b7fa8e1363668120de2dd0776000eb461cd67c04e72b0518eb75775b1077ec8e000fc3a1f5932f65c5a7b450db7a46405a6a39a5b6bbd80977e12626f5e402fbe6c7443e449f02d827b6960fac4b9fe786a9861cb21d28c001ef4bee0e7f6b2de726603054023e15f38c5af1b6feae5649b965abfeba801a210f07af752226c6e7030226f39b658250a8b3114f854a9213aa6df3858852cef12879280f626d1229e6dbfcda516ac2b48bbc0a84bcbca5eb787494463fa1101ab8cbe944afdd37fbb181ccb8d84ec7592848207a280395bb7b9072958250b6316bcd85e2e4a5367d7995995f23d3f0fd783b7366c70f00fd1af4752fdb7e34e5d08afe870923f347bf9a87fd086929edc4036d5e27e61a29a573009e558d87c85d60b6793bb40fbc41f2044b5bfd6d604c85ba49a3fa584389049b50fd885de7b3dee562214f5143f97677aa0e2d2d88a000c8718a5aeae4cd13f9d06bf171e1c94724c6c13779d3662f41d8c45d3e0e6ae6ff6834bbcda6fe324765042865e923457b31209232d9f29016b5ba683af5842f834b808c9c51660341ac1a3ca036b39d401a9a755132d0258d01a5576b54ba2cf65661c1a2c6e580a995786b4f561a31096909d5599e5c2ec5c958bd53e2598c6b4f2a0902785740c2921f8e90d68e64f34de9a253abe3b0e03babba7f48764a992de1a2b0d9355ef28175bd1e498a6d24456959d12ca3dfe3b5c5539ebfefd99f14d66c1d04d7f37ecff51c3c45be4d1ea4d74bbc0af8388aee96dd011e67950657bd36e97d790aa47f04d22d0edfb7dc7822088a809b3fd244c953858563d2a264bb55b01adf75fb3d4969e8b95c2faa29b661ea77af2be46e5e158a8b3dfdd52c5806e106c92d94ebe4ff631fbde31055384f25507d85b945a48cf7dbe2662f9c33946c977709f4e6f5a78afb7123666f58f78e4523345afa967283fabcdd315aff5883299ae27d817674ee8580412794f82243e632b3030d6e3fa61131510bf7dbd11b987253044dc59bc0c7873f9ff6a3c541a5afd78bf481f4b56849eb9b9bf19b535854ee7c6daa820a38954104f7c5b146cc16d8884f0a7bdf1149580859936e41126bcb14e46934c8a2d8d9cc3d79c0e86ee8212c6ebd72f2d72d9cfbfbf1336d935efdb5f92495b1fe2a22cc40f08d72e73ed7c0bebbcbfb43c23e24d5d0b2635c2e8ad93bdbd8cd6c275a6d77475032cb56bb18313d2b756956febfb7d3751b5cf1c43d8f9a0cb1b15df5d19f073c7095a0b4059d2c62c9e6b06ca7630a4e521b0fe9f1a6184d118fbac632bebc52cbd8710f905e1c42cff466df94950d0e6746b5a3e0a65fc64f94c5e6b32d156c4e93ed5117ca2461b0977b41710ba072b4c38f410e2a42b5e6a94a06a03239100fa79baf28957678d42e72d711e6e834da556d319e39ea350adfa6b32bd2f091a5bf6691f0a6c93f7b96290c31c2db35719c9b1476d1cdf7229286596acd42dc836ecb18d7191740c5351066b7b15ff4ea7c8d3ed848e33e144e904bb6a8671ae370652a2f195c7f3760f8390fb3616bff730289d7366e344a555649e1611daba387d6bdf54da207d8247a821dc7757ebea26b836d412a0bb4416bbd1effe645c946c3e5d64b85d711dcc36ebae23759c9cae1dc9ef277093c46d514bf90918129ef3fd052d40f1374319a0474a2dba5bb01342bd69b4962c6e5e0017c2e55a724e9ff00445d9f3471ac5d7b4a81c95a8533ada78b8186411cb677d671ec0c4baeffe47d550b56eeb4be16eb5380c51022b8c4bbfdfa0bd5bf1a2a0608642014af9d8ba7ba8a501c80a8a426eb49ea66d40209556572ea47445f7b3bd25a6318343bb9b2073bfb7811c3a053162677e4128a9c280de2fe36dde645a8b4a2d46e77da5a431615a41868d949728d64d5f4d51ce92669eab64df9a83c923d0c2a8e9145edee87a9b976a1f73b869880dbe7aa7f7f2a8110e77682488140a6379010be1de3f159e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
