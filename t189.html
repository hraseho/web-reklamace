<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e08ffaec03c9699831ef3b2cf953e1995f13c6bcee26914531bc1787273d0effdd93881f5d469d584266a1886700b62c1b328f1d5ac4c4165cb0c42345339aafd41c24e6930d7efda48a42398459fb1b44460602c27fd9cd8bdfd30815136d5291029e3987f7267cdd7c086520a6b88c8bb6383b8d42cf283a48a25ef46ab9be2200fdc890385c7b9cd1e283a98d8d82d13ff8a49382176abcf282b437399eee6be49bf47c0fe267666349a490c7739ed24222dc151a13bfe257c174bf95c17d37e188f0fbb8ecf9040524a29727f3a1bed483cbf4f7eaae22bd9bd4b23fa885327cbf770f654e6c0e2b4df9ac2892bf9dc881960f9e09882fb89cc2a98e144c1e0c3f5191250ed01a2795bd8b2ebd6d6de76f10d0500cd4280bb74c172b56f15a062e02254aebfa426d8c9c26609298e019fe08ffca81e4e4ddea7d8600f288a36177cbaf25c1e9e6371c2fc95ce6ea8f00de1f6e8a263675af5969cd5c0e6b0c6fa25176cc5fe0621d2016e279ab579bde60cd99fe324ae13b84312b620789d56e82e999449686b349e21805ec7ae3a95a5869fc8d92e153f5fe778e4062e42c546bea7df201863ff1c8b9181e8b0f6c09f74a84200920f58fe88a36958f778118ecd0f5623d2bd8ebd8ae8841c83e9b927561a3f7e3167d676c570adf91d969c4beaba29a165b99c36828274b70e9b784badaf3ad629566e846de0311b5971e702b6558415676e4a98fadc1523da737139c6482af9071ff48ba6d854d2a5a220c2426cdcde4a3a6fec9761fb390b5ee87cc5ae532485d6d5b5cbfc6a2c4e74e844094133d6299eb87eafb5c30038405798ddf7b78480ebf65656e22f18950af67488e3af753ed7177ff2be286a345c4df4267326d3403862cee0928abc416725fc3da72ef71dd3538e103ad6b62b2c7a92488ec42145bda8af173e601234756955686452521af5255eec240bf4ac398e45233b960d78151876b9e89f20ef3d1bb9734d93805b7fc30d220061ba09f55a5c70800b2875b67227e13387e839b43d8e0fa87171c56e44d58365bae0e368a8e055e0d8017a9540d68680625f6d7fbbf5424543ee5b3388adc8b49b0238ba39885f4637bb6cf4baca2fc3da5e5fd84df92646c5f00691768262aa5b7dc9c63969a0f07f8abe2eb24cb48e65d672b0b83ccfa7b445cd7290e3462f6f8a2b335a5e0f7d65182dcf5fc349bd756aedf3f6108e28b128399a4263c78f6c6e51613ed00f730067c629ac1c820c7bbad8e6dc9f9033db9b7bdd52b92566847eeaa511f49019f691fb74555f386201998a727e946f37f1db0f28b8c9cd42bd55c532462123e4beb9a6c49cf7509227d00418323ddefb347e25b2d513263702a2ee543a8eb4a15120897a723f376938feb74117f40ab5f7bfec94819bb305d99d1ca78d15bd3e6ed0cd3f0ce528c47f3695e4ca4fa9571354e67ba8adadd97c71c469b4a4c90e90125b006585d9b51ed0c5051aadd5a69923accad0c79040aa7c74f9a19c21c8cd82fd29c94fe0d60046dd6cfe8b546aa38835ae5f494315478df7f8bbbb3e14823c5e6cb1d610a80cae94d53412b49120b2d9c73f7415be4dc06459844584a6e1bf2589c4eb932edf3bea6d2300391d882a20e7e0303d9fa77c9b7e9998b29c2c9459a695bf2ca94ff3076bf3772ae6b19b309a69c517528b3ea431f5d8ffbbc66fc1044bbd6230a3eb9f6eebb2e2d6a0f4c1f2b04b088485eb5f810b658b88ef5141e76ecf47fe4d03a5a46eb4920b2b9a0b5fe9a6d43b31f4d3be8554fe9eac6df086bdcb11c9e9fc51645baf7e1a2143797460770405bad3eef2897fca7e9104a808829628a26417967156794bfa1f6b408d6aa2b28d01b652675aa3ea858ef0e044c870fddbc84ffb0dc3262b3c0ec738e8bbca7af96e9a0aa9fffdab0600cdd538e36914690218ba1678589d9a6eea9af19c7b9c0e297765b6bc7525265616ab587300a0c4324339a46d2c1d8f8d27ab921f7c7477a6300d8c416db3b34bd5ccff898e9cbea6836323764ae451636ffec1f5b7af31ce0ca137456b7b951e227f02b023e5088b324db16c314bbffa18dac472adde311bd03d400d0001005420b53242a90b97a22a7e5bed86d304827e3d22b7f0e5b4924d763f962bc7d4d1696f87491e662992a1654e8527a6cbb84a8dcfa2fce6c960a64cdbda8f858e201e0a949fe966eaf0d592ca6cc3a1d0c3dc02d24c4784f1028e0b465b419559db4b439f10beaff7505b7cb80febed73e816a70bbd9768cb298165e66f192e5f85adab7d3970274919113a37b1087836067681866ed176b86446584696591484ee78e0cf1beeeb34ee5aff619c4ddae01781a5f037065876fcfbb77782046a7cc5209fa6e48f88fa5ce4184b29ab759ee0d31ab829fad8c91fa6cdeade38e51329d76ee2554f31cd0b003055e6a3430af3a7b19051a899ec7dd89259dad36d6f09e9621a9e1101f962f417e148fe760c2983338804086588df86958ddf1977102bef9f78dce1425ba3934dce8bc2a83a18047c9dacd02d9c6f3715cf57c5077423790b14a92aa2627de7f824631f739438ed6343c4f7b70ee3c6131ec53d753b0526f93de4d260a4a740006778918ba57c327c11b19fda630ce71240c3821c86a78dcbd243ab45b5f54cac8951db23bd139886aa5c468a5ba31482acafc03d161a34295b89c32b36706b2e5bb6a9e4de28daa4fa17790a1172c1f5175e80fe3fedfb634daecce003424f4c30320ef7a438014bc2e0744632cfffda67b2e773a14234817d30991ba7bb632f4474854113340821da5cd37ece1a6ead79809f572bfb3eb8ab25ce06d4ab949147973c8a6c37f782db21754fdcf4679a30433613f6c642310159f36d6dda4ee8577969893322f86baab85c4a098e12ff1f12cd5fe49f7f75dec20d62ae5231f1a6069a71b0d681e22419ada21374569550dd1c026c9b6424e2859a01a14d96feb3eb46923699660bf8840739965e8791995576a4f14d644c1e6ac801dac3a5ff06b63f53734ef59d67b1094c6b4bdc0fcb074f846849fc832ae15cccd241e137d08077b380903c7a01c9c2a961c647f620d4c483e1a0d2043ca81dcabc394f228dec817c05cee0bb17cfd5a5b93f1f6605f027dc7c32cbb20e85ceb314c2582741f3395f7a7b7ba804fb011a7df2c31ecca9b0671e29524164064e4d952e90dd4648f963ed2d7e04c42658279b726c1526dd8b04627aed4fff855528b61230bf418cf0dfa1d37f6ad7dd96a6ad5e416b82b9dd8ab7207acb9860c291c0ae847d6d03a07029587af263dd372002e40e3926d4a6ec77f1d708f54130566eb476c9b315a1e480f2ced78cad784aadfbcc95dbec9180eaf60c58a0e7e84f74f9975c1d2422c35db75c51b27d2f2ca7816f2504a6a09af93cf0ca323f1cfae71ee58c65a153b1a4fbe533f34e45b858a89f8df08c52338cc2b40df1120fc47b2983c17a24e658beec58c5bf21448a037b772f5a31061d8b94fb7a5ed3d7c1c1c22635c0bc9133f93c5962385498d17bee6abb0f300d69f162d9204a65c473fca65dc430e6153616293e1939e7aae1bb34a986d263f769a182ea13378526d23f8f05a8af937486d523065e61ac92e632352932158069950f920035219acaa8588d876f013e3772ddc5750c9654a34e98b4ffb9bdf2249c995a71d84b90b1056820fcba4e12e54dab9d518f7645a7f7dad111f97bc577744ca472fc6c89cf16f1b69f46d959633ac3d092f7010d9bc38a37c9168386d3012fa7dde4c633b8f9f8fc8d2df07cb6a0fbc633f0e3f9efb20adf16ced9e620ecaafd7eee6880c3a2e01bb0f8b8ca8be49f3b1be0030466d0e1002a6291337f2ed1410e375ad2168435b1caa5de4a9de0c21a66f6bcbb9825e81211d2f22f753f49d88c3cf60052100a76a3eae03c232bcfd7e3a4e4bfe61d7ea7d6966b706b73fc59faec2b6ab5bfce7b681841de1ef380b6882ccc7ea5aab276cdd67117929218ff845213c27bd7f23328d23a53e38f92fc952bc8952ebc8601803d199684d80172d13713304e8a1f2e058963c9e91d685f08f3a836d0e041365a241dc491ec24c62fe637a5aeb9b4ed4a0e51dbc98ac5db64945109c2ffa12918263eac53fa0dc51aa57af9facca19ce248a20b31049e2fa71cf27cb62e2ad1dabe849c21fe25e9d13852de55bf8a53e5542b91e1f235bcf0c605c2caa3e96d74a38a5c5f7a912ffdc5d07353a1abe4e22b08a0d13bb560505573977ed7c09a24a22e4be45e06b4d5585ebaa718556cfd5c49793ed7276ecc4ad8f3b7c2d2d79bdbe9b4ccd7763585c4ad8c02258beb390526492c43599ac12fd65a43d94c4e8367110011f97b328189d482ad341e96f17cc786d2c1bae420aa84bf34f3dcae865bb3f9a171021bd0e33bc5e484b0ee5d64cdf0f9fafe4a0838dab9a56eb6c33e5530e7914275c4f97dffac040b191ef0df4147ea15c4349972f2948a27e088aa64bc5f41cbf61bab0f234ae19384c25e5f8399f0b04197c006a1cf1765488428a4a591b452a3a6cc255e719e251fa64acd121db0dad2de70570355b8db8d7372d34e6c80434568b6984bde84c579cc004b99ab247407e1b86fa843ee764c56efba147d81b0875a57844f0f5652406870b1f2370028e160b0a036b0c2b033c7979333554d05bb667a25090947024655431abd95665567ad565614742bd104f0ed7ccf243c23ef85ef1fc5be8362283cf0a49cd8d552fd7a8c11662dd139b43d4e25309bed01eec4445f5e585e296f98b1e2e5bc61f8583815c6db626d804f492ca0a8fd02ae4b919582810a8f5bdb6f70a13116d8150b9bc29d0b5fb43246105160f166638a67bc92a4a8930bcf3d7b6732b38fae7b7e97f31e15491827edcf48d0a9c4edd603d33c21bfd61f8594c4475ac2ee1b010069e0e35a8ec3d1c791ab481ad006a355b20fce99ba40b3ad8492cb78c107d1675dde5dafe3eec201023a797544d3c99b36e432f45c8de4ef560da55f1df378b61055a1a364cffcc9b213dd0dc68b1b76f3f24368591d4078e46dd0559cc074020ee8f78d9a93cd0ae20d5cb6c408153ac9129f0d3298a81839bb2ac6ae475423a2862340eb5d1424f1ecef55433606c0654b92ba02dedf72dcd0663b02e3f29fbf010c25dd03043c37fcdbedea4b7e34d17e12e0e9d0ddd5c1d46e917f6c861f724fe423040cf5763be06f0df1d14f07d456f4b61cce4fcc445861de68e640095690775e765c39c20e9d255bc07812b60ccff0bcc2d66e309fab485e67a896b5e175eb2bc39f15b0117e3172fa51b41a358585a46c019e23dfdd1f06c3a10324946fdf11a684850a9910f5ffb02b98582ac0e09f4fea988249a86623e8b7ee60e15b207c0ebeea1beacd60c5adc9c5c38bfeb36cc87f85dd6e9c5741518711ecfb6f4fa2fe44e84379db5220141626bf5a0d8f0f2642497ba925ccfd9b377a68722c456ced29b7bff10101ee0f35c13ce6911c43c7c2b553d6b472e82acdb5be658f8d0c8c52f5848fc8246473ae274e9a2a5bd404052b9fbf4ea828d12cb9bcb09d436a21e2fb83d36a3410a5a0755a7b3f475d722bc02c40896bb2680362ba31f0619d891e23bc0c9e256db9e2fbb40e77d7585822fa0c22e48996dd14b5bf74c3faee2337679fcf24cdd6a4560791bd50e958a23278e36b3b54c9d9bd93b341c3e430dc6a201e1afae24217874c02b1e044c3953be40863d490ca389ea83fca94c2eaf52376b9df49f997adf40408ff214f2452bfaf86464f72324396b2168d68abedd71f313b31f40a1aa5174e24b6f907acaf93f99ea740ea6ae0b5b4662c048df70ede2d0a479e2db2694945f75aef686deb6887a197e955563af52edf0d68af15419b13ee7922a5cfd5c07b19f67896e439d24a378e61e5f4a79fef2307eecea70c086cbda0f414ec119446e6bb9623d6ed51c47aa7bb574364db67ce7136028729c69582b134f8b1676ef3ab35651ebb48d837c3a931d6a54364682efe6e2a93cdad179ce4cfbfe09287e671d22a377b2e5262b2098f503bd82941eec8298109340a0203ee121dd6d80cb9a770ec9e2a89b8c562d7fe0ecbef4a3474b39b1290c4f85ea37044e457d5d4c490b1f41fd989a55e2547e33138d72b52c1f2cbdce9dac31d651bff9ac834bc27018c9c7344d750ae6e833c7023520b8a9ffac58f571a2178d537d288317d6af1148d02d2ccbea72786f20372f5f4b77cbe898c3a4f00e669c5821be65ca1eb98b08f10c1f169bef0af2b3a0edc0b442effe4f7e41987a0483cecaba4030f622070a8b1d1027904b6031afe5f2bd93291ff50ae2214dfbc46fba20e1184ddc9ba1d518221513dab50248e9af477b35015d3850b8515b50ee2b6edd3034bb00731fb91144ae22d2f2582bb7b48bf894f43f95b3d4044a984580a6bfbaf285f837fc89cddfb6ce5eae4e76d1022cdd25e65a4afcb2abe67789fc87016e6ddf1f808868a0ac251411e23bc6f9172afc9ed839649f92fe4d4c8248a9990086d8f02f9b7f594e703e2f4dc0ce1729d88b7a6170a1bc03366d93b4329f85f4822a648367bf4ca26c0866d397c9d2fe322f0cb966baec67a5b757a3eb4d0d8ceb1e6633875d963881188490a400537d3cb48427264c1c5130cba6f0e332aaa39e0fd1adc11253b6797393ac11a5b4c11c7aa3f1579f71e2ad397fc9b34fb8376a72064e2586e1a33648a696c0e02055d66451ffb4cc4233a1fcf694e92d14c4ff5f5b37937238f31de06553ca9fcf1e503a05822ecf7cb72e62c8f331bf2453e0a19d0614022e674d1dead2a694d95ab1dd641a4b589938f22e9a585aa5857460650b08f2c66919fba88d441a7840f449cbc7873158df970ef84a6ae6dc18dc555d51576edf16cce3f5c801d22ca45aee7f8d456ae9de3da70ed302264dcfe3620262bac09b42238e88ad9c18b49b77b3441276f009dc085897257293caa2ee8fe544666111aa6bca87d5fdc2fb8f90f9394d67444d1311d9535d59876ee29553772f10576ec0ff262bc9fb85c1b037e730390d5aa5d8e3c2b420ae499228611a831d9143485b0cfa5d76ecfa6a5606c5c239c227eac32fa4b69191309c0321677ec8857d0df8e90b086b3d296c00b9ae69293e8c353514dcbef6f99021d88d3dd6e86c8a2dd4c79dc7b22c8cdfa416fb67bd22740f2a5b0bd4ee8427c15dcd0440fa7215d2450420ea0136a089055cd960e07f721772f776faa551c1915acac4030cfaf95fc08980c8842afdf6486d2d8bbf51db7fede2f113589c359e149882e67dd44a5c1f57412985756905b582a59697e92d839c972f3888e6fcac233cecfac4c3ee1e167b7bb4cfce760a80806b0fae7d79d329eca0150b080057c81f184b0565225996ff6f7647f0b6ad6d53083e56dde081cb1b7dd9fdaa6aacc6a2fbe101bd53d1a6e37c128c1aa5739906c713483af2dd26923dd8797bcc12069127e27bcf9a65b380b9a1e3af3d5d28adae72ac051094b22808590db9db0b848482054c1a3af407cbdea4774ba1bc0c14986c628e7abd115e60c8bfde90a75799fc59f3a934f2db2e05c9b42fc88cff6895f2f1da1468cd29a3c56d935f17c9d283c59d941e2eaccc4de8bf2ade9e992ef45c75eeba4baf3f81b86bbd269886403af10067ced6f8d8e21f4fd325fcde77882ddb0ef4b1246f8ec6f061912e8c9d7db0f84e0b0bad45c589151cc9c5ee44fcd60198cc8d3c79c94e4982048f98a8d4d35e524fd235785ffbda210ea1aaf9969b7701c11234c2c7f6c50f5decf1608ae4fa20cab99b2a945352b5fb6e83b857ee02029d4de894ed17921438ee14573b6731dae3535262c0c22c4e2bbedf0186716c284fe813c637cafadbc9b6034dcb1ecd1c17630e4c2fdffabd01c77272b391e36c8bef922cb9838bae816bc8dc68e545d9c99adb32f6f04bcfba2fd3c1e747fa5c84dca0d3d1ce308333b603e73d962970fcc518693179f761709d417f350bfe3aa1ce4872483e9baf9f63a0158b40c0d6d72b2eaf6f0d547acf0d6238ac5bd600831889d14bab7c4afb36ca9e1114d5a2767f1527dc80ad9f1f83ae59b0b80ca75106a9a3705ca76c9c353f6330d8f2c04034237aa4c64b7b3c82aa765f0f4cbe473d91a05215b79933000c0c4d0d12956a58bd8a094756a9950d01bad8845d9863d6f695059006da81f25bcebabbaa477236b2f9f0234fe7f18739a90bdc22e26929e5b942024766343be4450eeba6defaa290e9606453e4983d0b2c204d9808bea4914129d716540b6e2458fdf31a2e21b27ba2c4b991e40f21164c3062138a7263fcc73b1933d5d0c8fa46db283f7c981017c46030f6d0acbbe52206814edee4ba1e1b33965984d8c122f8f30b7fadbc8821da49f39742a1f926f8995bbda83cb4ef496ae4639fdd98301079ef33fd8efe2f791812f8005079c39f66203efb051f32c0485266021c118f2eaf42ce1c65e14e12d176cdf628fc691d1ed24f404d50efefc7ddb999b30374e8df526b81da0e9dd635d2b80fee0e357e6efa0b21828177281533d301f3c1fe712ab6df2648dffc69bb4a02c18c9f874193002a858cdb7102e8cdec960bfc35a4a4549aa21e401e4ed12cfff57bc506b4a7afc720ba0a903da47fb862d862761929beabbb86708bf6c25b5ba1987cc309d9aaef92d040ed78f708d8ba9e1d9a516609d31bb5e43b64bbe1f2a4942baf9182624fa9c817aa977ab03f32cd5af38e3e161ca9a0b9618f66863c2ec7f75354dbe0f13ed897d2f21dc94cf31a49b5aca0b0b5d860a029cd2c85e8cb4030ca19e99a1765676f470574804d77a978d33befa447869f2af56af2faa9b3f5256b96364ae09583a15a7c400106d6cd0d5abc8cfac9b7feb20f44ddbe1386bba8dc32290bb8951547190be5b6c3f33f78dd47447af677464db8e5672312d02f34e14c9c96694582b88aa0c69a8cb2831cbf3626a8116f4f63f80fe2929bed70035d6f7f4c1ae969f4dad71ccce3c9b01dce99ebab658f96334b2361cf2424cfc6f7f2043dee83ced4467e0c678b26b18dc68b62a786de4e5f9176adc2fe97f09d46c7da298afa563a73919f1edc3ed1ba9de675fe725ab66d167769a6d17b3971179d9a7d1f9575ddbbe57793ffbf76d70036237187bd30ae5087a738c88c564125783bf80142d10b62f40d7b7b609541e3683356b82dd99de3706b6762dd88a0de60f8731ffa0eee2261a4e8126ca435bf6032d61a30f0ccd3039edb9a49019333c8292c4743f06c6d9ad18fd62055caae4aa0616e0c76917a2b78c6c4fceea058c3419a534f3f06b751c885812c5cbb549b1f2fd33763e0cfd6b2fc30d584bf4a3d4ad3b4f712a4f4778de6d83420ed0819460e8b81e5168bb7b02a164f3bf8608a083ae60aa99370b4c0258c8bbae003a9a4207af8ba0af5d6312c60afe10ab14323cc28d14d93e13254883ae7ade28760634362b2ec6e85e42cbd0f60a35ecb83be468d876cb63597e93330bee763ea055c044de59872e40202c9572efe0bbdc7a0bd81732be6d78f20ce3a090d75f6ef87948e62ff31edb0681c05095a15605b9d242ade0a0c4ba56ad6346d53308eb03fbd32e54dfccfe8f622dd3f2963bc620be4a6fcfc1522c483432e954d1120f4a17824fe3ffe0799d4acb98da9c0d49eb9ddc6ded8003a3799e1135c8ce60f59e2f9aa06990295aebbd245a4eb72db7ff45ba92a7ee16d03e3534a1fc4587bb62c226474ac3343e7cf84ea71a04483b0030db4fa3c42315816680060c239c194857f6cb08bb6e1364d1b1b9d01b2ceb579e8ab08a6239dae290b93241a4bb0f9f69c2479283470866b6f2745eafa7db68777cceb47b9008f27e458380b36c2d837f088c4bccc9304fd046850ae4ab9b05b0a17ff4ca584f664f61b82ca58803b4a239734d37edb35c8a58dc274752688f9c821c572f349f569664db00213968dbb306a07eff6d3df3f80ce9e107f2f1ba28ed2d11639cef39adfbbfbad4eaa2c44c23836f30989f88effc8f319b252df4b22042f67b3bad7b1595e11f6ee6c0c1cf0a62c6097f1739537a388dc963479fc6a701f6359da0ae54276948f1c4bf9f4d5370697e56a037683accd6601471667e65ffb613f1455d4b42c9430518aa0b17c24a21232d99f28e88a84bd778f3c2f492232fd759fae079449ea68a74900a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
