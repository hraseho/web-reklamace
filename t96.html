<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de81330934cf8ff0624478004713947afcdae7e823824a7598beca01dbfeec9a71548e1130b8dbd697fa33458b6348e848cc3790e73f4422025bf6ec9bb752e43a55a8de8d44569680e9d78961e5d5796c89e4759eef11a25f64ab2070c9c1816662920757d98308afb6a281206ece1736ae3848621b9de65262e8837e330aa1b8cb474f171135063e269799fb04d1dc56a85db6c990ef74c5a09e0ea9fdaf0b818128090b46cea6916e6e24a165de6011c0cdea5822c4fa966bc4ce67c871ef2ec1dc19332f308d9b929ca57d2eb0cbba46ec2dd70c8ebea6a5a241167b05fb34d1aef98145739134989792bde0a1a53102fdfc62a8221acf7290649dd77c5b40d00d899797fabb272660001677a56620f5c8b5cfb98fbf3b5e378082086cbaa092ea708fea3c6022085df0d1db17edc2ff0f237b177212811e25530d5ef74c3b3f75fa29d9cf75a1eda72a93dbb29b67f61a7bafd666daf60115085112d8a43eeab26c4725fc3e515fc6dec8c1996d439950b873996f3061b46a9192811fb26ff0c1d93c70c106817d5f4bbe8a2d3fc738c6c70edf09ab8cbd3db39fab081debc8a2657cc5ecbfabd6a12acedd5552fdd92a79347b38ec781d4c440403cb0aa335dca4d5f2ba73860cc2d3c43950be102d3ea890d5d279d669c540a3d6f262f8b9233b538a5b4f6c692cdfc147afd224373bcdebcd5ed6659d5acafcab63fd5a1cbd5610de42e2b9416806c10d14c0cdae41afe6859fe0581cc472d55145f86238a1d2d0927726176cc655c8a4cc404633c7fbd1357e8cca00c3835cf9857d5c1bb93371cc01905fec4abefd53eaf182c3f57f89def7b67294c9e073c4789c1d0417788518b52e9fd1386fd516b7e3fda3ac785cccb1cbec231018dd3e7348749ab1cd4b8f48c9260468d9f1c19d4796a74cc643f82265f60525a60b2de87803cb32acc43102218cb2c22a7abff1dc84b81fd1410f37895e373f67b50223e78d950407dbd991910d4d0f26fd952a7be6fd4e96924d5e1dccd84e4746cf12d21f8f9011d1b90a0c79ab378d1a12aa7fdd7ec2fa108cd5413702e810c1aeb40812edc0c2891627a48a6eb48b940d30a746c96c8a61d2a51a9bc23be3745ae37cdd08915deb48b0b0987957dc1b99ad5d18543d18b83fa77d32df5f6ef379d0ee56f59108f49e1e48f04ac9533ff9a5a6b609e2d7f7e132c07bb7192e7b3751169997081892ab6ac1fb4c446db6a4993e809112e2d36d45309108a2b2169cd0eaa83edc4951de5361f2b6f02e1dbb2d1b3698b4413015e0e3981e3d324f13f09af88daa0bcbe1b371211ff85981cacf678f31096aa6de5952c5579efc5c52fc860cad8baf0be169afa677121b932c9d307172bbdd12156c423721a2dce97edadf28681bb4575935cf8735978ac8b521f421ae08778f38645ba4b4d1e663b832f0d45d3b3452e0d699db431513fdeb3f15bd7a03f3b5fbb1c30547120a200a414495d5bcaa536c7e981c309455897a1002d5aafc56166f1ada2c41e1f33f7e2437f74d017d84fad5088595315f78c56b95a74053f4a5519df3eda5fe926e8d8826481fdcd865a43c64b48d0f867ba261d0307c3c23cc74e777cbd02eaf3a04cbc69cd86bf26df6b5e0ece36907052c06b6f44058e2d09ee0c2b2b86dda5f5570e29295c6704de034cc3a6b2f02a23f44b3b125781e19a0a462af493db949c82809e3353221d3456a7bc901305ea49d2081f4c46448f09e663c8ed711451b0322f503f09818d8ba6f08514d09ccc7adb4c3522aac4e9840f016bb259f4acdbd9ce7db3042d922913f890ca67b808f482293544a170460ef270fe4f675c8b3774eab1f60e9fa44a1ac35a673d664aadcfcbb5358f028d1009bc7c2d989d7b62d0f7f32ab4ea260ffedc38eb9abcbb8d8e0ed002d60b631a40769a5ea263bd948aed363e0e72266992f1d00cc441f5834e78956356816c6e75aeb7668c0089192bba5f8910d9ac17049e6058becf69797338f7993aaedb66c0b3742c2d9151a888ca3449163aedc153a169cd12314f2e8b32baa0c824fac2cec138ea2b66393cd437f59acb7450461aded126765bc6daf74e089bb64067409f4d9413b6b3dcbf9b4b7ff886a63739beb89d02afcf5d6eac897bb44b9f9080376286cfdf4ad9c642c01ab6da28a4cdd30de75206aa5072746c1729e5dffe1ccc452b108c342b92dae5cbbdd152e8434f3ea071c447d10319e35a3c95332a0ff67c647cf9879905bc6b5b37eb81fe35585f824981ea046311eb68816d1c321194dd72830fa45bcf73745690170dd1dca92dc13891ff93b4a772416d5f2108cf78b04f5bea6baa9cae7c614f83fe4f2f10b14407031ffd4390516e51dea19af414fa1d736a012beee019d6d270fad068c9d27fd596f9648cd57b011b95c6b54afaa10501d4e864160e7bc128138f7fec68d9c96aee508f741e6b81d07439efb195e271cd33839a797c2dc1ea94bd17f5bc4b5dd9d587d84abf6ddc009fce88976cb9b68aaced9a91f43bab5bc84eb8b48008e1669da8bf3d7d54bd68e900f0fa4add6d7c67c8f602fea8ddb2d03a369bff810cf29272c8008956b3ef8fa5877930d9c442d8410e7364857f7fbc3e67b3f18ffe2aeb86b5fc7c2094dbd6b06aaefd497a27a19445144bf7398f83ff19832932f930aa6f211714687412e5da204aaa1acd9b1c09e88f5ac9942b0a42c99aa55f34a0229025b116940c4ba3ece4e15ce88ca684b25de1e84fabce358141301f0d04b78b206d3bfd836ef0dcd5348a5efa4472c883412d26dce0964a852ad192dec308b3f90b410bc79e604d89a0cd145403a9d027eff6172c68356001448786bd8b74f41b354a915accb9ee2a1b0e3c65a00c3c9c6eb258f00c665ba160a0450188d32e35e68b70e52c577b599a04d48f60df9fde8713c8d6d9bcf6bc1ad780ac75e1e6286af39199a1d44d516bddef05c315be527171c8b306c61d7044c5439617d67505ff01a63977ebaf59c552c711f5289673f6fffa20ca522f4f4a25f71207c247d78801b5b2e9fcdcae08ab60fa7faaace6649bb0a6c6a6b42a0d7b01eb38ee7614459c85ed78704d4b43eb62c480419bf13767743d1d85ecbc0998e17620ac0379e7df11e4b0d717999d3f7fcaa21a08e9ae157beb9b61eff69b6cdd0aac1c42fcccdcd95d52c542e53274206b815f1552bf66132bcedf3dc15ac86223352a394d77b18e3a32386b5c33c95360f491ec73d445692665675d313337ea46a8719deca9c7275a27897faec3a311528c7204573c5b8440039f268e268be519e22278397d5c5bd3ae81952538ba4f4e67ca010ea362454573369b4fa0a70222f98e03dc1c4c02568e1aafff7146ea00d58d514eb7048c2389d50f72c73f967b2b31371bd9638ff34c0018b7323f671334c5a2356d5c9a0473496aadedd949ec4797b2ed175c061d76daecc6975e2a6d3bb607204781181c0f27a1b554ca9e86aee840b8828e08ed01f31d2de9e51001c5ef6d27b434d3be5bd7e1a14e14ae13d08efa19f1f6527052e6cb09df3b7f2269aa654e5d107c2b2650d0bc9b2230c47531c043246d6158d1a9bd72bd2db18bc1968edd96949c2ec01a67af404e2f696fb2bde614c903b89968e1ff8a9d9db54b6ca49df805f56cb8112183b3b0f2b43a71a2370ae86f4f2c9b67ac057cca5f0dacb1267b0893b5d4b21a85887511da2299a76543f355bc629d0ab4cfad5a07a11f537fc9fbd91efa5312c3e6f43dbc62cd7991d5ea2e037bf15319b395b16ebbc2f9547eddea16641140914b8509a226207dbc8fa056edb6b0efd26452168e2daf55d11e96d8646c24de0f66c2d92903ab631c88a19de5b57aaf7841ebdac62b4a324a7d246b470b8b0751c544390ed34594baf916fad5a4e07a6f8cff827132dabcd71cea8f37cb3ed77520922c0d688ef878003254643963aeeb28358325d2acc5ab33232a8a76e68ce60f20e58ca5bd7a5305d53bf4077e8736167ddd764651a740607723cc09a650ca18423ad1280b8c5968ee44ac0d133462cffb116135372d17b8ade9cfd9be1c05932f98116f72d2bff42a09ae2c7640239138c77e911847c523fc9757a828cd3f6440f571e5059a4450f75d256e223a507a7109f19b374dfc6afca9c2878bb25a4f64f8b2c3e7ffba70935cdb3fc847644f7f7988958bb21e0ef1c6965c8886088b98b3c609ce0e9c7cd325e0f754d8fc43e58136aae12620fdae68d05b1889137851063dfb835f9ade422b0782d0ca11b17ae09a0661cf15af657203dc1017c7a9d1231304d15c1cd7906cf67e5cbb5836b8a23c7c3c6db25a61691c66b198eb7e848d2dffea23e0a341ba196b6cb3ef6b79d704589b44dae75c7612f71156b020c1d8fb81d26baa6921e70369bd0e1ef3e2d8569d8223bd216d323e26ecd98392ddc063c414a47b3ab7c5afd1c1daf9bf9b27dfe995cf251cb40105a002cfd2cbdbd3b7b848bc1663ca0d5362ec8ee53fea32fe22cb2d778a8fb3c4cb3564c79b1f97c8ff6f5a88f54d91ee153f4af6f54e7b0dd67372c339f3ff60986ac017eb1aed3ec7f845811ba30f4e542d4184fc1564fae4964c815f9ba4c8e142a0115153b368655ce8359562813b1c4a80fdaca99757df1b8ffb0840bf637a6f4b34a1c5fa774324bbb83a66509fb2c69f9f130f25158a969edccdb7034b82df1c68a9baec68c0d943f9a3f66e1e94eccf05d2405bde6c4611185c00fd0153ed66dfb381a86e0dafdb5052db201374df80b38618cb0b7a3918b00613a14c5ad0998f41e98eacb9aff586b6b7359ac4e153cdd4d4c8679f1a3c2d1e6767b667d68cb523d929a088f477f7c74cb89060efeaa8ec7eedac4213b192b76da914cd0fdf29020bc1f8f3b4770068bc9bbd08e312b7cdea4b71d55724ccfe582b22a46e5012eaabddb9afb0528f98c3e23aa0d985c344ef8ed0f4a4442c458119b4862b4a3528b5f8fe60234e700efb0322afa80cf0ff8c906ff27427657479812122b284e8e961c9d72daf6e798e31b0107626c85a0c3d7f9dd0ba04535f8fa25e7861b23d0a58c2bb7a6ae424a9490125f332df51ecb0d2ec4aeeaf2a9b04ea0c56becd657a41c201fa4fe4f9ba4daba7d05bd627764095a8ce260d501c430060610f080755e5cd8d8b0967bf59f6947ce5420ccb719a52583e6392388b11073401a8a60ed940888cb4dda9b77b03e08e8bcd3918591aec2d91c003b680eb3e9ff10b800bf9d6689438f20f55fddb1dc2a6a83c7132af2b29aebd90cad186c1909622e4d8812f69ba8ecd9df4535f40a5f3b406a5a66ee66228bff4825892991a435d58a2e47df04b3c3cf2de3efb570b98ba09502d5e3cc88a5542c2cca456a70c2847836aa32a5f54af188318f36a1b7d471850c0ac3d11b7de6ba2799f17466eb4362a349aca74520ab03bc2f6d3391c8a1b137c3536cfb5572e9636107bdbf9d2458e6f9a326404489ca325ea159e7ad04dd27f52d6bce851c8433041ebc5c68ef1ecceabe0cbc94af9a255d929ae6783c11511c325318dbc5c7cabdbbac015948b89931327ad5c2eedea77e08f29285a8df8d4ba9a302d099535efd34c51f025991596567b54b1340d779e5902635a6ecdacb47ce11e474e2814d44660ec6c47a9b6ab2d878fd4444a23ee942660a55c74b22981a00f20398b9f83f30ecef3ca24f51267c08589129674096ede206ad59ab72f6bbe5a060e0c14349a7ef70f37f7ad267ce184031fe2cbd9cb14125f6283d7cd3ce6dcca4e60b69f3efce0a8105a600b5a2ba4f98df8e91cf6a8b350c1f6d942133eefbc6319e6b297af6024ff6c2bdec9d06eceb0761a47d60da530810f1796ec63073d298cdd880c69074d8831e1732471232fa14f4a89b213fd98b71a1ae55d312cc247f78ed154bf619f32abaea48dec8c4cfdc8d5868f3eae7801cd251944e65a586ed2db93ae4b5c37ac9b7081a81b52eeaf470decfa30d7c9d1d1d385a1bf9cc73be623a4eab877e98bcd6789eae5e445c0cc61ea89a0649f1f60fbeef2e029268014384e23f272280c4a68e5d6ad29f1b61644b393d9848e29a130434d147d33bc21bcab732a35f48c83661fb364af49b24e2ed131d902bcfe07a4df3201930c13082499d8faec66218ea293eb18208db0b9c073b8a5a296fa7e246c7a60fee5ab7d471ba5bcd3bdf9189909c8ae0d5db9eef4d31866ebe4fec245d04ab85966d5144bd1bb1901c272e19bc42a3cb49eb731e71bf7577713c780fad51be86c29889fd58b622502e9570601cf8aafda07b9ab1e5816a8a26e651564ee7a6d1b510990cae5efa1af7bae98aa76f275d4af22202ba7820bc41b305bd5417ca3a3a3a6f57caced232d06ac82bba5262623dcccc29b2fbd4292f5e6747e379db00829774415b9da9541c0ab6ade8f89516bc7a2aea20392e30f35c4a41a89f7aa882b0abd12b207409baf07a6a66a8090ed45e2a9d7a795ad734e657495bb60d68c75735f5b8814deb9fef99f18e827bd37680b623faececbf22e522be38c13e01cfbaa146ea2bcf33c10dfff1f26a351630929c05b99b5de28b4e946bfb0c3ea8a4e01e671ddd648b37ed695a9161be863ecf3465d33717ea9ce77c8f1e7cbdc857e1838931355ba492b47053424f39f0351bce86b7a34ac90989e56f5704462b1ac56c62994205bd5ca87b59d03840bf71cd6c6ce9763e92b700d3835b77cddf10483dae35e7e5e5cca5898531ea185f2fa15d286c7b491132f73e1308bb21e9a4fba28baa4dae80f01ec639e0d443e7744d7e6295f7653cb57f92d2565f3b009a8b05e5bbb5deb874cacae0adc5997bd4a900c1c3be2b2344b9a40f0e58c753ec6c5f2853f40626038c7a9f426811c2f59dc1580f9305eed4edcee9a91e27f315cabc69a76b66a4eefb8ff15ec0fd427449c0cef74f37101ea4050294dfbbf158e51b7db2683007862818ebe3f4fdb6250616e402f5bb181e6b90744be9639d718e5abdb51874334595b9883c9a98fa74cc0355097c794d4283fcd0db9ecaea1d7312158554ec0b3b090ccd0e365b51b36eb8021225824f87a267834a556e7d5636038eb6d0b48fa642c46db767a7e6321a423ca12799ff5ae28e501abe378e4a31c7e2709ee355eb984f01ea956a3ad40674a6544777609c96aaa42b0b3668b4d1e8755d9cd592f24fc77e451a624c3f8c412fa984fae601460c90207ba6ac282610b01c8fac8025384d912b453d5606254bf5dc4186fe031d3997796180c3ea601f48c2db3980f89b6b4743320f32a9017526d788b71875a27ed3faff19f9bc324ff6d7e0fb8f96b0c5f285742193cf0b68ba34f3cc384ddafa01dc109aaa0174683b62c5c2848d63540dfcbad3f440444cc2a54d36df4cb4ddf39366a1d0d6f51147e560d7c5fc18ee802b43442bcb40ee5a0c241c7d0fc5638b329fb10b6616e417efab3691d4b77099f1df1d3830f912ced50b5298dec4075fa6457e1fb6523ffa2a63c16a34f23a8cecab6f9b2eac89a52118f7e9801d3211663d26188e9237ce13cfd25b3b555a7667cbcde9b3ebe018668e1d35226c3fdc339bedb6985e70888b7b4cd3f75a024f9ad85ca23c13a46f9cf9419a5b9d9ec945fd3a46197366448b28ed556146b7b9c87e99079cca32b15b1ce4e696666093269c55a95cee4751c5d0e834ad13e477f8369f4cf7894df3b3572de86a08f0b9a46e825afade907cd8a1efee593dec04379d918444749c32966a93a73a4a0f4da29c068cdbd92cdf4d4494335e8c822aab882bb580c00294dacd37f5f4b1e8b80b643c3a4db9e5690a4c0d5447575e35b985f9c9279f582a9e0a599f03d28fd9c3eb732eb404d55b6a23ba1054fa10dc9a4c9a0994ce420f55c10e662e7a8a0a371c5defb3255de7069b87d8261b0c2ff5d9a2628d93214143da079dc14a13f5bdb9ce4f5862317a8169c5b4492438c217266a59f409bf2a633a61b84b83c831843547d1b5329548f85889682e93569925d2bbb221d31c74d97697834cb988984a32cee11703d38b660d9e0f9915cb2707fba26ec3e6041e518a1dc472f3240dddd4dcd9663afd7fae7a4a1de85372bab99f54b475c53b50a982700bb7c90ccf8bc013b7862a7c7d5a69074d68d7fb0c4f4e1770fb8a93d391c2106866f862fff895371bfaae0a6999998ab7841976b444259663ec59e5b4dde9a47dd271ca1f012000f3694200968fc765fcb3c79e292bb7518c11d251d895af921adc6f30f7dea9a0e7b6da4346ffc198fa92eec3ef787bb36c8f91ad896b4d3e9e6069204ef0467e22a0acfb74d2760ead648c5f880bb0c4fb0557aa5e058c7b22209cd391c78cb77488224f780754456e8a7cd13aa6f776e2ec48b91844537ecc2f686fc595a4ed89be2d57f5a4a1570ace9b84d2c6cf282fdfab0d16f29c5aa7dda33835ffedf78e7173d7f0f9e7a6b3ce98ada969779aa30adabc9fd841a3c31c02460bfd65e2195f3c56be42ad9acd3c8976d6157c39163dff03ba0105a0ab1e182a1212f91a472d2083bfa6549b177f7564214e848e6dafd7338a2bae9667d6e85ff62a4169a9acd69c81df685f5c138b6cdae71fb37043f056f006729954c0ca6ec219af4e6291ca7927b09318f7250120eef398b15e52c0d837f581e99a80128934bac39a3bfe53e21791c045bf3d82d509a1e4b5cdb3d7b2a8e2f8eea0483aa8cd24193ecd64531802341b1e5b2d6dead506514d784826857a31ec498e37ae390fac9f1d01f827ffae414806e0491864cf6a1e8bd0b2e8f02919c5d48740e23f90a7c268be5a9bfb602ac69ef7972c2201158468b0c5a96a4a4bfda6a2a62577e85bd751fcfa89d638db190e81202de6d1be8cd17028cc303b1171727c6e9f8f6f83357ba9d5c41ed8dae6d23e9e9a5f8fde05023396206f9fa36e076f13b18bd7fc531d03b7af63dd767967ef2523c6066680f886add467a52e2b1d31416fdd35e323402016eaf0961e22eec4ad80637b62ec9805e0e63d98626701fe62147a8c434520a185e1dc7cd977cd523430d322a369a71c7bf58a8892425b09a347c3300f3fa82a2354e24504d06ed2be446b293e978d0bd302c92368d6a8d81cfc5e9f2d058fb3f9534672e04365ccbe0ad5f7c22db1855edefcc4f16e5b4106ef5d52ad2431206a66127ac85b6c5e546966e9b65bb295661e5db2668b4ef0e32dab75daa32936ae3b0899deccf80d17c6cf920d08d9b24794f1d7e1222cf7d25f0e3d3e2fa1c2f90a335f438a297180e74c231c877245521ed99cf3284debf10b0641abcd71ad95f651cb896844f0c829e44a7eb5d66bca6fa5d51628e04d9dbe89b3bb20046ed644057f1c34f40de76df4ab07705f1f286f4ad22a3bb1e3c85f565cd93a5575e0809358b7aaeceead105717c210abe6165c55c0716f810c601be0d8ed1ff2d14ef267c7ce99c3908cae9a1f7acdee2ff4f503c87a9676fd236f188f552622848f24e234292c53c933a248f0223b1f748068540736d39943b8201419c193cda14f532263334bbae5a84443b02bafc0925a2e91e8275a4ad34afa1130426021327d3f744838b95059180040d3457c047b04f4db85968bdb504f8f0aac424443e98feaa89795857e05a7f2945c14e6bbb0134d7c6cfd897bdbbdf15770a274a619e7c26ecd24a53e65dba46764e9d748199e05bc51573b8504f21a7ae596622861368cd6d18f4ce87684369f42f9ed0578d4b2b3dd61cb9b6bff1b64a446aa98946039c2bb045d66ba5ab103cee3e9355542db80c89da096b37f5b926a22a32d3a100ccdaf32e3f0f43c7f245d151af48bbfae594b7baccb92ba7e27abecb3d92d70ab6f459fc6521c8d1b3c6d2a3e5d52e64fbf3670cabe31a18c35c2de1f2d26d79410a25c2c92ec8e3ee70295acf3b7fb5e66388a1f4545dd51c619d5a6492d33f74db6db025879469d93826012c9066bbfa02d43f11a924f3c861fbd512ff1cee5476e3468b7930845b70c55240d15281996c2bff67a6e29bb5dbb8b321a6ad817a9ff8e85c1e2fa1b80918269e234d5388bc62c9d47ef5f5c00628af68cf2a6914f305695da03508534c515956a3ac5aa1be7000d7eb053ef5a00216adb502edf2fee4ee5c895789ce08942973954e3689aec95af9d4eb17b613eeb1b02e3093c1e881f4aa10f934bae66d33799c3423d7061bad5c90d89084ace3ac86be8f29b5f0dcdb5faf4cfa3897c31e47969e451fa0bebc51a53fac6ef452640c32d2bda4b35c6e11afe8f2b9aaf3bc88764c75b2b81245a706ed847c2d0315c390c38106b94e59d642fbac414732d0e5e877388b271f6897547df685fdeac325f6991aaa8eacbac22feba55cc957b2101c3d528e6f7a57e19d934c184692064c37d9dd1a8cd2fa62fe331966ee158d23089d3c30fe0e44665cf1f5d1158e43e6afd85c67840d5b5a048c0bf7e730496128daeebda96e6391c7750d9dff8f4af4eed73afe1ed136e1fb3d65085108f1d5349d7080f580e3e673fe0b5a3b16c2f49349ae1cd87d38befe8a13b7c5993bf54b39f4b40e4b6dec4eb0f7336d232da4661923066118e424b6ee78201d0b459a9728f0e0cb1e846c037ecfc1555a32fb33a0e73a58fdd74484bf72101c04a0db3ea7f30ddb19b1e8660b833777aa80b776e0bed754bbbf256fa20aa256c98a3ac59c5df2cbc80af5a3dd93ece607d77780512f597ba4a3605399c1ddd485ab8ebbb2d238ff977535957cf6dc1e3f2a797cac2e155627b91e7356318615122a5dd4c4ed57319730092a913d6dfadb5acbff506c134dce88ae0b457e6570199705cbe9126c68820ff512ef31e14cc61100c2756fdc4945c801b6c953c8d6bcb2027d27403148b4e8bdfacf471e1c4008e0252c9220b924339655775e8f8b2282d7974cac9573cc5e5a421ba8bb59327d79f057644a0d4c1d23e8c561a31cf96bd8516e28a3394c9d8a6d67b5d9d38c82b068a0c765a561ea5e80b43d09a3002e111949547654438e7b5f439b4244c1630baf7ae08fa17623ad97088fcd75aad5faea2a711796b3d6efc2d5310e5d32a95ec61da2dff48319203f1577b932e3ce757bc1a7407bc3908dae375654eba9de3c215b4bd306d4cf4451204a27e00ff31dd1f20af66042e2419f25e23087c0f3458bfef678442b66493110cd872136ff71a2849a3e8d3da3661d7bb69641d08455a462d2d4e0260bd3f2c8f70ac2d8b5eacac19ed81e79dafa16f02","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
