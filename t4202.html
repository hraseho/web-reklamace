<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e538dc57b96396f9d0cfb37864e3cf040d4e89adafc4b7504bf04488e10cc98dcb0ba7da45e8e20d39d022a6f8dd45c18031607310a064c7a75c88210366bc2f127330be2b6c4934986ed85bdff7bf5c4723fa15d51eeb14a49a56b7fb0a068c0d749fca03bf18a9800c34bbe4cbd44ca3a18a41f49b14606179bff49726392e1c381e0f648d17bb292fc429c369466a484b1f4da6db1f7de89e0c8303662183ccde8bf5c7a003b28232511e48cc2955aec9f5dd1fdee59677d4fd91d6c43fd577466c131888105866d398879bb661ff34d4541303726b0c1785c01547d82d661222d9150c62e7c9e7186afdafa3944255069a80dc7649fee4d571ac68b753e22d1621f362feea1207e6e0a75c78157e2af1ecbf54f8f4285694e31fadba95d9976edc2188b70d920b9a1a6ea0cd7f8a1479fa8d5802799623c7df9eeaf055eb37d5edd420899d53be477c3df5fe76c1c02d3889811d55eb22c8a34d644de69d72948ee8981ff90ce8ec18a15f460f34ec5a6bef1ae997340b4921b40fef3f68853e6453b01b43b3c62f241fb0139eb2b5f87646adc490e477a0cc6b014af3b3235cc9029f2096d59cd63228c1535fc26ff759836172096c2ea4b436bae4f1058dacfa7b6f3110d39b2d35baa021ca22fe9761bc4f3b34d2d4f7f9570d265d0cbaebbafd09f995463141567e58a0d6796dc2ec66d35bd8a0440a3c350f484d1a46f4922a281ae6c816e00e49c26240f38194400b8c2604edd82233448b1fb6e168595bc823c05a54b8178c8fb27f8118b817d9bc53eee245723db766f4265049696a0e5059ca36b8e1f62410570000ef2fe9c62cd9df9bad9401f29795cc0f8fc2721c1ec1dc1e2414408ffa72a466be1bb6d61753e9a536b0c63a3a1af5d951e63475d9562b7c8d58ed06c4df108361809bc7a53b5a76a8d6197f29b9c6c2c8c94044537bfa8c9f4ffb6bd34d3846f9b1e040a19bf9d94b34183cd4e36d348a5852c048ab1e2780ed540a514f06266ffb9e41bfa4ed6f704da2a5596bc9fce47d59853b1bb6ce05852951a371c21acd0c7cac43c2b346d650b6dbb4fe7da49897a18cedbc4ca31db559a846603db37dba8d271ec963b5a08aac1c59b0204c7e580337914ad89de50e8fb1dcddd80506cef799d64d6e1ae496ec0cb51b00d29980b1a3722d6ea42a1f4e7d9cca3fa8140047e2287ce67ad6efbdf33ecebe2369d62e9d460fc359cf91ea7cfd7b1ea3e741d4f2d43e1939a8bc9cfbb2165ea45cde9cf05d33af51408dec5bac80f4d71356d0a5466db1154c32bd2ed926a7b1d02ac9f5bcced14f2131a386216c97f3ddf85f6b6d91458f6c83d0d5ccc821a40fdbe4a9d865112bd0f77c6269bf3f3f9ab82bb2e2d5df86303ba8465361db5c43f56b6d6418918ce04b6643cc88b0293df19b9ef4aa57fbaecab95b0cfec95df174346178e0a7121e6500b6cde9e6ad3ed817870d62770decd2dafa6787104cdb8b84ae200ebb5f210606b08fdbc9d2fe2ec04ef3e4e11065a980a96793e47ff3836180acd7170008eda0f56d87cf48fddca2ecb13fba80f22f73b74407c3066f4a7dadc88379bd2ac86337f25769fbcc0117d7bd14f6c62f3d9f8bd09c07e5e094749586b8144fe0595b557f895c7801da03574c825ee8c73e1e352921e57d7f060f926bebd3bbd13dcbcb1fc7d550a74f6d2490f1d8f0f8c8fa5bc816795a675bf5a0c1e0bd020ffef6d37dd308823b5ce1c9f9d5630fd367719ccd9ea5b4884a513a8b9f77515de90fd4ca9436d175bcf38e26f75ce7458f2e9400c8c935b9fb3f330e5e2940ee566643224ba32c2e788631099a646401bcce6ed46a58e5cc32e25aa5bfff7e1f7777fd69074f57c9a879308b436a6785817a6d64070f7a5bc979d8c3fa18ecd842ac5c3b7795d2083f964372691d3f08f9efda3616309a4be2d186742b10c719decd9c29150a6dfeabe867a5d793982b29032b8babda48681a4e2049c548e12bd2e6464ec4289ed8f1894cc82035e266816d9cda872a06c84e669edfe6e8562d3ed8e8b3f57e160fb3ff307deef0bba2533691995f4bffe924a19b878084744c9c4e83198b8a32464845ef591710771f481d3b863c612f14afebdf802a9c6465258c3e727b1ac4a325ce54ae6c49f9062845db84031879687f8d3b9b77d5f3c62bec5af294ac697a510d606fc04e455bd776ea7c92ca8248e22bc3f0174aec53fd30e03d4c9bab548c6060eb405e72351cf3733e2ed7d1ad4e9fd21edc1169e68a0abe8b8f3351977d42679d78ff2861967ba6bde51879cccc80351f89cd51a789e256203c92083669382638fdb3f53e74a3801bef05165ff6b280932b54957d2dfd84fa2e61aedc061fc7eb4539d27de248c3869c0ec2f48dcf62993f2e38f9f02023b8fd08967bb725e8f465076003efc844acf0b128c04fc888df0ef21e3d8d33e4eabcc03921a617103c3527c4b5c192a28c9b68fb91a383b8a844a8fe0cc97747514304d7279284fc75555d7eeb3c4fa1c109f46381893769d4cf142a29afb313541f459d633479c1f9fa947547d0e30c3bd1ff738d1ad8ea91cef112a15f98376592749129819d116072b6cef2e6d5002fa47ffc46ecd2a93abd5430fecfda7f6db8bded45c19b678ca0932c885a739ae2798ae1abbe822fa89c2b3709a54b83f58d5c927de7e27970ca6fba72d2d2f9e77f774b04f52a49fdd71a87b424030c097d7e18544bd7895f2bb643917e04fc68cc28901a01f46bff722cc5d891b994525799974e3742993f6e1150d95f30c50ad9f5978e32e34be7b12b6260381e33c8351d1eef67ae42772d1e17dfd8f94373d12b664ee7bf2aa85c3e9e4a129f3276b293643b94f265969efbf82781e7afafa5596bc35d3611a9ff97515bababf1da886aa936a1bee35c85488624e438e70b964a64d1d248c3721b364140689be34a74d48e5050ef5499577ec8f487586a4aad648fabe9a44e5f9c929ffa576c6ad6872006574e1fe2e48fadd50f67e78e2971024b3240546982c7d765c5a3f027f99888bfaa6961b2ded08767c08059c0475b525a4faa4cf94e00f57caf52a900c49c950587562defc758f8cbd5fcc949dacbd4c9e964f6838bbce6fb9e7790e473dbfc3d132edca7311059e2b6e8c4dfb778df7df429b4aa85dd2e05c6a098eaba05d7f22618f043628a0854add2b9aa279230f0184fa8eb93865c9dbd84cb72403aa46e0051a82146a5476ac0c5fc608515546687fb6af0f17188db9de254c8cc59ff86a0d78d0432d07dd69c998fabd10abe2527d64d8c3f375042a2e768e66eff630d9987fd3cbc1a052c9a9b99c3b5ad2fe4f3299b5289295f2371012f824d09c3f01826ef8eb86e4a7804d07684894431213df0db6c02efd3004c25bda63e62ebc1b78af33f74dac89d7fbfc50981df89b0932a4455601fb93878666d4d2e6160ef5280e07d3a4b19cb6b11c8b6487cd91e696e7feff06c58a62d13eea5eae927d2eb14ffbd9c35aa464d689d5b3e8252bf3f20c059bb60c73a21c27aab9bd6377f1e4d7e0c08a8e87466e5b89dbf42266cd2d4c08b366cd266e80b6502a154cebd22ce2c0d0009a5926ede2763b74c81131eb2d8f99e95431876f52c4367489394d8c486ec7e6cbe6c58d8baf0e9e0473b775381ef6488e9cb9ed007bceb01dade830bd9efa73a4eae6209985377c79a7cd12458718824f891d85d1de4defb6ce17fbd58ed21e0b5e139f7279729d941c0d64ec1bdfeb58b74982e8a405ef88c4fda5657ea37de529bf827533beb4b32f9ae287229ef73ed2a7becdf4eb64f5230976ed8443ef9774f5b33e0d9bbd8c5f4514a15a91a02efa6f4c824ef1815e13d1642b31ee152d4e58cda91ad6e1e93faa98b0881099050e963338e2875a473a661aead4f81ff33904453edf52834856395f2611fff1cd38d842c2b3b6e05acd3222a5094330da80504a13c5a7cb874154ecc6354c592351e19ed52b9879fd94113fb440d141ad663d8f419b559ceaef71214ca6d97508d13a0e29c8f6ccf5ae4283f66c9279dcc18668a4dc6e894d23cf344108a0419f1d3c96ea64dccd63f948294a19bf064ff4982f392e9dec622d11f4340c1be35f915e184e5bfdd58cf1079ebb628ff4ab4fee281649514717f4631d32bd40e555968f7a462138bf72ee082f60163a2525cc5b263035d3d9882d9849800c5a18906184091168baac6cddd4791f7b2f5763ad56f356a3f8b244fea64361a81c061e53339efbaec921e948b990e9d8b9fdb6fe29b40c5081a8c5d069a5c5611ab926a962734daf8afa03d23b3c87f2d1e46e6474acc962ac210fdfae5f2b85647f08b74a2097c812bb9e8e4a535b0b68f3e441b96b203cb6bbc5a49b3456087c6dd792e26a116b4a1207a8648f428b268b10465733a74fba67304bab31b943ca5cc86d4eda2d798a8f1398d0919b3645e0319c07e8f981f5491d1fbd6e495fcf359ed58d4d21815a993866498fd6f689dce577ac09008d2fdb7a020537d9e5591be23c82f3941be9661c9720ecf37856348700bf7392eca3801fa8b69d07a0f23999fa953d51048b31c43ce381617c4098a63dbedfa5297d1cd1d461daf4ffa3ae3a42ea9d1efcd864547daf01b5ac9a4c8820f5e234f1cfc10139626b46af3c836443ad8f7c24b8c81e77e42c7ded7cff3a620e59af246261753fd011ae5df6d734b1adb3fb2d57c1a87695d8355abb57959042a52e2e757f35feda48073daa33daae4dd69ab4d77370315725355a7929472bae4916a82633767245f7d5f9e913bb6e686df7c22f23a27be1985945d27c1c2e70ddfabe91ca8fff07c551769d15ebffe54bcda40e7f0370a2c69c7dd168d7140e0529adb36f9a602a842dad3cd31fee039016963bba74bded58fdd7a864369198dbfac1452057e5adfa0afd8d44003b9e08ee000f94840d305c6983f6b07eda9b1af57ca53b275e6648feddbd95856ec4d1a14c51bb4c78423b1439aeb400ca1828207468f4546e445083e26cdefc8c1cc44ff9631abbd7a1baa9aa10e77e5280077d3bdd756b08d6736e39078b6dac6aeec644a49f8bac57e3b59466526ccce19453eace6aaa9e4d987b80637771021ec854c6c74f41f91900641c36af92e423339fdf14540cece43bb2b3ee201b4101d067e6a7e0d14ef2401a43852a59900b38f1dce38712705b592eefec57b82c56ba0be5f328313a894e6c947a1e9ea73f626783bd3f26e3b87c36168ea6fffb4a0fe606a9f0f6ac630de2e561af3592a0f676503cf600b36dd1ba19e7f5f4eb42f35d884912240bfdd363d62e2d630317162f20017a84d596f30814654dbc431000629dc02fe9c7e650b977f5782c3f40172f2f503b4cba5f078e0167191a77f4e9028f40a0791394bb0c0ddec7cc629d77394ff8ca32ae91100c3287c808a8ad055f73ccd47757b7253ebe0a361381be17ad45595eb3403d3055083d6b2d4d9f868bdebd35f55dfcc708a7151e005c4efdcec415b596612923e61df5c588149e68e67f093bd99e50752bf2ee465679f76259c14bdc688a317384d37b52cf99941810b42c2c8ed76a1348e21514ff481063ada979ddbf74cff902584288aae8d97fac5e64edf7243ea7ae8fb98d9718c473d8515f213aa5ea2b865dd4059ca07dcbfd6308371dcb609e192c950e190cb0a7d392944463dc0dffebc92f8bef2bad2cd710d261393c7fb9d43c7ea4ce7b8ce7945571905d4cc6c4054026f78516027cd3fee818d308222488580251f4018819c9a0e60f0949b63e62c05de3a21cc7a1b6151c50e1fc0b7949c6556f6e81ed4c2d19cf7a6549f8241b820cbb97531b3ac49bdb80d7c66166e8d7fba6a7a3a9f59e137c6423716a60a1d4f91f26ad31c8bd82f142162d54a240016ab1d0accb53ddaf716b22002a45753f6b9c224c7541661647b895dbd4a8c2fec5eeaed2a61bb11c25133b8cfef29ef5277dbe0a05a092255fa04bd41205bd1cff4e2fbe32fe0cc81ea0f4eb5aaf3e3a0b3913f0b888872fe8790de76b749ca054c3b608d6eeb6ddf616c769701f1b6c20d06ad1cc2de57cc2796cc596c5d7f028238b01fa71bd3eb7470f7d80e3ce9645de6be4dbee45b85b2b8ff207850ca44546400ce7219e1e0b215208b6d09c01b2cdad9ae69c68cd67b36884ac6b05e33df934f10a7f06b2a32a68bc796be92313444ab4d748e6ec04429045d57b1f24304f733e4309be56543cb1fffc50e978a9c1ddc066612ca89b00e01ffc31738e89c8670f3990aab683ede9e119385c902cc8bba709542cfdb4e97e40dd9fa0b3c84d832e71e46b8f634002b5bb4331a4ab740f8a0d45333f2261e23047ea1d9630d436e48c37860bdfd5a52a069748045cbf6be453cc36d3e13c2c38b0e238d38a27abbd9ee0fc6445b79062bcaad4ba0eaed14a085ed3de6fb5d4919133727a7cfa965f6cbb2e6087d02d989481505271ca5583243fa8662cea7fac75ba106bab53935bd8c11850af2f57cdd4e5de23eddbedd594c4af5923f060914e7549a55dcfbef93c9421b53ff81cc7447c2a4a11b76b3a91017b6c266082fd351a6368cf2019d1321ada95f26bd30b16bffa7a40419a16a971c86b5b9b1008bd97ba2f27673ace6f07275498d10d64ce437ec548216590609590139b810ded18888b923000571675f5daaf685eac2358b41afc97aef675b85725af055008356475b9c7f80bd33166248d737fe7815304143511fd09d201e6a9adee5f26d6ca474ac4fe00b9ab004133ea9d7519d8df75f4b4cc40a760f25582bd1f42436313da41087076304bb9dc44e5b0beb563824732bad3a8bb260940308e0051737106daa3e6a32525c85269600535eec6d69c0a514050515ccc05b89e4a9768bbf2c143bc8a2867f581f87e012bc60dded2dce67275dd80cda7ae986eafe982d093c8f121951941f22c5bd12526c8d16938f5f65edc276ef348bc4a367728551747797e15bf1a3d2246abc3496b6f6853c01605a2b8ac8ec06ca02714e33656a64e64d4232a3b61a2e57762671b5ba6f8b0ba7218ef7343d9e83302272ff418850011ba75748f7016b529459d9028ff1f690bf30b40ef4cfce636035aabaeb67742037ba3cc0177779992a6842fea838e388533236062d98c6cfc713f26e33c379222e2f27da21ccc310659857bbe99a8216391c01bd2599224a85868aa36254134b2c204d15307d3e70be0509f9ec45f5b97e149cebc40d926c7c9b35f3bc590cc08f0a21a0f7fa07136a034c16c5e38b4125ecfaa11733d31928d52295f1d55b9d468d0703aef3cf5671abf366e7afb005cedd97480cc7fac1ef073d83ae4f740b3d836c6ab59a2b51d580491c8d7125d29f503f5e963f7f67ed94186de6e039fa7b8eddfb1162ec91a27428443a1c35369cf496904811eb1f9a709c52b8039154cb38449975296968f8671ec0f5a806b9b89fbcbceee1364c58acc2db0dd09723389604d8af96b637502cdaf5eea1ed829449a8b2f76757465dfd3a3335cd6ba6599866587912370421dc4077bb5e21c715b01ae2b423a9b5246f6b1de41ebe4910f08313df745b1c5548b379d054c1e34520a69c54570cb9ef2b3327c917152e44faa97b8efd870fa1c19714674a3f84da2fea148be9345e9e7ad21e6eb244d7710af9f898756514f13137bc4341e50b0cf4f0d3f189986d4f138b8208390c042dae1f9625c4e2dedeeab9e00ed6f86f29bff39f6c32cd146b27c12207fbb4453666cfc3ac79176165860e66ab7bf5cfd42a45965c21b4c21551f465e86c7772210830fe9b3a6030be11b1f47b4ad3229005c8db2ae7209aec7832211a8043a81171e32f0e5969cdb49f514f3a89466723c544a8f94ec8c6e53b5422438103f9f10db885153762fb9383db1bc97ffde38407fa6f4c11c55eb90252b9863c8c87e6fcc58ddd0bbc6638e2b582dcd258435bad6347ac58298fc8bc5d94b0c672f68c1fa62d08da5bd9a63745efdcc0a2f4093b0eb6a5090c6ecad04f349431a06dda07e8b96e304cfacfccc67e3e12ae15faa6bbc684c0f0a8caad4de947513498bc9ef86016c61877bfc1e6f767681d7d1ba92011cf7c5764625a5e973945a4bda6789258c0ae7365c4a28d73e448c4eaacd7e9fd41c1f37967bc68bd5065b72d0c8f3df30ea40c806969bf7331c26e6628809f29c44eadf8c7ceec5569d93dc7638ddc45e36d9570965a9a8c47c82d921a198de13c47dd50a14531ba0cabd49f5b95f7c023d7f32d9bb4951064d02c25b4f3d460774a96d99084d9b0159ab6611c9943650bac874987dbc13102488f561b40db93b161cc42afe283d9132a4104b4760de556332d94b8d13a247f746927f1588a75176e31b859820bfc0e458ac70c1cab40424499e4bc66175f4f9de64b922f961f936207d4477b92c7927f2a9d6ce2c78163c90e2266dbedc8a3c0c76dd8aa3784405bb07d340e4a8abc2bb2982caab0a59c72be62997c74e06dfc8e74c29c871fb5e7956076458fbf619171a0ac30b7996e53d6df0979f36800080c1411b8fb207799679176066d26d03b710a7ce5dd4fb1e686f919ee7dbe8891481ee89bcc080eb74e611f43c93e41c8222711472f685b44e8080aed158f46e2f68c505673b636e921fbb830e9277727ed3390ea60e4d1abb09de91818484d815f83d846369c64bcc8a97c0ffa45ce51766b640f289dd800868d178456e099bffbdcba625beb3270380de3bda72ac6dfca8ae6058a013cd6f4e666022af008b613c759eef0ff81f0cd85a610990f7712f7f822a77a4b7d2d8838c86dd389debcf9bc9df50843b2488ef50b71fda72c9f0887476c230fbeb071f261ab81f35d3981c163bf12680f96e6143b6e05b8f58534c1dc47158ddf12a83671e2b10a9d951e7cde0eaec76af88dddec7a20cab2007322d43fb5f3773e152d041de39235c8c87bc2707bec113f75245faa68b9ebc5c2b18c2653020ff4343492f758b64c667eac37a0a16d11ff7f975cb7687ffd54ee4db2b9c7489ce590bd21a0575c15f1e2999792bb16a91c4e5171e1a26450d6196cad4a2bb223414b7dd9f2c1b419affc613da9fd27e55e14e26d732d1f483756c1012a9fcf13b06333b7043f1eeba9a78a2e315af51e92cad1687b15533a4f088e19856527aaab31b766add992ab24c430a45c6a3a84b5899639fcd64f102a9b0b0492d18afa5002f35c85c73d28d8921a514002235eed964f4d3f19fa5eac3078405201d1e7172abfd4196d01bd36701b4f08d8b8ed9c1b7ad92cb80178cc72afd35ae453777c4828297ee8acc51fda6029d43eee5a4014b3ee48b23a8a54694c04e3394f497c70b3c671012462361072008fe7f1b2cdf3870279a4e7e93b686c895de8960f45a8e9ba84eba68a86ca14447cd686d12913385f69bcf72ea4120745a34ab161ed2af4a1969141c0de68e3485c2f6989402ce6d2be7059c5acf689389bc25b0aada9c52b62b03ac8270353d634a8ad54788cc669748015ae999fca1ba0602b5d0fb375c4d1c022f352c1c9431629ad60c234a4c85a8e22828c94b0467e63916790d4b58015f2cabfd5ed64937bbdc91266b2e2b967278dae1de3f574b771caa854bf6cc1b83e7b5dddcae77610e50c5245eccf32c6132cdd9a32a60c1ae3522f894e9af23ce60066d0b57f4bc391b44b700e9cde5170a569a60d77deb285c4fbb293bf78f9771ae5f3834728be170b955099df457801574d7461885a526bdad1e202f320348cfb8b50d7eb06e481718f159ea0fba75ec27eed4fa322b4a5b480e3a2f2950accec37b7c2fce1695c4467cef459d3fdf0ff705ff27c90d2ad95d1d5eb8bc1c4574cf8e20ead52c3bc8c217484ad480d881f71d9544b6f6c2b60c7b98523693f0a71b9427c976d06bdf4d7194bba012f2af1925321610a9cddaa8a2b61d7cee9f1a9bb075bc751b3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
