<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"404fc20954970af9171459fd19c03d824d2fab69befca6c10db4da99e3a9a47ea539a5836240bbeafc1d6bdb1dbae6c9eaafba1299a41d2829a8abf23a4e8c5a84651452f7788a2a619903671bd8f9a77eda101cfd28f07fb7989b0be014f3a1093cc0a4de8eb03b99b3dc9babb3414fd4f76769f20f378ffa36cf5168c5fbd00601270881ece62ca65bf943ded7704c4c0903d4fcac8380b2af6da24abf0a086b476b5aba4c49c8db692f3d8e8e9fcd61cdc5564600cc9c7f4b3241e4c7abf572414e7ce84c74b551de06dfe886060b3c1377258d918308a31ef6e4adf7155c84e8ad2d226d3b4b84b29163ecd74291574494b0aad6cce5cbfcb7e7c7c498026f06f28db0a9ca65db8cb33d29d88c20978433d16a5a05421697a6521547111fad42ac7a07b8c463ec4af46e2dea0658c01dea30151f9bf36540a2ee3236770ec01eb945fad9afca81cb36331b483417c682e4aabafbbf6c5b2d39db699f5ebc4011409f8062f2d0c2f65f91db5d2da946b0bf18b1577b00e0f5e3fc399a4279232f5c826c4e65e661417638dd2b3455a12f7eda645cba93e0c457c428daeee856821894d484c5f2936b163806d64ae8c1af8900073b79c806ddbf6857f156a431962e44677100ed5290e303a7397c136afea43e23d0b718588d20e860393157fde5bf6fbbc5b1cd838d9575e2f678d5f5072492234a62b389c5ca5e23cfe368d02db1725e85ee6632d8e5847d74ffc657a686893d176858a2f29b16f71008333d7e290a8022deaf9aa287ed9521e0b7449663596e2375affde014a638c9e7f7846a6c081fd954b239bf1690acc7024eed82cc65af15abe0c8d5714acf3a0257d2900b6b736452111e6fa7083f361e505665cdc9fb00e2972b2f2e2640e56affd5dbf57b6ed673bd9387640aa7f58dfb88094d0f4b0c939e7b7492fbc90730df3d0cb5fce0af608d69991420035bca382c027d2b5df115a28e30ac8f999a40048dea241cc925838f5c866ea04d619b38a1769b5c76cb41f6dc90ed6a9cf460924232c0a8be19541d2a18c53ea5bbf4c5749f1ce5af4947723c59e44c5c82a155c779dddee381d708d51b1b4f569364c1d5c82479ea9000483a140bf5b9549037f20eb5cf15762cc8aed01e207a1fcd19a6450726121ace6e6200f40ce880828d63c448a9c595a2e78ebfe72f5ad1b66e9d19817b362d02f1a72cdfcb1b7392cb18efaddd2c424fa686ee93d32716c0cec5ae6c1c658439ac9abef3c9b80b4b2236ba25dc7601c6c685db967b98e0fe8ef9928d995a5e7f082aeda07190b5448ddf977b1d86773c0411e12aa562da877359b6faed284a75e9cb07b800db46dad02c0c05f3249739d0021baa32148b16eee20b4d4ea117a6c60a1d7c4bedd66caae09f6948413662e8c893a351efa55d9f9de78e4230014f0de793626b586bfd8b45d96e2ccf909624cfe4e1fdea7b8c382f7564d10447fba06add5d05ee31f46c4d00e17dfcd3e8eb6e8b7c1cb449e0c9f58363e2d940020f8b04453a62cd2cc53ffb45646a1d3151c98730708f90c6d036cef4ab3bfdb4cf3a1b096d1e15ff1c56d74fc23c49295b20aabe32ca35194a3c9bcdf4c667b447bfc68c89a4b4634fef9ebe1fb0b51ed478a369047d397f3f9eccec266257255c48ff3689150054616ad8de729b4e66ae2a8e22400a2a8b9ac364174b26190f95dde1f16e78cfc56c22288332bdb197ea6fecf7a84ee3d3fb16fa4c4bb9996eeca737b54a6d2e74eb7fa2768de9690aa550ba9573d105b40e4e9169158a747fcd95a01663e609bea32c8861f9cfcfdcbd4c2dc5812d06ea1de7f564eb887a70c5d252d8924a0837bce0bf96470f03ddadafaa9e8105ccac8f28dbd5b5f7d3ef86b2da6d29317e6806e08e15ce0273d15e01ad3e358bf58badaa2eb090f7d34456cae66c70c52e46298f254bc3030bfe67438d1f947beb01f2f625893bcf7f76446f233d44bda5789bd243aed9ecc7474f50f09c01a96065f24f72141966a966af1b4bb327a03028f5c3c1edbcfbb93f53094bdd994e22e96922792817d48ddad6fc314ce648a450eaa261c8893f1615b6fd279940a4ba2f9b449ea8f2d225fe1ec6159c8bec848b06376153dfdf95aacd4bcc9fb944181723263d1659b4074973d9fa74e88003a4d23fca6bf3fd2b01479d797ef44bbb24d21734beb0d468e7b01920e0bd5bed75dc8ce5c8178c97eb2c36b04a4185b1210694ac57a77bad3ad56f2fb75fade508c548c9d176b0f9182d717a8ee167edcfa840f5fe2720568f817d107f2443a0707cf4e474ffaefd4b04b0ae6dc8fcc4fb41963e90c46a6c6b299911942bce52421ffebee91aaca35b3096c962f0abb342b30fb8cfd3cc67f034052ca49d2b52967a80a1365fc33d6c2c62323b4e5f1b9292107bb07f1b038f41d872e1d01c206c64163ff6c7a995f1d4b2d4daaed8abc68c3820f76efda79fab188fb30c1f4081db9051f5b0bd363006068827e90e009cfe317f26411029f7d32c48ef1b1edc853ab32ac3e574139ef8a858aa5332fb43a83b3a1f5724d407dc2d04cfee661099a7f1f17cfb62338568ef96bfe87ebf7bd52e3d19d49361343c6fe4a0a10ce5f0ae8a1a1ebc8286806d333719de476eedd05e72af3c86154930a91774b4e238dcacb56cba70944d98a382b1b88dc62a6344cf78310494d93a2bf484dd73189432f99175911981ced0be57aae84144e26613885e7679913a5989a0bbf872f0aa5e691b2e75f2ea9aa3b0ac780a763745c137d6166cbf4e308beb69a0adf21d8c9a629557e512b48b471ee32db7888533b30fd427171d70be5c4455c6bac13c16888ea599d0088ce81493332de76028baee583de262e03e4bb062e7a2af3e6b647a83e07402bd911d562589ace89fec354373b7e6377a44690bdd1ef846d467378099d6887526e82c65c6987cb75d458b9dcd7a1e6407092772cb99914b1fb5f5f850203838b89aded2e9d86aa67b671f9dc63e32a93fbbcfe524e739f0fc4c2e50823afc4994e43096df792cda6decb53e088bdc1748cbd2aacb4738d224b18509fccca011446e9b343ec2cac157829766c10e96ee9c9aaa07dfce2721dfc18aa1ef257b485fb9ae8c9d6099348adad017fb5976e5ccda44840f12fc7697c44ef9dffa0b23e4e8ffcc154c2f91874cf28df6bbdd07a4393acc672241a39d75eef9dcefae7d4a32121b0ca55b6478c329ee297c466df34465b0e24b9eaa14aaddcd793040af6dcff4bea5b54e5a1daeb3f65ff719bce049c239994895c2c08a11ed2a0a6b790f857d012aa443ea7928a3ea5b369ae6b1bc4832648302559a23b8644bdd1898a072443ac31271938ca093ea643c878f5106b28e50eb52fab43d2bc7e8a6b9cc54f5446d9233a813c04f9c95dc7afaa8022929c7b9becdea418c325a94aba652ed921c27e05cdd401bad2d9aa5fb13d240758a3ff4badaf458e2e7aac76664c2752bed7be8ceb83bcbcd82517d01a26a48746ac9a8a0f2c72b540e280089b7aa41515cd024134ff1128c6311f9fe013c6b88cd46e828aac16b596dbcdabf9227a2d4bb795c4e0678b8b9925b194cecc21c52721801f908967e51b63dd523b8790ddbe61a9515cfbf8c97a42a784c93849366b02d427cf490ea85d39367019e0c496297d4c3550f9ef3758791037efc16d4e35571714dad05366d02e62f318f9acc380db7e2e5469712bb7425d067521f3c8ec08b436406f33ff9e8ca1097d6782267dcc8acbd8aeeb3f01181bda476ad125da5278547c8e016fc6bc8bab58d3aee7d50366e4c0e7b767ad2cb2c383a5e65004f42495b19c91400ce22b59a820a6e1c6801ca24f88d2ed744bd7cc6e6c71dd3e7673c21999a4c132f3786bac2c174a40cf67a02afadaa23ea0eaaa2ea6cf1f6cda8f7561847fec0567020680c092d63682a3cb939d05c07fccc05cf0e7caf137b44742978f6c7e8be05fd5058f6cf64582d915465480524b96d66f2f0f90da59103ca93ab8252bb9b565ad8ea744cc3910d9c6f55453f312f2369861a0b2cd47964acea1d1a97eb2d48c439ad9d98b6781bee78a0f92ae82acaeaa577abbc7a11911befa755fbdbb3872adaf3fffd84116e027d36b64d7a349e20aa95ce5e9ea038fcfea05979663374ef15ab330d0ad0468c20e2ae8d375c686986593c96efadb63658a15ef6190ad0d6affbb48f0c2056eb6cd0d9cbaacc7d161826e90aa4afd0d24b37fa283d92763cc541c8797306065b3bf96e6fcbebf35310df2c13612ce5eef192d0544554661c8e5b3b2c5ea23e0b53996fd5365d72bdc6a8b5f69de0d725cf960bca96aa23eaeed9e22e9313c397f9283883ce3a2994f9510cd4febfd020d995ae93ade8ff6d51f7ff628f477f6d7e7aa57d657a7b312cc315b43f653bcd4cdd29ffee27240cde71647a434196e7cd166dbbd05a8758bebb18381806c7955fec4296cf83e90a3f09601746b50f0c60d60e36dc1559dc1011d265db4e59457e8ff4de57378007b497365d694f03c662f35e28c044c31feac618d4401bb8db5fd75d79e5874741b6498b98e806193739b6cfcb75c5a53cb03929cf59bf8bdc43b4dbdd95b9f81aedf940df513f4eacc3d5e2200893693cb81900cd84dc935985c06e3ed0122952a65304ee3f60a0fa962ae41321cc37c5932e7a569968ddc07f29f48d94a1fe7b9a32a9f4d4effd50e9b56c776df99edab6051863f73349cce613f770c2002e585b82a44d93296ebc33bc86b770aa169e9f582f921702f0cbe5480cf53b8ecac75a568b634a5be53b381d620a0fb164271fcf53a79e806da0645969d577f2d0825edd2afff16a6981d758f79b473e1f4d55f3bc8f97b86ddb7424b6737040f956b0e44f108c88b9783f50770a7c69db25697f9bdc57023c1d8523a5078123f0e1b1ae1546e1245d3cf9de2bda1590f0d168bda9ff6f6fc85221168ea1d86c1697c32f3e5e5ceb33c321f986e84aefb2bdf215cab9d083b040ad74d5a92ba25d55b06ab23c6760d821b48ea220869058a73084f0adb93b22200443e00cb1476fa71d5a6e08343b312004e3951c6b28ed399da6b0de6d46a12fff8776bd34dddd3858236e86956c7acf98da1efee55969cef3882537e14bd1f0ee5324855844ea982cf416ea4db867bbf0f57f2c02bff13eafeeb114d2aa7dd01209989b862caee9ccc0202aed478364f4ce9b0eb1a9fc040750f948cf54f00c87040665d014d8dd146f44bd0e23f20370113036503471266f9f3bb31c3bb896cc0144f2ac70d8d0e74b179f3220eab6a759185ec314c16b543d6909c3d95ce055ed2661bb9bda9d34ea12a50f62eb85a6f9accce26848bceedf2c08c565f3efc3d3335eb6938b9d6ab787d88e3db61f24e823496b854a46ad9baa402ed6761366b4bbf10761abdf5c1bbff1677a18eb3063f53cf4a31b91b48403867c810120913a81be97bc3209f496e480a529c1d26ce1884849fdf5ee3423411775a862f19fd05bedb734bcf8f1c71fdf1f4b81ba5b780d5f1a6bbe725503fa494bdf4a1b6e0b289eb544343bf10c4e72f7763e257b6b0857db20e1bf7385920dc2ec6b432980720bffec7567f02be19b3b3a14a10fb469dc4e9c89582919571a85214232a709914bc4f353f6b8921ba6a5a8d81feda87d357e5d2a1a5499f7e99f8daf5157902ff29bb7fe9b19334fdf0101d9c66158c40bf36385194b92fa2a1a3c7f8714cba95ff0907e60b2a1677ee7b78460283659f6ebae4639760ac0006dd8c8312eadd9b55af54ee2b0603336645f085d1bb69037304c03136bc82c1b3819e8ba3d454e34060e4405e2812503370369be54bacc39a30945b29c05ee982f83be88cdb45d2505af103b6c5a61f90cf3e3465359c486bc3e4096acdf2ba8372423bb00fd30b1420ef2d52173bd9356e94e3eff6ad63507c4d652a3cb1a0a45cc79ce81f05dbde4d8e155ccb27927558a68b23841d2e832279a2e5458bca7aec638b9f4daf7a7f5700d03d6a978b3c8baac80cf216f64fd8099aeac69f1eaafae0bca89adedf2080d0d13a391793ccff55bc15e37eddd8e704a664b778e49acd01e537893dee6ab1a4b5b3f415a75e40b75f71084651c5eba11b801063bda077e3fb67a31437c1c5bd25fc107f6d9e75b4cfebb5d3227d55ae720ceeeae1617ae2383ec70a060125b5ba99c6cdcbfcb43e9abca85682640f1cc37d24d28d9d2c9324fb3210239208552b8c0e29159cc2c49ed7f39549cd5ce973c2fd6781d9c30f71a5a22ca49300e94cbe2d89d423aadb74cec6e15032f24131b8bcfa935d48ccae4f96e7a767ea40a8ef59f4eed198b8ac52a8ee748f4c09173218d1b688ae92124be32ecf89a1c72cef0f329481cd6bab8c3cfb89911dff7711505835d48929cf37492f68e00624233874b1159aeba2470334361c780809337df6823486ce2f829f283be31c927910efd130d6c44913060589a88fcfba7dd279becec7060434119b219af88e1a9b2a62dba5fe6ab492873cc1613a2b7a72d9a0e1f7f289eada564e218f3f5fa86bbfe1b2ac2cbdd2db647d720638a51d60dd4aac630938063dac4f5b53ca53837f4383ad46b2540af077ef42b602aa3e55a0f6c1b45c68742d72c5ebc98f0b618a1fdc506ec2b96937b90564a53e816f4a99c8a37385bca92ee099af8b08355f85c14edf5ba29b301f06c29626d664e4ef8debba089d0e00d3c19986624e0f1062e47050788e9cb30961dc83236ef8a49afda4ec9cfdd280669a5594d1860393400c292583c32e7372c6b4071db28e35da1be6ea6f268b2e623d5097e4cb1b2b2de5315ffa5e246de0e39d1170b3b2af9d607a5a46ab2c40d4a87b3ddfc16f087ae533d0e5d89c96059387b05d3e3169ed20a452bd4ab91d83017acec307a6a2d09603f8b7a42b937b373d485e9174177eeb09880f74bddb779cf755bbc9a752225da4a8f0505c9dc0e26ee5b0526d9cec4b274e45425db93952fa0f38b62937d93ba66a44179779cda95add477cfc8ef07a5ab39c70d921394821334e7d5d9434bb0ba66c9b65bc531250b2a3dadc22526600dc6ad56487168226ae025ce3f7fd24240abfdcd7960be04ddd76cea621ebf520beb979825760c0d4ab70e92dbbd55e6f055a3b771eba6675c720eacb17f855da14a2e205e41b5b84f6713cbf487b65ba6c1c03d90bbfb4fe9e0474e8c239043bb817c217477f87d12ba46f76db6eb0a418ca7f626aed98123be29fae33dd6821dff1b22cee7814e1352f3546cfda1e6ad4fd68a3bb98cf120c241b0a8293ef8d23220aa22b6df0865670ed362b803fcd7da4293203c38cff164f871466c8e76067cd39b3a12b44a1934ea4755d91e5233dcf0aaa9b245862c974201306df1a657bb4a08fb79a3b30b520108179a9ebdfc2d538d9225256caf03db5fdb79fb344d7d9a8e7256cc17349e67231e4ffa7dea2694c118fc72414708d0282b3ea0ff9726af4666e4c2c34e08a58ee140d7427fa5736fdec32b5d9000938c92e5a03b524200a7f7475fb4c94909969b5e2fafe37b0511ee63d4ca67c574e191ebb44480ec10dddb44a34c9ffd4f2469e615c37213d63ca1558356aa553452f17923eacc8ae3b675fc0bd7a9044af9400a0c2d62c382a4286ccb536b6c495c64cdacfd177fe8967dedee63d8be0618996c96468c5ce235707726e51257965daa76f43bd7830b7e3dbdad2fbccab241e6b098fe0428df3e2f7fae3c82f21d4b8d3297f3e1e58f859b1fb1ee398dff68354519188b05d55d0e6f29c0531b1df2ec332ffbed55ab1857cd7cf7234dea34498157351fc31bf24da0487257e0868e342fc3b4cd0c3f0d6bf5aacdd1935caac627937afa51e191f07a68bd151edcfad71a6f43fc6b02a8754ba40d868baa041920df18a18ab2c83c317e0d3a768230af164ded7a00ceda533a88104cc0df71abdaa4444c5d7036ef5602a1cb9fd407c051737dfb5b3da634b4e2a828d5074caffb473bd5c575cd88dc78329cd8fab31971bec6057bd1a31ef3c2bd29691be8bb5673f02382bed6e09f4d3d3680ceaefdf8c4b0c9493199117df8e014547b7adf1a9386a3730ffa7a1d5d283cc5d9b51abfe42110da28b48b74a7df37286aa7e0b8449127d7f75ef3bea7acac90a2cd2812b1780b8685c71370d3c95ef3b1b0191ea82dfc144890a8dcfb2666f2a352d7fdaaab146c85ffe882b5d818ad04b9b7e1817dc1c629f8f181b9a3049ab283891e6a0823e102510b08a412d9e640e18d54077e41bed3273a556b1cbac98f8f9a911355c662648a7028297c676a713473fb07820f8c32db9f0f0427808a1cb5393780f26db7d874f06fcff44789221bba0cdcd434293bb9aa13aa7957619dae910002d8adb32212a98716368c89b5ba30608cb825a97d07382979f6e1adc9bdc0ccdee4f6eb8c1fbb2f3b273648deb997aa951460883443fc204d39e37cd07c9555365b706562f7f54eaeb7c66e7ca541aa6dca5dbb68648b97f569bc4bfa3cf40b16cb3023786a16a79f62e7f27174e1f8c29788290ca483e561105a947570fd1c6d63b8d5bbba96413ae284d2623f9fdade4dacf74ae74804cde11afa17b9c6bd14089305498581be4d00b4f7c5f62bec257f5b1091b22524af854a325b400517f73759f962e8d9bcd6e5dc70047b5e15284416a5b7894723a35757d43baa5241007da61cb99d22691f99dbfecfab36158f1816d090723ff21a40465b00ae19062bf7696176c0d4ac11ad8bb88fd85c08674c53968e8cc0275b74ce04ae2e69be24cb7f1c74649dcb3bafcb9e54bcf872fba6338a563dd0dd37b4f75916ebde9d2b3ca4a6ffafc110d4e2fac29f1be1505aed0afd30a2cbfb3b5a459c57fd40ef6e32e7c018019d2fd1f2b5266b205b92cb617a27724dcc814804e7227518b048910f9f8be868974616bd11d573f2add065766b96b5475ad1409f6054fe0c52b799979c331eb645b7b7a0c5f233d3f1a44606eeceae6ae2392322c258d69e664ed7d4e141ecb8f49ff4ac1cd9ee2bb5e8b696f0d7c77c01612eb44746ba2bec510fd9eb4c24ae3033e4ef46adaa37dc08f698f7107a411dbadd82f1fb4073e2f3287ebac08c10252db456c2c9d188ed621e66a16c9f898e321d2496968c8e057b569d46699ee7a96d3cbe7d678cf9345359946f741636994eab0823fc4475c47ee1e5b6024c330c95b7f3a401bc202b4e167879b5510370a9645a2b53172258ee0c6e567ee6a9633dd2b1771bca3968c12e7beab030e0ab40b220ed189f27e6d6e7a95119d33915508904bab6051ea8f272e6e7c6aa0dc7804d886017f9612479f8a4813d53f9155901c928fd4afcf367cd42768525512774ba38517a1826d4ff1a88188cdb6df11976f37d3bc5b477e1dcd1e49b94fd5a7e4bda972a255c7a54e33f5c845c821b480f105af4b85d79cb04d47f2f513094ab91add42fdb459ee19e52b1dced3b716f809a9a94a5f052ead521f1420a63a0399d4be90db4de39270e4eea4e9bb278341b8e0fbffc301366f40902e84f8cccd0348f1c96a2d147baab77e9b026c4d054adbafd99ef4dee2945f08637cba712eb50f9f224ff43b385d89574a5e38d2d640b3e108858e3d53846cbfeeaf3ac4759fa38bf69b1d53034738ad9e215c1281535dba2288514549fa48ce99e575e8b08338b3aeea0dee6df22b189f5d3ae7cc2cbda6a15d1a6dcf7832704395ca49a1df35738e200b74b3e05830e7960e4ef2ce5f7739fba536b2079c519fd97523e6a71d917177a581b50b59669029c72b6a3b59eb47cf90819fa6c837734003679d5ed4ae44b26e7e5eb5bf6cb114b88ffcaf5da126d1eed8237b4ee8ab8730cad29c4ccbd7de2c550d80d76bf5426f944c7daa0eaa10bbce6ab6d242690b76b62607fe140bb3651199324184961d0ccd5c86327a89fe9b09bfa0443b997476d6b9e1b5dde03b11f6e2dd5b9dd702b9a139517916ce9ef2b66991936505e540a5ef3ab6de9e3c2a3da4a46ed3e501d756e038126a70cf20b810cd99071dbe3d333f8075f2c90662b15024095eb13bd76da48b9e3d14625f9824e230f186eba1556861be4817bbfc2d5d3f432229afdda81e6d067d6554c117e58a778e6825bf69b21419ab9fb9328f2fd6cb59830065ed09160a7c517d4d00bacebf13b2e65669b67d8654afb9c668ec07b16b8789913ada6ddcb271996efcbdfb732ef15e6247936d3294c3acf5b7ffbb67577f11d30b8275df428bde8c423ecb7d97e08bdf92d7a1582a6edb50168d63d2d5c71354c6cc36f188c8d7578e2d4a6dbdf131887a4faa0c0333a12ae16181d84ca5141fb6bbce8faaf7be0a2dc889d898bb2c93d029465f8fad26fa27eae3013c0761cd3c72a6e72cec141e18d312d2861e277c696fd8cdfbc64a6c3866e77c81db30de630f46fedf04f4921e2909bef900e3c1e83e87414503fe113a6e0ab8a948eccc2fbf3251cf0af334d0eb737ea112ccc378d3a5d09fc1dba55c7867e982e8d4ed7c7ab16808c9f680673b5a7ab6437b642aafcaeb9431650430eb64012262b3579252efdc5de00671fd216b0ae8ee897bb1c29ccc8d0e260510fd52b48bf0b0ecdf9425ff08d3bb159c07fb01b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
