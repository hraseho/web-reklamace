<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"72d462c14b6e8ba91b1fb36e2013c99c1f2683d43279ffdbdda24621f46d6d90c09fa56af015c9c40eeb47b2f62bb74916d008f14e05bc12db3ebe06bf2b7b90436a419dc7257e5e11d57cf6178a876ccd256ff73fdacc16c7fbedadfa66bf4e4bd99f1efce96240fd8e63754c0f7c1f960b29dca1016a0c9183ed86239bbe0db75bf48af4bb2859e9bd4eb42a1f9897fd7c6750fb79abd17d79fcd700b4bd6b0dd9a14c0e6aac50cebd43981d64c5e2b3e26e7f7530a40cd57064f3f21a4872277e378b21027629bb532026342e57e51ab18235586a3274c12cd86ddcaf396e5ea79721f0c8b78e5613d16adfb6f5bcc4fce5d98be3184d707380696bbac9a1459f88748546b5b3802f8edf3fd61e70dd71cb84d76a00e1f76d83828d45a6a287ac31d3a40ecfcdc568473f9cc70b74ed737bc009900e4c1bcd4a573827554e12b958ac9b63f3da6b33a5ea71ae248bd051212ee0f22e411b4e9cc787bd707e01198d600a4397e0746f0cf7d033bf57427e4ae123ed003c262a3db8eb6fc9d20d4eab396058d12733f57bdab904f9f977520bca48a9825b36b09fb28a7203f1df29c6b026f05bd74e5265faf1838794e191dc24fb779c45dfc7aae5366b8a2306511906ff4f1fde499be41762d1399619204a2cb54d4a603e6751774cd7f427658e32f3b8e0a2e35ed85f77af817a392e9b6930b45fe2641ef9fcc4b212aad0c67d7be0440b756875b8e53dd5b4fe20150f3b467570cf351d1c424e93c5919c9666df7de9e9797cc996ce652836595c0286a7daafd65f054237958178e49804fbeff7cd010a6b64ba80e330b6ffae1868e2f2e1f9d0529fef0ff0fc61485b59b4bd53bb5c3ec4c2acd29ebf1b68022f90d4c01cf3fa39eb5a48532c59de930bb72bd00136fc2de8eddd832facaa11e0bf258c6822bfe0d9f1d8fcd534b8124c879985ff5f708f65752d4cc411ab2de7f74dac12981590a6c7d2431ae20db1dd3c56d11e35f72e3656a68e99d7b6e5ba402745a24601ad0a700288e6ae91722957368792b0be2aee1d039840f806fd9705b6b886cf47e290dcfccb85de7514b58ffef6d939fbec8f9ec658e9afefb1e052a5785ff8583063d2f94a88e1043503301714222bb2ed8803b909e4a0c2975c4c727579d6b1e0f52c6909b5dfdb4685ba0450e4347d43265db853cc231b50e696aa7be3998ebfec5620d6c0264a4cd23984b2861ab134c52276efef46c053d2b26bbde1554d34813004f58d31c724f89f464217785abdeb53a7c44afce4ca3dfef572ebb32b2491bce2ac315b45318dae61914f6834c37c027ec3a9486795a9abbd1080f04c8497f43a5d5b0fedf1bb003987e092e0968b9853ff53ee0268b5ff7c6c8572e0b0825b4c15bd8507368860b66d0405c6e454ae78f249b9280326b609664d3a1a6d3764854ae98898eca5341798f937446101f1cc045e8d3f8cf953fdf8061eb2d1e11a5472e3b07fb171957f63335b56cd3f00a5c2e22754649be18d4e82136b56408c09cae5be1cf84371f84cf2baed55c379cc62b2273eaf75806fdb1aa54ce97b1e340af0caf9f9f365d80ba10d192a53823a9d9d6c71b7d84642f89c3c3c6605312d17a4fcc7cecab2161bd9c5a2c57ebdaf77a8ae3ba4ced67cbe70e3671c5f9191a6dfa47a3a82242907938a7ff5aa29097e45a067b29c8615b637b383c9794eb16e10f4d8ba47d796571ecf54462b1caaeb94428f4aea024f8a72c3c8182bed29de7f8c111b6060b68ec730ca630feef57f9cb80551c6e1bf516f402a5efaac94e57976c4fa78af4b0fdc15a4f9a01e0df2d6288d7a51ebe1b0c3c39eaeab28f3f7e80196ecbab6f2cfcb4784d15e7913653d76d9964ce14d71d6d3a8ee10ae6e149cdbbe262fd1728d381fe9cb4dd1d26902f31e7306780ada71d03cbae94ff6a31b838b746609e5338d551d79b627387c5ea89c3d7171cedaa731f80763cd84d56906e5a06739fc6a1d1ef687d5580f8d20d820b7355c694a22ec575ba1f84cbd590e67fc2a23644679ef8928e07c5828fe194a0c0a0a03909a0d4c1f82b8b210eea273b27976fec81f8441d94b3bf8f9c97a138d0d9e2db12a10ef31a940046a6880ec2813865de228098b88a9660c9bc17110516143c6d183d17a3ec33adccc1c2ed61799d35f4f9c6cca5406d879e41e16fe86edbb453afe7b3600e823076ca928d7232ef33c2acfcb60ad120b502cbe5e78a8c5ebfbbebebbae9e096c5e00bdadebfeed7622a8762c18b2bb21ddb4876c0ba6d773a2a21ae0ce062c38f7881fa754e450dd7e98a5c7c89ad1b6445262e0880ddf997bb6c963e997559d6bc0bfae9f86bc22419a95f536e60e087d12ee805a2b781b60794c82a667fb79d03c1c88533549adf73cac191e6169505dd8f95c2f173e6cdec9945ed5594a697c6355f5077eb798a6b882ec1b2d1f5aa8fa730a72c9c662cb3175b696c1de037ee6e460e46ca91a1eb12a453c0e056c2643bd7436ae86ecea41201093045ebdcf57fbb07e24f5eb640359664d70a9cb8982a904ccb9dcca0b011d230c062cb4dbb56cf6b58c87b2f6c157df0fde1cf462c02337a5274d9da1f9a68385cad32ad402d6f4ffaa71f249af1e9f4887aa32506279c03e1412ad32d3eff533bcd9d494c2ccf1fa45a0ecc200509020a32275d4498389f61d64d3083dd8cd3d710bc6ccf291b66fc7375fa9e2c7a238d40cd7658a119784193d594d73296ec4ee2b1f629025f453deaf21f62b19484c25545f50b5f1ee6438883906cb21ae74e8352692e76169601d2241f656bfd3695cc2d35988c7ced117e3c9ac7d0d3740d10f2e02fac778d03f80a7146934f98117bd1e36f9f43a5764fb29c68bf8df67241fc33e7389b6916ef7aa313faf3fc588b7583918ae695b8ae71c0812f5fe2fb62314749cc55e9eaf14b3e76699884e9168b49eb00fec75b74f46ac3e3c95aa78db8e94d7d8c8231531bd73582f63b75e7e5b9b072caf5604a9d0a5a1e46469c8361032d77dd744ff4ba503ccfd63172f76d6752d58d6f4e3caa1587c2534d4f825e31dc6e7c7e1598736386bd0e938e5be50b46fe72adc7feaaa3028cee439696ad3fa479934921c33b250fd7a6c02b80fca859d1b6c4150fa24507091e36644a27c64cb2537c04dfc51d619381f1312ebc58fcbdcfff43f5eb55496dbf1176e97901474068a2a0b8b3c982279abce9b2b782c906a1ee0e4da9627fb45fd4bd86177605e42f3a8a52a7b1a98f410b32e322193993bb175d911eae4fd26795d3f9b2cb9cdb45d0340038a30a9e9160fd6cf3244989c67679766e4611bee015c8bd94b6ea9b740202d2e0e856dfc2e6b622947ea0caadef24c22fcabfe8f9a5975dd4c1be301e112ad5ae79d0277c0e5f1b1473c27580beac29a625a762fd6c4a4448d5d3e045cb285d205a76db94148ef7ab2b62854860fe49a01f496c66c5971bdd47a80e3ff930e819338b5e32092872e61c6e1bfd17a40fac24f625407026ce6fc0c5d8de6f48fc4adbe4c476c2576956b75ebdc2ccaf8386167a40ca14bc1d9681b387709bd239b63fc44523fa1a0bbe85d32904198a9b1a194a3f5a5d93cd70f91faa4d7434e2cfa8d274e52ab38b2060a4caa25da8b86fa1dfcb280bce898f5c6dc77455138d72728909ea03002c8b673d4e4488062dd22639ffac44820c69ff018e44f70afb0be805567c0395b5e3966b0e64016aaaf18007ccc9d93ec725e502faf8c306c77deac2a8b6257c9ea48612c8210924036b5e7fd74f6cffc67526cbdf6c7941e75f8757a9d127c36f8df63f5468af6da5660ef2ff06942590673baea122c9adc48579969a6818ac9189a84c772dd76ee311283a04846c81d2b401a77a4b322864b209f9c3ca7ce7e0f711eeeaa15f5c3e9636b1da12c514c80254868778b77452cdca739991dadaa0547bc2502df073aa41db7b92bca999bc3501e32cae469c8c62e3880e258e045928ebf95988214c03b7f029efdb145266bb8a3346f470792f63bda0b9170b24aa83e7a0cd6c7de3d8b9c975a780894fad3036af9052de62aae9477704aa2e11c23957eb1d946fb5d04f701d90cfa3dbaef6c9850bad7400cadc20be8531c11577449022dad306f3d9175b610498e397d14ba475c6df81dbf9c5574a14b1ad46d900e11351602ebe3eee486c0abadd19362af05d2898836c96d07bdf3f3b9eed7bf664f0d8de25358ae72273dfc42d4452580b7b469cf064cacbe3467ba8fa07469ac5c90e0dff9d9b2ddb6471dc8cd93f9053d48758550f6fb9517d7563706cf90326464eb4aee9ed6e2c50c22ee2443d2eab388ef21cf15d19e414b64e8bbe50f5d99e8897685ad02f11cc836cd5ae4e4313ce3cb9ac605dffab85da0b375eb761e85f58a472bd1ab4f8532b9784612e8aa76920714c74353e844b76124f8976fa02e4e477e285e57ca14e744fd9fa04be912144e0bd425efc9f593c1ef231c9d519a2a965ac53414e81cfc686d17cb7cf2e94a6be97be9dbc7ac44429a0d3b25259b2f5c9ae04bcfa05a30ec194c874a0d84f18f3dd3b29f91d3edefb1d2ab9799c7094557b0fbae3abdf6da4e2584cdb7b1a68f2d7a8b3bf2a5acf3aab292a1ea26be9714b780895257ea1f5f6c85a867aa2bc071f7af9299de6220d3d910a5c2a6b3478e6f07dd9ba2e5856ac192b70e48c3843fb1f5d30ceb05716274c0a875e18bd5011378b7b82141817f1269cfa36f7c75e17b252f8f9e5ac4172d462c8812e43d44ede497285a718f549a0523bafa50ac4b02dd0fe96e71575e6aa699a71d2dc539c27992ba9de2a3252c07460dba2eec4d83463421efb493734f516740eb3bb532257adf8a1ba907397802f779c5d6134373e619f3835b229be94088f98bf0f7a6fe3d5a2441c548084017b3d57b8a7862d8bd52ba4b900c9e5fa69e60bb6ac217add2523e89dc8aa4b3be13f86fa4ffe50a8f2dfb2de25eb1a8cd6cdb374b996ab35726b8030cfda5b79d5e0e228f6d4f60bd4b5c818112c3d788a09c7e644a01fb97d7301194abf4511cbcff41c1d0cbfe5d9386e84b652bdb3dd4e5d9b267008edab9296ac6500fd59b3150cc71789dc67167677e9cb8f42f35abe80c98bc30e27b9b5620c4961799cda4d87aec326954e63a58a6dc34c499923878e7220206d1a56b13e124334562b03e476813eced1464db3722d7eff0f5d7ebdf64e24ed73eb652e28bc6fa83f2352abb50a4e47a92993a9b58b91f4de07a3fa1637c5ef5b7adc30ea616bb963a2b0bff1d6f20b85aafc0d3ec633a6a01a2c2423d8ff5e039c184fe3ab31aea9b6cbca5b71ef68393e1cec665e84841755acf9509b03aa400f95703fc9abe2d11f63c249fb2b8269e70e5bbf341914dd14bd6d5b50f6a8a49a4d5c189a2a0cb38a2d84e5b6e16510c5364174aad65de600d515537a218f590ab49608b0622f39fd2ec270db3d53364d63c773ec78d9934ed56d27561c55bbaa6afa8f6b3248433edf68f13c7628ccbb294073767c671a3c746bdf3e63846e8b36d5f100f2e210f540e46809051978c3f74aed77cf03a5beb33024abe7bdb0d6b6c82f67a9de124a332f1dd435a891b94c302101264bbf515b0510cf223ec704237c8e4938c5e093cc3e465f08293ed531366012739af03c02ec4e6d72634b89ebeed3456708ec4450db62d3189f0e938263dd226db062905cddfa12bcc05d84b3cf01fba1cea94d18f68def886472ea9e2a3dad93b54b553a4791fde5f059f63f982a2a4f3b795e1933808072c29c8f7e5a98c152b23060994607e60d745e32511daf1af5ee6c5670084b0ea5f40c7afc6e54c05c3b32403ca772947c15c1a4deec9da5b73033da3447c89bcd3e0b39a4ad1c487ca776b34a38e82a25e6d22540bc7fb7273e60fc0362aea4a616cd062bcb56c08c97eff0d74a59b29d5985370184a3f281073b9e0e5ff0d40a75d2b93295df1fc6b2f1ad0bb16826d747a8cf8f3e7bad85dc7792c7e335d07d9d3d4f5d07fe6c6a49176ec5254de9a54f5c7ddf8e0e994d9b1ddcdc3dcab81bc32d595cfe4c586120e73b66fa54dfcc02db61394f402c6c79cdf73e80705ab881e3dff123050f93d7c93e61fb616d4de741a5175697e0fbebdd9afe1175a1d04a64e0accae939de9fdeca57b90bc0f55855d9b53dc2276f56f851cd2ed112a0525d55464fe4e5d3e3b89b83dd4a16347ccb1a345d2ec98da06c2292fe274ce0cca86d4b9e3ac8e2d991ffe2bc631ad2e36d9a93b644222834ad4a9c30ac1437c79bd2c71f872ffb69bf50353142c81685f0ae303affcd7561ecce47c8a18ea289fccb6d6e037deb6bd40d331f38819b2e594e06fe0511f026e28619f57101f0bba91786cfc468932547e9741988bd65caebab5475f26097fd9b089fef5b63ab9a3347c4398da1cb01cae46520f0ce45778812bf611157745733212bfb48513f201b7f509d53f9a46570905fbca7172f43c864ee1f3f5556ad1d4ebe0b99a6a2de0242ee522271695e96a83bb5c946b75edc1df89f75be557e86230f2e93cb9b7a7427d8105eb26df4cf1663583c10e9622b42eb9b2874ea47ad2f3d8d8fd04329565f6d45dc67de0a8992569a4646eedb6ed3a2f57ab56983df237e8e03440850984072320a36e93199aaa2381131ac783918a4999aadc6e1e0a58f79a448af05a245d2b1211c96e078bd936a8b8018b2b55a61ac53dd05bc76cd7f5669e01a8ca8a01045aefc8bc52b58bae1c4eb49ede1e135117336f89d2019ec0803d1dc79ee43103b74bba020bbf2883a98da8d3e94a1878b87efc581e67cb76459c5e83291f49179352453f174455f7473f50b3e37fc7226ae49097fbf12eedb6ad4e73b4d9fe96ae37dcd24a0c380e6df67e5cfd0d9afb7a22c6b6c74460c79c1bc5915755a8bf670301fc9fe5419f9b05c01a916c20588ea19867c857d722a23d7859b544a3e6b9046b532730e8ad5ac80f8c4e757e5d800efb30dc0cf1b0e580e8b67e9696c2e5aaa4781f5f473fcadb08beea59c2e326d4fc0ff11ae13383477f31abcee86d23f10a88df8d229eaeeb5473f9a786f3f90940031d2347d310e63e1ecf0b36a6d928d64b65a19f95fc65fb27a5097b57efb7af3339bc60d597475bc5169964a2283dd4485adcb039250bbe0b675360be170cf7037093bc7b885658ad15d36970afbd5e3a745bd587df45aeb78e5657b1819c6cd36bc877fe8eabbe9b043c1a863a10bf7bb8ab2ecdec24070bb6fa518ae95e1992739a3b7e7e1cbc260822e53d8180be6d1ca0120bcbadaca32982055f4935d1ee012010d4da168df795b2ee9e795f7ba7c68ff17a76b2a04c9c71bde2ed4412853c37b2814529dd9c5931fade0c8f3ef6d2762e994fc7653d0debb26bd368be60a280941552b56a1a01263dbc375437eebb3542c6faeb0893dea9220018727a00acb39ba637f887c1f6c9a092d0d44cfba05eb3b4c247d68b0a9a12a9f782a5eb739adddc79e99fc421fbd1fe80e90548e6ace402f082bf5cf30707374c2279224d24d6ba8548e334527e102ebfe734b9ca8735ea34fff3ef391f146c2277bac243f83a57a41035d9cb237648f1bb080f6bfbdadaa28f94b55f7dac8da309003c5da086df920599f189720559d2e300f0f5060dccb2d2b871366b683c7af7d40f4615e0b77f618666a4ac49132b273332762a611e54e06908ed82d6fb0c263d57f20865b45384179dd9d2715e915336f7f7d67d9ca6cf06d8d5ea237199beabc7f80098eee35244342224da173fff35dcc263b53d0000064e821f0a7536b2eab6b8c288a68b00432eac5bbc7a22dce8c46448cf06acd2c8210896dfc4b109921d9bdd300961b13612bc68659198d272ebca0a8fb976c1cdbe725c9d8577dbd8fb321c7b7e2a439abe4a9fe55e9a5ada7e277697b850c7043116bcba4a4820ffce5f153f61cf5d51db3fd3a69c6a7e1742c29bbc3e2358622fd81ef48d1b0c0db783bb05aaf24c5b40f6e6049e0b8f501abd1946f65b674e1109471efcf47a72841efc1adac125b3baa8f25473df317d0fdfc95d8a0f907ecf93e59e198989e4e5ed63479f5e879432ba2bc8bd8813e27dcc9674c2458160392d620c9b3c20045716eefae1cdc73c7cef948af1e832618a93090d97bb857bb922c93bfb3c1be572da1348ec4a1f4cb5c37d0d97756603085d83adf7d6b83bf3db6d2766b9fa4ff6b5caebbaea99bd2c7755366a9aa3134691d0990bdcbd2cad8beff9d4c2ba03f462b1f469a2c565493001344df45f4f6952562cf2574ca0d7e5d79eded1749f286d2a433276ef726bdb986c54055d444e2601eb5da688dd86772dc52ba0b96ce455c22bd771cd6fd3425fcdfc2e857c96bb3839fdc4653c064bab2b0b6666c7671cff880c44c510f592f3ff8293c69909f2972a935afe022aeba99fc0cbbd33a4c4dc3a4ae462cab14a9d9b18855c79133e4fefa87225825f386639a259679a48c6f364dd96856e40688b137baff0fa66f79284af312bdf62822b0bb3529f7492fb4faab3ac85ac0df026541d47e06eb734a710d477cb75776bbecf83c66d1d8c5483e22702277e190bb3b5130e53a6ed8fcd29883f675f140b3cfa9497063439bf86feb9de62ad5c3970365444562ce20975c011e1d1dd1cd983e8f647dfef0ae2c181e9786b1dc33f700db7fa9cbf875b101588b12f901308e76fe4fd9dfb62f3ac330e4ae13af61cf9e31f64fedc481affaaada33084cb799991e4f43cb2687fb2a35d5d7f37eeb3d83de5712b46bfd0724b00b039c52b82a5f9dad8224390b42aba0c9748027b1e2b77d3d343cc7f516f38f3df06a9e6f30e4f2f8ae533afc3b474d8d2fcd39384c27cbd31024ad6fc08073b17afc252875179fd7f35111571c818b6ca9a59fced5196f1ac72366c50f3a0e633bd36c55a34f557abc4c3a84e5e4c3bc93bd1a22538d9f8444167a22df472f557f84dbc2fd3cf338cf4b29343b025e9c53e7b75dc17e83f5d6104a77c9ad397b6570294f9bfb6fa60cefc8fb89790146401424c5bf88ccb5a8e04d044c9ef97ca3f7aa7f6e4ed56b95aa74a7bd6e663d9457050425762485d1151d6751d321a8b02df8c2081481f67cab0c4f37a01658f04a16f588377193f0d331caefc09ed8d5b6b06829eebff2d001411eccf02c032450a1aba40ea0fedafe9ac9f462282e650dae1877387ae079830c01d663e52e613011b78ada9f1cab62d067f4d1a6e5ae9e07a870070ce59a48c81bf8e49bf00af6daeb83f60b01a3fc6e7b8ec0b983c58f31239fbf112531d144f6fda2e0bf1d3f30c24d37b9290be5a605725563d607a1c96f8a3c93682baf0e58fd81ea85d711572098445c4d30b3d7ec0d044c7994cd0a4191821bad357a0c8df4485db23328b56077b4b097f01c321d7e36ce004ca2b4d658fb6d5435f37057a8f3309335400a010edf63fba12082416a3499467337b87ffd5ce51aa57d373a40abeadeebe99a7d45ada106c165b35d6a4f857b9d060f6ec11b40b6e99a2e5a2536155d185a3fea8d6614328529ced6c486254b86853df455407c3896f3325d2fcbf4720bc64f623f302238580fc6b1b2d6aff46f27d1ec135d143ddbdc57067c8cd98cdf2bb99ca0d1a6ac7e61c9caddd793496a5cfca52e16ac43c19e0815b1cb0471b909c5b2d6eb030bca96c5d69e8925e41dd4c1c569ad54f74db7a47cea1f198f9b7e24be166c68d87274178b85e5110b97e1889c7309da54b14f05d06e4ef510410f079e3dba213a86643cf3b89646b703a2e80fb67b48e896a99617659df05e1afb9eb5e54946de1aeffd2b700ae49209db9c6c61ebf292427c63236281df98a7bf84c874b9c6e602d641bc936eaf7ba367339457588337c1cb572b8bf5bce4340cc21ea4ae83fefe497309e4832682b3405cc4d94d62020d6996f6c370f950110e46f9e0ec25e937a3262b6177553de69174138f6b21576b8a1316de34b045ae49dedced3b487261e07c4488bf8e28a0384371d18d412b40234fcd10f087e2fcf4fc3dcf34de5d17078e7959366c3147425f480a3491877c03954d756be2b3ef05f76f7f4570e1cf372cfdc08bbfbf90ad87cea436c8222fe8c88fee235498c1dcb3a59ff4bc38ef3877949b2b8bb49131c874dbc61ee406e4dc30d866a6ab1c03c4d7699415735b961d29cd35cf0fe76b0bfd81d5cdca7da02673ce341e8195dc32e8f54dd7782e0e9ba5654035090fead34214d74c90b2e7a433d182218677fa78904154ebefd3d4014fbe44bd94b4487482e88ffc1d2da8700463dba7f6e566b7bd75f17e9000e200df1204d0f9ea3380a47f7edca6bc3aacfde0145e9a7f320f1ec0018209c272a6ee1e30160a49432a57136ef054e5b4c0f8d83827aae52db9628a4e0e4f42ceae233114d9e3c03a5ad1a536d386f52796760fc1ca539247ede8c2b550427d01818b935e04d05091f38fb6eafa5d2b2573ab33b2179e3d5e26fcfbe800f1f0c511865ce0465913bf358387f379260dbae5210b604940c782db58db8d66471fdd69aff68102d4b1052a0cecb03ddd5e8e68637883a3ff01ef26fb3b15ef92efaff0af490e3bf0fef8b52367252f7c3895e77926abb99e6820ea2f8fc81e77947ec106b34b0ef1deffb2d6751ea6f9c5fa60add2eafe411e8de3f2e0c5a920b307555b5a177cdf8f498074b70eecd01d6e5f64729702c7630a08f676cd3e7c0a76c83354aa6387273da770bc70116507276137fcd3e482949e26f7aef990664bc29eddb1acce6bb31e79f2b0edc323c9e1b9c13341b9fcf4ea7d5e143a058ed9c3bbc9a54cb0880252b444b5f1a1ff54102d2c6c4ad6afcc25b74342b20a598865b0e0e87fb399c18e32bc5210065daba4242e2ffcbfcecbaa3510b5ab546f0d09b7539d85dd0f3189711b781a565e2690e892220742ed36feb94bff673f4ebe725a7bc16b4072fe06d9dbcf5d15d568569daaf253ff5089aa845a28646321f3d8e76ae3d30e68b5aed802e82f2993b77e11be769ab26a159d770c1d7fa070b7c3bf07640a39874d937c5e95fd774a2e42754bb6618efc46a2fa9afb67f4dc71f2249a14fc2d3de1ba5664c3f565cc70400e3823ee8ddfced3df43d41b3b7f7ec832b5b27e9b1537a673866174c1a80dc65989a1668bd70994bd2f11f9900c6fc92362dce5dbde1d939fdb69bd59eeb196aa82029c63758cc29bca11e76e7076694bef30f64c7edd549f55c326b2fb73452cc5658d8457339a36183248bd5b1d5c011308b6eb291331e6822f6e99d17ac448f1470cdf65a22479789fdb65bf8cc85b94df29324eb9f22dbe2356a352f650bf75fcb804f9c0fe23ef1402ce47163d3edd0226e3b5d2544810686befc1089e704a970abc70f3f1c866b7959fc2de18dd158d4d40356ba6bdb837997331d2f7f971f9196a5a33f2b108cfa3df1b42d11f2de04323326bd4158ae10bdfe6d28aa5746ffcdbe066581f348cab279f2709c736e5dc66fa2b56c97bcbd97983a7941c3b4e15d5a4dbceb13d22b56ecdaceff8a0dba15338c22d6079ff00d6bc5ef4687ea88135e118d040c91e7287e4e49fcb3028bbbf411ec9ff70b59fa8c1f2f6d99677f489fff72cf43b2af5e87794281f3454f6ec005acd8614b61b2f74da5127b2f14019a82ea3ab15af0c8f8b59ad780af366b20a08a7f5d6d1ee12d6cd8c64b1fe0c123d5e138c7ba9efbc5e160ecb3fc00894ba1c825dd75dbb18a8fd54f239effab26636c68e5ac84e7f49f8cb1c0d64d4c8ba184a2818c44b8efba2fe9dbfa621d7005910974ad2bc96b76cffc541df3e431c092ac4449b4d843e5af276c1577b9d6dd21d24f2aa65b7e9134b0cb7e6d7194cdc2d0a80922ca9431b0d1c6562c9dae56318d6f1e61af442b0f583fb9c8e031c83d1cf23c14a06c8b6e10b78e69a35b7e6a03b3e62ec084f1f1dcbdb7e07147ac7d30cf50e4c0045fcbd0cd357f7602d6a4e1f7e31967191dc74e0585ef0272cfc48e6271fd140f89d20cfc15498ff21b9aca300c02afef6c8d02b1d803cb1b3cb1ad646a943a09612b59cf623717a7af12c573ea328ecbe7e2981d0a94d422e287deae10b4effe5091cc45323288e135c7833e8d8c69a389bf30a671469e2bb01f420c5c43cbe5a4ec76dd71bdfa97c2f6201da8986f5477c260422e88a268e43ad8d5d2c39f0b08d89c0e067142eba49462d6fb37b657dfa65597667791ef166e7fb33fd0ed66d517d58aa8aaca1557c0bb849e9140bc176208fc5713d0854357074a401d440cc253113cf04c4135ea57183b6fa167f29e462753606285e649781f53606d6f934cd4b9f88b3a1686561beeab0d40132a6b4e2fe95647ba856cd3a95edce996bdc580949de5235bf5a9c54f62fc3cab4bc4e90b4721ac3739c9b50f3cdd7ec3f24bd086cccac4d3680c0b20c095a92ea9d455d844136d612bcb73873d8a8b5c290c8b068e4640d6833111fe1a1f6bf8a78d4abd1c29d3ae6245c4781cf96a624ee9ec7dc55946fa03c2031b4a58a4fa7619d997644e4ecd6d2a78c4dcfd8de772c7fa10d3a51ad720fa02cc957d1b9f41d7840375e64cba73bd5ebe15357bec2c4c4600603547c854906b30cfa529027ac41281449c24ec95112f456d486082db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
