<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"258a0c179852f2c061535b576daa06a8b3a59881348482a3fa9c19df3e91d523096185fc1f6f01bf3db2c8523fc70ca32de60a4ced7a8dff4a021847a6569b1710708a3f7c536f48d9fe59343395424911e4e95cb6aa2b5c492491280a5655521c85f0c49d4b9c7873857365af5404919ae01378a7b02715d430f41c413243ec201b9e460715f1427d1f1c8b62d1d23447d9b6fd27930fc3d215697738b7361d31af3d08864b2b7f2905e3100496cfaa15212046c085f511f538d77ee00e1190135c43844c15d9ef53241996103344b3b0fd131e90e7ddeabe285269950ddafbc6dc7ebf90f339448e3b37684fca344e29bbd2967984f6026759c131e752ac453f4ee1f5ebc84a0011d02e630f2a14a4a3f935db9517a8ae58f920a24b1571537d48a38837e49d9019723c3d940fdad2bfd24993633c3b6d7cf8ebafafdc632427d0b591793f923115b7b19415d44b9aea87dc300a81905a7a3b5e1355c44786f7e20669e3c7eb76bdc08f90e18e42beaeb44390a3e03e2e47bd0a6a777c53b373a440450a93edd4153e688fd52231a9866f08c4f4e0869572ae655f244cbc259110d7e124a32b8d0ba14b10505f4fa9088cefa403dc9da851a0a7836464841bfffbfcc2cf88be1850fb78ebe96db660019de9a0fc909bc039575926c19e99e72a683bcac4ceb1ac9be4de40b8b5402865841370ee9a8f05065d7007e8b621591fa7fe847820a6be4fad71c4a0d328ed396890163fc38ee6e2c0735e6283d7af105a0cc1baccb0dd86c51003abc956eaf0c846edb11a8fc8bc156bd39435ac1a7c1a42438d0c96083a6e32e76eda20422e976eda5ba31693717ccb222160d453bf6bd2276a15c31ccd05e78e7302ab4a45519a9698549a6fc22b00376c26bbe9da1e89e16636e2c7154e97f79bb8c9e8cecb4eb156364d4dccd5a9edbae212739accebf49c8da38f6fb62bd611471e5d56f2169a673314350559d2994cdbc8c230467799825965e3fdfff5ea7b8f0988fb35731deb897baf70d40bf3c5e2d1a58ef5e34fb59e7a7f9d5ca9edb23a98f7b1526510f2e48350647e6b40508243099d00e4cc6aac33235a792ab10659ecc58a94e649d9f001631215df9f0e2659c083daca82d491e05c436b9bac98cc4e27d6bc837c68b8b7e23dc8a1a138c398c0ca01a4f089cb200f6abf881d798ef92b78e5e43f82ff8d85a6d85188ebe056edfa2986aeb00115537dcaacf7d72a7498a2ecef45636d18cce145436823c8f8f6f1cefd2ae6d74fb09bad628325061c21a632fce6e78dcc18d0a64d31a70cb952da0d679e678b63f268c11696687b130c928638f742a45b4afbbece648a44685368d9eef354bf8060626137d70cebccb38bce3d311eb156fac09d659c580afb59f8445fa345d49c396b721b6c615926df62bf13226725fd23c141e98966be476706a10f016b662fb825b87cc7871cd348d633f54f61e608902fde2c95d987bd0f645d03a885204928ed49842eca7f7d273c2295b215f7d752739690d026688d83e3b762580bdd47c3962c5634a7fb5d34218bfbbd5af0ee22d6a009ee697cd74e0a2a6770fa3149f5b9b335c2d3654addc9d5ea8e3412e2c16cd42e5d6ac28bb3d9c0bb9f9e0a3f9b1bf11bd14a89d2b5ef7b348dede10c4edcaddf8fed60a6c3407e9dce5d9729f308319700ad5f28d78c4a98878c74be855ea32f837ad6591c6e5d5de0e34b0971709cd0461af2c2f39d5a5f939f42773cf8f3cfc4a23ac09dd510b87303d5cb011402fa553776ed453216bd6bbb992de09854197d6bfe139d078c7c88c2d6910100b4927a1cd698fa43086b37868a5c480e1f4498e60bc34c6dd1ccbac3e981c06b81445e25a1e21dc84dd315998058f4f6c1ecf38a19590f99fdaeea47e6cd2af92e1ab817933e107d90427d31601a2916b83c2cba5efba0a2a598d9eb18395590f9e97db564a33440c04ec2a4adf4a193de70af8ce00e2a43a6412fd06af71d2d1c22205bb43f07da97f6752fd617192020da6f3a83b04adf43078b2fa105ab32b8ee7db6f9c06a6c74a4fe989566c921e97343a46df4510ec33e86e09f9887377d8b3ec0b41e1683745a3b401cab8622e03735e4744df1cf249415febeef12341543bfd95ad7885f099a13e161c7d1409f4a48bff1e9699b280638a413d9ba5deeaeb38a9a7670574189e6a8d219a41721c2914ac6af63482fd55d4c52b712d236550d460f1273dc182d240ab299d1a6561204e0229403037119757f54f3b7941ec832f6ce12d063ffae8fe4e404ce9bd4284aff5ba627a9d5f9353741ed9cc334e2be96fb4d66192486aac1b0955ef127f05064299f96ffddd07611cfcb74377281e125e2441429d05ad0dda744864ac168a7c1df042be9a08f35d825d2e9faa1d170a8d5cb9bf43534305ff26a7002a4e7d713961693e4f43b8432a705a16c375a77a1b8ed037c395abe61754597f6441bdfbf044a2d7c1a22d7089f69fb6bf9d4432c6849678828260d4ca3c49253ee59dff7bded9d8e54f66bb05387bc328405e8e18aaf7a540222d665a983e4b978dfcc6615fa74a674a1f674cff5a114bd01f6bd428afbba05ef5aea1689c94f71e0b3465e3f7f617100492475fad01208684c77fe149882e3bd1607a49b9e81462636853d800e8e0b05a2db3c191b7f5455899b636aabee11fb6094fdb7263ff68ca7bd8e457c0eaec286300db0ff8fbe1029cf2a3bd750fccb8696e23069d64fc18886dabab7a548ddfea36e43d6eb53c4f6d5790d7059ad00f274687714989239fc32b4be4ed281df88c600bc7c30a1032781e5e39694c3764419341ee0cf7844df717ccbe0e859e01d519948e79e5e6a3344925223bef5afab1b68b88773af3aedb762e84aca052ffd68c2badd2022c3812929943c0383ee0c782aaa6c3fb210f136b60ed23ce3ae9686669788c7df4f8a6fd9b8aaa8584e4bdd388ffef5484d63d53dfbf97bb3187e033eeb8c6b1016b8fbe0c3feb46bbfa4e6909b99d737f8b79dde605f0e608551267c977e7b2f363228961ecb374f3c8963bbc4e0aee61eb16ee1d03eb14e0bdf4ac6e7c3069a2184a3e5d7307bc5c4cf8ee5297c5b315b0fa45354976a050cfc1d382682eb786612ce1e1cc76eca47c8e65102d99790eaddd424a7cceb49738d6e1d7fbac7fa83c5126d0cf4568b3f2206b23470c259587822dfa3442fc263c1f1168b24f4709d99342eb1f82ab67910f94a73d950c960afd8bdbe6140e5ea3d797500ecedb0077ff8b4bc2557ad7d95838adef8fd6b41f6c2498d28043722fc19ce71644c332528957ac083d03b5e25c18c94361921beb14acc46237c58667d10b1d26845a8a246405e11c44cdc71ecb2095257686fb4b7359f7b06f9db180fe0522c9947ef6b00fc563b2818119fdaecf7dcb42f310dd8e3b5af212a4fa8f56aee98eafa49ace3ca7fbe593a4487256e93c668ecd70510e7150042127e75fe76f4964a38ec93156bce01a67d975ea4d17e7b51b020bcd3dd92180b6339dfc17d5ff751fbc783fe77f4d79d4fa47e3a1cda9d46863764d60f9118567ce51a3e8fa1cca9404f57754f40b29f3765b5b9fc7289f550bbbf3db01787de94f95e07c38509b494358807b5d53a4a6c383925dbb4947cd6ccbb6d81dc7fb54a71ec5cacedce0607d3f94bb8cd3d0bf09f168255b5733c97204615ddb8edcdc4e81e0720ca523213d17b9a136475b343a3e21f77ae9eb2e335a7365c1083e3ab2466eaa14856754197096e8ea3b00a6eea02325419dec32629e808da41a6d6b3dc41c361490d341344436974afd468bfbb3bbb83c4fcfdab28de97df835d2f774507ade36e4c4471d5bdee19a6c4448b2d590e69a90abbdcbb9c7524c9929eec8154971238aec5bf1a3a2624a1b61e751e8359e50d72e1dc993d268b81abb0e6e5ac3e3a3d80baf1601f420bdb07a917e932121e9d21acb1a3236f9d3e690870b511df3984643961ce769b894799a17f302a90da7d5522949d73f5bfde4a808b2a9c773c51d2ed239d46db48e123620f5051772965c43b1ac2c9ee88601d7cb93d8971003150dbd2b0667ecd30e230200d5e69e3cfe75ddadb94e86aee495ce82f57ac0bb3678418c0221e7b78eb961c566149a9cfea9804da0b0c1bf28e6f1c90f5dab82537a5dfb09cf9eee82bf874ece95eb8da143c8d754b0f51cec8d2cb769c65077e82808ceb1338116ee46c1676805513cd5e92e736b2f45a29f703dd6069e1b20366aa21dfd8563ae9071b60103834dae2f0c071b390f96827ca264c01f5b99ae791c05167aef0cacc5ebe3d0630d86b2ca68b4e0de5b6d6a37e78a5a7a27e1c2f7abdce64c6afc0025fd9d211d94ea3587d2dd666a32696125a5ff7eb6dc26da28f95c9ceef1c0bd25aab1bfa12f376da2146afdf6864d75777e5a563ab86626a4752f5d2c4f23e6bcb7b8e211d4f3bb948ab33288150774ed6ca1cadc1931b8e1862b4f6da552e06e49705b199ac5a4dbdbee645a9223cace44ab37a6cdc8f6ec4aac9720957a5a1ee648cc4b922013875ce80ad5c9f6e04e28c3ea7747ef33eb1253335dcb6a7d7993711fbf8fc9b283b46e4f29ab972f7e9349208c63cbb67c36efe619bfe5b6176a33761b662a2570f647572f443fac59139a1241d32c96eb314d8d0d66cf402b343e384bbb41da9a5bcf9ae2e1bc4982abdd6bd9c48165e19d8bbdba0626b05667a8338ea4a4dc65cc1694a3173fe5074ef9f9d93768051d3c2843eb749d000364de0e3c85c9f49cd07a5e6abe883232d5e661a7d5040d8b42018fb8b52374bd97d6cb33b7269f23b195378d5479afd21ea1ef358a20f9865169d63f3082651a92c8add91f3835a9de2b9bb5b653dced9b00847d37efdf8347d604cbf5389fe192b86e615b537eb9505c8d2178de09b3e5c366411a14d87b4ddd49e265864bb41c39f1d8a31612d459bc7037d977318c7b19eee971a8fe1ae2df0e72320ef9dfaccc6c448aca8bf5cde2a7ddd02e6016fbfee532c8b4a4138aacdb05b7571afef4058d5d16d4f48bd4702fcef33ef7a87bd3ae6043020f1e380a8fff9680e5916846bf2837bcf5fd20acc7d0fb8b3c9cddafa0fe153f51128c9f91bd0a605daf66cff77f4e75b095cdc11e8f29ab2c2ec7a48aba9241e9b162eb4d6a4e67fc219e27cf712cd51b89cea52eae5818d3eae93ad5142e76b22e7270555482b6bb519ec2e074f4637b8ffff265832989f8ff13127fc7bc04de8ecb8d424e03296664535bec4c231bd09687b96de3afe791969ace78d8814f4504a5e774acdeab43246c9bd75cd47c2394183251dec0a6ce2f7772c7843f0db5d11ea3ba58071715ef07cd7cf00911e074f9f3c620361f942b7a2c65c0ff890e37e1ce77a94102a0e0f7d5f591f0aab19dc4abe77463a44711f4c5249b10edaf8bb78a6cd4b9e6d2a1579ab9fd03f8c45675af825f0098354d88741f95bf278c141aa2c25187137c15f010817a66c4df130864a45a8a1899af40077475bb5a93ce47200c3df4a3e56c9cba04b9bb5698b0cefa18d6823ee3b006d08d7b990a5f32e657f2cf195142a1b3d6106666e3cb454bf7c10312172ed0a85359bc315b1e1e9361770a218c7e8e8f49888e60b2e09808aa5b1b00c78ae444dc3de02c0380d8ddb5149c4b97d3a8e7bd96b476f4ddebcd7d8cc3f5ed274c63c408392562340c46f7831646c1c54149bd00580d605dd72feb97029d5e2e7dcb5a5e9b1375024ce2707c8646fdf88dc6514d3542fc90d4209eee56129357ae9ffb57fec2b4ccd18c8f5ccd0cabc3bfb069580d2d335a246f1f904c39baaebc0f1a6be8802577eb2954e87ae432fbc6a95ffdf0434ecb3c9b40dfa1971e9f42b6647e40c37df439fc7719fdfb0ac5a6cc4a75b0478cd00635a2f8383b18c8fbdd8856e5bb15ce03b1c3947ce2a6ab10b155431372fd8f5e5aa8a96e82d3b5b2cbdfb7987ad742158fd79a01c5fd8800f3293b929c7435af491ed609d73c40c93075e6524df37c3bea01aa5228a00a6592880d481b61ee0b2dfdb85a6f5cd6497dbd2959324825f511e574e8ff75919a01045095d9059869de7ea7c9b2c439873cf2c2327cb1423fc92bd18a6e1ca826ef77ada81c7f0cb3f613358e7a3bf0aec66753c539270e10c198cad9cd01f7225d2ecebab34c0062f325419939ac4ad4786c261f100c39abf85a752e2c998300406c8837ee55e91aecc9fdcc9fecfbf2f63897cbd266f09504eecb8bf5e3a3256eb90895867fc9dd8051c2dc35585e6c6ea1bc45b641769a01706d92aecbb4147aed61d4f7599de0c3cc1569c2de467a0dd528f70c07d11693405be67279531a69a7ce93c4b275c9c5bcebf5d8649cb414b96966816f546153b9201dc7e81e19ea7034c6068f49857a55ba13d779f6d633b2fc5d7f32e57e1c80274d9d5628b5160b74c9a519dcecdc074cd58ab7373f4f950e572b94ca4fe4865bdcc17cd911e475834e1b5933f3fa790a4d918b360ee49d0f704c50210ea94d6ecd724ce3e6f58f1458cc352665090a9b7049b7741a75dbf45d150b8777fd0d0f3772dc0399f1979505aa71cc15d8b3593377e5fc25a4e142088c180a9046ead330cacb09737316ac15cee6f53231a3d2968e5a1b63503dbbb16221ff13853263a73d7b01705345d03cd44a93455630052992ae482f02031280db93404bdc1f3256d6efd8ecffcb335a238a419275c8a434216b57f7ae842831a9f61e73da85b1129e68cbc563b644ee040eacb04b9758ddeb347dc5612f1805d12d156785b67af50c879cd4249809a43bd9d1a761df10a8879a81667bd78ee11da36148a2e089552125dfc812f03189e6c6a28e955b93394f990fff96cef44f507439ed50dfbc7a1e1225a9bd3e2b7084a28dd1f8c21ae8f0a396bfabefcd2aaee0da89942dbea4dc9e3a0cfc6f27690219358240d02ae806baf75cdb7a3ec33ce9d61230bd84ce17c7e7cc184e047a4bb43d26b211f30e68eeb8c32a0090b44d8a46a422532b4431da8bde6dfa2f438c0a5717c2f3ee553f721fdbd0cd5edb8d27f4c2cbc7b83e5fa5f42a2cf8ea5aff5347b63669e5e209506a01aee174347c047f8cdf56c695fca3dfff3085ed7fb8910dc61dcafcb2260dbb17b63c136b8029506803109a887e6f91b1e980720e441acd0e08d07801c2684523e7bc98e9b4b3a9f72374d452b5f3f37e32c0f5d907ae881a42fa2f2a72dd7f62ca95800b310973d337c197480ec8c6b4b2e4c23b9b51ff09e7deae131309ca041b3a8e694426fdcc7506ab72275d1ec092925bb7b0715cc0e67010c305e2030faae88360d607b699e5bd604ca86a1423a250fd7a7c186f8c6bb4fcc511bac51e81f6513c21538b1382f7880bcca36e6cd4eb625efd7120e186e8aba06d907fe4aba7e32abe466261d0dd43ae43ff5260fe941ed8c1d7c765846977025b3d2b50061ecbe52cc274ef629a9368ca177ea2f107474736c8329fbcedea6fce283b598373cb70b8587859bbc012f0081e447348aee3de502501bf89ff6a16255a51e591724f3826bfefc8cc4b52ff7d18973ac858af961818c9532fb86bb15e494136680efe2f5847c83a8aa3ca0152be3cac6ddc1f7cc0014f514ab134703de687702780d804286d4af5bd545bf181c527a3ac4bde60d27bd565d36bd29dd611cf6ecb3fe83458b783db96856e270fcc09e1a4ae77dbb77fa20fe7d731954716340d2be89ecdaf2dda9f55aeeca01d1024c8bef25c7fc2c47d3bb400927d45012dfcda67af42c1c41aa65486135b1b533ad1b69134984304f373f0594bf31a7e4f1dfe539f4a7a6e7dfd2c8e6eab488e3c922a18a67f25c0ffa61372f06fbb6d3cf8942b92240eb3aca74792192feac2dcfadd52b17b12206028d497fff697e5d72d041cef28b849fb946c65f800096db11c55cf627985dc2d79aa72bded46dd520f0b262769f5fe4ee9397e717367acacd02dd99a2efe51197123b1c7ffb85a0e53cc2df4f9b2f5c9edd35169b131f4b00f13710d89dba9c685895fb33c58e964bdb8cd2d444464aaebc780ed5074e738ad7f9294d4de36e3a63d6f10a90945fcbc2366d6b6a057f38621675484ddc4110446ebc141409ed0825de471c15ad2418a5cc420af07ad86028178ab3df9aabaf76a1f88c0239c058be2793568b99011d5dcea81ec62276ac18e5b5934c8a8f5662aa006ad4a03f0ae8cf8af4b7a73944819c8dc175babe6a1ced44ebb504cd4ddf8f92b54e72014c7191155ec5fa52187908abd5ec7de9b73b94375e7380b0d9e4f441117241d8d58d89a186d088f560b1fdc3bf3e748bc5ce4c27edf110c3d2483ff60244989f0fe25d90140cb15703dbf6cc963f4b862c59eee6c0472e9d45a98e273a276f4d3efa53d82e75cbd4e67478f44f77d8d500f94cd445c80654c1c840c8bd4eb63116db79f21d9c0eca72af9f5c8cea6212897268575f7b25dd286890abfb144583b25d151175d5f208577f1cd5d1f11677d102927671f1228e51c08342b75b825acfcf573eb49c68acbea89f173901b3e7b17c5a0b51319ea257b94a41348dad269bc34d1bc9e9c9c1cc64b0b5db5f0bf260613efe203f847acc9931a5b5240835483a4f17d6429ab023d3e59da4589677eef99cac0b8b937cd2bdb01b3175f90f735c13f6b7c6eca3c858d1cf1c458100ede9fbe34ee736603e5ebe18aa07b1bcba69be049c873ac1d677c9c23464c933eb2d79ec4543ea55009ec4e7e0fb3be88ed5c7f178433b25410e9389c1e13ba2d6ea7ec54ad278bd3b44d4f55dc2f3da0fb8fe70890f9c5fd8f94699038e9f9acc72e733eb97c93814a10d1f20fd6199e7025b3a88da146e4b8aa5ef043f6ea893c3de97f5e767df0d3c1cafec0ff813fbae050e5a3550caaf22874717385d6f5fe05f93463d8eeb37fb11c7912decf20c50685de30ac027ca2e5951bb1a444ba7a059cae641b1f6b2d4bed0a5b1b858d30437c95c1e294a76437e8b335ac29ca8e1c660712a8dffc0c19cc4b65ab458abd606ec7239d7dcdd258ac552799a9c09229b8d7928d607f5aeaa293ea01569b32739d8b62dbedbf62487cade366164e267a93301e02f4377edc7daa6a2a5d49a5a9bdd8032891a26fa84c061533563738ade7d39aa7f1790721da2195ba2b3407587134282aea54af560dec6c15dd533dcc576c79ee8001b60b6860f6b82bd710755b4dd94d2a3f106669d37acc9f3111cf423c674100629b27691487102e0c1945553659f61adf33aa861526858c02f80ab26655922f2ff16a7ddc46def46adaaeb870ef42eb9efe7e60069db578e0f329838a0852a0f66f9a61d4e939f6202fcea3df25d2995f376027b4d53713f729967fe4b0db8abb09403df573cdf53b557cf1f35d4be21525eebd8ab7f31e33bbba42432d64cc6c4e7c7bac75e8c857a1ec75bd6d1cc94ede9f6a59343f7cf86ba9f0cfab65594144132e7b9563294e9258a82d48353171eaf38a3681a33b4d0e13809b3e58f3d0a512bc7a07b2545a4c3db5bba902d24c978de34e77913cec84201c60b3b05cc73102a49cee75a4a7b87a0d8c169c05c6fc211d90ad33b17a8710eb3cc02c40f2f13051f8457c7aaad39f4f2ba96c942da8a9ef6821d970b2d2f1c3d3abb5eab33f08a4b4f32cdc319a3b86af238633dfe73a6ef43a5cd6604c7a9c7713d47b400b97280074777c885754356725f370578faeb144de21fa57bb86e0664e2fe966927539dd882dc9caf6932112d28cc6142b4e004a13bf08e8c57efeca28554d0c5c411c228cd6e5f305620d253c633781629d1673d32154753fcd3f16a4d1d957d4e807d8fc467a172042c622ebbbed2f79d6e39f707b28adab70554fceaea10805158a011ab4fc34fd4799b8437095357f66ba73a44f8da77ca4451631268e7bb9558fd9ec2304094722867949f689e2417aa4b59bb4b46176227f7d2f9561919af98178dab200f4934bf7633bbae5bc046724bd56e9fc2018f487c5857e4ccb8e18c972604655e0af39ac3ce0f45253dd9f19f58533f8647efda6fa59c9c4b03ea3a65ebb197f58ed36cf38b875f0eb33477c3c0110877b41f221b5effe242a50e6a001a485b3602df6270d3bc5a9b081d3770d84498532c9bebe6344d74f1916d7d7b0629290e66ed7cc4f6fc387ca99d1bb0789a4fb7ee3a8e67dbfb2e5fd71df1a943519412c568c8ee1f6fbddf369578e57be451592ba81de3a112dbd9892372692bcba34fce9cea54c58b2e827365d225e12520599adda25815289d4c9cdc2d2d6c187d9466b67345b49d92a06434f69a2b067ca4d13a7ae7de5ca2180b94b36c0771c63a7cc468fb57c31b76b223b2362374e940f2f78e90d8ed1b8a93297f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
