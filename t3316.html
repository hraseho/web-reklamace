<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"507aceda524420095b19c21b36092bb34009b3261e02e98598841a5eade6ec9c4fae8214dae3de2d0ed9b49099599f233ec10a46bb9dac212ec89c67a143a04c0af207a5c7e290f8a5e4e6a3391231c15bba03586a9aa63de369d51980532d23bc53a75f97e26d6666e575f1a7daff12724a7c3e3918419c229f25e1ef70722b0593881728ebf800852742c3aa6de8e582b00bd941fc2a93c888e1ae1ff8c2af56d4ee5d6145096bb330a8b21c1f87c40b9525eb0a047c84af6b619aa1ef5a07f44b95036ea263886dc876010eeab5663c225b50d974ece03d67e838434a7e5d32bedae2f2b62fe96b2d91e298ef8e2a9985fc808dfc96f59393b6886a1a37606107430566e2e3949a7feb190762ef5f660451e7776e1d701a08ffca4556b703316b7b4d33e24f200c53d1f893ddd4f3a68b510541ffac855fd428662c562669a6a5f1991a6e35c08594a33de9784409a1045e71291d9437a17262e340c6c8cd98ce138f88201117e7d9f5229edb3199d253eb10d63e884b2e0223f67d3c64df120b4577bfdff2d3cf9f827d54a539f02f61e830fd3829850572ec6602b215addd59d653d61783c1753dadfe41598478e12a0e2024f5976063b35e74c21f5bf736a25953cc70007598ba2c33fe123619c30d98dd06c95356dfc84a907804c966619ac3063275753074f7a12db76b03c8a50e23bbacb1312694258ef7ce048e2c49ccccc6b3082f084502824530d16968a551b4ad3a8752e03ca280aab1106dd0a974c52844cd861d087f93c6f530cc4afc154f03c09fa2a35da64b53cd4b191326f32379ad0a2599b2a47c8c6266541fd57690b169eaa3c18a0b06b45efbe0a3b2cba332247b3edcbb7e9e313ed9bc46988bd9b8db520aa6050eda76f9ce62d498f30ea97256d61cec4164035e72dc4535ead8815a5e346cf2c51fe6cf521d92aa33f4b66d261e889b3af6b5e5aa65b4f377c7c228fff8cb937ebf0cabe0ffcece9a58a120645b18a85f065c83bec0555561b7d089a4409b550e0ad538e4e8d9f25becba0cf31840d8bdbda928e2e7c2b863c0b7051bd38f71a13e02cac8a42717aad8e89cac955458f8f26dcc8e3ca4fe111d5c3b7946834a7131f1721351f8cd8ba58ca22b54f1c3af5ee4919fc301e85caa8583dbf6a84c80fd911f963ed178d3665bdff6535f24eda0fe49c096705f4eb8c466ecab0e028b3b3ddb3ca2651e1e7a763eb6d0529d8813235fc6e91d423c803f04c8443999dde7ed431c54c745b8fd931fb9bdb102fe12e29dad720dce5e7660485ff954d243bf713512fb6afcf31e03ba70104185adb623c987ed44c6dde17dbf6f559f0bb4eb066331ecc1949312be2bd17bc8109634c06aefb11a9e2c30949f88c3e3b43db45a2d9a5e0f79d98a53784885e62811fda340264eac46296ad9f9d535334402ce418d7cee8ded90ec4c28885a8078af4b9976c49d0df810981c1647916414be30a4f103a550e6632a40a026b81bd0caeef4589425df039972aa8631f20cbaad2f8942960efd7575500f0bd49a90d3e90463ccfbfe7bb83a25ff58cf386ac5f20342f77d478a9aed55c49f0c4ad1cf3edc30f33ac836ab8f3f344b0e2a9be94372e9ab13a0460df64b7e0075ff73f7b11727502ff057d0863faa7511cfb46361a1064c6e34f6f36a2c656fe3a882906169e77bf71a3a0f93923ee45c7442c8f552ecfc5dca221f82657a78546552016192304c10fe1a484bf0e5f06ea3da008f8a4cefacdd2b9c9b0eeb4cbb5666b6fff07e84e83ae49245673922bfd991d2308085ba87bda6cb9300b28076cac03018fe57f15067c2e435d4a34837d946504a657cef2fb4505f6907f45c62f4fe24edec8668b97d4b3a63994a52881a36ddea913ee370d0ec2fc609f4fbe72d528082b36e5e27ee8714d7b88e504bb83dc9ffc0dfae1245cfa64e589be44b7711213161f2bef977eb31011479a1c9ba77ac3c598929f7294f2812afd4f742ee5af5460c3d8660831603ccc0c77cb9a65f05f7842c023f9c41965431ad577404a568c16604267a7c9904e8fa1b3cc0fa765336704d5938741c6b6065a8c2d5e9a28b41cdf5637dd87c2e4394512d8023a36e9376c6c9e4d3933b631bdc0fa100043a76c5daa8e1e3492db4321526f6c0b49b6a2a069d1f3e225a63eb558911d879927f5390293acff5dffa77a189a9cbcab708deecb6fa28c10bf9b512f5f9fe69c4eac909a9ae64ff75b0ad65a2caa54d23acc8e9ba7e85615a625d6679786f0ebc7077d78348167e64e1413bc718332ff80c9152ee87e44e2831de0c659da9968abcda4a5f738c393be9c5017d01fc83fd78101acfe4740cf092115c30d05b68feeb7b5a265ff9c67849d77e5857419bf79393548248640f91db1d2e63d53dd9bc672ffd84f4a87dabc9cc3f7300f92d1a49f26818168dc04677f545e3b6cb07a3319e85e9ef654f313d6ba98b29f36592ea5cb9ad2920db9c09621bb980a2c27bfcbd3d89ff7a0e79c93b6c76bd4812e01094dab37f33d42a2d41887ca461fc7adcc64a94d5c17d4bcb99537e2ff2e8d6f78ae20d23822b9542d7cf4f6d7bebeca5d38582b49d836e8892123f329e68b4d051521d1a25987588a0be19f9a6770dda8b5f2fb72f6c515a0a5e7f6547b333b4cdfd7b5ef3184bffb2b488e941958acb14f8de4767621669cad59b66a92a26f8dedc6cc2f9507f0e068a587c96550515eaa16302a4dc0f8cd951c27cb92e7bbd1b7176a4c58efd422b5b4e2658badb4fac6c50e537d4b8d3f2e384788b879616ed7dd923daf5a2575cd51a3b0c1a1682178a770b2171b55b5acfe83e7173fe25807ffe7a0b1bffc071e782f8830e14b7e86729b92850fff0943ff8a7094067c5fba8d92845884fd5b11ad7fc541352b76c2f52658e62d249b19cc9fb1b83ca58e3bf5bbae3087f3fad77ad3b948a3e4f2a5fdfdfca1fe04d73097919f8b9fa99ee749341ab53bd3213b313127f7b5398dad30ab3a40caee1b3115019fedbc6bc568de4fffe5a8fe041b9b3226d933c32216ab5f0a87dd19f484299bf61b091072486490d2b00adf3bd9031f8e2ef115456e9453b97b98a98317ed072a9ab77d9c3519498cce31366a7df9a7900b0c304019b425f9900a7b7d530800170517b711955c977b455f8d003ea9627f85f9ab02c21acd1bcb859494c29a20373877f376858b4375c3cddfe5193696851312b131e1d65391757a5b041cfa9241ba04d87a3e30008cb89406d875fba00197efa9bcebdd1c1fb79f7f3ed14c75a0cfc901579d068f58b2c61b22a62798e936163f50347cd07858d9e29d8f9cf00ebb987ea8e5b84530d2bbdf1330359e2227ea11c4fa9a74ceda10eab3363a33a8192139946403df0f082adaa3195225d1476d7f8ee2a1790950d31b5237ed861ae83f9911cd3971dbd4908ceed702da8bb5e1f94191a4835272df2b5eaa3ddbe32416d47b270a9b14bdf969c8129f3392934e85f706e9e4dfcddf9251c9fef676b4012bc73fedca13afa02b0e5d6b0c785dfb585d35614653448ce2fea09f18649b54709de3198eec31b9f8e51e77488eaedda39c534dd30feb55dea554e34b0054997996f88c05b6b9ddeba39078c769d7aae83f61e908c96c4806f7ac408c5c959567f8c90f7f13946d3e5876ab96fe30120164d72b14361152ec5900ab9a00177cdc1835f3e58556bf24e158de0261f841f3cace43586f3adb713caba9d568d73dccd99d01cbf5c14511daaebecb69443bd5d8d7d8e686bd5ec83ec4779eeeba3de6ba26927e7f80b237f7922813d92172b686c7c61fb06072895077a689e1b68140b61b93b13a7c999333fbfc0e5410803206876738ac9216951e120c8d07bb0be5dc83c1d8d0f76c0878edee9b5db5669099bdcdb96f50575ae6ba9c21acaa29f23f261d0c80fd963e4e01e44899cca005fa4bd69bed6a58994b100672148162a29503ba77636b79c11e52831846ca525de4f55ecd15fdd84c72eac345d750ee8ed5b086c25b50fcfe553bb56c7ea0c7d59ba9743346a5cfef30e95d2f9bb46712a6849169249a84d8529e38aed5f074251b5db1d132735221935d8026e40594869b36583a2dff03591a3ba46c12fded010234701964da8487e33a31bea9d944e1a30276d116e3a764c6d6e51546413c5fb7a72270ad31419dc0eef4d6aa04eabfaeef84246b4864283d21e1d246a7d73f5b69a6c510a37fe8ad72d83f27f76a3260999550ae41a8347e8549f0f99c21df2713f42f4203591d4733f234958d048d3c1b29c8726b185dbb10fdd77426fcc72f4058d5e7496dd91e29e20bbb0de1bcd81de31b4a9201c05d49618ff0e8dcdb6600fa6282c1aaa22956cedcdba74268529268161a393ac0f553e5cf676a0724715884e1f171e039d60f461233350d0c4e3b99324aef8266a132a7d45707c8d8f48ba58c05bb63004e2f6224332aa10e66fb45b2d06d15cd11ca458ba68e9c5d47c2f1fa20a361637a3721e26806785bc4ba2f476ccc6cf1e8abb9328ab447a90494bf54fadb34756492e44373186d7485cb99fb196cdc4b52eadf3923b1de9fbd7aba903d4abb8371e935f8a5d0badf82b888ff997e2d79a8ad568fb22c213a93f86e084ffe2640562946f57804759b55fae6845d7edb1e68e8336f4896c88c08d38d9e9a7ce555ad5369ff157ae3da4ccaf308ba573d9255a2ea91f10cf121b288fdd4cbb907ed18dffba7d5a9d4cb2f5a6ea8b46b427607e7ceab677e5247328bcd3b27771fb4c663fa54b3216368e8b16754a599d4f82be8c3ec07c074f5afe770ede51f9a2cd2cb6137b856c416bc4b336faa941ee1662c1562f1d09c7d813b8edaf94cb207c5102d1266ca6d9be019a1c027313f3ae35169dea4d1c4e3af0d379f5132105b0332afdf5b147fd3890ed8c9305334b74b7ca864509dc33fa9acf798597360926f8a7234becccd380ae6debdae0eca3727cecd6384a16610aa4e0fa5b01e0fe9b2f080592c8337a6b684701da35d8a1b6e89bb7d1614b2efe55a6f887eb592340a39ed7ede035e7ed84ea55880cb33c80ee2f96aeab2600749b594748a45bd9e7bc7e2e947a23bf973f2101cbf3e96430717b6b2800002a49ede1357f43a019a77034cbec6f427df4f7cef78996dc3cfbe8f84f50780e5a8f219a44186f36049ea2197f40bc99c5de8cc3958e1cf91700d1f3d6931fa2f109ab23306efd0e301c58ce168c513b63c11db86053c16d95de3013b9a9f516018ce31f1e5d6e556cafebd92bb779a0d428d7eb539abd9f7dd3adb7a39b4deaaee47fc01150fd2c1476016f8ecd592d8e4a307ddd13c827e6a76bf4bab135a50acdde7a3b629377f0a591242ef48174dd33a895f13175ad6d66b408e30b43ee13329592e54c0c7df663a95f7a40e342bbe078ee60dafbbce7750aff9f2e141724873fa7c9650b34555a7a4d840a435e62ae633ab21ad8bf42b1015c34c98362353b44c2b1ebbfb068fb721db12317812ac3c26b3805bb5fbecf2285de809012cebe774bae7f6a48bbefa4f2d4ada75cd4335d63683cc4db750e6542cdbf277a822c0cb95e192b3b4921bad37194bb964fd118b6f70c84a18621a3d7aad490525f55472e69e1f63e298a43a3ee76ede3d2af553c53c58fa3a79d12bc51cde733a43dfb7cc78a9f5f91570d8d7ad07315cf91c76673370b9a724e39906cf6a9a6c2a5cd6768148e8b55ce07f53e91c930c07cba555b348c19e69dbab41dda3aee9f245a92e88cecd825a3b5e52b8fcbcd629a57831c8d9c31f66e81d9484d6bcd9cfcf59e564cedca582acb9196ad2ede192afbaa2f1c7a6a2ff5e94549818edabd3b06b9571b3ef4ca651f373ba1a1c7528ce6e1b840adb2fc129db7944ef4ecd0a6da9487a91a83e51d8b9b05c87d9fb1bee5e9b7dc2fccc371436a701b6da51af020c9cc85caf6f8b9906e3f95a6fbfed07f1191290cb2531ac9f30ebfb82c99ff53119d3efb18eea00866d3b32b74bc96d2ad41116bf28f74e45bd90c750a64326e5d5d2d3940b955b3a90c2c91ba08267acb34a0a1b86324a5834f92ae8319a9b3e193bcef99b5a4a08375d8becdbf6047c3522e7616f63c61d6cfb00df44578c83d502151663a060591bc7bd5eff37f5484bb377d3ee50c81cf9f59868e80f50cc6a0b2d3d74cffd38e0073fc8541f305d4f87c0628660ff6546b0370d4eca2a104d00bd18add3ec379c644c10da4261813cd57059e8ca5ff359d0840e93818c40cc6b9995152a35aa853a36494e34ded67c2030059fd6a7f65e3fab5ba1e18f266b4295a6b520362e37403910b8e52e6185b15b670299c2d96aec288e9bc58c0c1fa62ef40610e327bef7a5c423b1118970e2aabf7783bba6ec9bc28150379f7950d4c8383f0affdc7c6a6a4547667f9c6bbd701146b61de141b44eadf2a35fc5875732870cc3094eefac0fe0d18f313fa226796029f6c019bba5ae85d98b6237def6ee9ed5f456916e0cd455d5556e41e585cc76d88ed00f90ce8e454037e5d67ac9633b349b2f0481bea8d5a02ba15c1831cd8884cd0e1cc8a8c268e11cc9d2f2e162ca39c2711b79f6e03ea31a8d43113380ce6730fd3bf153baf0ebfb07127632447d7a97f0e7ee3046acfd98e4d134983a696876e02c6a3956e6574bee7dd26a9fd468bf6904fb034c76da82db808b219729c33d45249f671ba1a0e2eba13d5c22030a6d70c313be04158fc4c664f6afac3619b0d3a76337bb0f6e0e1dea6ee854786afde114fc9bd75072949505ea70d20614b90cde519d769f5b998bc8ad531d52be6f17f61f15168cfaa0362453fc36885e57056f5b88a23e31a3e3b2f65b232ecc3756f6071ac703f53ba3b9ff635c6a41681de96ef5b17e76cb53fceb945746739362648978fe99b6e412edfeda6e5d06412da90d22da6e2ee0bbc6f395638f46d5ed2f50bf111b42b0bc9939bcd0c8bc4acf31d36cb714c5b60443b2ce09598d5464f21354890c72240fb267962678f7296a9668b7285eb8f44b11c2efaa6c5467629db10225559a43e72e50be7bfa071206a87be5dd17e0f9dbc97fac647d55c65dbedd235f59aa92dd07cdf25a243e0dcba4d88939ec71bd823ad5c43a96824aae8ab7039ddc4fc27f0b911ff2c44b5df609a3a3f7bc589456b0e45296bee54cb581eb8cf47f7c427708d04084bce718b50aecaba7cce36c435771916c00dad284dcf18ce79f12c2d79e83ee39ab3abcd92417453bc472297b020b75167ca81c49c859b0110fa94111cf366fb03d0151b18a43553851b3ba1d0a0c463f71baf5e45107f85f8b5fd66bccbec805f9be54f59cbb3c943f83271483a27343422351c5b882b8d7e0c9541ac75f02b27c144e57fc0b1cbca958781f83d2e4787a62bf87b8457eb0e7938ed30010fa51dda1dd6b60c9b49a5b7fb2efa9f419b6e95d0d4833332511b16fa2af8278466e7082dc8a2228f2135cd33b1c4e0e347d79663cfbdab30a2724c22f876500a6b2fd6cbbd00be9b503378a9e5b31617239bcacaf8f862f88f8142aa2eecf3300f597ae1ff3f2bbaa8c054d7460a7c0074b496d871ed2845fb075b0ad490e05d48978b08cb68efdf537568ee524e5b5f8b7e5dc7e6507f1f8d1dca32e4e133e4cc96dc87c21caffea52417acf7cb9b9da8a57e33d552b93af4a4304a1ec051f6fd69967b3a639d6fa4cb1c9c029bd81648621f94a5c0345dadbf42dd6d557dfffaeec9f71e2858c0a7b642dff1924800f553693ef739e1d161a73f0e9e8d375f95a4971f4deac17202d4ecd7e90db1e68d613dee2df962682b37bd38207aa23a1947bd39382d30a8939857cd1fbcdb4ed64bad522ed47e658307af4e1dfbd14ff222c2322a6f43af9efb2023c66e33c63ac7fa5912a45b63f453f0e6192c2874eb71b7a46789bae0a9b5261c3f204d51850b69ab17279381b348f5510e0e6222a19299763d6763b3da274e4b705c9da2e899d24eef5cd4b6ca1b4744831cd8604cbfcf4abb52e7c447022e362b440e72e728295fb0772049ee5c73c37c42c3f8dfa06259af3f0d0b319ccf0c86387d9c938b93a1c5b56e02922bc3ba685a4ba01d0d24c8e18fa2e5c4283864575c85e8a7c3597d125d9a8881e09d85612d9d261b2d680908a41db99137645c19dec6dcf293e872e2a58c117fa1223d0bc2060d948b08dd90acb93b6845ca3b94b58c71867164666b4497c083095421a07093af4eed070d3b3ee9351f199cd56e492a96ea860e3f2085a09ae1cdf4b9c54340511671785b4d07248ad1e595ee6c897e00d74c475d7d44bb3c8df7ec18a87f26be3ba02b7a5b2875b0471059d2a7f90af341b449fdce42c3de1c1d63de11fb58654530a074e9eae54b9209a4065fd4b1c9da5c7ad89645019047ca6b00c25fc7ec4d7992d45bf2aedca56ba2d001621d45a47019ee9dc69293328c1c8dec5cd59b2596efb54efaacece678a242b2e4007fe1388c2c499c7fa29689cece02dcb91bc2e17957825dd0a11b373b672efd3f75a6b4ffffbf0093f10c0fcf77708e7e8440009e8ada67510ca6806ed4e347bcc0d0cd115572d2c79c15376c3e5a2c8757ae8941ee82f624d39d043e3e8dfcddccf112bf57da0b3426126f259faba77507b66f43364b7a46e0fba46625012ac4c17abbf7c43a7e0267a7c2e841b81caf2cd1dc851ea65bc3371ca89f3796f5ceb744989ac05c24bbc85d8cfccbe9b9e2051af6971d3e15b76cec7debaec896934fcdbae5f213dd71e41bd077e77de8d37d9b36aff7564b09420bef027c57baf70d6c25b14ec2daaab4b8643ecb1e4f1e4d6f7a74c83332d7e7822f493d6a9b27558f520b30e42cdb422f936a942390b5f732066fe34539111bac0b03e11806788b75f8a34014eeffe15e9c910ad25db543b68f00606d0d4651c20e70cd509dba898f2bed0b5a6825b0d6959eeae21a57a9443b8ef7f4e644b030cdd063cc5c80c92aaeccf34f05eb6b80bb912e5bdcb4949efd1b6c13e7b0ad3a644df86d19a83f0e121fcfa33d56dafe8631bc619580ed7c34fd3d26077be7cba0c4120813edbdbedb423ac3580cc56eaf5a4b1bacd892940c087c545e33250a67666ff0b59d4218dd2c1902e44679d208218e0738a72849e9eef41cc7f9a6ebc7ba8ed5865492c373108d4d2e454bbed7fa7acf0c99927906bdf39fa442b6ea1e4968ba10ce90a71084849c6a46e72c06e0c511c9d1eedd822eff4f771ed90070941a679a1804a75e9798067db36c2dde2d5b237de44839842d74c39fe9e72dca908b44f6ac62671adc9c75182d48903739b4cb2db3f5429bec9b2b5945ece05faf482652b218dd6c4fa13041cff6c615e3518d881323e8f09e409b78eb7222de025357a2e4f195930d5f72b5fa6f18a2beb084e7eb2853fbb0bb6a000af88b995bbc7613b624a1e32f81786e40c619fce12e11d51bd41db6ca086d740d69032dcd61841c97cf843d81b3be97990d26824ca612cf59130a14eb058dffd8ac83a40d00fb7b2077cba245fea2bf29d0135f61f8f26f3e2f6d658ed4c6c2f110bbfe6b779911a2ae2a095a5c5f5a9ddd1d1c76f5415ae74a22ff047bb812106ad6d0f1ba11d8f0f5a92a9f68717f4840365ac7bed3567f46b97777a02de15eb4f093135a5036c3770af976907db659922336b8c4c7b001175df313d9808fd241979d6ac895e665cca611a30a775a4b0f4d2173ec034d56a37f96c7992ba138020d52a83b5592e3f042d7643a94c34cfe518f41d2b1d11ebee12a8dd5e000b090c0b2a6b96be77f380344d1f1dd073c6b1ffc0606ba6716663f95f5779c3358e0af8c22902af9679a59339390826048f73702367f5152059b9e069f3f2bf07113ccbda250909dc874371bf85be552d600375dc1a3a3f44ac11ea540972a2450b8b7468d0e335367270eb9db2905def9fac805f90e502909eb33a5986ba89ef921da3186eb337b1509b3b3e51be7dce81bf1174e43f816ca397eb5869522eeb5e13c42172f9585fe3fa5799e586248be0907673022b5b8892d6e670cec5bcdf16d56b212d6291596d0fb46ddb47b4e38ee0f8849b6383e9453a8893787b1ce60557a88b8d778233a8b10f122fb9e74183670936f871e715adc548377e17744915aefb6eebdbbd738cf065e2af3aa610b3421ebe2ea960f8a22633cf2819bd83662e1b711c8290c649cc799654169ee4ab7ddb4f42ff9fd176fedc60cb916b77e0e3fa1e6b8417af7e7551084dc8489dedd0ce2ae29471f22cc1bef1fc58947a6c7085e8d80a9a049d2cf33c27e905cac81a6047fe77340e7d1ec1cb43e224643dc566a76d332d1809a371d2bcd77baee19a97cf02d1947a63338c8dd12244bf8397f03ae321e8043f2215457e1d8529fb0ccf43382ad6c121c9170b07cc0c78f5dce64fa2ed662c036aafa98bd76be356a2c3957d840df14c3d208efa096ed4cfac6029a9e797d117cbfc39d810eabbce3d1a6eb2f0373b3c408a4231d7c4025d29b8533f40f7c120aa4749e91cc135f3914e6cca85d5bca7c0662295530926a66616fd75516433a07640f1a52dc80c2119b3257aa0549d74718bd021d3ce536a34b360f74c4333994ab28630e86197951cb938f880b3fea0871e622ac67fb72279e414da4d86ba88faf60b8297ce44eed8c08e888adff7ae5c5fa5fa37268aff59a8eb2dea3c967c2f19457e64e9cb20c7f01140142295ae08ebc03a3755db873f680b81c50b034c4283d1e6e18c6dd7778ca145c58d707d5ddabd5751232ef6ba24e36703cf83ee80c985765bfa030109eaab6e83e4d348008e25d6cee7dc071e479aefb2d4019d8318927d763fa78116241444c9508bb65e236d883030dd6d5a8ce26a6508e9d2b40df4771cf6d48ddf6032d958df6d4b7bcb1a7683626d07184b96c6808275acf8675a23921aa861121cbd1b36c909d404c7b7d8f786290c7c4aefa60ee62b4929f7134ad66437b38d8403b8aab5cf6ce2e8c335e3b258ae4c24a5739ef744da85057a1ae19a293cb222c025eec89badb8f8be8d2d897911cc8c04ef952cc8e6fe58a28c5e0a2b5bf44822a9792e2581504208ce8b2e48eebcb4bfd18ed26dbc21056e695d777cb924db151a776cd41c5fb88b5c5cdf23f5925bc86e36d4190026d99130b92bc8657d8da5bf7f35c4572b70a5c5c2b21f12ed5e11506a655dbf35017e1fce6a178ab6cf2e5417610a859c1ee934009696e3cd380fd98bbe577b1995cae1d25c0497a24dac700fdd0a2f5ca25c30a8f2b49638e590a082827a2569f77242668fdd6ced20c98a73c0579899bcdb34002c05815518148b25d57fd89965022a10f8ff33c5433a2e51fbcc9602bf0522949a011c056865697c615c43642c9c72e928e2477051a00206531ca3b98267e2d658015ced5142cd2da4a8cc49110aaf54a4dfede04f417e84cef4b262e95a8a54b3678ec476cd9fcfc5a0d8b5737cbe9f80e9f73b2e36a7667818e18eb1cc37df16178ca9d849d8226467e166295e8a030774f9b53f0b30f6af0bdd2939d6963e53176f9c8ba4a49902de9dbd7120a866cde5b95dcd63d952b4e1c0f8c9a1f18612ac0ab5ca2b58a2c85e4ae78e4b5fdfc069c45bec244b2547be9e9d07a8f4b8150afb698de9bfb9f54081679321a18518a99bb1b655c7220126843e8e9dd5bad9e03b25e3a61a829a385668494bbedf2e5d733132bdd1babbf034bd46c2b7aafd7947e113425709b34c6627824f54d9f51b270e7e7d52760367444308217473b3d22c203332113c40a35505a5328f269511bc5cc91cea3fd9486f6ae5ab8a8dda680ebc6ccb4dbd31f546bc73cfb6e3d48e7cb308fde249aeeece8903c7453e927bfd7921ada08f08e48789735a784440505417eb97c5a3e931b260e1f2635e6ff74140ef42d5e0af7ba18e4b0d5df92179e689ceb62cf9004835958f1c7b83e65420df79e780b1ba771cbbcdb3b94c41374d97baf199a8984c041e60184b66970fd3662832af4fa53b06791a234fd2e28158f5d9fde3332369d91a6f64cf1ac3783100291e8264c75bd5b56e25f9b3899e50d09589c8873f81c8e990fdb5ab5e968528aa7d4bf600de73cdf13500c8578443794a3b90aa77e73dc04c2c982e59bcae125bca7ba937caab43ccc9546a39f99c405885454255e20ace9fd5391e0a352effb7f9863e9ed90843e98757fc5a8730dbee9da48e793896a016a4277d28d2290174b81ff00207ec1b23b1257c444b371b2f541b61e3c82ac341564c93ddc62f36bede0305e954ce069b33eca221aa960f381672961a7705d666c9d8bad5d2cd74f8130d8933b255db001122c7dc2757014c079cff9f03c35ac27ecce015a021fb2ac9ab6bc352fc627f92e3d723fae3a1df0ca614b8dea0ce32aee91a61833cff9d164410f4c48840df33080c792f32adda3ca9ab384aa6c51f098f9cac4609ea40b20f993921d375f7a9b8d057339fcf4e5a9a2d7019faebe87aaa5009e1d07be593b1752a2f1f82ad6eccf27e2b2bd7ef6ca54f6be7dc958acb9b0900ff80fd413a53cd6508ebf43047ea7c4927b2b7fc790ca257515305c4f5a9b383769cac4b2b8b1ce162de516b0f63d4547c70971d3f2e44a7acfefb33dd3f4523318110bd5366306366b80533d81bbd8fe370a98ab96635da41e3f6baafcdf9578e2d06dc3d77860f0ee3e329eda4010f979afcc7b5179ba9ed18cd959aa7bec76a37613766772ea38a9506f493ca80d153cb7e65b7defbb0d8a4ec361be79259b0ab833a27d9cea3a5e625270b804c53b6c83e937299f4275ced776ac8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
