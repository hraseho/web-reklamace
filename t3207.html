<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"791cde7bcea6692ad6c5a4fd1e7aeead70468aef22ed07f7241cea1372bae1298bff588e2a851c578308f503416c661a60bd81281f453ae51bba6803ed113c704cbdbf9ba79e0617bd6bcce717842ec98905e1515cc0f977c5e6ee7c2e04e078b46276de0d8336acebd7a345706c28a241ba8f8762db630e1ff67025051d048e79a0210cf1a44e2dcdae55d7f803c9a3426a7a49c54eca9d553c81c2bb7261498aeeaa263ef6e4d33c1872cfde41b1b965be0bb205700a9ed2432b652b2d406223758eacb635063812bb4397d86a7f38127b544d259d01c14e39eb6093263eb152fa536992fd870f6e4a2a46df6eb5ca815984dba73ade580644915b13d761e73ead3ea25c8e69f209bf35dc20bbf60c40a364259463d649d7f5245a2408f2e0f1ef0cb7e170c3e3f7bacf0404336ea39b731377a4843d490de95d62226cca8eb7a5d1c50dec8da37bd09ece8f10ee71578655b7baf5e82ed0e671574a51d6dfa258e166e7f8ff9013e4237f496a94ddea762c444f66f88ef6c4cfbb88987bb3475e07bef43815e9c6f3cf8564dfef36410b11836a42fbb9fac05911bee04a0ccb7a8dc676fdd0a78ed6f8d917d464c8c4dff7ae81b175e9593e5261e43c4efa691df35059714cdbfd37e467d4ecb67b590ba7a86e37fc3aaff69142ee0bea253dfa2b81b15c5d70a7a5edc088d6a4bfab66ce265e7c77e228a9183755ed03bbef2bb4a93844b6e2e1bd8a7d65ff0c8435261ae233392340ee0885ce3d601a9b9988674cd780720d0c331fcf1d5a38d46a409e29bb4f2220eea8056b27e6082300890c367fb7386648a5b3caea4fcc951362c8db88384ed10988ad00a3f5493d4b96e3b625299eb22002584de0842ed0afaa79bedc1692c6a1698a713a381af67184d0c11b4258e6698fb315684166b15ffcf3e2e939ed70927adf1d7df2c021af4424806ddd999157c3025899d318390db19bc649e312324418f626b4fad121a507906d498491eaf739a96aba5911d13d3c1512f4f5f28565415a6150bcc5521c66b90cad8db5171e5771ee61eaaf0822f3251c2ae0a488c8e14f3a875b53d25ca015ca18f055b5e0f6bc28104566f42923569bfbae5929504e59b1bf1bcfdcef0f039205d22ce927d5d584ec1c0d886b9153def0e586cdcf527d87a232e2874e9ddf6623b2179bd7259d84704a21a33d81e7f9f60e7dbe79b4f8938fb3f6f00f917ba31f158b29fe7f0b9a0c4aa77bcb196f40f1d5de4607b70c979e3ce976015d85595e31ae330dd1d722d8ce497e7e4d562df18dde413b9cbe3def5254bc4706c03ac8167329a6a1eed2e50ab017bf60bb476891b7fd3b28eb796a46c29c2f2f8c757ae14e124d0eeceb332a3792b69f08078786a8ab708709599f4def1a25881913872c5e12dd11e89d3485e908c375cb6a8c31751a7eeda85e8b6fcd9e1934993e6c1c384c4f8c17c21b9dcaf3831c817ab509d220e05b03ebe86127e6a239e61f652a391a959a03398fb4ae4b93a57e723e908106dd5a88fa6ff2b9539ffe248cdae1e53c9f667e5a7e1a2a9c2abb6b23173185613daab48bb76e15a09bbf83c4ceda028e873087ebde9e435bbc8865d54f0aa03ef6fc29d70da3758297a12bc7e50fd32f66a18d4a37b157b9220ad64fa76c902d2007b878ab094e324fadd08cd3a361e1fc808d3dfdcd9b069143d4a0f4af701149b02897cda5b0488f43fb65530ce8762449e1ea893145aa54106470462c4a011d62f507b54f26481e6b05aec0d9cd6304830e0ed7814000785b8047ae69a1767ff15f546b87a390b8368d5d0ca461ba971e833fce9b55ebbf91411c83af61fd86b62e613c708c7ba234c716dbb9b69ad01867d38633431a71c49b44ea76d9823bf6554b7f91e29acadfdfbd332a794b03bbb1ff64fb531a65c126861faac92dd8b674782c2164a93c7f0d408742646c745e21fee64083f485d207a0ece83d6ffbebc09fcea45938ac81c00de5f918ab69b014c01df13b3be468a27b8e3347fe7cf54717f509262a24d55aa07489eec0213aae104c255896f0f3b252d7a367d3107e541c8000de55a076b63e2fc991d5794c478c74a45c6f082ce8d4cc1972ef8d667bb14707d05add12f1a032a3d7ac00b157422f18c603f6ab3028573dce6c4569513ab79753c326f8a5a6620627b2b42d6cb83fb249ce31090397d6d1fae37621a5690750c93b1482f99e2933ab813d8236eaa1479d9bb60deba6620d37c95eb3792a6fef285675d33f32a0c887b26819dcb1d8f8ef847d6596a0c7ae760a24c15103569607a59a87e49d82f396cbaf5827c103d76618fab97b6d616b3f122fa0b69384a0a888f4ad144b15aafa4b5566fae7ea9cefa7447acfbeea05705a4b4c61bc0995e1745297be49e1cf2f9baf12de30ba914d35c0592b6bc4a37e6c28a6c7def94b98273c11223f41da0ef6ca74da3db5834bfd88b6e09adcb34069c2550e7284b7ca54834c59ca3fae89fdbe734e5ac658f8c817ccaf1739652ed8b275d5494b3a67bb8e61d415a07a32c064a20ccce5d5aaa49e46a65a586c39bd13869134ff95420430c3f3691a6ce87e884610504da9288493a8131deb615905085b0d034933dcbff6300f9bcda83b510e7e5f25f1abd9f972459f2068316a760ec34661644b09d8446a9961b2a6a03a5a71e5ea9c519850c19ce126d7d0220dc91bdd55c579ded1ab47b4c21522d2959158ca0816357de1618fadbeb5e50bfc2e1c22fd77423932659facdcd3d86d3d3160f5dd16633022c501e7ff4de03f5da5954a90315b9386b25fcd9c1ac26b18a440469df362dea9755a4a252965d2018b05f5c71d716f0077a29a9baf27b6f426c310c3ea304b823855d4f7b766924b8f47ae15b4256d64cc55e6e4f6310ddbb6b3655b90d3a39f5452a6a41c22c29f75be22d7ab03a5edeab3358ade2ba60b266d8d746eb761d409337f93d709a89c870aedec325677993a42c6e0946adca82bd3bc9fca5546c1dd8a3415dc45181500c6d8e752875a93839f43f3a9c04374576d5e829538aace62add619b56a7513c7f97a0dcebbfc8fbed505f648fad50e01517d406284f549462a3d950dfb39654d51b44e0199e4183ff35d0d910ab4c4072d69615644aaaa81a5f8c9e4889067bd4ead7191e4bd7268625c2e441cf4213a7c4cecd69278f80849829e21318d015b03970e7d1e29adfcb25d4b5477a86b48e026c07395bff9c0ce9c750dfe8ad82f8ae722ab3bc5846f2001e4660e29b92ae1a8115f76b75ab6bc692ab43eff9c05345d973a43d8a4dbd7f3a60ea921965cec4634cbebc006f4e4a82ce573b7c4f9a8f1568e16a06ba8c013de449f6f08aecf18af759559a98fc713b4ccc1bbdcd7127d5a38a89e1efa82771c71feafd8d32088bdc8721707295ca3682641eb7e9cc758b82039767a2c30e0a563514fb7f0a85fe28406933632757ad7357d672e7c65c15be32ec4a86086de995178fd8064acda51948b63ac4d62d7a02a130f9decaff6de01dae4a54b38e0e9370cc303b69ed7ab7c6e49600a9d52a7f1910b587d12efc86157ff6edb4c6d3d76af940087a835b98449e5f8fcbe1570809d1549360a6d0c0599881385177d3644f309793c6aaa1b346a5cdf230a09d0a0b78cddf7897dc7adc9be413ae2d29393511e23326809b3e895ebd4b981cf38ce9d511bc3806f22e4c58467aa011bf6f5872267c884742d0cfa13945666e3a53da7d8129a3584cc1799c9524391352bd6d7ba0d8e3ecb6b8edaee55be8abf3bd03d8be85d79b53f428991bc6b739e1d52354bd10931114de3bfa07cadee4bcc02f3089e6115eb6ec28b09d3bb21ad3812ddf8cbc8872ef3d1a51f5e7031950b2384756631bb24dc3b8212fa82afdaad3a2d1d7ff494ff223db22006015bd6d18136123ab4bdf2ba811b552661a845ce39516cee3680aa56a72e5c52d57d11fd56c00998819aad52891048a62201c08f24d569ab5a972027ceec8fe3b6464078bd1ff182301b4cf58437c387a897e00c37412bf2400521dcf06fe909627881bca36d834911b7880a43a9a9f8b071bd32b871d4090d9488d2cb2711e98272ccef1a254957559cf747f529d571d67cff4579eda68f314da44f48ac1f08ebf648e084cac7e9c272e5c47e7d11d75440717971ef4192176e5df0f2b7830f8fb07ad3f85d9a74986b817f0697f29277e20ac2c9468c71e023929a44b10555116c9050b0ff86d7372c50c9a44ba7a709c817b48e1349de446f464a410e416db956db098647efeeeeb1cad2b34df28bbd51df2384e74efc042e23e47a4f9c6fcb84abf5667a89e5dc8b45ff4f3eed867981ebabb55d0077f065669e28266d4ad66c943d6bf4a39b0117a639431851465cd5800b4c5c737f9a37c7fd67d3dc18649d645d171c4d931d90c4db9cf105ea176857b91822c188edd19748644fe699ca2f106bec2ee40bba997a036b3cc6025334c4019a1673e9c736043d4c467ab965eb8d5801a6e8164bd36f6a14ec2f24d6a22f8f6a2f874046fd9b0c86dd1f7648ecd8d51cde35d359480fcf9a6b93ae6478baea38fccb6bbf069e6d4943b44948a8d197acd180b7dc7d572f34ad01435d5aa90f04d46f7385c85d7180e928ffbf494e1e9c709e24f09ee94313d14141964de21ac736c217a46f7270641d9f9d89a9cc96332770eaa6ad7a49554d21613809b2a16a5350122785112ed108b64dd35d07a0d47540b1b10301107a37acf0670fde8da35dd065439a7362ab4a6d305b720e95c3efb98cf6b94fc0f91874b9c9fac30aca2ac2e6e55e93d37725b4fd6a34987c862c8d0cf7cd6bed21fb2f0858724eb155bb5267ff49932a0fc20f8cb9a3d3cadc56004f55f8349853ee88d08f63145ce4c999a4866aef758df9976d3b82ae3eb6cdcf7590aa33b09df850606bfc4bb49a1e71a72b0b297f5e28b5b9d92097de68af51a7c3631e371d5b93b69ab860f2c712bde97dfbcfde0cbb6df6ae7af23120311e1ea2530ca5714e8ee4a376764ea53dcdf393ed9ac4443a00f084ab07b01bfe073606a50b66aa15f0a587e5d8f5950024255f1a3e1ebb68b90a19315af12a692b0ba7582bf3bd89af49765df9e0f99ad8a2053063a98e4faa92826b2df477516da744d68d99ceeb820bc8342f1a604ced7ec22b65c21bb8a2c995868773883b73a9cdf17639ce858fb51d4c197d1d53c1037d054b30b7f363f096eae98aafc08759df55d2e272d4c0f25fe1a43898796b722d7cfc08d774cbc12ee43984a1e3a283072b4054999105572344e32d8d4dcced445c093832ffa59824f5c6cfe129c56c0d185cdede199a13a69c186a738a6e91a89c446d76142ae5fc1e936ed60451b0d1208017bf874e358b7ba7a8e0bac5c5ea5662c188afc6ee51f7402114a3b95be6567570b34a4788e355192c4be0f0244fe106d486c900cd76dc1ce5bdadcb542bd32ab584fc7f06b8e5206a411cadcdd00f9ebd393a8362463320a3467346b449f82ee17bb9646115d621ecde2622a919a7cd6790465ca3713baadc2a48594a1c66c1da82edb3e17cca6f76d66fab3e0ca900a5908eebeefc73288628fe94ccb09c7962ef757527da59665848b72398d8f7149dfebd0b6cca0531e11bbdfd8d488625e2dd7e9c35662d232d3348e6c1002c2594ed1c051bb095c0a4fc53caf622158b7adf55a3ef55cfbc0e4e20ef97c4ce980c37a6a627e1031a7a4ae22f22741916de447038a022b4eb2bd5623439d43d2b0d9786f331916b6b7e41f91c1dbfa00fa39b18f57698919348f41b4d33f833451f29599091eaedc4b0a2513e3399c7c73c43191a705c51f5d82dd4dfc4d1a519d8d7b75e303d9a1f886abb2360d9cba32fa32c6a88615e71a62f789c3a91ed59cd91f187bf8168d4c37d6d1f7d29041e6a499ff4e719bf72f12471aa4732490420f92e7f8f7fa35a58d4678cfec122d96dd4bebf2ef865aa82b6a901d929ae273e2dee19d65e1dad70bc8e32a53e6e5b435161640789e0e2ddf32757f5608a05b08d9426d2c6ad49f30ef15d2b6e4c6f382b49084e36bfc65bc9a6ce5286e65be7040061014472651074b48c81e3e79984943afb4383b9b155b86ea3b736b168f0036b13444dbb6245520ffad70c0438fabfdd2f423268567e4e27365d1271c009293d3f27e870fb8c7015e81e529472423af3ae72f0a05ce3a182f4b09aa9b0602fbecfe3ac27fcf4804152ea9f7b044cf6336fd52fcc5329cd6d272026f8990c6a76a0b054428a3d88afb3cc24198a74adcffef58fd454618c631ff1945080525dec86a6654c6e141e72c4d5da3e38d64cc16ba09e0d2d60e48ed817fa5ca9289c581a3927d3c37a746ddf5602d54b9ff8f5db862068e652cf66227491a67dd3e507925d384e13a70defd1eb01a91b796e6273dae58c2e4471d16da70c3f392c5f3c332706bec8e58086731703f4ae6bceee272c737c0bd88496721a2b18881a387245c790f47fbe29d3ef0df8e498fad810b622b915c2e9ac4094b90ea1c1aa19b4acf5665a3c5a02facf2ed13c215aaec43e7af8debe89d3b14f747bfe9bcad43e1ae52223138fc76eef801a9a82884b489e0bbd772c923df3c079aefc3a193d096f6cef64fcddb354ed64de60e3b1567a65cd1a2f4a9188dd46855cc4bce9ed151373e2ada8fadf18aa24d9977d29a8669fde89817bb77ff0eb6690b323b21945d34537c078bac6ba0cc1f1c1996e39a031ff90b2fdd7c8e7cca7ecaa2cd3c003a85e20a79687e4eadf7210dce31955d569b6472157afeec0c4a140708afbe32a58551a2c379bbb6163bfdfee18dcce99ae0c1543902601339fd20e4ef1287d15997ddcf15160d9228526054878a8d7fb836ec6fdbf759ce22fb817903b10a2325caf832ca1a6745b984d4c1e329c0e4f9b721472e6a60b373ce9760fb2197ee6d757c9fedc1c65e09078ebf61622aa75eb8231f2f1c1f6ce2a5d0b419a488e1fc98a0139bed277e2385e8262cc88337059b07f255b97f9329665a4aadb2abeb435efee70946585a61e8c26d0b89aa461c2e185ea3ffdf3ebecabcaf4adefe7f9d1cffc4db0b6eea9d0909153dee033fd9cbbb127827cd45db8047342d60147538f636f4acc3acb5161483027559efba7f1788d739aad07ede4b9430a32bfa6c6d8353d81e85afb50ca4bd3fea4d67dfba2870ab52cccc80418d9be3d8a2e3333a6eeb98315ed3c8db980981d171f60cd1de17251c1cc8619e97abeaa35d96a7b4c3edd8ee39d859a1ac30bef81e6420c78bd1529158890bd67e5ffb2bf01215c253128ab961c11478fd32761ed03906fe97b1d9b248d0f910adf47b622a748e4cbac7797a061256d053bb0641924a8e80f83d68f991c7a986606a2aeb8a35f1e791e494a5687988984c66ef7c89cb405807f123290cb0a59773ec7eb8326d498485814ef988ca2c81f7f83c4163f382fb2b4cc6786ff0ad4aa552425f4763129f0615af7a56e7fd2df3b6a98acbc33e3bd91fb3066f3751d880ca741a2967e4ca84b9872b8a4d1cc2e3b46564f3bfa9d8ab179f25bffa7963957c24c8162f6dd021b7c8b77857114b7c433dd81ee9c66786cc7157b49f9f8faa29f4f44f393f93ec49c9ce32e09a536f6b6cb68ca8e56198903d756cc75de23fef47384cd6aaddaf0a9006e61a924320fd41f17a42c9cde204ca1fe84a1c8bc5f25a6cab9568a97962abfa0965cfce44663a6b7d5f797ff56f0ac4123c04b1a74921a156582156d980e94c88db01e70a2eed347ca19e110cd84138c030c5e4a89a16a0f521c62ee4a7c6a96c1292733c70a01d53c015056cf29367caa45bd782209d8c797a25a3e8e7fe7ad8e039f3c234a7de991488e526003fe1b256a8b76ed9f4e6b79ad14882c21d31289775bb33138282d7c14c72c34305aeb4f3ee6c932ab2e632945f93000d2368ea4888ca136628d3242474511fb8b66265125fec6a456626ccb282ab935e9968e94c55177ee544ac2a76a7542b1dca32a05b42577a0bc521459819d4cce1dde8c105c0f83b84728926f7ca165a4aea04c2a21b1e347117c25ca133befbc7901b86c54c00be13e6aef8738142b353b26361b4df310328970dc57acf7035188a143b0029a3004e386bdb8f53f084ce8d33388437039c4358f1a50b7deaa1cb34a0dcbe3f9b43f567def229902b8bde52505804998945ceaa67d4290422c05748e597b0927fb60c52d036a139493fcd51f9c92f54b6859d846cf4e1386578dd5996e889ee52e4353d15a2b7feee8b717e838d6f05b6b38ea8674536373f0fc9ca334f482c277427ff8510afeccff160fa0f31141bbde2b166754f92279123028f60678dea8360a8d99a9be4c227bbf88d44d95c1c8b458d707b097d866d68fd3be2325f752462b179cefbda95d2d1dd06bd8dd02acae26632b670aef1236749c334dbd24b46bfe0c83e0332a045f46a1d08bd61cbaa1f360fa5d016d9865e5094e3a6e1e3771cda18e3055992936fafb57e991253c0dd69fa6dd8dc119f93af2218ce047abcd6ad0d4edd48f2151edd58ed2a33e603f223017e545406cdf99d485a3c46e884cc5a4c899ef97a6c1c75641e19e1404b99bfe85663fd4335bd6591fcdaa8caf53c8b265d184577ef530c01aba7b5e10ad6bde886a3acb24c313efe7979f6bac1592f30982b3034630780f25d52e47bf055af6bf4e5861e6c69f2baf3698f28af3c2ce69058513663255ea9e3d25963f881fe1858b47805b73a63f4312e7af1db653660003ec0b963a7f0e9854133bd20162aac7974176cc75a2be0218956914f9b1a8ec3ec4e19bddc413916011e9d4e25df323cef9ab411d109fb635e5f6f787deb3601ebc1d2df6de291fb28b61294c964dc26a9cb2f628cb20e2f87c281c7beb785c5eef9d7bcffcfaa50e1fbbcd9a01c76e9a34e70e07b4805ea2a280a808a3256b2ddf4689b59f99191defec3505c307b64f01ad97f6cfab9cd1bbf25d68cb542981088565f2a12214400b5960fc6f752af408cd5d87f7b404f998f6525f2f90f37b098a04d9bf958df4bb45fbaa9c63f39dac41ee7fdc729e86dd06e9e4fe40f63c43efadb1c359376a62d3469359f0177e1df19fdeaa229a72e4d5a6e8024d63bf6d4dcfc17c12f86341df90a653cd97e9d2fc8178fd6e5439ffbde999b8a6208b47851fffc38ca00ade1d2c1325428c6bb1339738fe66fb4b4c38d655de96b284123571db3e5c2298f5d50678ec1290f1e3b2e8e69cc624fbbceeca80dfec7a8bbfa4ba9d3f4080da1e1a95a50b3d33c16a3e38d47ee18e570468b1772401b9e1b2c4715c75cd3b18bdd85752530fbca3b8971795273de22d4403642ac6fc8c1a81c0fbfc5055f77de0f5172e8af760db79a9fc66f71584c61e86048f3b37167a75ccec1db2eef325e7c864bb9ccaff6e6fb65bc52ed9c9ce3c851488c82dca61919e01899a2ad2b90919bb1f9f93d4c8e0445515279856cd2c43c7dc64e28a11373b2011e6696b7851052bc7d4dc6273010a0a331ca1e704d6541c2427d3710b5c0da82ffee0768c12ca4d2f1b116e5c51ca313be6e503ae564c8cb2f3a771e8cc6dd77d9d9fd0cc3eb4e9c8bfc7564e6b535f5cced8efccc901bb6258787deac3a1831ef59a4b1a47bd64c5c0aeee96a1721667d4f4127b6188ffe4ba6081867104bdadebe13578a0b3fa31bbb0fd51ba8e2c6c9162b61456c21d94447d523d32dd73b449516b918406ab8b8418758e270206a3152cda22707f3dbefcf50c50e0aa945f9f50d74f34798708f1f621fc35fe38c19766b8fa246a7aa2adcb0d48ca98901c95688bcfe314653f63b126c28b07626086aec8cf4f588bc4a12b2dae2fd946df4258e5e1151a1b7bb83370a1d58958d9f377dfa80f8de32b909b78232ef2adec1c7fffc5f676a632e63aa9d7da4d20cdf2fea6e97c42f4a599635ed0e5b0bd19d1acd8670ed1f58b6107774d1dfe38518a97791e859a51a64512588c94070f12c9a717a2c43eeb4c72dc905b46d7f0e54f71e3d127ee2e88b4f29577363c461a54de8c5c9bd2f4d7d73fec3619c8e1873ca38f5bf9f7a0c8a8bc13e106105dea2272c1c7e90f42208a42617021c4201b70ecca4a52f3c54dc4d63514fe4655c787184c3b782d87e73f9f70e55a5f25c136da8e5cbf516e02b3da813c82fe77d0ec0ca0caaf98010d1761b0b32c18d2bef967892ab8314453876256b880f2db3445d51d52d43252c46c1da0d20e698e350457cd67b168f5f7fe7adc1f9d23ef1413097b1901ca8acd4bd97be3cd72bd4e786a65ee92a645a8f2fcf7eecea6cea8224dfc2fdf664c172fc8297a21792319366d8d071cdde1372f96bcccf73053182f98716fc4e6425209ff8d21f9bcaad86338361491f6c0be22080aa3d8b495a0bc270d6e319f6c2b8923ce2b54636e376312bb162ef0cfc13114898ce4796c3396046a76d2007e19380e8e0c2ba6265ccd1e3b5f703f71ecc4703420afbaa7e19c2bae48428bc16452e1f7393fda04ddd7f0e4de8cb10ce73b83210ca104b47bfe9e091c54a68b9eab08d21d10ecff6c6c7e9ecd185f98628158d4f5f282a14987","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
