<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"937dfe801f88db452a840eca6b3772bdec10f6f82ca2036de6dc153d45a6a7d45b208d46f657eaaab39678107c9a1b64a3601f42477f3f9caa989e168ddd05b7a9ca7b43dcf850ec89a1bb33b4619f27c4221e8d6611fda72a659f237f165d54535e09f4c1f5dfbfd56d08935792b238f3148d68027ef8bb11499be260ceeea27afb4a0269d71fe21e70c7b1d1e4458ff8144b94a3417e657895639eed236253d288ce660e051c2564b12588ba508fe4ef246c1643e2493b4e5dab2d299bed6d56efe55dc5d094e849efa8f15aec4f2af7abca0478001b8581de6bd03e160994940eea50b87644a4d2b1b4f633f0ee48e8a6d11660b73156d882b30ba0389d6e2e8e16ba37a3b77786c7be8f8fbc88a1bfcc2a444130b887657cdb370ef6852040ad003ecf28ef471e75c159c8f48e8b2a949d200571a759d3b093b6375b4ed1e37dd0736cc28bca557f788acc0e78d6cec5735ea0c859934b9c9c7f30d42bbd45b6934b260350bf2545b6c6f8f42fe680cbe0bca555323bc33d955ea5d2bfcfb8e9e7b0e58f171ad998b8eb8ce76478f9577553742f3364b1bebbcd4e8ce897c55fa895837958f7057febb7a04873e91758a0b6278c2bba6440e0f1adefac88d53292793c1b21065fc8b0ed4df4b1b653369a9c59b1392173c8b20352f8e6ad4efd5b4b16ecb0bb1a59f07a3178552cddd9b9023ccf780b7cf87eb25e06a2ffbcedcb08bd071f164cf001c8ae47991ae48fc12f3655e436a877155be0dad887c982b14821ae471b4e7d4ddcbde10fa108c6fb13b2bed497872b2a1135e6ecde19e01dc7c15eeb554521ab4fd08058f701b93347f3a1940c5643445b93e0cea1e0c394b07620bb81a86d72423837b9a30d7d31a45a55fcb327e2e1332edd2d13ab25dabbf1be0019ee4574ab87c4677b6fc88ea1e27cf25e0aba3d2983dc74b7c7110434a8f1438a268de225b8bf3613718d1e5dd686217f3c55a0fae9e7575e7187c79e1fa16c17f4e993cec976350a571337a38093b04c0e3c34b06da48740d8583914d4b559c69fdeab0e99374469c684d3f4b5a1efc106985b2430b05919e568e7dc6825e74200a971311a3d1803f570c73f53a5edf352d61e1a43920112e735c5b13859e541f809118597c77197c9e2e2e4eff7876cbfbc81b7ce14c66da97013e9052e4c8a521f40f6a419b57f30e001b84568c33b835f64b685d0354f83848709e93675b1809e1d9df9ff9ee851c03b7cca25561707df87768438f45835eb2d4dfc84757c77f7b1b96e5830931ffb0f7d1cf26801a41546d5e918c4d8c15ef1ad885811137766e32a0bd6618967cc5848120392048dac1a061c7b37b93c16fa08672a870ae36422b3ca9a22c6c38d75a6d45eff4dd9e639a3750943ed6d5d397b430ed05b1c92a6323df2ee38a43cf970d44c7a2ddfba54582b2404d06fc28f916466da7073e62c7faca411304291158e9700835645b80c2b5ccfbf3ce496d2ac868ee28e67b423733669d907506d17aa6bc30c5d4e54d863c65af5b7baf2690672f0244dbd030f55a993fcb47a90eb6da8a7e0c4871845e18fd294f7187e693e8b3ec0d969ce407c469e1830c7dc7fa11382e06e03bd59136277b7747fc7b792faa614924a2f9ef886440f5f0a3a3067bf510a6694cb64f705b18c67d39e359644be734bef594d3c47d347b4665f27ab4a369f5b304727afdcafa22de81c52cb01d1ed47ad2385b20dd479de49fffc74ffa79df6da5ad34caac1e289de9d315b2aad0f1c21a59c93614345aeeca299dbfa739f226c9b38894967dc7eb604fd2b50a4cc5acafc09143b68c99876728d9016fae0fd70777019229e9419d5c6b29d950cd0e40731c0bc624e7e7a92570c6ed059571533eda49c862b2e682cfd2d601f43ab4aea0f457e10a015ed7bdc9429223576630725346657d53ae5f40247e2e3c1b70ac300ed699865f4579ae1c860bc751ff99331ea43f18f56e41fd5d3d825e7ccc86ef209df3748a351ca698bacfff0d937ad8b173199382ff4b122aedc8a7f9c6459b2584ca2724d98e9788afcc177b7281eb91ffaf0eba116c7c5ecf13165b935c06bedf44a0dd233cafefca546896f2d62bf388911e4399f126a0b068e09020303340cbd1203cff2baf0da106da5ad9ee5b2b32b64b63ed94c2c5c3e0be6d1f1a4b7160ef60838bc8802b454dbc753ee66d74cbfee65f03d812bee791643ce1e5cc88eaeee90edf320b50e7f3f5b196f40f52582a89c64a2d07935554eb690d00764646abfc08171aaa248b432f0e96fb4566e7d9c4aa00b7777f237d3226e8393aa6e98cff349ff0f0ffaba739a131c7f076133b1ac6df6a683acd7a85df7b23d2011835a32b7318682c5e83cdeadffa6f80a883c3d60677e2ff43b3c71819e60c1b5b7ed91161bef8c1ece0ed130977f07e0e4d58715f7b4f7a6c88d4eb1c307af4ec40cf1acf385474998e4f540be105d191b101464b9f59caec86f892a6c8be33cf81bec69f953b3abcd1cf6d24d6d6015082fdb713faf481c789313a7c32aa29345bf515ea0296c0757367d53b63bb147affac73c3effaee7241579049592fdcdf7a536929465a380cc841dea599609fdd0a4ea3e1c394ffa35a6075238ab968aadd95de3bb4ebdb013821eb444c96e122958d34330511dce72bee7be81adce2914e8f9e453e669361b5c40a87789345fa1e4d0f8e706df3e05428f03920f3589c2d023c419655dcef1c3407792dcae49e910e54e9b79b987e264d3f982f3c353e6a995f1fd21ed153338f4aab8ed382ca868dcea3f5cdbf33d621a069d94f3d9d1f4a33855d3a621414af990c41704aa678b828529dd3325b4b41aeb39c0e71d8dd9c7baa45e1d0979c7048a750c2e0a7c5bbc195a076a8c3ab2f669e581c87b6eb5277db9813a3552883caa1c418ff0d86ee99a0d845ea9f659add92397cf5c7444b3a1bc35e771ff632e3ea2e29992b886f9d85e94db422e14a55c00a8f3bd26dbbd3214685af731b7712333d6c54b137fd67d22e14f7c87cb9fefdee0b3a2a8b9a94e58721fb66879df120d17f0ee1eca3cde2e539d5bc8f19a2b640f49a9a4f82e4cd5e077b517a9567595d3cd312861901bccb369d3b8cbcbf666c4409a6e880af106fe3ac30fab05fbe683f913be3b8a0198c641b5f3dfc0d2fc7a26e63afa784954930995e35c2d7a9a23e148a071124a48534926ae13591d0d77cb7029593e12cc801a5eb7e30dd7bd0e4ab927d9e43de0fdcd38f59ece608b5c8b02dbde428460513caf2c59c16e77db2aa55c1496835367abd75aa134aa8ffd0711e6e883d8b087fcaac09ae6258ac256955e8ac169efdca151d6cde2c0bf3e8a7853d90a3d0810f36c28800faa5be5acfa7e8091dfb15160c23eb2e99613907ad5d887b66b964f51c6f15c42f19adf12e2dc3f3723d9dfc561810f4e171ee531da413508a99ef78faef142a4c7e049a0f26e1e954963ac3ff99f03354c39ee48a428dc2cc1d81d46985ab56cce4770b1662cebdb48df36a703e3e99368c31aeaa1d7289cb230e11eaa23eb1f9878237d6b815e55dc15b9b57b4098db20405e064e92d330a88af18520822ad835783252efba38f18b6fe4d120e79cf1d2abe1ad81d11b9470f87718cc79818ae478f61bff99286616ac20aaabecbe31de944f588eb998de75ef94ab0add5dd7db31e605183f177753f4703481ca754096a6449aaa08651588cb52f1578ff5c2b4c0fbd99f5ad2af425366e933e5d4d616740ce5ee2edf1332b91f05d3456c106393182d0678ecbe9f778f8e814eb5ea4d9c27ba45c0e537fe89cef64988060def015ecfb28922ba1ebd1a43e357b8dfce2167bfad94eba73161c52c83c6dc8805194b89abf0b3e2f5963b8378a603b688c2f9d37f99e6079a2568cea9ff6d17664763e26b22a007a189a2b3c54c89882cc6ce30a9c44d378718dd47852eaab6ee47dec674612754687ba42694ca1ee3426d02650fe1b28039e76031ab0968243e100c8d6e682f8bbc3a588f358ccdf171e7d27d1e6589f051c69130f5f7c41aa2f7f0e898ffe21c4d32ed140cac541e8cdb78564e8e29b2bce20d5c0134dffc0e7cfe0d296fbd7a053adf6a3487f5e78c9ab792d98e069f2478ff2212c091ec8a4c6d4d71970283024ecf5cce2a933cebbc74492ff3241a4a35f9377f461a9ad1c2c258b685a6a06b3d63363b0e6cbef52cbfefa2186fa2bc0ee720da1c4ebc948c7e17de99295d266683394747c2211aa2c956df38a2d6a2d7e9d450a57f7795d52f6b83dbfa20587023fe6b94a6e2ae1edf9b4b41f4541ecee3fa64825699146fb3e8ea9b3a49b5374a4db046d55cdb36b376ad699fcaa1e1cfb5334198e6d7f90c48e58801b5b976cb15da90b6d48bd4811612fbe2f4a7d16f1e783a2124b98486a7a27b4ee64e294d0121c25ee473b00ca3f85555ef16c57b335e02994645fd48798f2bd50f1c695b1e8406955ab478d8527275a1759910e86b83c2ad391188077f7e7b12b36799c7df31d6b684982f64a118f1aac132721ebcaa96d392a3f2113caf29aa7276e2a6800c93513b40f39586899355a254574a9fefe05940ebbc5c3292b7dba0443ded377d6bb1f7ae78163929f7f009910f19046c92c9b827e12a389fbef2790070230f3f4f8376a6d6944280ef92901c39632644dff09c8e34091e453d30af685f594369e36a8273f40674c8ada8eef59ca99390d85c868e9202dc9e3a79315f5ed639b64ca5a729cb542b5eee5ca2e7e574c3442aadd245db977d486770fe7eff7be4f5687cfe393f61aceac9466ed43ccb285f38f70b1fb09bcd431c18de7626baeead7b89c3455c05379fe8b11e31db9591b5eb7b1ec2c91f7afee6b3d8f92b2b148cb6d423420dfbd8d6001e2a9c45b59f5a3268f2182dd3f7c4d122b911a2af6d8abec13b3f27b1c46ab51dfb6f099d6a9f01d0e53f4e8dccfbedd8a4d4c8cf163d767df451f4e312029a2f17ac30949db1a4db5d8c320e7eaac97a6cce80dd509bafd17fa90f2c68867d24359cb55e1a35d52c287931939bc393240b1abe709f688279d3f8e7c01cf4dcd952a41a87100149c73e677324cfaed0298d92f484e9b2f98900a1f2994c78266a94660937dbc4cea3ae7107222880590fce77173c259d9cb282f44f603fe47995291cb6b1d7e35b6cee0b0339975c356c7961edda7e8a4e6be09dbbf27c6bf16dba7e603707748fa6d6e812796e50b78178e2ea59a894dda49b83ae2fd3956cf056702298ce6b3281b3c2237872ac715bf9ef3b308fbdae7abd9b213bca9cf4f3287c47e774005f4aec30227aa303e3e5d4a959cf80752c7a639126a28bf6b49083bf5f676dba9cb6f518fa7fbe909688faa3493c9310cccf38533b05ca17fbc218b2dceff9da833189217e30c9586a61281f94595768031b6b179f952c38f7eca6fda5ecf63f858bd9a19e470e635a3553216265127464c79fc350fb5cb00cc0fa938a522fa5dfc70309a111090f18dc646dc98cd69bdb8488d92dcff6f09c3f941cb2cd3c74b7ece1c60c0c1f698d1eb3da259202629964de377017152a21ef539fea0803ad6e885c869ce3d8af3d505bcbd4928177fe5140dba116888c574cef7c57a459d48a5a5d19ae2f429e7d210d8805255067105bfe1d8733284ab48cc7eb9e5af14a8c5815936c921fa33209a0880f492bed923d2594c6378331e8da6aaec50f6a1b0aa69b82f2fa3c9119a5de3a675afaf980fd8cf4132ad5ca25edd09008febf03eef85b0855fec8c8214e36ea1c45936758d2d97e8ecc5f9cb2ab07c583a7c70aebae433a94fb5012bc31be67bae060e3a9b3a2b79ffd09e87145831b67a67db8dc6a630ff53345d9888f46b586b0e1a755cb6282aa9c90fb9a630e9c971a8c147efa787166b4e2881c72f599ee95fc740a9393972cff2fd1392cd816b2d1082affaf8f3a75adbdd9943559cc459222bbadf72aefe988758e5dacc3cc27859c8433c4eeaa663bba0fa379478b617cfc7949e423f9cecd697d9d5de22af196373c59f9ad7d901e030fa6da995ecf122a8bbfea44a54f1583b29f31f91d33802a6a1c86ed972954bf0fe2feb99f1cf793fa85e27460d14b5ea693a13e2e1bdffb42f90beac18b462a3eb7c9cb9f95939df108ad20bfc336d977da01d3182aa977617ed88ea0a2663ab060100899486dd4dc360200599d015b4f99885b8b15affa1fd5461590d2293050cc3414644503b6a9de4b097c6747af4f1eeb07beb34ccf7d48e163b055741bd6a12e6f94ca16a41d2453e55230c1a0f57663380588cb0feea70986633d2dea1228e3f3f72a95b44650cfa89836086456f8b1fa7c62c81837b8e88237305a91bb30d605b63370458ea19a7b0b65f8bf74ff87195cf1d142f70983d8bf097055825ffb908b0b1e18ce02ada308cb26edf52690828def2110782dfea9f6ad24ae1c667a6ffc1e964729c532762978bab1b3bed356b0d5344c6980dddef7d1fc24d9f517c7b0790a2e50b41d34166f4308b7000a1f23b973275e978c07ec06a212dbc2422806affe69c80a6e7cf8a901a42e10a69a54824d79812aa8c85ca1dab43f73ccbba48444d347a47ea7bae6d2ba0aebf8598e0846c5e17f12b7baba9fe9e035d7d9a0672234a65e73cecfba86c8ca19a6d616f858063a97388c98bc8225b6eb3e271fac2f5d2d18104bbbb103518ea3a50c4745c85bcc93d0deb38f6998682fa53c7e18b7565da6841fa437bafbefb469db34731d847b10cbad928a205de2c467d1c5005a8eb87cb099a2a15622584a7005c48fc03382451336c6b26b9232bd3d85dcb71d2c7ef50f1b53e4301ee413ec4891572b848c8770875d98ad2a27042cfb1c1a4f04cc6fab037169d74406f29e4d9319dbb819447a1f7d8d83d7d5d91c629f1d8f8a28e7921ed518048391e7a1969bdd6ed5eab63095acd1e3be31eb42ec5bf2e39fe7e238eb84b68bcbdd014b4e9060ef8da8cbf78609b4c6235244ebba837d73ade82008da32bdfad2b874e40b703ca93c2fbf7ab4558f5817ad50f8b7e948b2b34615ad12d29329e11bed3de3469af8929217bd36803532d398ac5f7ae1844390cae6bbf94c488ce3525f8d1f475c9687d1a550bcc2271d61c6b47206cdbc38a678ec3e057867670c6a4b291d9b42cdc419a46126b921dbf9f6d6d1d0d94917c15ae97e6171079fe02e58391db95ac43a3ff8dfc31eca4943980af6c10ec26ee82d50d08ca01441128f9f6c6080addbf1066ef9d8d71f692e27799a90787f450b6d3542fc065a4414777fe24197ec4c37ce9abc85180be7fe53a127dab64f87f1fcacc281b750300247939d46ea6d5125729598c684c018a123a88a08cd5800998ad7492759b48bb5b78ef44371aab5e049cf8fdbda64e633ae0b1eb9a4babf07f94672ffbcaa71e3248ec4e6c5d182e23d96ba55aeb4c898cc2cd0c698b227104aadd9621acddc2b4374d6d4fee5fd8c84f1319170372c387035a2973f8fd627fefbe4bd8744015c64731be4953409bdaef0497c736ad3d34c30559f2b5c26b63481460deffd468175c76fc817448db4eca1f13a15a87f21f313da5986aac00f1f39d550d006226486750a9386fb1c61617d622aa911ddae0fc98836807c3b26d65c909f00a260312be26f856cc278b4f47de5ba36f761cf8d450493b081dae5e13c50d9c8b4dce8474b156b6cc5ea7e5bdee2c8b22322af1a5425e711fd7c02fff0aeaf1097663141d4f0c592322edc57162332d3a918efe703486008ebe5d633226bbc054005ef3126d3b591232bdf941475022d2adb59b24cf0cebec4f4e3c8e425b0f041b369f73ea11c53fe528a886ba31052e1b7883f945563b51fd59f446c56f951c13ae54a5095572de90b44bfdf482762622998b1162b9d0e9b598e2badbf3f24bd3e2e78780fe98a778e0ba40533f3318983cd2de208be5d80c2dac5cc3033dfc37e4fe66d929f1543c12e045bf2655a6f49c2b5b7599660d05cba3fbb00efa062ff1f545d244997b2ac7ea7052e2aab67f9cb6e1f6913f871d689fb88c4c8be47a4b1c70e37960bb90b9aa5d85796914e6c628c0b13ece05055680808927e336708a2d679ff1b67a34b64b675999add7321481e48040dce76d4576616bbb0d728098847c77e99687858f28b42628fdf732eaffc77803f45a73c807f342732ddc40d6201f9e95b8cf379475a06b53a671a7eee1861fa244e8af00f28fac810d233d71ec6a401d6eee9eb09a7c29feb3c38dc2ca8ae8fd63abb4efd136e669574940aa76b020e193c9790baeb4b2201788b3e2e03d702f3feba42093dcf872c07f830be67f96feb1c6fa6b63b11fbec760bf71416c00bbfcedaf8cce5f794d8bbc6052a00323ee6e76fb0493e71206a53d6df9af7b0e7726a425de65f26b6dcb4c9e8432b42a1eb8201693262ffd73864b8c1a3dde6ccdad74a503d14e199136acbf592ee424af11948574b0f8470a3f8bf156c18d80978aecd3363b096c713ee2995e82d68a2e486b225df850c8209db1f53463b499c6e6990e131b320542793efa0b9e22d35afc5cb3fea759a7c424bebb039d4a5e3d0a823e0ed1dcc7ab53005c335cc3c6a68e1f35e455e3e1fe5681cc2118bdb837bcf112915deaca5f5edd56a190079cae916a4ba5653f39d850fbb60173fd5980b7a2493cceeb52da70f64edb0b45d6d6d88db6158ecabe39da23109f68aec8cd76317d9f9757d744f6495f2d5b4cae515b0392421361c41bdf987d65220b072881a3dfc49fc3181eb4907dc048a6d40a66e5788294368d2866a9f6603bc50157988ba00d344a37f4a473f054e72bc1d4ec5f20e30de412998461212734765a8ae29cb485cff0d75bee499739788fe335ed538a56cf19f615a5e6f29113baf659b5e3f3201305e436179df90cabf6c0eb42c9861398d3ec0574a48eb2a66234f23084496a6b22e05bbac8a90ae0bb128c3827e4e328bd0a716c934080870fc793c1b0fceaed45bec9b4335f8777b92dd732d49332844dc3e68e239a20e708fb2444ac8e196c527fb0ca233b06863d17bc24de8ee955b67ca305ae0461a6eb8f10d5e62571e84ba0a1cf25a56f0a4a40263b21ae70e3582cb04b5339d4eac0839cb096fa8a1aaacfddba924ae948a29d7dfa717a44a80c2ded87f94ea7dcfaf24fd370bee047a13bdca29a98a399dafb4833c50c32e10b55565ba190f450aaea12b005205107cc5cb5383a88879905ecc1079688a0df3e05f63eb0c407d0bbb7ea21bcf953f402ae1d46146b5dde0bfde838961ae5a7ed38757c812966ded4716146972ccb0b745551df4f29f502ecc5e72187a3438c1b2c90332bd926ddd719d88bb8462c71ee588bda0631e25b0bc8161cd20b6127ae5c1692c783bfe2756fad661527f722099420d4449ba5993856a4714a4667fbf51addf7b297a37fa4016f911c10a695771456d1941824ae04b8f923d1c0d863e5cc0dc0023f38278e1da4f8b178ff595c31eea759adc5fd49d76c00127e44d0f4967d7e152c92cc7884e028483d4aaba7dea5edeaccecd6527059b7e0fcd340ee65ea61133377661425789c7c7ed0095ac7d6a5f59631fd8543d6392665ba1c832d035c60443f641701c25268333b5925962d874ed24abc98f2be8d4474b54ee3fc4ddd5a89b12738cb106ddee9c62a44d1fa32c4643b55a72a709ff0ce45085a87602076a26e605c4dfbef3624cd931da1d202b9486c493d59d927a050a03bb28498e7daa8940e0ffbb3081b078a33cd23d121487d760fdd94a628a33787d264bea78db555f74a575d72b5cc82b6013b09a712d6c99322d4f1a637c087b5d9a0bc0c0a34019fb48ad2d5b3220e5477ecd399002d5025c705c0ed43d9daf80a2f7b52898169ca174e2cf98e3ea6037e334c414ba40c28cdc00020906b906169e89bf02d490807f1ac6987052ef255565dbf592c507895cd5efbe22c19d43d29c1abe697b52ae26cd0a0fd578b03d07a5ca7a2a7d904dc39ed1df2fb9c0e43037d0c6ad3d058ffdc359806f9ac7b160548a2df35e65cf4de053a9807e8bab1571fe066ad58840c0a588837409808c11b751c6c550d5867f263083f0697476ee12de669c13dd6e6b4aafb4d9f7d48f54149b255e26442e79683f6a709707cef9ef0916fcd80ea786d1e4af4d92952388809b1c6bf6eadfbf2b9f9c7206abd9a065188e9b6dfbd84bf20b6c1dde9b2493a0d0dd3d8f6fc9dd68171c1c37c9029c99d483b8ffd97c0bd5fe723299062f49fa47016273047d4cd0b64a67d56cab4ed122fa72fbd13e28edb687585e5d225b5a1d4567da4615df5da72da0fb2ae9dea566489e4336c220144134ce57c0eb48250a9b706b2c4ca3ea024124c10c824df8eb0287b664c3ee139810b0bea9a4dca1ad11f662ec26246e503a4d6a7b5fffc445545a9d3e10e7ad2f302fe9901a338c6b4235d357f17008c168cab9bb8882f98544ee7ca0d07e42b3fd7d350608564a4db7a92e760fbf13eb89d2b6c0fbef9318e68feff2977733c8b7d0b87acb6b77710b14061df36d6d8413ee673967144e450de6103cbc48a339a74d00b7dbd1756e98695b3aaed18010e27fcbe68c9f61f37b56d1025544b65fd836990048dc9ec3d78e4f0e1e85625682f37bc45d664150c3eb68e6b990ebe3625f22da81211c838d934979e5547b40dc0c28f535b8ce3f5ac6a51efc01a1199a4df32ac8a2ebfae25beec1e92ada947ba3729daa767a8161e68e6dd179a504c2255b7feef2e24f831665374a59ea0af47477bdaf4fa11b96c479f91a2635d3aebc1a3ef597fcee1f96e836a8e9eb5c5f174f5c694197f15fba7303a453a28a9903e87f3f7677af7474ebd9331bd20e45a2fc7a9a0a93f8f3dc93405d32a077e0078cc5beab8bd1f502571a5296c942a2d56c673181989eda69d2a73bb2ab6ae2a6eca8e6f23fe0403c90f8210daaaa75074fe664a3da21c1a69fe5bac8e55300848bb6963a11be9608214a05b68bba26a485ce07af9eb66e313223fa3a7d18f6313578fbd1a939247dd53f598db12da00473ba329d6b25f15d4cbd3551a281b52655a8f7b9cb38bc92ca68d8279875b71726f6d2be5dec6a91a12f484e5668eee2d2f5b79339b4021d675bf6e6b92c5fc5ddb5b78502adfd7cd0e4510ddca9a33ac703328a482e6033f61ed3841f126a91fee6035a553af7733495d29f586f4af9cd42a0a21d329a0fed4458bd509b594bebcc69887302f1a59332958ffd014d346eb05c96cd1522e81c15db22ff0a695ecdad853045a33ab90433cab1240d3fd2958b88c37b9b316709042ff977a0c936d01bc4cab11221ea04af873a01bf6b76ac46a0fc5eeb7d65383f8708f6f882c073acfeecba0a0b9f041e4e1318af2304b66b9e36610e5fb9075c4078b98a4fe6e367519711682cad1556ce1afaba08cbe76cb7e153ece8749eb8709ba4d3d4db474f5e7832db4de36f00810e87c814dccea322418cdb6478f8f4c3bb7e7c474f34006f9226c200fe6502ad19753525f22c54abbeb9de40d015111b24f05766701228052bfa45bf7ce327fb27808eaefc079fa3e64bbe5c52e424486f4af1db4be2f654479eb6151693b232d0bf4c44836b4c2fd7f8abb5711589e41a61ac2d2b8dd448e0d2933d32cb656b4311bf6f73f1a5847d73a45f2ad09a5c8c5a5d6a6f14626711183ff206637ea53c2fb8c6301aa813a823f67bb46c11076b4687dbbb35ee797defabe1affa435e0c5a6f4404b6da812ead176bcdf56af4b2ac57a107c99851a0d88c23680f3ef194dddc9aba10b08c06307175b0f45b8a26c5c4eca10dbf76934b040bea95da4befdcea6fd3ab5a571bb3556274d95e81bd7522ab5341fd503c30facdf85ee2bb7aee1e21b148749e09ed3fcfdb5eb7ba91828c5ae686f71c07d5be0e595ad8218ade38313062cca377b4b1cf8955e0a0403766b8ea19747346fdca95fdb890505cf2f114801401","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
