<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d8b9ec17cb50c725fb8fa96802dc6f7e4358bf0b01b1f3c404b583fa339c8192b3d2a2af5ac48f7ba5b91c3be2390c75f7a86a7bf8cca411a65cd3c7dd31e433938ab87420b389e84b453539c6ade7783c2942dd54dbefd071d409833bfa84b24663df6e62c4ff37d783a0ad60dbcbd69c25a5cf55b4244e4f1b5e83b7ad992bbd034ca15299cdf88d598e02525e12aafd38d9637472b019d9733a9d46f1d0cd6ea0ac9d8f68430e5bd3ca74bb0c171f1287598d88bd5f31684bf4cae809e1061ae4d05ecd47feeda01fa55e0b5492d9a31a3b6450a6323c850e393e1b0154b279b88d2ebcad8ee03a4c43b3e3c2b465266f84fd16fd314f7a9f12156a052024470cab060046343a9b696e622a66c9caa240d32d12e33cb13659d6edc266b556457809249256cfef3a1d6db154aae63a51561d6fd46e969478ab91cf58bd7d6bb7d457b0a218a2721ec39824176f3782de2475ad6e55d800211cfe76e6be05a701aec719555045c5ec699864833f3c7bad4e81e8ca2891feab4566f2541a607bc236afd7fb1751445ad8e3653019ff09f3b12e249ce6acc0a42e874081760d6e24fc12a258e9f2ef09df80f0fc133766f4f0d98c530756eff8f6e5c402875422fabca95d2433e328729e5083e21d2d8ba04612f799877757d8436cc3638eb009bfcb053defab9ae0df5b8f371aa4cfd29e2242b617d0235455a4ae72b36c7d3247099f8898e487f782db4fc01c8f56d4258a102aedf4d6775624285e5d6191c66d0449af0fc4b52a84fb30e4e5d21740511799777725d51dcfb205b944a6274b9233211a2923f2db2c92db1dfb12894694810c3f0442ce382e2178a3d7dc4e12e4c3916ab963e0dd99d97827fc125a2b1ef7848239eba795d40d4e3154243562104c33b4c1245106595009daaa62b9ecbb0eff825abf41d4728a15605478a16d145495ab180aaef655904288a2769eafe319c104e0dd89bcce48712197e68e18e6e67d7700f7f0219c6e14c5f1081a0710c9614d603b9b4de535ffa6eaef883db769ea1d6ee738188f0e7f70ff75aafa31234e352a1e8d0e4283e340c13cdc0560f3a762375da90810128cfc29bafb0481b9318f92ef43df1ce918d0a32511aa6840ade0deb9fe6cc18d2180be63885a6cb4623470ff540a9837b6311b7547e789f42fada4f36713a0821dacd9c3e99b37a20af95e8252abd3493c4df220e15153d831861a2c21bae993c7067402881fd520b57bad2ed18ded5992e80db1d83da90571d8d080b833b83e6c215cdab2818458b4e061bf43b1121655090d22301603d700c86f83b865317584c2b2447752c729884399abdcc6d30899dffbf4b73ad8cde20773333e96af50125623ec1f49e31974d6852861a385c8f62031b5a88a9343329f95b12e9c255830c44d73ca559d429641c6b81f795efb40072ca928811a78713ea57c98646e7af4c966440fd3d82b4a80323e220f75f234c2cb3e65bfb47d5bdd41c603340fe99540a34a3045e9f2534bb56a0e88a781b102d4542bb383ac9db882f5a41941746fa1eaa4008973d0b282f895fcbd7beb1eb3b87ddfe4a0d3436c4d13aced5ccdb1d87b5d599089d50badb4d0ddd294a73e94e4cab9d120a6cce4234e173cc2ab5a5c707f71cf9224f7cfcb9a2286e8c50e1db4f80f4c41758c7a976ad0d088ad7ce856ea1686cbce2b131b079a86aeb9ff50647e71d176d906865a97879be0b647dac640df967720fc9405e4d79b7ba5aedef5d9a66ef9a887aea16b2bd57fd4b1d96464155a508836591fba1e351305131f0410afa34ec625fdbb9aab507494b9942f401febf1440f856164973e56908b92c2574efe0515960c8700f0cf9fbb2816bedfc6fa731646db088aca473dbc2b615c8f1b569fd224a66fb1d019d08923a1037adc2ba71046b9dc64fff999cd087d2f97058aefa09c79dbb6d2a5db575f7206dee07a9b82d08527144baea7705978a70dc3ea1132bf8e27f1fed2cec3070609d5f336c0576294e371b70220d1813ae3b839a2257936065d893263098a1a3c55d2fe43e68f4955d679a43be1096474e3ff13f67cdc1c479d54a41ededbe88d7a9af10d02ad30b3c90e5cb52e788fdfe0d39a4160bddb3f176578766a33371cb1028108ea0d6017267beae6e710feb421c67d6c8ce34e5006b5127da587b0fdef7d88448b72eac76bb45bcf7cfaa801de6ef95d6a7039ca71c5e85bf3f5628df5cfb37692be236f0aecb4093927c74b39d1eb08f36a3893b85dadb903e81abb3383dd6513dee3bd040cf0b4f318b93627049575711db8f258d2a69aa2c66ab900faa3f528a41fbb6438b2c2bded58e37543b6ecf5b720cd6edd92317b773763bf20d2dcbf1a84918218cb7a7049b6d2af828e5ded6056a6ca842634853104c640f55510b128401b13fb78add44489eb3aa8714186cc34a2007dfca12e831c77474881a7ff5eb60e1913595882bc5cba4390c504afc7066f2fcfe843e48fd9f4e96cc7dc722496bb8d41205f1f53c0baba920cbf4d374ee6c9198a7aed30185aa9d9a53d9d4b92da902843a60d566543fb242d32370c6972215ad900ce291423554eb80e82680f16e0fd6f5102f35f2190839007b88ff5eb9cb660254ea5ae1c49308fb26eafb32265785eafe79198b0f244071c6b2efc911cbe6e6b31144d50aae0977059cd06cc638873c33adbe15df6b1657058122b354e5309b4df4f123ba94c8099b219c495180b4183f73677d598a1269102b7a9574b8d74b8cc575d834cce791653ab77a93dde0c1b93c745e3a495d69f6b8a5ca612c2bdc175fce330a75e8455aa43f997458c3eb6562adfd41836a2cfbaeb9c8f3510d815d0ba9c29719a6d89e69ff7df490e8b6c6f43ebf5a0f0194ec1264b76c4b355eb3bbad1aa138623b4a2035a5e551b885e552316236c32ff1030caadfdb38d39310fec503f9738009f080870a0e3a1741f9731c6342723a5825814b0f53dcd9ff59fe03f8b0f2b13204ad661953fd244a123a86d297a141ea457aec449c8a683a95783100d78965b818d8077c204da5b0418232cc7a1ad5bf4397d4d4c9d601b9b3cdbad44667693cd9259cfca739771223069f19512610ac7aee24911b8e063e993c67c2d8dd751230ac57ea51fa9ec014b0cb5daebd2d491dc297cf3a1645f376a5ed744d89776c648a59c770c449e30bd3f3cced6449a565e7ef5436a21fd00a1aa71ec698dbc46385304b1157526d6511c85d6f50bef10bf0e8b9a68e16fac6b0af63a74c9e9758453d10b766379e78d48d67908282b851fcc92f483fb57a765f92dd1eb3b2cbe0a571983f69810bc4316bb2cbcfae98ad365dad923323e93b998c967311d2e02162e1cc084c62558d95a03828da26e18c91f36813dd13d9c6837dc10af54175469c282ba26f0ea3313787afa24df6cb62e1ffa8fcfecae7d504f2964f5f95c634bf435f8c083828c64a4c7c6340468c3424ff9c2f5ae5ad3b4ba463f8df8f1139639b3f95d7eed6b13eb2e70bd565128d83f16d3eb7dc45f5e865a4a8d6b130b8a16dbca8bbc10e2cf22356f6c41819ff9da0be0ecac6a520c25f62a6b12e1cacd6ed95dc099af3155ac7541c6cbf8a31b1c476dfe5308bb7e2fd8b501999c147e1de4af0e62236e8a7cebf2ad9f8c11f2f298d270fb99c1526ff70e10f67151a215a3dc761adb47bc3119b9ae937399b2309f1b30fbb046555dcca29aed520e006c2633d4ec04ae96e82d1ec2e393e176a325af97b37f872307dec56b603617671a1c8230b6c738f213744061a2efcdffedef64e38c901203f1e4e4cd8f25b38c38ac6ae131014b7e271fcc844d54571d60f37224af21e2af24cf9c2b64ab9a96b1731cfe4aac5916a3695eff5954200e017be96ad9c0ee3a880404551be6a0b6c6e350763e9e15c236db5ae265f359ac68efbeff3bf53799b88bc9b37d6417c5e2db9fd61c1e6aeccb7733c160aecbf3a164a6ff419fe23ee7c4319a506fa43a7e83e24a2b9bd29387c1f7c824ac8ba22028c4ca1818e27ca73d3b27747371f151bdc40f2a85e22fc5bb4811c6d20312b40d66a846506dde5219918fea1369d1afe6e7ae05c4bb1720e51f351a49ac40b7ac91fa9696cdf1ceb8eef77213522cd4b00d2377bde01b7f584426968b7ef29835bb82ac6f2b278919e35bf2f7fb719656d01b1f7256e098f143eab14d6da2894162d4abafda18712794203071ddd0a308fe996b9dcdb685f34d715a448d963a60791f326621a51031e0d3457b52ca34dad868331fa0cfef80567450cf9505159d384d8218abc8601d4b7374e214128e0921ee86c3d942f3ca6be2cfd55093e9c03f8ae8e960424222883a44831ef3a0eb618ac1d7ba26c2937ace8dd0db1e72df684ec1238e6c742bb151928aa4f3236d2f22c45a43c8ce3a96c28b6e96ed42311a1e7a1341a5a8a08b483cfd78a9d4ed69bd05fa3405c639c34d1a777a90603a3c05d7f829b2a3a512a3e0ef63373de3de9aef99f7edad9f321db9d6ce29959ae916d6ac3c54df5952d50d50f29123b4cf3bf1158660331daf6d1a8e4a363a5c625be8b9a7501a6f23607e02b12d20905c424c3ba732212db3c8f1e1438d07deacfe52c9ced03c49d28e8a9fea2bbea901ebb8161bac05ebdc307dce33d0265fb1db62325717f316e8255f86493fab2eb88f9a7265502cd6009149e0acc2c0697a2035648b22cf75386727642086b64b9275357f2e65fc6fc189b73d9b15c0cad9a2c142e7a3e1f377ab681225d5cca716d16491bf7c5c91c8e3e6c91602335ab73b8fb59ada2ccce60a462050bad67bf3212d35c43c265a90e7d9fbed36405a69c68732297ebf83f07b1dd6a33c5c1bc105606ffdc303dea1b8fc93621e81d2e4a9d7edcae6fcb74014c36b199302b9aa08499715d09fe130006dfc65c40ee993d5e6990ba54ea8610deb2a9c3a7d89e1b435a098cc4f762708d815db5691495d1a1a9b7f4da3883a05e51e62601d59f31e33e79dff41b6b2bd89553616e915d79095ded6cfaf7f3554bad2f43bf665d03ac485712ba3a8e8fc94c4ad494d2aa7ddccf33a305f5a5e87b02b6fe46be18be8d1dc14dc1ca9be070a34590f05e2a8a1d306973f00cc72c3915b00d9306915cd8a53dfdf52c306ecf90e951588f46114d0b001de76a5c801ff75e580852e62e588026814e060f98a6323c38b63673869432746d390754437e98e5883fa0b9bef1329b2ed5c2dfb6a84d9832ca319ef5d0dbb716d7e733b2415257f2856c15047615b9646a7647fce3ed06205173d916497ddaca72405b97cd3d2fdabc4f535f3d3b7e9186b15ac14205f01757072ff7c07ae3ef19e07fb1765cb906139682cacf2bf3b9fecd7220e2c666b11e5a10c934167af7ac3422aa67c2b4a2c6e042f18353aed64595a1cf63e94df3d6b0de1378e2be286d63e46dc61ff9701e0fb5f43839e057082fbb42a432f9c53ae13f83d990664aecbbcd4a510d2031efc0d4231f70862abe163deede32e3aced0acf9d7a4af55b5ce70db113cef8dd6c48ab3a515a2d9fae127434285581605a491e81e1bee329eb6b240c7c6a913bec2fc821c3b4d7864421c9ca1c0ce49b9c4448fe9ed3957cc529dffabec251d24e4c3fcaaad40d0884e043de5f6eec825ea210854236760c9fa7812c144a7f225afcfdebc7f126b716e840cd717ff9a46c44fdcdb1050d785828a508b27e390dc56c9c54e9819cfbfab98ef25b1d0078c5f8b3a83ea8ca5b5f5ea2005e21d378d81257e7cd2053cee2c1db57cb2b119cb653fc688669c677e10af3dfcfe88024247f29eea0e89773bcd569f5f0acbdbcd39d7e9563643ea9bf8cadae3ae371ec6009e8506572349c27d8858f33fc1e545c9b00212d46027b6b1ae547137a391ea364467145f159d7ce0d01e0065615071a0712365a0784d8db1ea5b2d2c210ff85516dbd7047e2db0562ce5c741c9feb69f5a4d402a29c842f6a913fe0a5aba45d20c9f5451b3d12f9a7c197f32a469ca79e6e138b726023055d6f65a94c3161d920ff23406415aefbed70262a3839d9ab271f90e183783de00517e01d1025c43244b802bf05ca7179a130d20984d9c41f1e65438e8e3eecd4706f26ce870f8752a145edf1c97d27f0414add6e90ca12c7a0fdb4c6d3bb0f27f26fad38829d052a7ee0b4731b840fe1369ba9ac035d4c9fe416c9c339452ec10ecfe9fc97d43bc1bc45e83a1e4a746d5c933566a5af12976a3033e1214457736758d24713857d13ccccf581a289e763fc98395667aa7c19207955509c54c5d8a26df106126960b7db90dfb5d8339fce3c873b0dfff34ed804b53ead7204b85a3d2fd72346a5c09261e3d988d9b0cb1cee9595a8cadde0bcf115020e7db3973e1bc791fca267034b08ebcc9d8ebb5daa73ba7b2593b8aec341eb5ce9856d4034dd5768eaed0655de0426c0dfd27243ea2610b3f3363abe527bdbeb489e39b8138626c1f099ef58af89f5728730ddfbaa3abff8a02cd79b147cbd5782bf6817ae74b567eb094b5dd9c299ea4503b2dcdd05f51f0dbed177de60ea1efc9c3cb036fdedd9d1d852f9813b9db1154fc5352fbd2f1d7c157b89db909e36298a71dd124413ed785ef186f1bc712411e0efcd12028d023881935b4ee939222db56c4e1691668d41ec45c2c06965ecfd3f5ea0b0d73bfca5ae58e0e85aca906e7b91b45a2153c56404501139ed706a50c82391fd38064b8d5e8acd6868dbd7541f54c06014d49a9d8c263b2fa243f6d1b9499524ec9ac62bf67c84fa8437dc1411814cbd1c5e2d487cdf7bbd62962715ae01dd0bcfca53d362fc728697c109607f77bd7c5ab9f23457d9ca4395c2b9c7da9266fb9adbf6134d3d4d6b8f9a095f87f0d4cee17c20c97d3c4b982d426404df7c18ed1241ea42bc8a27df32f62a48fd6c7ee9ffb3efd33bc9d1f76af9877ec2710e05c6ea89ab061c7b378a352cafc4b38cedafeb2c59acfb6fd9caea536f20dd53d53d3412a2c7dbd14c4010a92bae181740b9f95435101cb5d92af8ccc87e8aa15f3c81c01d0900558756f579a21a60d4cec49d8741b65984dd1af46d0a888c3caeae79112b1def7b99a617760d430ecedcaebc9a381125c9f006bbe56d98cba1c427e1aaed349e349ff1d506686cb0c74737b658a8905d06d3afedb2a9c23fac6db1a06aa99e2bc2ca7d73ff7deaad483a3fbc6efcddf5b7bd8f439f40f81c4ba3eb1b3933caad722b653c04ff8f692f84bf7cee1e8c1ecfcee67fafed218b941721b33c6fa0c79e6928516b8f5c04079ab47743cbab714e3d822584cf3dcaa514f142f954a252ecf3ad0545ffb25777a9a41fa695768d7e8c46fafc2dd1a3c5a5e629f3544e09aacd2d08f663ba4536403b05a512521bdb6a9525fe39a1b1b488a87d1a477228395c2d287c12e1e16b8fde783f8d009e88549ee70d1a522503fcca73c309b8166a1ba01bf1ef6b206cc1ab68c81a1f2db7e4affad2f036f03932e902e0542b4fae0e4a2438f10b0d8b1eb5489d39a223114478f00246d47dff618357307ce21f5cafacd7017c80722b940668a38684a99417dfa7063de99a9e1fa76105e7f15a3ecbd01d754d92d9cfe4d77abeac8fb98f0207ef683a4e6f94a53a756174f16d7ea4f2b7fb3ae707497b5312e6f56d0a3f765b90b2c28b2373566771cb4bca33a3e48f1dd549cfc1649fe5818d7bd142d120c02f4c3869c4ffba8fcac3ec502a04532f881dfed0de370dc1ea0e037624227a2c93484e950c846661f1a8979a85a67a2293641c0c28c91dbc3ec1cea499c2b5e5610e0411db2c5253e4bcdba3f160df7220f7d85746afcdb1542b45977d52a42d35b4d86a559d52f58efbdaffe9329d9205d1a91468d41d010314004399be36b93ec2812e2f94c7838676086b314a05e7d0463252305ef21e0c2894a90c2fe9039bf3942938d491ee2c135477246ebaefed2b64acce2b8fa58e997aec4472e94f215d7f04c27c40b4a8ee5bd3e6ec9f6cb0e35a5b5e45a67c0993bdf7e60beb3c46b8d93101f9719683626a8c3183596551c8acd8f2e17dbe613429f593562ce22fc13f869027f604ec48e365de5d5e09f425515cf9601e80a545db40327e95261ff9ea60f8c7ce57de1052e51caf327e8c21b7bbde3c8a26132177728811d0cc38f883ed0f0b6229a40845df3e6832bfe3d857a1d68ed2eb0a62c24d35160603cf29d624f8c38b8dd06ac27ed5efb5d7fdab7179a43a76c42446a6741b71a9686900415863700387dfecc48d07b65786f21f58c7f58d0b7ebab4ec8d1a14a691fa99baf9fee48fba3a546cee89e6881eff72388b02712b6c9ce74e2bf4e61c270da8103a6b3b0733d6de4ef8db3e78e4be3b16227117298ad192b274715caf7e6ee2c32346ee50b172f19d335a695b4b8d04be9acec393bf8dfa0043817754c86be6ee4a0a74b7290d417698cd1d8ffc32e5a9ed547718d0e062f5c2e6e4badb99dc3ac4fa32f86f04a5a2d814c553496b23168175f910868930a2753b1439cf8b8be678dc9a2c8e8948e236b315e57c0f98447ed143bcd19f3b7006ddba96277bf6e92c877fdd254312fe31d4f40128dd39cff030793f9358cc72a6f629706d87208ead0eec0d8c72d28e437e31205f5feb297888562e7b56e650435872d6c67799cf4601604cbef92b9f61e81eca4013792d677cb74707d5a9658c7bdb57c6070cbb098a847cd5c99415c2e6a6924c45ab016a708190bb4c262646a93483bdded1076d37067d841e7733d062876d2d35bb1411fb16e1f5a5e010785e831b98dede7eea4c98cbd3611c18a8a787385580b78fd9822a94c7452df106fd835543cd0ebee83b61606e7275fe5348a6a11985e9d2dcd3f0d2512b3813ead402a25614171685c6903cc667545cdb1eca219f9697da06beeb824d2494df8d6213a7e616ecf91d94da7f68e1999ff0cd053c28fa9e9eadad142da1536e8fda8ed8052175a38b0fc786b5cbecb22d29b37c5cefe19aecb9cd508b3b35c5db6d82be427fb1eb14243c72d31bd17f19267c6aae404f64e90276fa41db7f13db464454f734c113161b4f50f7aae700f8836a9fa1542a13ca3f5c4098a95d890f837a019b060c3a299307ae3599bf3fdab26e9bddff967ed8b871db04c9d0fc54f71d0379d7e30f1f75b89306305577756a2cd065cfaaff5329cd5679494652d667ad40b9380d1dda2cf0a72df6fe053c204ee5a43a5c52315772da8b5170af729918b24811dfc09177bf9366802fc7f177e9b1e6c892efd4d85c751cad9eb4b12d8631924897018915e6bf66be025a4446472b43aa28427f973365e81a629c20ca9d2aa1cd5d8d70306649a9923951aebbc4a2dd0c6bb34790f16acebf81f94fac4b7c47c2f0a6cae3adb0b4059865973c5233d415911061fefa6d5c5aecf3d1ebb22ec8e4474f729971158c7b65297844afc62e096760d352b85b9c6bd6b1020a1871ad9e317499d2fef33a911ee6d5a6bce2ec0034987f078f632f9120ea2c8ddeb1670bc4f318136b8d3fc0d0720e12c6d995b6ee49c96dd9c305a4c5dad3bed971d22528c6668687744c260dc4c7db0e926ee5d5c9573302360726fdfbae9bcf4515cd552e0be2fe2e24810b4f3e0a73cf6488dee8ca3b754d8e5d4632cf1d3e0c4e137310f198059d5b9961f9d46e004b2b09d4881752cd522b0380bef4dd88090bd9d6cf7705914ff250e87ede78456f552c73f2c08d8b6ba22b0f727b76e644fc0fedddb08b80bbc26709e09cf57b3fba80db435063893637f186f596ac97f48b1fac9ac8de913f24d65d56be83e9e11fb6d2b13bddc3227cadc42cace0073fff4790de21861eec038cfdb9665b14f7b50a2b9748a306c71a8c4b893238650bd7ba0ec887ea5afc1b1533df4b236b14f6d82ab6e4a896616ee8ac5c2f770d5ca2c4a281addb86d73c95c5bc1e01af9a2d8401976c759ac2e13c12a14bf56447c5f1ef276a48bbb25094420ef824717b70b7baecb847747740ac3f0886e59f7ef4ec6b1139116c2679bd91cef6f4907cd8bd9449e7e2f219a8862c9eb9caf82481208be55d07068925f0c237c00bc525c317a90619d2aa25a6a08c7f3c82ab512888f0d25df244596266a93b4597e2ff5010dec14c5a206f849e61c5b7776ee78d7cac8b22020372f6137189761fe322b8febc822e85c5f30406247ce3cc1d2bddb39866e98255149b15497407ebf18d53cd90960f6bf7c510f280cd2afb784d4b33226367d281411ea079c649ec204ba3e3c838f95c5b8df991fc7367559914cdf13f0dcb81bb138139c5c9389f1d95c03c5f38d284f518f8fc2d203a966279c6f597ce7fcf88bb22ee8eaf711decfae17ed9659923ca0265733c6baca628267d33c9154e0a0f97fee31989a732f9c01b1cbe9729ec5196bf3a9b75a1b481200d2f948613f84be69271f2c5b483dc42d4c948bcaa4850a9c232f1c68ff23ad56b991221593edccd57ddc9fd02c2b7a9b7ca42ec0829ddb018c2232bab5d90c0af00561b26f3b7e91fa738b2e6992ce9c8726237292e3b0e1e95bb14a0a0916af8b0826fb6e2b4cc57ca3378d791bd0b9eb79b9e469a47995555fb451f38f6ff72e7f68287bd6708d80e82fcd239a45ede77f4b4f3bc4562dfd9ec99872dfe2ad600eba4663e51cccc55a1f62e38d9234e574452d5abb122c724900838f49c12436d8a8a26e5d4cb30a2b20b263fb28bf289c774aaa8f0d92946e7cd9a1397eba95076a26531ac9eaf3fd1a944eda6e94267d6863669ab468f7a24f15fdcb97120a2f5ecb783bd82dc76236c177065e271d7f239b960ce7e95bfb732d42f813f9a5c7bc7bf6f4c1beddfe052655f4d9d8e766dd0a7fd156132e60d8f31cd0a2d233da85adff65edef38d35826b776aa15ef9c7ccfb9039e22700fce28f46dc0c9a2ec50d849e8abf22ed4f8c57e401b86fa6512491e96fca826002e211d13faab4e52a48086ada511cc8bc731f359b5b7f2db6ade4d65f172f672bcd45a6b0f1819e1a79f672cf6b09e711c342aebf3322f28a0fc27802a2d6d6196d314c462c28c25e742856e82b8d1ceb02dca74ca79568f3a2804dccada363e65f5e15dbf8e26de5d19a2a693e6c97584b70cee179ba170042cd0b71477e64cc468c80419e455dfacd1be0a5455253de01995ac2040fafc9302ea1ce40cf3f4dae17859feae1d6d7a53a4300ae1e2e0d4cb29be99eb6144a13d2aee17e260f905869a8cb6f91d4c492ce82c748b5dc58d7c03d17ad3ad6812cd6dde82718771f7735e8e69ba99c8042b3ca941c9957cf7cbeb1225bd6c85a357408ba1ea93e3c68d12681186be286105ad30e6f96d134acfdfa1c8c26071a85ca87a2fed0abf2f90e195c8be4da412ea4e5683d9575794ef0eaadc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
