<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"443ce286d085b338c833cd1a000494f5ff96bb4f7642504852c69d83880d2dca0cdb8af94da245a04e10b1efea2463f1ad17f5d5e974f94920b1969cfc7852f566dfea64b681e8fe7f9e9c753ad56c22c07db2c78b855b7aa805bb02e25aaa28c5de64ae3b3e2a3cff9e1d49857e16b9c41e56c248f043ed9c8c965276390199380a188733f6758db9fd668aa030c272144a6a0b48a01abc5bd44392ac74fe4c43f11d97836c2be8b3b779c6b38ab085eacc2e093b46243659cb1fe6ac5eadb5def578cf3bdfc02491fbe550b91be36bcfd4d6040da250cf3ecd9bf27fb3b067e0cacc8d79f10029a4b7a74abd8ff831f476dc098e8a96e7358410893a9d3275dca9162f5ca2ad01fbfc47ecd42ea5b9db6f755f8d4170ac416c39e9a2a439fb11043c2940ed1d80b347103f0fde3fae9dcc84d404c86ab7a978a9d77700afb15a50c84fbe67d4d4d69899a670cf0b1dd59a9a406061e81dea729afde39b8e96bf81ca861aa1c195e91701a227bfecef62f8901ca2fe5d62810c39ae209bff4269f7bf1c11ffe9364b6de06d91d9342f4f3425a4b24e14f19dcd18a06086f71a8141f42af2c166ce792a1447fc6bd1eb543fec3d107ccc06e1daa394545e35453ae82feab5e38ee27166351017c0aebeda6b3cafe5bc49d7d5dd8c65c525b9af26e9b39b5c2afaeab9deef9a90310323af0fa042c1516d199ef43be79f5815f7a1bdcb6a321282a48f977cda972a947eefa1cc13cafbd1dd83c85d3cd61e8718b0a30c8db791be59da5f298c24bedc28ac96c84aad8765a2ed3362f534756fdc0ae8b22b8a9b3ed03919471367d948537e5cce5384fa04a62ba90a9cc11b5237a3ac812d3ab0c19f97ddc666ae22fc92a948cd28b32108c9b5544ba08eea5f10370d895bf03c3a85c2d287b761488466f9e4745f2069a0594b4a6a118dc3bb76a74335e9f636725d92d586e5aa62d37f02c71596a413256a32a4ca22978ebeece3052bec71907434eb432cc9fb3f174a606e10805f83fd46b247aecdd3e6ce36d5d8a8a711d9c507a9ba4c46a83080dde5ccbbc32bfa61498d68593f42d6b7fb3b8f729167eee023a66a24421074684114640a21d0aa33b9be862ef31e76c5be1f579442724a61af2fa1386996df6ed17fb09f2a662bf4ee7d3c4c9f89d93281cd87d2e66d052384bc4b00f86aacd227ebc7520b2fc54c7de16adcb57394bda8879ff4fa5df7adb07fa2b2fffe80ce29ecb3228d6e6effa22190157d504fb7839dd3a5ca3a3a1b08dedc7e3e6b95912f21293e0f3175cceed939d705a954856555d1523afd4bc1b50efcee8eff446d31266a7fa42866acc48bf1e0d4ef79c1a569ce6daa086f8a1b1125cef365c937b01ebe3d6f1f9af44a6ff69ee5aebea5c0bd4cbcad2aa0118c134e3bb481877f0f03b30a9900149871a2c7232d18501001172f91929a8755d10abd107fe1691a2c7b82019fa84bca678bffe7f42d72e99b7b203cfaaf8bd54d177e061852ca33ed4c1b1adf596583b570a9914c604746a936b190ddc4ec31f022221d85f96f375695cbb72ff55f7e2621177d5a3e813bec23b22c35c5afceaf85563708d4a4a8139245c562de7897dc521218d27951cb58ccfb82707d10e267a5a4e723953870f8e095ab52116b4ba191b2fcb69c19ee512ca1084a5a886de9607e6bdcffddff94d6d182c35b0813d247be0ad3a6b858d67e6911eeae48f411b8b83ebb2ee4ab0eacfd6f2fdb518a704038774e89ff0bbbf9193cd18a45c3dce3479d32f10a003bf794dd523ddefc9ef6a5a1a603ecabea0bfa79953f0f81ad87083e5f54a17395f3a0d7b14658a57e5661d0220b08a88f99a1dcbde25f25427c4e208d214895a75fdf22d3f33546d17f889ce5a6b51eb7d74d27ffbe39d7c77ec3c7319b224a6eb655e1b76d8515c25f7d58c52317bcaa8dc731e1602668008fca9259b90b697029f90175379748c26d8dee044ce7e28d8178806d58656dee383153a55b320c6c8458393758fd9171f27d5ff3b781010b230727a32eec7ea0878e201d205ae2e58b9b22062453e5f17eddaf2106d0452258dc2f100ed77f486e93ed2ee2f4189f770a7a380b47d404be8a560f05c1a2693a32fb6aa3b1c926c63febf0fb9eae0708826e4e0f68260724a5048cf14ba7d38ce621d4bc758ce1974b17e881d5e396d14e7b56693e0af434a96f43c00b28185b062ef4cc5e705007cc9fd128f6ec5cfbe10f22cb218b7e0873aae61590ba4893319747d2be2e3338b59435746d29c0e4c1ff006474aa455ed095640ee3116d21ea33852641258db55e9a97c2b3d4b34906afb433ff0f9ca2c4c2369eb807877d55fb4579ec027a3a104f242149a1caa6bd793ee0236767c7b4c6780d47cbbd9a31b71c9a9bf69f4df19366c5d8202a3cdcc340a41b8f3974b2770ef9a252ada590bb741bddde70494ad83d88ba9a5c9262a0ea382698585681b37efa1281278a8e6e1645b276184e5ad73950d0e3cd882993f56a978c5efe03143f195b72879c22edc24a7a34461d6109b7134a6d0d37648eda2e038833dcf422bbed2d1cee58b93387fbb2b7bad02059ca1ef250a99c369a44d562da28b56febffe6c5d53945768be3a567afa4d2e630fac366f04e78d4f12272ac84fed0a147a8a5df298d6e645ed82d696fb48bd9612b4970496d3cf57f52de97d113453ad27870d3d352dd96e98c8812fe8963ff07347c566672343627e6df7136c5df5ac63e226f4b9f4a1e897dee27fcbf183bbbe4c6a5042534805edbcfa525032fe138674d95f10cdc4d15e738d2b3a2ffb1dcfb134ad4c1bd37b2fe73ade490597f3af49e698dc02df35ed91583a0472fb3a9cc540538ab96350b277bfb0ddf4df04bbbeac598e330f396718d2991e80b47ce3a98bd6bf87bc96e3d4afb635887521b9f0b25fb16dcd33c610f42a455412c60ecc0e8a183573d4ee7eca772d1bdab90754f6229dfcf9f06123e613dabdd2849e4d3c278f0be8bf119791b8a0b4f41a2dc657ed29b8ced3fd852e1a45e4eb60aab9aec37d87f752366ad93e48a3bda8a98d5bd19c9ae57ebea04247b86e32a29bbe35769a9f7df7fe085573168c016323a977dc879abc4ad0aa06100118aea14880146e299eda88bf02ee0e756cc363f146354e98a3fadf07409a3e97e3bbd2c40efe0af9a9cf20a4595671ca12b53e92c631996fc9712596eb8a71b0285f838b6dfb0a4fa04ce0437dab1f6bb43a97df1f0436de8c38348b8bd85c6d6af3a1d43e47f7703b509fd75104ff9b413000920228817e4dbb7614401beeaa383cf522e4d8e99494424471529e15368c7e1ba9f83050123bf9b6f6c1658701feca9e0cc6a80d8288761b7e25f51aac152e9e7aaf1064b01765823844c96150a5d8e4e954581844f21b0ac4b058f88d6abb36b719fa031018d82d9881c1a729b844ddd7da60b056d03b1abb8df124f4166fd3ed1d12d2f831bfef14f4c97078fba56ddc51bdbf16122ecfb82c3dae9ad1002cdb0ff015744f3406ed63a0221666e98cb1890385057b5251fcfe9038815694948f174843d0488be60bbad29111e5d2e50e5fc8b08d607db238106ff7f4012b0c332332bad2678ec9d6d8d6e8d239d1325063b91e4d44ab4ff5bbc9ce6cd8a1ae69fd07711a9bfc9beb55faf910b6ef672b2d03b8fe0ae6c21e9ad00886a8f158ebf382167b748be2fb97e161ed63a659ff12c179beb061fa165e9c375ccc72785db05067ce575801192a32d7d46b1d4e908b66afeb73870dbdc06e037f34c2ddf9dab2e42d46ee45fde9c92cd3791eaf2fe2e4e3e32f2cf48e35227acccef58a3a5cd6c1b3851ed95f6d25c86146c44ceb009d73cd70883c1249dfcb2cd271c365afbd0f427fefc73b89a72d0ded58f8e49c3509c048a96db86ef894b97d104d865dd42da8e02cac548075c7d1ae694bdc69a34fe9682f0058f05b4e7a185c9170a7d4c86a942af7cab8b630bb0dbf7b46dffd326a96b620436fed0a768b0cb822202de17573d8be714ab116837eb7600726c2e9ace2252dd188c7e38bd64fa6117d04a91d590d428070d3046546b547a22b7fe9cd1fee904e0eb9ba2d47a5b7f9156785618d23f33bd2db55353a833c9388b5800147fcf63eb092c7e212ed57b02c7487f3bcea33019f5012de4b0fd8f273a54f20a67b1b1efa2425c98252636124a1383d62a09022fc931ccf7dc674c0237b0a468204879ff2d68c91458c79fad7ee6644b706a99884b6a945c4abc7e3cceffd4cc61b87acc722a9083b9ff80712d7253b84b9c6ce4e6d0b785cabf2af5b878c1a8877eae6c735c5d1963a22cb4f926741a02dfd0d1b107c9b9046a3ad904a2363a37f212eb104417d718a2f761fabc12f9c9f87f34c24bb2f019c8cf42023bfe4c1ff48169a206f67bfd4b1abcdeb0f5581c5f8737926d4b18ab381b9c9ec29828e7fe0ef1f39d01d685ea8aa27d82b68fc16fdfa6a9de2acde0cbe40062b9522e28ff966f615a7996d96cede05962c921c8bda97d937b5eee8f0ff985f0ad189d0467684cfce98be972f85c100a5fd328feba3379f1691706c80133a6532f1c84917a42c90060cf327a0f99532a099e0a0bd67d46bc52ae062485f557286cfbcd8100d2554a22b02cb59f755cc08ab32f4a0e8cb468842d733961a6a002c8c06bb3678d96bc812d274ff7c461f7f38b1ab79c80daad2bf0f64b9b5f0d0f9b819ad3ec5e2d10942b16b7e07d71ebd83aa30985f0d3069fb00cd03272c77234cfa975034e0df130aed6a6a159c6ddc2dd40680e589c05bff391b9e2ea05892604737e1ca057751835814c1168b188308d49b0a23e5a11a339fcd2f016c8139c1b9d93c291000aa74c44055c321e15a8c0d1994669156dc6d9379cb9f2d55b35eacd19e9e7b70055b50a5c7f8062faea478ad4615b2c9ddc258933b971123a82f65645d5d3f19a654ad3750f23b7b0b8f863c2d488835da9fd7e4cd654371241188d4d7fdddd164f4fe77164d74f85144e7e906c7112d26bd3c71a14a0fd33d7fafe9a9d255225f57cc0130d1a8efb2a4ac42dfb1248b5abdf890aa4cee9b0acc431740f505b4cda864c54088820b3c9a304a9b1a2ccef5c0257bd0b57fb7b48376edc63b42d72cdb65e0efa4e8b801a418e0d9e8f96715084550a67fd0d62394dd19b99e81789a588b32601f02a1dbef55216742101d2fdeb2e8f1852e40eb92f0ab1b2ee812483818a90b8306184463ba16dec6f5df70e709aad51b595a8eedf160d463bd4775c97678edf2963dc07ea55c4f9597eb191554ee93f9538e7669a9e5ad9eec5d73a8170463f011731c0988c2d91ab3fc53ab67203900e2ff040c84de6d8ec3476bf9d7eb84bc6358209dfe5995c92e3b1722ef5726d9fff31ffe444a184e03a4689389cd2afc8dd16df6574e83b0d097e408c474ab151a07a515eeec77a9417127a2aca8592359acea1e47ccf723629ae4efe6c68f089bbb286eca47e2ee0d5231e80a2d10c4b695545aeef73ef51bba79c8379e6bc4e9244156a19b7439328f27cdba86613b76e91aa15d280d756a708ff91aef41a58a091a75996254f80aa61fd41f28081afbb9eb9a5ec23924f1332c81245e8c08baa14360989d94f94ca92ae59f580f555c0d3f65dc2993c2ad8f71b472dccbc28c478f390b147f339711c165c71ca8cb084615035653b476537b3e3cadf825ae387c975ec520374965c4407f1b558f273590bcab8db5bdbb849246deccff0a4fed287322745430c6e5796d3d5a1b91d9e3feb118d56ce861e22d06e5ac443e67d40478176b14428b5788bce1e2bc9b3bc5daaec04d67bff4ba0ba2ae05cb5885f90a490ad822b2ebe3e65446786bf773b01285278d137acdc2b3f9c1fb0d6bf421fab46e439a1d2683d88cc27873feb5b0a13f18445ff615c3a5b181b31a3e359ccbf1fa84b826b097805bab45628bcab592eafdfbe5de3b9762bc1cb9b138d68384cb770dd06d796b7b920c18e3faed4f9bb71980446e5eed454c96d7819ffb43f13c8a30bced9adedb6560c51d24e281d595a5deb48542f74ddfd9eed08ea767bdb4d6ab547b54550c0e7f921f213fd589ad8b3dd1f5f9e9eeec3bb5bf50b99485c6de20aa2d20750b7f3169d8b56aecc25dbcc17cd64fea43a94c71d90e43bd2ce8ecbeb63f698787711679c9b893f3d3b5033476de7cd0992b6287519ba4e56264b167911dad83deef76e66c4ca249b1b7a9b68e3ac900c90081545c858a54cbec2e99e822583ec259c1ff19b3fa5f78755e76f31ac720d46c86fd22b26c0c605c91cee99a1c28a2ffe6cf25e64e311ed48a1d97c1b969c6b8dd2e084b3b69a39c9c039f386693e583b88ab8d37b2211aa1ca727aa0c9fd4d4e5c97125f53464b2974d2bea05c11a9e577c58e23fac45c4f66c0bf18f9cf491e6e7e5f6b1cdb2ca8a3d0a7b7008b1388f2e73db8c469fcdaf7e38a78cdcbd51aed42ba6207cc8467821cd145b7fa3f8cef1d167b1d2e507eb1814edd4dd704c9b718a13fab6ffa004e80d35802b98856d98c7da3894e1e73bc0ac39088718b11bb74ce8c8b29cbc7081f82aeb0574cadaad805f75e0658c202755d81f6a99d8e06fde0dab37c80ef5124beb6af522c92f72349cf7e44c33fe3568f949213e5198ef1f10d20a3035aaf903638d2ed866977351ad9d887fb716fe95eb40dfd08188500209f303e9d441b1aa97bcf7dab2be15aa0ed7ee31865f834240f1b97f2be484248ff62de37bc7f703ecb68fd6ec8d1bde3a0cd47960676c18f557259e9dbeb3947cfe7491df587e15d74502600cfdf16a6b59d4fc513cf9504a10840e6f7d67a806e0c9d34e980053e13f3bdf6df682cfec4e02993e685834e8d7c1d078c389e4ae111df2ed773817cf7888e08b8b677e8489559a742e8bef2e1934afad57bae397ba08cc6ef7f9de6172b1b7ba88e9e523e3d4b8567409b1dd4faf3a9bc247714ac85b68b0e02a7d0827f33f908e8ad9ec53b809d9d805dd662a0bbaa710ab03fb226c928bcfdd672ebc80d3422e8408385223628302ae26f669fa8a194099c43c33c76f76ac888c5ff9887a05ab87f602c69c828e5e176f370cd4d4cf8cadc760f69fbf9018836049ed38e43df210d28ec10ecd0e3a288e16058916b336ac364a25174f3edccf667be36edfe0e827d3bf27735a53f4ccea60c8ef7e28a74f003d355bbd21ddc923df80a5ebc09185053561220a54121a9dd04d8702f80e3ff4f7563dca3c28cc3937a59e6e3684e4216618823b491b4c04fa7cddc1b1ed85a1486cd47dbabff51b4adcec6bcb0cc41448c5d59bcfac822aabeb8b797c9dc5e1285ff93c1430073b92b4c248551c620d7299438ddbde58354830d6b722b6ebd0b2e0a69f0e2d2492728df6a4e48799bc6818654577d06af095326aeee4310141139382516ea3a313b8fc6f812a2325d0294d8504992ff404953b10ca6847ed862ebadd34b9132ca69eafb5cee39b578fb00f9e84fc8aa5b96437adc54aa657abe724d91c9a8daec3f6c11c5aa65ee6937bff5552df301fac500ec2b08cb2b9f7d6d75ca8d7a92a7f8eb0dd0eca5bcdbb9b46fa5076a8a411b0a72393ecca2b6f3340cc1fb903824155257bb1d3525a58f03f9b9ffd74fbce787e7aec5864b36a34d204fefb0a5803a4aa13cbac8f61569d52da7dd82d30e246154890e48da3359820891baedfe603056a8d6db7a0bafa600b97338a4b1c7d99262f5a7f45ebf5ab5ec0fef077f9dd1484a3733ba2fb87c37cbe7b3ad44f42c7ca300f5e5f7549e3064f41eac7fa63526b70de5fdb6d3a33cf08216c851f6105c5a45d885e2ce9cc22ed31c8f4958ca7d0f3398f8afcc4710e3f11931956374793710c864bce6a530e392ba436d982c280f99a5d13f6c417cc1e7d17b3e826b313e9ad4c3b24985a28a9c52c2c5a28eec3c4ed1d9217cfbc22a7566ddfb8fd64215691b6ac49fe1b0a5a0e0b44a74fea1f856e0e685a61009498caefc8c856768e3037dc02f5b36716c7a5c3fc292e1a5e107ba5a7fbf897a5939b3d54e7f923c4aee083ccfad0bcafd5b29a00b6aeccd96992b0a650cc031c11ab954ac85146c654e46376777fae69f400aea8895a8a2f26bd4d0a16bd1609a6278885ce565b9b2bf2a24ba72f55c7150569f93faeaf761fd296f3fcbb0ecd5d98eff4e1b5d2c6dbe68b7c17149faf4161a010017b3cd9c099b44bcde6ecee4467842ec61ab8b795777dd109556d34e1fe2008c40a3d9f7f36ff9d46c726dfe991a0f7fdbd7f8bb342a1d5a0d1e50df3ce25e9868c82336555a31ffd95f9e4f24e830df1dd6f5d4a5c1a06c96a12195521a3cfd9378293b3e43cbd07985103196c7fc55a1955465c835663f22255fcd7365ab7a2ba70abe74c32f8ed57f312d912724384404f1534b3c4decd29c28dbe38cc4fd697c0284daab1bfbc02802afd15828b7756c0e662de07da449b1fde4442a803bde55d82e000743a983b63c06dab500965e9e2e8e525b8645cbc8ba1722427d28764260198ea648e2cbb9b37d444516503b1559d3356d6b3b3fbde7c2dfb82dab6f17bdfafac30e4c8e300565c686c652a808cc5900246a85c7d1dae0d33fa74257b4439f378557728d5dc9e127d35e751bd42ad64c848e63f4f48372b338ed42ccfdfcdfe39dfcf1f237271d1f09f47d2eeac92c77673cb9e55874cae0c1d3e4474aec0815f507f33100424cb308294a16cbebfd605afdeaf6173c69c7ef81321efac4ee7dcb119fa423295f0293bffedca7469e92eacfe1bd2d165db2d9636d0071e25076f6952e131c25f9596a9315091714b06f8940ddc0a4e331036781ab0ac5d4309565c5a3200120344b2a74cf17f5ad4f5422896a61304be04d4802a68de950ec69175bd6f568a4753e0a5209d8800fbc692794ab8f251a98de714c687f35d7412b86f83a85e269fcace762a7c603e756957ff8e293e83883d55412e9b3caaa5c41618b6b871fef5c68056ff819dc1de9f1a62349321eb41e6086af22ade6eb1f6f80f2de3d4972657aa19a4724f45dd3d873a695fe11853758a58b6b79906ca0249594d5630fd38e572198010d0d82f2cc72b001ebc53bc582fa54265537d5b2fa2c6d1380d0442f7c169fea2d65d6d32bd25328f9d1596c1d08bccd44418fe0ce5afe10cd6488f0d4496c04ad5e3330bc39765be8e50786f2ecd5955e0d572ed27bd976dda478f32f3c0a34c05e7cbd06e1dc96c1fae3147eb0667bf721fb1d4695a43664ecb6fe86669427751a434210ea827b1eb95734c642d460f2702f279dd38603ae1233ab8f8a69b617e30a8c349c2dd6fbcc49eaa23814aa07f888309cf601f6afb88e400e9f01678eaca77c2ca158cef14436266a6f77f34455872fa25beefdf2a26d792fc089bed22bd65453474ca073e683b7ffdb2e0568fd229d9d51e6de7afecf81ad64f00479566fd39d9d1ee83b1e38ca85639c7d44445020c873386365c4883ccd7f54afc8c62431baba68df7849e8aa914e514b498e098489b7875c00bd634cbd3d2277877b60f532e50bc100b3b78359fcfd5a2be1efdf236c09199b0e27d34276e42467bdf21e602f255b6cd3288350271d8296809f7c8b7a61a4d718ff7006d7ab6aa9c1898cd37dbbe8d5046e253bb4c079b3f96750ce9986ef8afd32f68457b6f1ef4fa734773092992f8b7ebe662548cf5c66a5e5efa4b0a851d3491e5cb461ffd0e3eaded04706da41c24cff5a95493bfa5264b395fc059ab4ba834cdf3172e6155d08593cf9a5b893f90d2e1919228efb543c96fe56b6e564b9376ad2f9cf3d8c09ab5418285be3ae8ed757f6683708c8c521a4e9186ec412b4161bc170ba8e922e26b5e928f9ecf07bc23032f5074325bbea2e925d0e143287f62cf45d20636e5f797f842909ae5795f5749a3585144b8324be196707ff74dda9a5b98c1a57f1431b3117ec9c5214da909b7eeeac14e8b50e41f5a4ecdba73a611e88c37f5b7954d671c0c21c1094a66d9e54969d8aeec5418789e536a5abaec85a21c177133dd6b5cfdd457b462d9d4f14578a1f5a49a193ab50f733abaeeb73c6c1b3782e21d6083fc054a225ea059df60cf8929465e209033ae7bda5143bc0fd628f213087b1c4a5cfcdcb291cf9898d4465d36d516311c3ea2b861087bddfeff897074508542a44886e16d8219a613a9f927edbd7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
