<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e849f12c0961a348154766f4ccec2adaae04706e7dcd87acda28a16d1753a9adce82f44908c3c2e09a73ddcfd5e25575d7df452f29b682c82e881a284698fc2f85ba85a9efaa179b520b8e4ec4e3b7582093fe944e15c9ad805af6947fd9cacaa0a969bc44ebe0d2569425c23853f28281eea3fb434b1a7491f43ef6597de5c6af9ae556cd5b242a2390161be52877b9c12c2ba6ee61d7ae2644c429dc2c5093591ca60f08d55bf34c19666c7fa054273cc3652a8f202af3464b32a35413439fb94b23215e3d44c46aaf2583c6380003d402f8a9c43498c578b554ac8366d01b9f63d45591bdc84ab1bfa812a3276dd2c03aaa9015aa3a7f01821b221d6e327e7b866e99ba199c4849450457ab1b702e80f86b1273d7d9f0e6c8d5c349b2f9b91a3f056459cf33d0728398b947e40a0e55244c38eced882840e8fefffb17f95f2f549c2e6971a81a5557e6e693b7279b0799743b7921035f07a101c158c4a3d048f71fdeb4c9624d70e3550497689fd54c49170afe203c66c5cedda7d42c65a1f598a2ca5fe15427552cd4e9185629458a687d686e416051a3d32db2198ac16efe5ba0fd3a0a445879c4d65f03d87310d0da4597ef03dc2e73618a3e0cf3dc1f3856c62a0e72a0ee7b8a61eb4196675fb57efcd26b8bc80cab3a630184edb1e81f3b986ddbf861b71d20fd08eb37fd1a5a701b3058868f452d9e859b8234950c72d29541321b6caa44dd5f45b3eb294fde2e72574e43cddcf599330ca21abbfffdaf6526f224139f3657f9d8c55e7981bd486fa8fb10b087d7ba2352cbb1e09fc84cf1d7345ffe88af1a7f1aba1b0456819f03cc65a08724f1e8105efaa3637f8b693852e6f3244f741835faf35991bbf3a4b94845f3c3e8b387c5fdc3410db978a7473cf96e3c77c6fd8b7ddffd78d2cff025c665ca3280b86a9670d8681c56826647ebf651239f8ada01c2b54719a212ceffd00bb8790206983ca714cadeed885f376ec04c2623b61d8f89a4bf3639dc233f827078519d8a51a4ec3f28411f14eb9d9b1efb960c7a815c23bd12ea18dfa47f1f2b98039cd79280f4ad3a28ff909cf2b82c0ed95e54dd1527db4a1bd2bcbee5ff25004e0a13b33db561c59ed4fae74c0aa624d54fcec704f219dd16d0733652327d99a7f941536b716c624517afc6c89e2fed19f7eadf22e34f80f175fe3be0d20df914f6577bc880d356ef68144ad7eb3e529b9c4290b9e4165a3b236722129960edbc0bc0aca5c0726c46e683804b1c6563d8c9e642e8afa2b0deddffb81cd19628ed32cb016090d6da934d2dd126ec8335fbfa2b649924cb0ea22a40dbae82706fe2f1e029e445b31af0316227dbc409fe015b433093529a75155ab2458ceb3577571e8293183933f748b0a40aaf9a56877102ecd8f1692be9103c38adc33e45f03ca8d23a03325bf9baa6c702f0a480b2351a5f4b0d0d971d742f8d5742327728b6bc85d333f6a1473eca68ca155c79a8e89eca82079b239e259d316a3b5e627888656f56a51d1a44b4fab71385eb7fca24fe0a8d7a0fbeb8457f9553c3233314309c670eb74a56d80908d48718be007bdedd565a115c4246f97c3c8e089f441ba9c338b70727bfbff94c4218bc3fe0afe16c3a5a1da2700f617e1e2fa679e18cc2c71b1bfba56814be608826d73441e91d5f16f382a5242ded520121060b33245c4f7302236642f2438479b14389fd04dc7c722f70250a30010a03de1cc670d9d338ede200e0472c4a673f07d0c006440535388c5e65b0ed20b509062206406d04e967d75dd87858022f0bdd0952c3c975870544f730c22383c91d26fa0e6ac786472144e48ff091b5367c507f4640498a7471739bf307c6efbc992915a99d5f81f9a6590df2f404ede94a5760247d6ee613b4d229474de385fb30e423a874f52929b85c0fb1160a0a83688ee0f0df68b94bf80ee18995b4edf1cbc32e2dc642f600ebb7d53cda6ee4c43a9f38ab387e186cd1575e34ed59864853e6be0951e0d81a1b06823c113c5ceaa1cef29570f6b2763480221756d152fd3286eb6d736996252a5717c5a549944f099a7fd1e4215af2bfd53f9f86082d63463aab583ef1cd5bae2d37c6803962e53f03f1a8a37adab95c4071d3b47f163fae4c2cb3cb910798fef76a57bcd85702fc7eaabf2ad6fd3f2db5adf1628d197b9b3aeea333403411ee7ab0d2232e49bb6f8515473003fd48d45b6f00b63b6370ed3a42856a04be2ce7da879e8601a4408d8cc1d71ca64517110d17d0d0ad1c40710540f0e06ce53ff800c6f00947a048fbd081ad929c65b5b0dce765e785de5cc488c3107ee14d3f7571e30f0ebc0360ee30b95bcbb570f34575f354228af3143f007980cb08ec3849c508eb143f477717336dd7aa0526247b9aac5f22e918bc8c1ce4d58ed3d97c87b5d3346d8a910e29dc63e8576dd5cf2574b46286b43a1ada07e94aaabe8633bcea36a0fb02562e735b55b2b516265ffe631a0174aea10f81901ef00c1716b124870e88171dd2a009f8872c0551c1ac94e1d3307aea9cae920036cf948658b545abd20cfc06a15ed849d5a3bffda722b244b6cc9190278a6a915915da6bfb108e261e903842f9cf7c0ea92e4e4efea2c884547d1ea765759e1f69c834d090b9be5d658a8958bbc75257c51a4ec99f9559f71dd61d2415ce99a4018362f9fae2191439fa8c08a7e5edfe8463b1a3fcdbf89898558f3994fdda28cd8b803a404386e99a11f6ce2f6a089297fd14f05854e181d6c71650a61214f30d2259d4fd2825062480e6ed865450399183cf206dcd5e82e826f90e9072f14649f94854a57e92a8b4f56e3e1deee38046e7479204cb3274574734e97fd1c7bddc6539c57286779585a9791b76267ccefca7a36a35da9be2777b7185ce7f0e8beef63fdcfbbaebf84838ad30ca0c8e40afb2a445a23877d955c5f6b4b12d7b71b0345c47cf7fe0b08a687d82d4e8882fffdde2047dc2c8f0778d083bf787e87984bfb4becb81c52757ce30ed0e3d12df58ec4a363648f7e22d89dab52bbd310f8b0c9c89a613f93440e62c81279cfad28a353987f54574e478b213d926e249e7aab3d08f8c1ba07b48043ed8930ad51aa60f1dcda17c8257448adf71f85f2933ab554e9bb9e7cd27c0e4b3fa9c41abcad856f47583b6b80d830c997445bcb9baa4a961aa6b3b338e874200e05f63b65da9c00fc7cbab73bd6fcb2a50123a9d4e2f86ed8960e60e505d82a8bd3b2546a55240a658314c6b171b306bd2eaf8a1c68a9ec74f57e7414a94cb900c2f13d04b80653fabca484a1ebb35b716959f1fa1e9851470680dc622b948ea5e38fc8635663f582f082a9eba623d80c8712279c05a1e442d1d24d6cf2966097959203145d67f5e9752f808a665aa4f0dd0f7934186f322dc9b7f1d95dff3f620b8ffcb782712ee8828d483cfada069844df977ecb51272238994a6f9cdf5e3a691705b83743af2d415aa613368ee6d0a199e08012dff4f2a8f506f61e8e807054965ad5a43c3c3295ae7905a6d4fb8c169a80dee7eca847e7d9550641fe072332bf02b938826360200462f4956d12882f8ba0f584824f46caf52f57cf55297e252754919f8f529e438590486e31afd1d37b6e5cfce5f98530fa1a58ec3148ff6b9253d97bffc0d88e4a95795570051b6192dc2a01e58410aa4348fb34d188e28969052e2289cf56dd123e7f534e7a518474a5ba1eb0a1891387cb97e8f131169a85a32c3d849df4f10873670d55ea1da4366e26843e296973dacd015093cad9f21c54185b139639968b6a07e9741cf46ee6638c6f3c064c656ca1411161bbb39112149400c53caa1386cb2cf7fbc45918243597b44c7aaaa9c8676821b431baf4e051702232c254ace60cb4e0845a94d3bbedf24506bedacd6efb3f75f60c70cf1b0c04e0e99675c60d8f28500382cabd4c1eca217d80e5c74ef35d8ff28cf45190e8b53686a57e6a1699c81f0dcfa3b9b2c6014d0807431e496f1ec15dd3d2b65fb7c2a3768322ffdf7a80c5940d42d5baaf61c4a6ac2595f2e156eb2f78a6231eb4244e1428ff6286b27a152689dee9915f2800ab37e1c95918fb06f68fab17ef90801697639d7d0f0ea8c5f193e961802d112eed734cbdb3a928f2748b38a67b9576edcc1ea0d9da449b854e2fc637b98cc45331608c8d9f5491f61ab4ea6d9493e11fbaa7974a172f6350af3e03ae540347e745935359f5d68ea10df668ef5db9499981621d8af2e54b2af48479d36c5692be0bd8fbeab2dab4c9e3f26e13238b4d6b3bc5820fc248ad004fc758e26641e91b4852ead471f52d973a255d627ea614cd45a0a07ef3c1e56e81bcf1c714ea0f7f836db00ffe32dbb04e747293416cf3a550a265766e35fccde49dd9588757212d40058604ce66346cfa3272259ec310da0c5ec495cc83e40c43fec652586123c42a92e81354beed638d011218ff7c119a443bdd83ecdb9c6ff36802e96d3dd4c8fffe0483ced87f49569b27e851af68412680f94bda8d09eb48845fc49023ae5a2fa70b1b0b744833066dae8b7ac57168ca0731938e8edf390206efad42cb64b524dc844155914a15e8c4afc633ce4123e6a59fd4347a00e112b81d173dee5a1cd6c4f1b16c692e13b82cd4321d8adcc8ebe0e708a8d4f099d63abebdf31b2c24660b95a65cc5c1272fb69d360917a614065543a9b13c27d939126eba1d01d235f81ca944575d815fb1cb9952c248d3b0819f3d3f1ba453918c8bfd429afde676c1d20af199e2d09daf4390a3ebfa808ae3ee44314faf51bfabb540a276c1b19b431821a521177af84e3ad087fa8fbc5f84e6e15ddd81bc024ed9173b8cefe1fc9c9f8bd160545ea18766987949a096747aa43045c5b38ea98ae38bc700bb36bda62ed23b3708dc4688f9467b728259b36c96321a1203df061d47b437abd827d3d3256ec8fb41626282d400a03e1cf932f409fd12e463d904e024349af510e301fe0819518d9750f45a7e0930e50ad6ceba0ffbeae0d41cc3da9e01f6278f13c7041711f8443901645ea8ac58d9e2b6290a4ddc1e4ac540ae269ef66dcb6281fa4de83da90357b68055590d3b183f4bb779625c966ab889ee8f1b2d60186e16d2768b3ef90a7a3dcd2363233e63c565b43cecfaff2b8e2c9261be82c607ffc494da3af0e1a835c76fcde040106510891252250944d6b696d2f8a86cf551e3da538d140bff4c221d51770dcd5b0d53455338a7b802ce8bbf24c4588f73976f698d87abbf1c47549f8c67e66700d747fa9c549c0d02e55f2e800e6f59ad4147457f5936fd0b8b2b28af2a467b911a6a4f95a08f588abd08fdc2d942ab5d5267e3124e9f40ab32fdaec25cbab5bb441627f7999bbbe1908c4203019082f5f43072a90a718bdb4197f025a0b36da61cfe9b3e605f425d04707e701e5727c929244f807b2140e2c7d4bed6eaeb21e3176a74876f9bd41d941561b069167488df1a085bf8268d07c23d06a25e326d3b6237925ea6ea1b8b1edc7704733696c88de9915d4850bddd9b59fe0e88fc27e02d1de418d1af4b65292f62d868806b12cb93cbc1e42b9cef7f22e5159cd13736309a1a40b785c359db996da4e9552225c1ae13372d70b9dbfe9ec42139fbd80b1008316f838d8b558125d3697553af094c14515d50f79673634890901e1b0ca523f608d0b3ac9cd61247e85d53b5c27d33a57481536eb16925ed0f64d2cbc0bd580b6afe4f1cbd2a74be5536af8c6be473a1b7439ea8e7adb237341e6cdf2da80e9ca6dddbc770ddd68aa723090613239deaaca7cccfb0e9b92673a4cb06281436b160f2a2cf0ea9ada03ac0408c71d738abf7a6b91c6878a5ae57c2df53688b03298e3cc56f5073a67caf39dbb52d6202a084033c349eff023b889982c74cf03b5257db82d98c7056add4d952c1c918d4b6e1a558174eb8444bd4457f42945349f41399cb92b26dd6db0dbc6e5e06780829c2c4a1f8fa09b97070cfa9341225b1f7d73c9ad1ad8ba5f8f476db672ffbdb0ea4442029f22093062fc41a88f94b67e3bbcda6fa9c1faaf77cd1795601d89a04e8bd34630e65f49ec22ae1bc984934660e8e3c876a90fd92083a48f687ae471eef61ac1b08ca3a412f494703b9f446c536aac68b530654639317bac815b8f6c72473a3e0dce3770c25bc3a7419988a3964dfdba67a103781723817058900ec2f83a3810f2c90ce3af4135ea5ac1ed57660b78aa2a2ce8e403c8165393bf8d5a0d02928b896e402e500b9f76409fb04d970f801a504cdd9a4c6441e99bd208d41a7b9e60b11a2317c527a29c78e7897627e28e5f090f6e9cfcd47ee1787ed36b2564d774bfb7cb3d710c16c31ffe1805b8477bb349d064141a5eb5debb5e8311db319acd1e182a20fca1bff8ef812be6478948facbf5a7542ffc47455d901ea9a48a7f60729dbc862cd7d2934007cf415463e0662b627ba245cfa0fa44dab117a80370850d8c8932629e2173c9c7fad02a05aef6e112320868e5a02a4f2f95bbbe031381e44dac4db92d99d5bb4123571440cc7d966e56dccbfe1bd5c0b42c12fc3b56c3ec38ab2f26741304c3f00cf577d75018ec405f30a0e143819b93de3facd57fc78d1e209721b013855a29054f85cc78c097a1e1d3c3f3663d6b5af001360be8a998ed791c4bc1a51a297a3a47c4a1ca99f4a0fd1d862e554295d31214ba24047a4baccef4b20658a532026a2797633f83cf35a08b8c5633842a55f9e8163e5d0e273451de307fe596f3928412c42ee88c558e0fc19cc57ab7dce3592a37f0c8d4883d3f4bb99c9aac83964a8953368038e547b2ddfd7b12edad522eda2e90a7e68545c488022b0df3b5c191c0c79af4387e534284757351b5ad8ef0356769c63e5e655dbc0b9867ff59e14ea0253fe2266d386b33ceef02c58cbc4853b183f6f7d8b6d739da0ca204757d106e2c606f0695f6df6e5e2773f29f27f99fff87f326ce471c0cdb209fe807f00e0c803dfd5e2d867740a470897e7f36373bfbc8982fab158c26aecefdff64b292b9c5a80b639a43b615e65cbbb2c6aaa1f38b884f1f9ee1dc7ec18a212bd3891101602aa422999035caf6521ddacf6365a6eb246efacdb51c6119ed09e922c33edd29d3e677a0317c5b8f12b742b6c5fa32bebdc1a2c69669c77ff0d1058a63260d89df671a92a31ce191ceaba5667ecc89d8fb2809675a7eb4f15f2feceb0a773f5b30acb2cbc8e2ffc6f6e061060f39449d05c1504285dbd762ae46b31a1635589ef7c1a4dbdb360fca97d5527d0cd0b4fbfa3e409fa9c77fbf8d161fd76ecf2d5292becf139fcd168d316f0e1fc04c55af12e93bff564f3f425edcec9d21efb6dbaffb7bf59938dfee796faeb5c8ecb5e655ac730827acda8f0d55cad33cbd708820361d1310b62e7c6763b1e03ba2ad02807167b0a47a970c7cf6198e90a7958fb9c28c23fa8a00efb875ddd61bed3c193ca8ef91b8c92e81ec7584906d0ce038c032527e1070603a3a89c719728140968a662f587e80ff92896e2df2920e18c2b98f8315e558d165c9048b63758231bb094027bbf86e9afd695658ca2523f7cb85f1c0445f18982848f5995f2c644677bda65c6cc4533eaf9bfca7d0fea93355ae4692b304bb43b5686affe637f60857cb624bdd55988dfd86d067558e67f845550c768e7d8dfbf3e1ab4ecf400748f2c74134dbf163ba75558511254cb09529c3523949f50095572c932634d1039c66907f1de8ec8db99139e2efcafa1b1a697543ce4a1aaf90f278966e0df9422165da203cc9eb0f043ae7a743dfefad59071d62335d5ccd9be55ec508b876cac9c29d67958843b27e0b27c0d78480305f607cb1b4fad35d279a14317f89e5d85510be5c0b78ae0c248ddceaca3d9ae60b75af0906763572deb18f57be40b27c59c280a6cafcbe8af71cae64c24ad30c100d62e494cde8efebd096bdbc5bd25848703e4ea71fe477df1cb69d28639304943ad3d25207ddf3bf93abd5e0a0d087521f36b3d27567eb7b5214b7775fa60886b56ea746ab08fb3e8d60abc3fd389df31a82a9a27f6afeaca2cfdd4ee9f4e39578983a6864f6aaa4498bd4ca1c869ebfd6dbee1f216ff7df73f4676026587d0ab1536812e20bca22312a5dd6634f1806c8684507853da032198b13633592724eac11ffe6325a632d253ec96338c3f533ca94049ddf559109feafcfccf9b0ea3e0272424e998428627682e9b02e6aeedcf162309be33128ad45bdf6cfc3ccb82ceea9e5643a151dc715e6099e05c65d33be94232c0aee6544e7e758f092659a734dcaefeff1b144d9fe4c261d46ae89c748515a837df08283281834e35ce15b8a602f9436e9e6ab34b121b4e4d0ea80a645e963cf5d53168d1b100cc3ec5a4e24d8d3b92342202c92eff64002ea85bbf4c658815f8cf86b1d1ea55bef64708624defbbf2fccbdc84c33110fbd01d7f07103fd0395544042e91b890d35017258b568bedf9fc7af13de1920f32c287f5b6988e0eed93d3a13d70ced1b4cd79cd7c71e2071cd5ae9aa97665b3c62b15cad781c12da8ece5731e2d55a5ada4032b6490ae512593e7eb570654f2d5084fa24d791e14230bc5207e2bd816a8fd9993ec611e94e7882efe53234f30208be8d84c712b8de7a4bde5647560e9d9442b45fce652920a3ce6f2b83e60071f710e5f3a1039b8a95e5c1a64ca83e1e95c917007feefef2c474caaa812c8322d98736261a719a317dfcca46d40f99d5b0b513d5137cf2d9fa2732614001977af9c273d2883bf0d1e1878a26d3d271ab0f39c742de8ddda6d1132747096b37316efc71ca4217a56e1e76b29a11454b04d65aca329d746d6a97bf800fedcc37519ceedcf78dfaad9ea65e355f4c8d630ac334c66e3b7e8d02f71ab51eef2793beb0c14489bf9a7da0ed261e6e02888a2bddf87f019334e77476f5d4325f4ce6b2a727acfd1d672c88c05d36467faa9e4256f627ad7782214d2ec801c3360bef67767e2a3f9cf8460e46826089514c354f6324d17493492b33dab5a1475e9597b14bb6ce6635781d673878673a3d960e5fc4ca050edf1ed85bed048bab917f85c26688f6cbd42dc26e61f53b86b019aed56662474fc471e9344cb6da44013612f9cfc8037927cf051e64812d8c436d856b0f9c0d88ab5e067147769311e22efc111b2d7f8264be8ec2adb80b43b42ca7475183ad57d2082329b5e7a2e6564ef7dcb974cf56fa795f5169c4b73a819e359a818c75e8bd2bfb9423b501a628bcd0b2952059bae192502338b55173721c4c7d21ace4d408b9aa64bc9ac846e425f8a9c44ebdb0df23ae058ab3220bdcd3ba4efac1b8bc7aff009d84e45a7e6960b87816308901dbad3c0e5f0ede4546ed9b5737d21b72a177e48b836c0c8e3ecdf25c0e22417c7bd8c88e4e4d6dc2fb58d2aa2928eb604ba23dc2d85afb4771ad7ecb9213f7e3db74f0ad38a1fabc360c3864f4916ee33a72c06d988573c7d8d89977eff596d6ab56b38482ba4643d946cfd59988863d0beb074903ee5d14ca154f4f89ea409d598611f36cd2945f108bb0ef0d21f3093da0d633e55edb884a8cfa3d50558865acf031e3c93e53c5df02b8b70219b4e65c277f069eff20adeac55201fc086f79d61f1b4b92165de12a1702ec28bb0738c1a00c332391007eae811b7af2b9377798b42243991d271cd4ad4080a3bd7525c3e4f1855f1e01067e4e637fc4a9ae66b2119ed9ecba39adfd62fd11b37b535471436406fcb186da9a6705145cb76c8e2fc09fecd835fc63ba82273e57f0c2fd4885905e60ee5a8faebbb22aeed68b8c09666da63516622cf3ffea2bb0232867cc74cf58b922de974f023252f5d0edcb9ad5ac75906f0b1439bd60d512ba1b50d09740d3261f8d5ca6feafa1c290bac799","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
