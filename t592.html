<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"590cefec7c25bb4933afe518bc5559eb90ca9cf69c10a6af98e73bc74a2543817488095f8988787b17a6226e5447d4ae816c9864c112d7f224fbdfc7263d6528b3d676666005d7d7b55a32ce4a6f7a23b33719afc051a1369e1b696fb83999040b47533f73644a7b2ed8ffbf0c1f2ea2e94b8958a5dd7ff443a8a287675bde2d6f2cc19e828934a41854f920899929123b2c04cc08f935f00bb511a65c2db22df83ad38e6c604ebb4d85dce2d9375bc35e08a1d25ee160c5e086e9de97f8ba99c1ba9765392ce720b7f7c4a83d223b4ececca427a68b622e79a9586a535d6f68f0031914b71d545c68d0472bb8e1122ef984a650059ffd67297691235af4383dd9e43f3a9beb6019a8b31d2e1c25714c6ee7776edbec07544fc2dcd844b5c7d9761fa68073ee62c669c7eb4402e228076772af80cf221314979f6e359a10cb3d2d8b5c36e6b4e2f131cf677f068ae4e45c1bfca37cad37aa8482c0130c93a084b29b277049ba32fcdb5eed507f9042fe0f6731992292614bba4186698ebef9b7746cd340d64c80912e1583986529ddb9016f8a65e8ea501d9adfe8e1943a5b73a63fb4f5d4bd0257bcc064cb5e3f6afbe63c03ac5942858fea484b2d81d571ab67b5a41f4ccb0b7a2c5b12efcbfefe8f6da6ebf8a9ae37b71a3929019a97ac8621d542b0cdb4dba7853ce6147c609d5d0aaf3c04a73caf5f747003f4173ed4259dbd9583d76d26af4bcc96da8c2dcb8fa6d91c8e6bb9c695040c0d7d192f9b81bafab899c84c5a82a7db8fb26e78b4e80349eb1d6d5c23fe320e39e85d7fb40a3eb089d11ad323d87e4dbe3fbb89c0d01d847f3ce7ba038935b794a05103ca43557660f2a38ebb1b06cc4bd24fb6cdccf783b700ffbae514c03cad798c30cef953d9a3a8c11f913bffd27cb7a1e2a7c02a384dc4d115583082b059c65f66689fb22158f63d16f9bf2972e86ec2175e1d8b6381e048c278704e342cf8c453244914a1c2a025bc2ba4478545f672d50fe9db782eafce44de2c47f69f566e9345e2384faf3da0d71a278e793a97e0a9f5c685fa6d43d3cf1726d42414a0d166cc09df64e00ae2affb48a85ed2ae9c05e552178cc787ee10ec9462ccbeffb2d165640de68381e30acd2b9886c6ee8b532a35a4da9816019ebe5b6528976ef6497e198a06b960b46099c529be738dd36e1463cdd570e97587a298c17a49bb1e7235cb35c0509d64139d0933848443bbe4faed48dd8474c1e97110557a3a5ed7d6af5fcd030d58c6064adbf9c78503c9f648db886e9c57d504d3140fd624fae33a6d95ef8abe282b0dbaaada6fa057c583c8a2e8c7bbda6bbc533daa14a1e083d26ca2bf27b5827e9d0375e5c53493383840e857a2da38c3f1fedc95475fd29271fdb990c26f9b17d26b08ac0cce859c64c4470d47fec2a0c13b0f98d068c084d04e05812f3cd575a0644fe426f700e2555688423ac4d81cb23e57403b1bbccf7c988f11b1c549043f8955f6a3b651d9cc475399b67d5d7fc9d287c2ffe32e658bf40acadc9432610f70b487a9da1933e0a437a7fbc07280f6fb6f492d0ea3ae0ad5822327f16840fe0daf3d6cbba91c0c9f537901abd45201974328cf461edc4f7d9320e5227c6e8d6a0a6ed9b3386a371045d3d38f97b66bcabcfb4d560a73519c3e08bc311796163f968d189f3703bbc0b095235745278f56f0dbb4a97ec2bf127bdccfc125efe6d0129d70794db30e1908090ecc50a1363680ac8878033df51eff989e132ded640934c85e681917a72d9c9c45648d5bf38424b5fbb588c6c25a60207e54341ffcff364fae2f3ac0ebc3d967d2f21551fd31f37184ad5a76e86398bb3934693a50e953b267730af83a8fc90c6e2f22daede849643bd7777c60b5a23c27f8a54dc89e1426eb268a2ee201199be0e16dff8628bb4815eebe85c8f1b52c7660125be08a0b28451fb352c311cb7f442183f88c18608c28cca465cd87a3bbe95ac0306f24ed434bdb94f5e953b311eebe3d3acdf2a7022a0cc88754d874107831ca989ed1cf3ba34d140c1a72f850a2236826a670d8160b21c59d261ef70766757e0dae48e2bdc2feffd5921ab2d3225e9597e570dd49f911ee6bdb35c167a9b05cce619a644a154302b7cc013545f211e8f1d3fa83d4b1cdd92a0d325393ec7f6dc0e7c5dc2c51f89ad106907cb0825841d25e1b00d8906d6e6cfbd28b01ceb9244350e0fd59795f1bf92ab628fe2d1b1b04cdbc13a7d99050e0674eb371d359503f73bf9adf0a349021e7d05838df39a70f8bcac2703ea5091ce820f644e5c6243ffb85085e7394820053b611ff4e151a15c516586f57677294d011b3f719e7f5caa45a27bef8d3aa9b38807359c55db72c1d67d1729bf9093c8a5af0010d5cf5e6ef6ef3088a412f1648b5f2f09f6ddee37716e7f52c13857765930d94f5052df65e3f79dc3884fdd109799348190ed9a4a12bc7ca203f2db46d04e1013a2117b651e9a4f868c72eb11d9be4e32af327504f61e6c6c159386163a23d3ed25f25f2bb9a08d03897dfb8a5338da4d53e8c0af0108312f8039880b763f26788ca4e1b60ebee72b71c560cf9cb7e1684ec9ad9f6cbf8db741a1f51630e6dc0fc36bab272977e75632e2635ac62c74ef8b5fac0d694adfa1d3c48a7a84d1d207c7de995abe7c6c8c6034439f79c4752f512b33e97638bf19b2a02f461784a46b6ae9c94631bb79c2c5b4affbc64b74ab0979add2f3ae48a1908f2ff63be6b5ab82a46ebcf9f8f2503c365bdfb1fca2c911fee7b5a985c9811c1d534d12c33ea37a0a41a5e67778416b2efa56a2b0522cf1d5298e9528eb5c50388e2d25567831a71844924ecb89e75c0bbd4af8c6eb372604ef86a426cedfb582cb5c1d415bc90cbad699dc8b3d9ac6f06668cb810da46c23caefab83d5199096ed15236f928c522accabb0aad50b92d86f869af8abb854c0b2583e7b1ef61151cecb3aeb7800bc0466f3b88e1dac7a27ad04ea7c14b5840b8a474fde741d9c3479851aefadaa5b5361af80096f498bfb7caa513feec8053f4d7c35217d35e7f509dbd07d1f12d55e7db020f00033a49ab10e10286fb38b8ca4280b5a418a97ac165efac293f27d9344f580059636040a05ef9a703a1211eedd9b42ea264806c4d4ecd26cb29d1fa9ff0a562b499fd83f3c9b4a7dce3437e2b4e67157a9ecd401dd8bbbd3fe8dd7fc7449f27150e7745fd71210aa5b9b4fb3528a495f3d5267b4ebbef5fcd478f121ba513c87f5fab08a48ec1bfedf99b8f74d101f9c36aae86a872a1e9ab6af5a9a54ad0d4fce7082e5edc02d3ed1026f70b2a15b11f629ee8921cf245ec2b3f9f575ee84c79c6ef9ad853f817f97d826394ebd8415397e19eaa0aa78928193af7101cafd4879b9a804c3f7bdde936e7f4a15403c0071ea6ec2817a23c163850b4d6fe2251ddf5518e6f4eae8274c3fd4f309cb76f84aca0de9bb8149bc06cc34909516084525eedeefb63b900d6a5a6a02165a314f06423346986b285b7439c465b36375ab6e53bdebcd249b51a1c63cf10097d1701c9eccb85d7f13bf65f37d06961a88f6e3c0434643b1270eb47568f56c62467e440c436318d9de5595ca9307285abf855df7c8590f14d23d8cb61d6fb54c718ecbcc806a181a3f82d2fcf24b39d9ecfee4bb5464374aa1931aa2f198796023e21ded20ff92b08a0841e2496fdb36578a5e82fbb2c2188830e833154bc3f7472770f91ba7973a0416b196304a5de90983203db48208b3e1b03381d0968a6d6ca6f28dfb4b5320199e4a294c6865aec4a9fd7a2c9d890e2bdb27aba98cfd82bf22e3d89459dcc17a1dd430a389a8135539c73b290b974c44b725f091a10bcbd075440d88608c49c1d09d3fe3feb080cae321c01e595f9f12ee92fdc5f82a906e846359d6ce5221ac41b99b63430115ebd3cdf6ac19e6d22d3c8a418900ffc7e7ec9f4c3278166a592a2888958612522131c424475e52d7d82c4b3d4c1a7e673efa424c3bc3f09185e806db6cfc83f296060219865f30661d22c1f16dee8fae5e4732144b88c82ec184dd789c00a257988ef0cb67acb70259fa7c7512de331ae53b7eb5e54050bb96967a887703bbf6c14053e3734616def8c3828d6aa4ecacc17884488e2669a14ed9bd6c89e22a0477dd16bdbc6c26cfa129c1f8b15de4f10fe606f05f1a72b6eb59ff438e44478849ef95a973fa4733cfa6f4b07b75f653b57fa4d9956f1939639b2fcdc08fe71f981a524c454d10beb0be638e4bdc9f6d78ec2c0113d6aee3e68087392dcc36c44a0ea0abd4beb7a1432dc3643a56f6fdf164cf607e3dcd3378fa2efa50cd29c120b65f6f4cb838ff1dbcb43ff9deeab3bd6b110b4d19a82e28c84cf6410e107cdd662aac335f227b570daa049cdf29b42abcf821ae2002fc12de42fbf617223289df17d4dcd6710c5233f8422be8c7a3615f7e32d5b83cdff972f8f84efb712e553d1f48179ae82e6caeb403ff1518ffe519fc5061233d9e4ecb554e61baeae4467079721ee7b45763592b1dd4ec012f896b515c3e45ed21291bcbbace0411cdc5a5db09a921e33efc46e203def2f26036a0e3a33a7a0458f4bbc894a2176c54ee178c76ddcc653cfd4ef563c58ec5bd56c42b31a46925550293b098eca496d76dd92eb4a55d321eed8407db4b8c71784b31d6e1c292696210b4bebc7b08c8b89b6ec7862b4e1ef288d166a7a34560b30efa4ee9889ae75b44accafd06b86352c9a5172a9e090e8f5176c4d183b9e44afe76ddb9caa1fac1ec84456340393e57436d4799ab5818405ed19c96b26874de677710ba709786421483a7ba243386d6ac225feab8a78a381b79836a16b2292f09af1e6933ad659006a200d4fe430b704a8ebbf13d1471b66bbbd7261e3f0cdf3d65690e0c560454bcd14fe250daa46273f64f33a53d84a009c060c779567d6fbec8d613eb63362021c9908646450ddb8a485147f487d1e5bfa1a9e73ce311b1008ef3657f8815330e7037120b5211291522f91cb1b0ea23d1a4f2c333b35e61df0c141476a4a52eded46d677a8117731f8aa2dde0503a7301b0deeaa08fae689102a1b777b09ec47d267da649bd58fa186b6711bbdc6703860eb6c01645fd52eb399aeb3ad23385ebb35b62e8c914712662bcdb43cc580085606c9c84f81d67d2848411fd38ddf86160272009f7ad3e03d31cde958fcea26b03387bcbe6f9003cd4a711c243a9bbcd010eaa32e3599c0cb4c2bd799dabdba9d36e58cbd4a61eb9a82fd89491eca6cbbee99a962acfa4600c12b248937ff6ea59b7ce7618f0622fa57619df639ac3c15ed815de89b1ffababefe36dd29d2c33f76091186262744d36a94ace9e8bb4ff10ac1e2837398a4b0c6cdaa693b25d5eb740975b6ee4941c5b7af05d6b11b955b9898b140a4ae32a0af9e80ab7a42a4a287b4987aed5e84fcd2c0067420733d62bba56d5ec8676c5a9284d726263447f101e751369f7836885d449339838fd12eeae7a58ccccff579f7d66e33179d0053a9f687087a50ff0b0ade8c4877c33e47fa0c9a32bf2746b80ccc565e2175df09553597e41b0a78c62434af7c9680471550715e03d9dfd785c2064900e6f637fc7ebfdf848444b1c260eea30e34d60406b347b80eba14d8aadce1d48ff04f16cc6ccb71c04ca15fe05bf86b4cf70eea46a2c36b13231d574717d7592a0b0aa1f190acda62f8ea448c5227e6d8960616956fa4c8c3233a16738dc711a4621ef2a54aba657b493a54bf059a7ffcd4ca59185c01470fa2832ba61136f7308f5baeca98590c1f7fce923a3b90d34e79d2012f8fdcedba7ae50c09e921c038f6d00c85f39ba78b26ab4dc95d79e9bc768cad0709ccba5b7640093d315a457bb58d1aac669719055c4e8eae928140b0b8c5b58bee2f674bc05738d66c4a98afaac6a48993408c4466000df17543ebf9bf65b012fa49ae62b78bd4df577a44cf66865e672dd36c955ff4dddfa164b98796b1aff5a203cdfeb961d282f1b32f105117f27aeb116ef3a76d64d93f03112958439d40cb57941bd590f5af81301f834acb01266d9b0dfe6318976fdc68cb2e96f35bb1133db43bb6ced8be13e2ea0c33b4559b12d0108c21dca932c58df0d093f10f12eb06ef4b6177050af866cd2de76688bba79827ecd66df6e9f3b04b7ec4057ae739c4a2bbe8e15e9fd94396c47619dc601fb4cbb452f44f0fde988e1cfe55729bc55192ffd2593f3d4e57a1e95fda7c4f91cb358164939204becb2a9a8d28e6b17f5f8e6f39a9d2bbe34a94b1234f1094d19c62a865ae24499bb715c3fc32e245a8ef38e8d2ca405fe4c0a00d48da868ee75756b41b8b18155c2def6febc7c038e5debc6e78d0f0840035462e09f71f0766111a398b974eaae7763c4d9dfc7d66493e583b20c6e4f3603d12771dbdf1682cd6586b269ebd7c7ba33f50b848eea4ab2ff4b25bf16f638495bc2f588544c54fc5ccac8dd59539a2e3d09553df16752618c8d05c3dfe22fb5e738ffde5a4aad93a9fcbd5f7710403c6edcab8fed81f83499dd1608fcda2aa949ee49c7b0b5a3ff2b5d43453231cc92dd571286b2cbc44dc856d14a5590d48f331a6cc98d8c95bf9f6dc9f49bc4243620977855704876c35428f53c9945fabc1e2796fd4c833eb7c5e534ca40e9d92448f321356b6e751dc69f3c3b328f7f75a431b4eb1e781e551b7cdb1d5231f4e1190f7fe431f1d6a4f927541482e08cb09664873b026b7418b6958980fab37a9312e631294408c9122df66b78c3e3096f59e5e4d0274853eda79c59f9104d6495eff5fefaba6fbd196f50a2c7bbe5d58030fefdda89fd98ba196721a7f552e75efc4754bb175db76291d07e001c702c9c824b1704d7d50df58ba12bf569be39eb1d5fb9350a8ac0f3c2667d16caf0331e41358bcd429e6fe29c2bd7159676f9c36d11a6fb19cf1a0252b55a0f38bb67b310ab3b232a845d68b1f5b6926c143f7c7205c20d85f6ea00834eea2c500d2bbe69c9d0ddb3e155a59153ba3655bf29dd79a52a47f4db3daf828b92f9f70cf6ad9a47c60f1a15ce763f2004c1f6aa6565600db311c9016db398021c1474c44b54d8d9f8129bad67d4f6248a48dbf3e77e732b240d84547291a511088ef70ae929404d8cd3725de410d625fb2d2a812c47f18441da55511c4e69337a4040a971b2b36199c3873387e731dd1c4baa6cd599f86e225e009a24059a56774606026949da0ceb2fe50330167c81fea72781e0c76bf795deccbf76bef4798ca9dffd135658960a91f30e3af81d862d5e8090f8d9f12da6f400d162d4542b8b92ec3b4720e752647f51ce45214304ee218802750aa6f348c5522ee6186d8baba190ebf08345aa102de1ae107d6185e8acdb3dc7fcb186f33d5d85957041c3ba2a81c3adeb49f46e1f2466f87d877e7cac476dc9f92161f28f06ad88a4a47f0b7d1bc7df8ac179929a4fcceb8bffe1fcba9c065a0ba3588f5df1aa83d2c173168680dfb7f119d94108b238bb58d31b5f2c37da58d0ab14abd165ad051be35b912e6bf779eecd77faac06e1f63089b38d975d8fb692ccb6ad3284a4e4fd505a5f60d263135719a60855f1cb17008bebdc5fb7031c378efa07d72bb4f36e132899d56e54ca6a51b876b8d58ed9d8182008c2df69f36589a5878174be1fbec774aff41ee6c6b65959dd19802d8a6ac6a2b39b0231354148f7102b9aa5bdc24bcfe55ccaf6ddb9778765459b6ba0d17d7a19c85d4a8c44f606fd3333e996d60eea65a441ab0c32be5c2445cab538af25f364a473fad52c079cab911d01d194cb8e4cc9dff4b203c5836fc11eb30453bfc3631cd39b5f9e332550ecf43315c6165ddb4f9d9bb33a1ab290c0e544bc5224ca556da97a97ebf7e4e77d481108dc011339f4dbb24c9b97b3e421eee9baef67a8301df56ab448662c024f9d30766966e50cce1794dd370c4085bbe09d0ff04393d4d1cdb1c634c7ef569c49f786c52172929de8961d681fdc49ed7d445b328ce73fea323cfa5e8411a876c8b657ba95b33cafe21a2e048e4edf50fdc1808c7fbf7293e41a749c7a69fbab6837ce51f608bb2481ed5491b98bf209294f15e7251fb162de5d351ea814fce865b5ed8a59bbea39d87d8268ca2812b2d9a3465867ae83fd0442ad7e59290e8545a3f8809cb078995da4030dcc967bca3307f2986e289e6f49b5806466cf96b951a0086ed49383dc5a962643bda4c2d605ad48f2304efcb4573aa42a4291488f24eb80fdda18fcdec0b5cc24e3cc335fe96d884c03a8c8726c91f878f5ead477b3a805195e36b7217c63910e3317d7f1923140ad49f7aa59fb42d8cfe56e8013fab73379f1cb227c292e0afff9582a05c8465a1715ad57cac36fd8c51b22d257786d035e56de341cb06709d053278faabcbb890d4620c0d37360d90a02a18a1cf5bf226a32d703e5f39f303ff74ecef9d1f7e740c9b69f721f00bbdbb6fbf306dc92e73d4c448966c412df12ddd347a2d7ef4cf9c13d04f989f755cff432f086b510109bf5ba0aa509aa56233b50d0801937a25d35e62968495656f64fcd7a7e347e875037da58cb7e82bee7e5dcd29aae5f82404aadc23e1b549cf61d564c85a9d48810ec9b10771357bf8b7e65a71b7e586723c3ad148f4fdc3c8c231a9c542900a7051d79e0d7f4a60d614e869511ccaa837d4e0b709f7246e879d64f1ea71b9f311390e25d0473aa6187c65b2bbbe55853bb37abe13867fc8c920cd8cdf7c1769d6a4a7b6d979d18bd082c3bc5c623e97869897735b37e694973d9151327564b3c6675a16f4194dc1e1705e584e010e9c993ff458401b1998e18cc03583cfe55d48f2c63ef55494fea3a6261f839cc8264afebfe23339718eab76c1501c35847f4f1bb664ed3c7bd393ebd1865df555d8092b3f1b8d8bf51ad31be2dfbe98e75985b38ca0d52a34b3403d4766cc61b23c081a46a91ed217bef44c9070e70caf2ed254eb6808b7d4737ef9a28238d582e98298810ac0c5ee5ddb685245f950ed4b69f39402890cf0004c9ad33c58d09bb4ea596b2ec2d6dbbc8612afaf282ca57e915f7f8537107f85523538558d9c22cdf214577e519315505697b81323cc619815badd4f57b07df4ef606999686d59335aedd65854123c9f8315cfad305e7de8a4c7f829aeee2878799b1f06e2a3dd012de2c7210055657b32951a28fa707f967b946367ee74438c9fac7316e7e99eea2c33b16ccc08b471799a24d411913023e78e38c35944ddfaaee815e031f880191219abf85eb95699849c67f63d1c62e16909cd807ae1d9485040649966e8c9186164b1e47b19756d1dd9b898807a18d4611bef533019a6258a4148dfc29872e928f467b86f97604badb259031dcc2437351c6f31c89ea73fcc9e0670aac7a78264b680e3acc30fdd16dde68c7bad779cd332ab7e54b7d27b01c9ce72f213a22cf85248303067a4659c346863028aa05312ef9b20beb44319e5eb8a29ef209f977014ed4df3910293f66aa57bb70e8aff8e51253265f70b3a06da81830b4d64436ce4fcf0c3bd9486a9ce03be80e2cc5c32c95ba0f7b6489a76ad77d75500a1ae32af923119cd5b8dc9b8ccbce75230855e357dcd3a4a44c683e3c001586d18f8d3c22660b042a879b747242c07ab23aa69619b1053476a926b6388cad201e9439304afc8c8d6ec8959867083c1b3d62784e50d33a0ef0537cf36086175e550d186dc53af3e48e88a4b9dd6f1022c1d87e05c4a338e5dc4223b1cdc4b030d7d88b22ceaf9b1b4593b97521d76f28efdafef53f1ae40b9e32c0d50c7f9b2c0ba5304d358f2db1257f774a80d2c21722be504c42a9443f53d2b733505a3af1d44298f4c1448418567ffa0dc3295544f37094a5f37be1ae3017d173ea00de0468c50c1f2667d842b3badc005bbd49547aa819c102288f5748483d47ee22a845384134ec541441591106b8628aa564fe0b0b84ad3a8709d8b1d9ca901f4fcfd785c8f8e6f799fb5c5b52a5a2f4ac70a924ff770313c058a5028f8c0dd669556b3fe773f15228134c600731f36ffd65ddbdb5edf32f8da27f753f20be17dd958696e1a31233835ae46aefe225f4dff60cb4dc05ffacff885419b6008408741317a48923828d3d8fd345196972def67877f44038d2ff88dd0f4d11034fa91260cd7a46b582a4e256d282a68d4e2b91622a9e01dc295a6e5e9376fdcb64206f9503f09c2135c2055f550223d15bfabed80b518822e8892db79bb19596677ed8d241e46a03164f41b3838e1dcdc28bdabfd0d5c13da82bc7a88de32f951042190daa553c86f9b4df6bb6a1e5aa395ee6fdaf8dd96edfd0a3b95d022d503506cf11407c2cbc8061b734a811ad97262ac5dadfd870251bc93324d494d24dd6179cb2dcd72711e3b57d3fa3abc994d933f98da7076784503de9f16d6562bba98662b8d12f2ae073693d77537b7efc91ac0ffb2452a67d9419be352643005caada00c82c45c2ef6bc814080a0a348672a783d66ccad96c0b3b8f94ccd0e503c9bb538bc4d4634f56d21c9e1cc2c622824ec80708dfa24ba60c7002aa75936d33079ac5737bfa384d8294e60c3915b5a1bb5c76974028cc13037fab2a76cb24747960fbfe9f4cc084634932b1e100cb378ce2f2ad58744aced09f2be6d0cf60a44de6a5f7dfe9c4686f23becab6e891170c4ad6ecda23000630d0a4e41019b039088a53261a43213a49302d59ec8671c6a58935ad66029e429a25f6efcff0a646a7e29960db5cc8bf86b09f327e567d9eaf85eb4a539d9938488d1d83d1af586ffc50fdc95b67e1f46b29c122c8384d95ef3e2946b84fc84c09b06dcfbd8e16b37b40def7cf52aeeaf6a235804d73018fb6c9a16f840f4ce1291c3bcbf0c1bc7764a110f2ebb8b8848148fbd77305237389e7fb3eb4e9012b05085fb1b8bea6ec729043c558d4c168b4d891fb162da9e916a29f424b157aabd7b5b1aa87beb60d99d1873abeda8d7d2b943176642351f3fb1d5c278db95625d7e219e82c0b5c38f42d2d8a063214b044215a586c2e4d2726603e4f09686954c1a7ddd1beedbc1fa246665df7af2cc220f83aa428b5cc0bbab224467b8b61e539f90cd454ee356645acf8b5c83e9771b3aa5ae10a2e90a14cdc7bd94f2eb484d2c7a3c71034093714ee02350ad684534d9b70b552165e9cc45cf7720ef2ef386a8509e89365efa479c042476a0fb11d0b2e02d0632afc1c7558593aea8a61ba4152aa0c0402218139230ce6c1e091906530e0d2f00705e0a15fd7743c0402d6b1df5253b5858fec8b40d68757569f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
