<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"571f445b3623ea66214127714de222ec3e1fe4c12d8875ca5c700b165370d9b988820870892330edd7c8642ab8163460416fa7eb4168476313b521da9eee37f8cb4058c71a85eeb4b5ec2cde7f3b8a178632a8000d30ef691c104ba5df3ad6680e530de3846212c780e630621229f275630493e59ee2329d3f9f07be2b9ff01cbe2adc3e0bfdd3fc4c138e4497134a85eecb7b41f616709aaa4b56cc450993c88e76cc10d57d2bb79ab5fea235846e135e1187133f7ff532abaa8d210053f6e1fbe2928c7f23d3cffbeb315251a651f8e47513477a83b584edcae9038f1447eb8a0646d435cb4eb975f3a4b629cb022f779d0c72a6c0fdc8437f8fd8dbaa7472be42368c3ccb84d18b1fb7bc3ef3a170705edaa118597cccc7463de207e0b7bc16f4ba0c04defc82464da057ade90e585fb3c0a39d7a49b5d43ac13fdfdae836165db27f776b947679b7cb97703e4088ca9705204cdbb555e996487922563815acebc23b787ef8ede1668c24af495d39b9b5e5665eebb60641dcd048f1b2cae20b6b053ac8404583b19116061d22668cdba77c7e185598c575726939f797314a5087728feed2c85f40d345c0c3b60088bec3e509f1d7efc484faf01dff89da64d523b18043c70e44eca1d3028d62f1205795faa76ca426b92faee7e6a63b9e30b38be7756a9ea7ba6df99c7b30dd8636428742dac792d1f4da3dcf3699b29f0bb58bc2fa7938864203e91dc8a86b45f6b8dd16befaea5033db6a638040612f359f82ee2d05ab4eb50d274c88241bd5114106cc9470eb4ce579aa8c8815913ffaab3f1ff434e5af517784f0ca97af86cce2e8dbd0b4f504d9beda5fab244e1a8839eb695f55a87156a7723c252d8ed63604f2299423c665f705736b276344c841fb63424085d5e31a0d4ec90c5fa878a0e017754dcccae452485ef74a7e71b603d9380c8b5bd4e9f7440ff3d248c5bdc1332d69b3d7a0d54042ce70fc5fc63e1d727914af72136e7ac428b7219fc409e24a24975ec43c9c7ff51fc20d280f5f677ba3d8a6213bca97fada4a5a0d3b645e4f4ad7c7840dffc970b426069c7effaf6788fc436325d00aeff9a392344e5234a83eff802524aaacf79124a88629283a4ab06adeb8afe8cf9542e88a9f00c42b48a37b68554a242c23933a5242fe99b7dc33ea3593ca3f22a72818b281871d95e7e47be19ca96e7b6ed22484961dbdfe7ec8fc150841257c5fa165b93848490a9c52351609b81d247bf41a2eec40e4d91f969113ff2e8928223a779e601aa5456c7bc0c0c432909b4fbc394fbbe205598c76e2bb2ba5a2104125c43a86c662867b95de2e860c5c8f8dfe6c4a51f6bfde086c8b4f6189fd243af68d0099e52669a47b9edfd4767b0312cbecf5ca2054c1d48cdb6f43536f4d04fec424bf2eb48c1c3dbccf1ca7421bbee4f3048e07df726c343e8da5764f58ac783351829d990b394649b2603cbd3a890e2f779f881ec87c1d53d9e884f2ab04300ae6340141a9b083735f9055837a0871509746319a1521bd78cf2a52d7a5c2d3af89e583a5c22a707fe8c4ea04f23f0fa4b8bb57d47887c8dfa90cfaff43e5ca412145472e0ebb7111240f8662cd6ffb52dd90f8a283dc592fa55de398f596f9a7c8a9983bc163f7883ba05107f596cd824002bcbf0c1ddfe9006e011fd24618e4613d5508c569617bf341b13ef78aca019433db694f09de7c29c5a7653f6730e247f58037d2e8a2c5880334aa8349b7451977cb76e5b7047be8accceb0a5c3dc94a5b4421b865e4b15a51b5b61593f6c3b86eeca565df274645e72fdf224f1b60fa552931db3cdba1a34ac5c07667271720713dd04983a3b540b5d6fcc4cfe663244740043aca1cff456025ccb2fb714eef974af119b8a82cc2245e148634db68fd8e4ac93ee9fdd35b7a0cff038e79ef7fdc762d06e8689c0ac01548b7bfc7b5c4afa05a299193138f6c92c0759041e0df96b980192bae1891eca23eb81c4c72017f1ad4e6ad1533727dcc1c74b49ffaddf60cb7a24c45b0196efc91f9592a4a61c9aa234e80f60240fe615bc1cbd47e6c12adec87495798063e4d6096287b232ec4ae7e1e479c3ce593a2020d41e3f4d585663c19f545408a97f6485b2061240127c2dcb04c3089aed750256f6f5aac62151cf7376227aecf321cee66db9ebfc5d9f51c48e16c71f8058622bc802e7e1443da285febde3615957c386c05808067eca6007aaa605134aa5e4effd74bdd33e10bd8f775686ee70f14c2e60ce315936aa6c9f70ad63996de527e954c17f4b83d223333a90ec884e570b2e6dd83d454b806993d9ebbd12f0fb9c1cc5374789a385b351109f07b10a9c825092ded63783ec378093243b345f808f0a4bc67dd8fb5bf3a8194f6b14148d78694f662beb85434c34ea837f48fc390993371e2235f8dd772ca5dc54ede8ef02a3cc3ab39a77c501bd3e8c0028dbd359561f032eef43470a4afc0f15921cb4369ba499e41eaaf075ddcc9ba879e0618e525f24e3eb4567298540721bd656c1ed7d0266de98474627031cb18876818152c1a48001431643bf3482bf8c92610b8ef023295e1b56e0d2b098c051f1f16bd37a622f3a7c0f9ab76a230cb27e34900a308c1db38b38a75113b81ac21722d8ead88a2dbcb48ba332477893e38cb44aef7a21abcaa42d164f331e2ebe05ebbf7faae00e60b15987d6b93b1f5547c1a703a5a4f5f25cbadf4ef9d0821c8bae83db48f6fd8df6884835a46251dc469d186409559e2ce68e7f6c54d62f667c4bb0db6eef4e732420134b349934d9a04b4c3c4b463ec1f59e339ecaf5490bb7b39bba25cc414e7eae5f6b83ef8dbfa87e6e91c92a3a1692f1a4cc94206827ffc3ca7b10a165766cedcea06c7141daa483a089c8580bf989d3e5364e50b6af3dd19012b188fb0301103028c954cfc7631ef0d703d361e261db21b6d5857025b68d48b0396e25351a9aa436a462e8927c14a0c21757500e6ff8b122e58f95e2a639591d447a582d2f88d928c15ce0af5f2eb1b660e95a92b3868ee00727ace180fe9ef9d32536c56b714547edc5c01ce29af7648d1a58755d5fc1011992f28a4d26b7899c0da5aff8ddca02988802d34547e12e6077a8af4dd6eae8cbb677cd523bd883bbf8486118309f4d5a15068e4c670388acfc3b4521f9458d6f8978e2232bf81e309965c665be735f19d43e51dbb6b33c6adf7b811e0563b4f66435e2bb06ad0ec19c86a27aec09c448fb3e144d8e3d7cc377b01ce2588d2e5bbb23b4680531631ae554dac02dd74c58987cc1651e404f0532ec3d423a46604ac92b4bbbd6742a91e25a4bcba39adc096ae90cb5b3905e3f17b3fc45abe5e4aee3c72bfbcaf6fd238fc9465e6effa4767ece3868c8e9c33152c1512e199de674e6b8350a6e7a25c300d7b805374a15635c27867987085b7e309095547e5667b957a3653d84bb13a388e9427ee649a0b93d7294d99151c9e7c91b12323eeef780b683ef9c8399e276d6c1ab45999640c583102d5d5c39f32d14687e82b720e8a309ff3ffb1766eef82cae19b89aaf6603e36365ba3221786ef4b2f0b954f23e8961f780d87d8e357e5aa7096f94f226ccbe0289339cf4cdd4768ff3a52d798cee1b4542cfe6dfade12201276b52df154cc6fa6386cf4c7a2d8776b78e763b8336dae913a1256c0c936fa7b97f2420a2655078b8af12bbddd09625f643bc94e8749e0b2848f130ac3c68281313a8664dc34c747aaf69502d06b24eaa965d624bd9521dd05038975aba5c5a1117a65b8d0d86b5b02da79afeadead69563205d119a793d405104aa79cb3078688e0d2952211eb5be03caecfa6ee41057f826cc9b8019666971cd8681d3714a7fbf6c71f1244b9e8bd72c1875d7538924f3b6b54ca78714d0d1e9fecdf0be882ef5c73f33823c072286bd0657df699fc777c165bb5c20cbb9fbf86ae3d9b16f6dbef8157f940a2c9452b78bf85874e1015f73d3b67cc6c560a97723785a16c0258fad87de1d039ac20158a17c823aa3c976ff1f785e71de91eb8ba86927f6b2a55c3f9b0363615a5a26ba4f55c64cf0e4ccc4d1da131534e5eb282b7eabfa2a7c28f22ff952812b93b465195f2501f77cdf8cb885fcc838fa75eca73bb5d643ba206aac83785b35470b928c0cb51f3f340d15627e8cd9a50993b3e1769e7c7c1a389ea94b4bf8e5aab2850c6b0d71e08c95bc7d9d8ad3877f8c37b5d91136a357eae67a6bebe04491f380fc362699cd3b4ffad95cb3ddc1b40e76ab5f10b09d3dc034016915b62ccb75ec1d7edcc531159cc42dac3d1669ade9002950f4b29050d864b395ee483654f7537374c8f68cd039171cff5c88c484bbf33d2e3e1c1bc7656d155415f7edb500c3f0f5feeefc6ca5a76e943166c70d000470b9923dc0259fbb3e8a2744aec05c51c98311b25f72930870b92df64968aeeb59d93bb04be35c83516f767a989765413c0e32e57f987f5812162e248fcb181b165e0366251fc7182604170779fbe5ccc97300051e1f4eca6bc66179bd510777722a6ecbaabd54176b69991c24051f29c61120b3a535a2618adce1a1d7706f6d6143f95be62ecb80748ecb69a5e510f9c90a0ed2fcdd1931e20a26f59d39057dd1634b6dc59082566b9966a255dcc8dab482b520c2322707cf9c7b8631bc587c818a88b393396f6e3f2c9000bb4fc27717ef3ae422553c14fb4c996750659e6c6ed9acbb2575c2afb598e8e641debbfb9e5bb4bb5311a5490d6eea4826b8d70ad6dce1423fb5dee89db7297691ce5f7a3e66e262195a744a894d8036384469516f5fd20fdd4afb343040910d10f1283272253a24dbc496bdc85266e2e9a06027c2b130f3ff042541641145337c299844c242947e82f79834727669330a85ad6adc55bd2185d1bce66bab673aeeb0a60e8d8e1fccf3d547c3af1b83578fcae5c8560937fe914b01c535065d6b3445a34df4cdb0e7e8567bb65beab0f846dd626cb90cb82de95289634f748e80821bad47b67710e34590b3478b9a623a013712b448ce2e653bea1dc242c9c25ee753b3d3aaea01ed02fa5a17d57eed90fe7a7cd96c5c06b35bb7994600036122940a3ff2e190191ecb77e15e557bb004dd027afb4bbbcdbc067333c3c748d24f5d49aa3ece40edb6e1f0632c11ca125a64c35b91fea9a33f2cd8025455075332956029f3da70ca8ba6b50d5c647c2fc7b4b2c3f63a825c89c2b62edc0ff1e4cd774c69c2aeae0812f21877d8dd5ba518a1f743d581915d0313dc0542d98e3e9ac226c59dac2ccd5aa90f4cdcdc89629bb3b47c1e7c5fcb1bec6771f4a18f50bea6129aee444abec89f5560a0f0c0124214868ab579f65f38d74f83cefa0ec8191ffe5da3ea7964497fcd52659ff69a9d0de6823f0f78f6d25deb4aef02f6e0393ed00d5802cc603f0500a65e561401f9abba5326106479cd4743e7efbd12eba246a9df0efc21c85b1dce7fe8b9e205abe077c57121bfc79418e2ab1769caf6ef21520da750b7c81ec5b62658466d5be256cbd443bb37305fdb508024ba4c2687992e17675b723fb1cf0a2a1ddea06eab12f7b4e00b1a4abde04cb18411a3197149d65ef5980d4220e66766382484d111216d816abb418450a598fc6f2f39b6ae1b7c4d60b32b7d4177f889a8b900bc18a849cf920b63ab314041db4f85ab3b146a197290b4511f0938ba12afa1660e43338bbb8e0905d2a0f0f3233362ae38e6694484234d982ea9fd7844a3d7a934d111687ec4322f3d61cb845a72915405efbaf3b45c6a1d36a4fedae5b5b98b3091c7e8f774fa92c09a04e1b2e8ea47f840b16669aa6931e1e1a23259a14395ad0b62e8648aeedda69f928d683ba35fe854c275e978f0d30be4e0c3ba093e73a212068763c559fdfed00f1befd4e6ed67132a67f9f52cf44bb854ab577a05be886ce5d4cf582945d90c93e059e33f550eb984d8194fc0abaa8c2fc85eea41fbb74c419c201eb7a8cc0bf920b941ce0d09acbc5a2820b80495ca2090927297a76bce568f527a678a0683e2992a25fe7a2101cb277bbd1d9ed6f5ee22bb194eb2354a0ab6111c7cff906ebebc2b1952a6bc4045915d9982d5f159438a1b935c31ab10909f359a77cd723e9a9fcc3db58d9ac68647f576bd60bfbb4d39596d718f1336db43b2783470bad97d376738a15e1cdede3f2686d12eff707a7abfab94a4a50cc0ef156860e5ed3abb4e2f09a956eed602f8ddd3dfa710775404eeadd8caae3ecc1dbc21c73c68b472d60d2a5f8a39dd44b3321fef9f68961e2964b78093ea13b21f832166778474599ed6f1ab4d57250bc3e97ccd68d73cbad8d8412917c79edcbf4796c1aa7cc146109c4cf6991906058f65da00c2a0a842924e646ee9d4dc6f2c74c160419632b33a5299deef30729e0ba4e5b3acee21cbbdc354e845a041d602dcbad8239ee01faa410d5148cd2b0dfb25c59afb99292c70c83aa0c08d87a16376010dcf9cc4528f64d9bf62071304ededf6c95c1df4180fe727e8af3859b84bd21fb70421a3eae5bc66e06f2e8e268d218443b56df6f52c05586cdc868e3bcf70efc4e46de1d6f2970790a7fa21df7f194a48193b1bf3a9412ecbef3b9a830ba620d9a63c2a4953e7aff1e57a15660a8410e1589f1222a2876b5005da4fae07e9243f873fb048cfcb1da7c30cc7bc21b235a8f91192a6c1000b89c7bc2ab134ab63364c438bc4744ab8f72c975ac820384fed7c377634a5b70b70d06c43a8366553e41cd290a31cbdaba4ef57ef084a10e8c74fd0a4050874a990b8cf8e44fe736f4f933a455b6b96f0094ef9715f3550241ad0f353712335f1b27b0f54bb5cb2afd589ceab5556f40184e01bb991bb4b44b2eb4c3d6acda4a324efce3b54e00a80a15898f2077e3f3070696452ac7b4cf6ef76ccc7311b8019766f26bc618c0925678a21bb4732beb13e8ac4f446a007ab05643e057fd0ec3c6b2f8c48f375aaeda58cb93d07d3ff3420cc707a4ea803508b9e4f8c38d5679ed64bb3ea28344f4e332754a03bb894e6d75dfc958cb4fb7dff0cfd9c4281de0f90d8a73492cd521a452e9922bd80965c068da3cf7d9b808fbf29898643147d040b06f03b49dbe0cca0eb8629c43294bb0ea8457aadc81332d8f6eed326b8672a860ec4e9211ac9688b322d98a873cbf1b08fed0b5537ce317943d7abe75cc6114efbbb2fddaaf6e2419f137b8cd24f56a4dd8192932e37cf5b3e6e0af554fe3e37755ca22f0be07e2e9da776c091b6024adbb160956ff9364607637572de6fa73ac86142dc144ffdf79e7ab39d36ef87e1bd42491fb02d78aa9933e9117fb72be099e5b1bd23119a9e5e558e48ce6ce32a559eb445b1e1581dcab2ab1e2fecca32d8371837f14045077f9a9211f1a65f83f76877e3cb64ac03921097c443eff15099a19c8b6fea2857e9b5352a93f2e6bfc8212fc72f3c330eeebc95b76fb203c31ccdde91402bf11b75692255eabc0df7c1695a72f31b56ee3954d17b3b38e0eba596e75a43eee83cd371c2274c91d823d01c8139387cadd0ccdcc244c87f05313dfed2b626b34da9532b691006268e1c912540c670deacd233885555775e561fb69de781666d38d755bbc9c868810aa266bdfa9dc062492c8d4a73c5e88d08cf232a3bcd23e5d43aa33a421aa6198a15ccc6d3e2211cc6d2f851062c161188a24338bcdc31c5305a5b70e0bbc892d474a17b1907095f9737391b34dc2b28aa65200f6f0df1c7bb272299edf3006d0afff0870c73e279eb49f24152cca09e9bbe133d9025e94411c677bb7d760461d587c65e2932f4ff866216d9837f837ae8085efafb000734650d7536dfa97de239929f31d08ccc65da67b43f0c0dd845b773166cdb0bde2b842b99a4dc3696225571528cba803a7e26feba52ed291803b105424467734a4bfe30771d1db699c749885629a8ecb9ef211dc7dcd80bce4965d8e7fe3f8b574b1dd5e7ffafa97312b7e050c2c6102d9347b881f541cab5c84777df0f0562ad6ebcfdbc4fcfd4df6e9b954397013d29e2fd570ebce09ec6d7bd08cd196112e8c5e3c8e9d62aece48b283dec15509d0a106be2557144d1eeeb160131b0a506fe0a3c7496acaa1e99daaf4fa3322c76b5e99ae0fd9b9f17ccedd31a7017458a771ca903854bfc4a3fa11868d1458c0bd56326962cba25c85ef2a77201c2ea11765dcb4a44205ad1f3ab36a9f210b2eb402ea2bab274913dd385199c7eec04344642b79ce9759056186a9ba15c64da832f44f8514cd6ec2f4756f8498bea3f11ae4587145d88b0b8e13498ec383aede9b48bff0bffdaf9eeb49d5785a46c465bae3bc51590f15bd9cf5930a80e20821d90416850fdda2031fe87ee100a87a0da679f55cd026ac1c08fa713bd591fb637f98f7923cbd7529ba8ef213a28d67c0de74898df1af0adf4bfd72c5a38671b15431c3582fc5086a624bf0e34d4bb559aceb0b6696c183a3168c3738f34891f021f3fc7f6990840277a4c2f1d9b229f219e7d176ee5bdcbd1a35c564ebc47859a8e30f46313d0ba223b12f6f2d7ddecd67b108035eb08067e65128d827b75b20895583f867c4903444a88e7a46855c0235385592fdc8d48128595b9a4a67f0c547e7bde1e23313764335e978c4ed4c7df61da7f4db4669ba9c28a719cdd565c07a430067b85ea784c32fc83fc4cf087a78a5e995fdfa51aeca54ac0fddfe71c570a7b89b58d2f0d10e3dc7ef21c89d21b6dff60e2c9d464ed3a83cbe7f2a14742d121861c09671c30030c9d5d9e5d4f3ffd0d647a9331371875b9590b6eb3504e317ceabaa4a35afe9f9864815cbf58b9504e05feb29b2fb788a68018499f9fe8dae7343cec0f1fbc56f36da6a1bd4af2f98289bab676cedf89cf3f3e0a7472b5086a800fb1f901847d2449e52db11095d15f5d097d32655b16f7e5926ed7107e3f1d18831602103c2fe24a9c08674d5a7a7f58f8a8f0cf5cd067c56ea1afff888c489bee0b4feaabbb2a7d4b0f6b5b6bff5029958a37e49ad00d1183ec1b7774f83435f896151d058646c616789b55695675a9fe5db45d5307a95dc41dfba64007da1537bb242013c7028fa3b028a5916153a5c05a90304c0b70d7f2a76f049df02daf048d30e2e7e1eb84ef8fe5ac20ce1b5bbf1de175ad15a07504cd6b8ea136dda1cdcef7201c23eb84be8ef127db092a025b6f3043d7a41db0f8e419c4674425d4ad3f62932c323314b26508c928688c8fe30cd151372b117403a7915e83151fe9db3c223ebe8bc0c408b36af4a8fe531a8bcac64f9f3009c4fe519276d7e025411bb926b5560c5038fe39cd67893aac261f09f95038d5fb67c4f56cc92b338f6942591cbbf610546e9dee75e804bf60fc7a8cfafea2bf5224efae3d442cc8fd5aa3f86383dc87da4a45e26604ae7c24f48b921ae32ef52ef123312273fac4a1a6dba1dec7b6276519ab8bf192212021e64befc020a21581af95244343ae9fba25f88d8fe00191a8fdbe57c6582d7cc18f234df0f648c78bc2bb3f90bc514b95ceeb752d8d98f9d8770b316eb51fa5316349c6d7e1a46c40173e626c4e1a1434b9c0d9d0fcb949e5864b99a4278ea7dfc9518d536d07825add789d88ad7f6f047cb3dc2c866a2e221e044224b868aaee167c254c249ecdd29fca9c18b240a177a6e2b714099e1bce477e3cc477f2cd739e435a50b1f0ce42e225379560149e7c31cf11b3fc08d03b9b3de321edf5cf5d7ffeb78a6d0584b42f8c295ccb0087cf91ead8d55b5026bc219cfcb7549885ce3db271c07eccd9b6faa6ac8103a8862fcffc10bc1822753510a41c203b1893ac1dc046743d59e22b5d8fa43552ceaf2b363e7a3907f53e05e039d186012f9b9a4b639770ffd2858c0ed227912f7380bf26b354f74c66b1c383c9e2f898b359abd2236615eb81f3044301a270922c09c7219f5cf3fcd369c5c07f465d37d4a3e703c39ceb29445295de3026f69617f08eaec145d2cc59fc9dae9b5f0361c65a977d0308a63a601842589c6c473a129d5d6470f90027a5cf35b28d521977855f46d4aaf9fb4a172802b89985967af6a27003da7095ec50f21add831bbafed33c504680ce47f98862a3e6f00fc3c535bfb5f87589d76d9c7353dc00475d1e88c1642f18ecc4f466d0cf293d81ff48e49c8c25742b9e3354d86b377035076b0ec746c52e4085b1918cc41cdc7b139eac4f613df1025dcdc9751e61e01fb45124f849ced835f465af027f81411b6ec9b16e1232f480dd71a4148bb67a7d95ed398685e0d17a7b2f7396bc6b5e1b51bf31d679507be6d671bcc222158939d911754eb4dd25042b86ce3d286b39ffcf472cfc434cce974b34badefeee01d45de09617307458990d85f402b15086d69f03d6aadfe294c1b345a2c5d235a527f3755721ec11c365f9e75112aef327ce7e4c2caca846a2582d3fcef98b6695ae8b121b4a410396f5ce8000a320f861f10c1f653f938f010236cc454cfc3080064e056704077cc18150786e057f05095b54faaf3c1dd5db66ca8f9452510428889a067951ad9d59a97aafef76decdaa207cc9c2e0d473e21e204b59d9feff102504257092ab4a6afb053c104aa6c03fa4cbb4b1546d5a118fe930b851e6f148c0f7a934e364a70c2392c34c600a84a2788371abf9643673cb308f35ebd8a3a55aff786e227b5b334020c2fa67380c7e9bd4d5f6e980475fc6dcdf607f22ce58ac60ac6a6c0e758cfb7ea7fbac57f33b5cef5c3533cee7fc17a8cf7da8fcbaeb407517bca7d2faa47a3459f025f02a7ba114efa87fd62fecd5d58de632edd5c952536c58ee555900c018f98b3895b778b2a296100d3d77b864ad43e609abe8db8557a3241504ab8466ac4a30cdf4054bcf1b8c79b78635800490decd7c63ff368db2d1ddf75172cea73600a75a78856385768f4e8bb7a18a5c6d77c3c0dfda70f98fec23da271799ad402bb415c4b3c9eb4ba7c8d74d8af201ddf6a1d2c8b22759f0bedc28a234a59f4306c3177c8e5d2d1f3aaa2d8e626be72bc39a664a92253bd66488b1a78512b4336a5a1e20f50791ad70485f60b478250ad878e95bc592ab495","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
