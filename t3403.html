<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42ed7ec0cae7e5b1a23ed6c7480952e9d8d5b5e3236638d2f4609f3dffe3f91a96b018d0c21fa8c67e424b84c60adf89d58ae544defc7e2ddd6cb27541075481d515612adfedaf83004999a6175d23f2a8531a35b4cdbaf73d751cfe696ecde68157ec5090693c83e17e39b8e03b0492415a59890a3557496e7927630226c687310e274c9a572fa5893ad88084cf77d4d3616c461ac819f154722956595ef99a2c57c19ea4b971c72254d049b99458f03e0c6d00cee52013c64f11459aa627c7f51a55822f07f7119effbb36bb2ebed81a4295b417ec34d1cc986191086b51042db13c1c75a4003c793a12ee2cd214c138d1d13c21d7c0e2c89368229c645d078d0f1faf880afe4a6a17f54492a590dd14ffe4c6f115f323317ae021ea670357127b42ab4402427966dc6cedbe3a68fa14eefe5846de90bd3a69bcf1be705570034a060ee35bc86418c0f8acb0ee9767493769323762cbfa9a6b80350309bcc25c2add7996c9f6bdfbc03cd6c62836e6e152d2111f2990e0c9c9b5f5903b88dd8714d47a27afce0dfead49d1c4a9702702d1230de2b2925923511e3122b52cc281dde8883d5b54ba7b81ba511e2601e6375668e42648bec5ccd4ee70bcfaec98e4d128d39c746aee65934a95fad2b63da6bea150d1dc8ba1bce422d17aa339186173dcf7403f3ca1bec29cf5dfbee490e8384bf4949c4e89a85031aa3f501071092895d09d728f00e2f660e6d661e4b3a95cb6d3d2d869947cf59b80b93f8d92846693ba586f92e891fa6089ff76dbb336a36f01b016013d6591742f3be8f69975582dcf7af0239459512a86c23e70c417b0f3265fedeb239f2703641988a5a565fe966225e67f79a2b1f224f8b6786db1f6985cff030507c2125aef80c07195c0284a6c1ed4667f192cb8efdbe5a7968e778f227c24fe7472024bcd32f456b9d48db9c891d750031894874b6b5b22d6456d0eaf20cf5f2838952cf0643b9abc733174427e92803c046e62740221886ec43b0850f0c793915ad056a9d2a6f36fa78bd607d08b0b2b50ee1f6ab2b04deb5b475bbec7654d874ecbf9d8a615fb4e7a6ad001eab43d29f38589bac12b4f0ffb3859b95a02baf8fbbf50432170acb8e57801f3cab5d64f27d2f532c10146133d1a4c92cce024f365aa2176bb38a5a9befcadc16f29d7aa1fdd495e39c62df40e12d7143dbadd423da2d4ef657c2ce15161c4e159e689a34b90deb2e310d35c7b86d4b2c20c413f840eefef2835041d89a750f15e84146beecb7015a7d541b2c81a1c9d4e381556176d74e9b62002c42dd40d85221f0cf3f10e3e9d8bafcb678b8c564728450eed9b9ae3bb0fdf630dd4f77c10793f7f383c947f598dd24c89171a78b32436a27954aa651fb1ff0e31e0084d62c05ed96f9977c623cb98956d4d2dab13948f82a06f0f4558dcb116a4b3e99f054c23e6d992d6678cceca5516fd070482c0f42dd3a44ba80d76695912dbaa7759b029f49b9d78b05aa54d9f4c88b69e1e9d48477839cb115c641288f7648fbe5667a84600bd70b4793593581e3ed541a2edb71429cba3afc367bb9b4a02cebd6320f8841a447159c17993393d3568bbec48c125db5e45f8d3e02121858de3a4feb12017c214240cc4427f96ff344043a4d61a1a60df0c7712b160f2a9ae90c2e3da935a07cf5779196bb0339b506def2751c2076b74f1c130c3a4ed93d9f1d7f5df941a786e2a343e88620c595c5a6f79f00b3a383402de2b29092aa0a429b9f6e4d54c8268049b61fe2d41620d67152927cdf5bb46d2857e6e08021929ecc53d9fd2125734b2abd5a1277c0b8c48b276488a27e9c5661c30fa628389dbe24ad1cd4d51bb69cdca7836681c58f0e1bb31bb4c84ec20d3b1d8c10a56d1aff5e95b64562cf768af0ed9d866fec28c5dd56c62e41d10444dba1c67c4a7c238b0b754ef09acce99d3245e96c693b148bb3a82a2bfc46e8e8a4ded155122b557af0cabbd5f0794f9bc5b52fa59d4e98ff7485f7c3adaa44d6898724e89f36dc6c50e71937a93fab9936460960e8097c6d41c0ec59e7c6b9445e5a5b42fa9ac35062292a132604aaf5771428bdfc5fd92b41bcba0b6228d414d783cb6c41789612d58edf641bd3da8a56de270b2ca3de742444b74b3c0da57f26481d7cc3576c813106a03272c0db709b752c16773d46ca249e21741831fb838e80e6fc6ad287a67cb0d7edf3d24871fcb5b80ef5a8bf6229e19d03978d0d74dce2a5c78d1b23e2198269bac43b7d6d39df53c4d7cc18798cebce62d1353accab8df33420ae4fe5baea2d42d8b70b2ca00b0f05059adc3509693413e8f67d5b84f24cf46c3ae30aa72d3ecaaefb80799f1cca247aaec69fa1d8d6227cc07db22446ebe98edefc0d8b5b04aaf7567dac6b745636a3a6d4f3739d921d3d1a231b3724ce5b2e6f73bc64b4d0817f1655782343cffda97230baeaa08d62bb821da32ba65a48f9998405f3159f6e12a8597d10ecdd3779da56b38491a6fb9c446fb9877aea3f1e0785b5d64f183385d03fa4b6ffe15024d863110d93ead92b08ce05352176a98fbf5bbdb560220db5d5e58b83be4610b96b4d7ecc21e81531a51e18f88f6e1f998ddd4c61e3e00d5076d808395c1716335ff4f13be13f0aad2203b703be6b7f507ec20440453e091e8381dbafb5547f71ddc5cfb5414c91aa853fa5900aee83b618f2ee05cc8582ee9158b735279be31419928e5de783a24e3c3f0fbb9a2405c3fe5b85dc1c5fdba09246ca002a484e3313ec81de36145bbd3c2766c2b36ffe4f19b49f610a8b39d4a201289a7638aa0205d6edb3881108d94251779039520c4f6024837b56e265262ed8c4e961dda81e47070e5130631e773e8b5fb8a33f1a22571c08bdab7045a34049fd00fdb42334f9580e739a0d8c98d6f2b0c7ac78ef9c2025386c08c580fb3fd6d57330a11ff20a61fd77c731ac46b4184dbccc40edefccf602c65931175db384288798a655d07e850d3c9b76d756e71d4c21c40eff60a684a5e26024f13beeadf9a6d19a818bca63a2444326732a42d0ff4497e731ff11794079b0cdb10d02d9e13f651c07363970c0b342d9f86be79a80574c91fe98bdd0c05dbc2c2d15d7bdf1a87c67c505b6de37541ea18bf30dd3647341e845d763c077c3ff0ceeecb5e574540b2d7b77b39b098923958d7e529e751b7dfa6dd13a7180c9b16dd904b338c93eb0f17e2d2c95b732859ff45e60042c9ad4e171c6a9d7eeaca783fd7aa3326d433b27daf1232f8d42b6b9bad4aef521bb07ea885d19151bab7937eb1e7339912074ad38b14f68a4f4c2c5fe363986806a5a3181f9ce8c551a2a33bdee02304a95ed534b9869bc7f60d95dacedbfba42022c55cf7c1bed93b6481ebeeebed8b6269ce6fddf39ee25b07b772e3749ce58b3b43e488173b0c4a1c127346e2782af18ab1a49ab2076fa4aee4dc8bf128b66d566d5ab12709fe8a02d3e36b90db326334f000b8e0d66a80a92aac13e99cde5b13f257c07f6aae8dbbb011008b8f78fe31e8bfa3935717a5a28bcaaa76b0c33d86a89d320709191de9f3be8f247eac5f34d491a01609edc06deec8096ccaba448cb0c9b13e39dcb2dc4532f771c410f8c203abb059093abe304829059166d1d68daa049f719af4b9d6400151b60fae008567211334cc28f7e22fd610c832d02a7b7e63076512a1cfd499cc7c1651ce1513e6e511cde1d0e17f088200450e5c4860ae6f68af617ebdf5adf3212152d781e49ab013a77af6a84ed490a0692f80adf891fc02537027f8e460b7348ce67c7b9c747285583aadbdae52acc4027afdcbbb2089d213f8be18f6c12a53a42695a39b9dc27334a301789dd28f5c2d6c54ddb90dd93fd2ad9ebac17ea94211707ed7ccf6a6bd3d7fda7f7cdf0c02a24d86fa754dd5bce6dd8d68e519e3ac27803c63099dd3776884bcde80bfce8756fc90e049dfe037f7f4ab6bef6767ea407102415c9b848fd54534b91c33b83eaa46abf56134360ba28393d0c2a84dd66dc992032d3f3d5bdd8a44db6300e8e48d10b15288313742809f5dafec33395d3df107af545d6da9df058437d8c73730d75616f3006159ccdfe631a805cf4b14691535c3c9ad3f614af37b50a6c124a46d089a3f220d1191ef5581145ac7df98a4d60ab7865c2a52b3fcdf1309419070ad715ad6d42dbddaf086327918747fbc8458994a9ae223c38cff0d0f7fe48493e7267bec7850b8b237eb72c931db51ab8b9a64f7795b5cbad443b324c1abc9b0a5b122b3733163e04d3f2c32498bb21b7497bc30b36ee57b4b05458d236ed9ed2fa54527e6fbb298e12eb64fa647afb568466812befcc620c2c32d67727bba2e1455de7d5bd30ba7b5d11954120efc3270a8017ba64ad8f8942054bed36688559a0fd75a6b4417223d20580b4d8250552f77603eabc6133bb094e8c395d59df2a4264f66d68cdad38dcc44d4fa25b79fe06c3e9236f8b19daee9c0db00b594448d9b9ee5d8959af2c1cf6cd5c39b64b14a04e1067bf805fb650c1bc10114e8640de844a3adc4696d17883c384ef6aa5d2b9b783afca88443ed23fa1ffd66850581093c2759d920bd6fbe1ca339d331b7fa4a1066aab8ce6db2a5bb72724a83f462c06a4593fd0f7302e5700592b479808f73bf251fc52f115cb76f7eea66ebfdf6441d1aa342c63a746984c821f109f59eb8a5d0e900511f6e62537f54fbd75d3ed7c2d8ac74a3131b9af17902fcd31afaed9753c0d527bb31b1a9595b35ee323a36da4f7e2044b9ee5f8048dc6c02d09b3e6eb28c2525299d2540ea5ee05fec616cfb61d183bc482e26c35ccba92de6dc8937dbb1ef38904e8752cd1b41e43b7bcd9c440b0191b2073c860e0b514a7bc56b16fb63848d1d899265f6bb7ced07a78ef08db53dde63ed13b40f57aab65ab9dd106cfd2468a565831bc905076af5e37607d94e8bb7af5fe50e8cd6f42574b50ac7d22d81d097eaee544edf123191d55c5979a6cb54b8e047aa607caced86e73000d820489d7b67475d01a4afa63a68a2432caee44d558f4eadd5627ac1853ae996b08d80a8909417bfeea95e0094b6aae72bb92c9c5e537e028eb4e10e078305feb23edf44a8b87d3ed14392c89b24ea27e4c7717d5e1e306d87b699af9e5391f04d0399b1e831720228713b2e322f568335a8c587ef99bd0db881ad149cf2e7b970fdd7e540cbd2264482575da3971a8fb405d227dbd6b3090a07b036cab0c4966f8cfdcf8236a6e837a0bf30807fbb0e5b633f73102d1e734ca97fa263b3abbd9c7ea6df7696e8c997b17ba50eb2d3ef47a3fda94855a4834d660aae99a53a8009679d43e98a022029ba68657b15ea03fc4194ddb93745956f09174b8b9626fe031627efda463ca44ee75aab073c452769fd69f2ecbf8b6d160f8d562c8135ccdab36d670a7f368da6328891c13f69c17ea3ad001d82362748ce0fd617830aaf4317fd8169c90acf2c1b7e1730099e869b4a10d935f02d1ec82017c06949a9efd2432a3ce9ea7ef49822fb96729015c65b6d12b569701c212cd9ce84b36f9ddc5a27290ca09f037f0a4b0a8ca5261d9cc0b9c1d2d142b4f260b9139d546bc836988cbf25ca3fc98a470512c63e7fe965d8e0a1d018947263ab1df69b727a9855bfad91de2757fdef0634cb01dd28fe1ddcd2430121290c7db83cff04a8fcd02e92de2316f5a434aaf8dbac1712fe3773fcf6e0dab2827b796f31ae0e24713eeea8acd3dd383a3f9abf2566000bb8d6a7c258221d5e794eaf2f3694639ded4e265e8efc73fe1d73330e89e0e19bafa3622f8d44b7aef59ce9ba383c4327868e00a52069f4bb7fb954b60f3f9e1f2459ca576cb2d4fc437ee5f2a5eb4f5d819381986957300d6d8d67a925f0d07246fba618d65809ba9cbabd3b07d9b39d3ad161328ec928974d01fdf04f8b566ccae74df20c4306bf025bab5f523f4511940df27ac1a73397080eb034af6a654d2f6412ceb12e270904f8e6946a880a501fe485eedbfc1cf447cc68fa0ac268b56a35b0760f1dd49bb3855327cc19b7b526956c15004ee78aef354e37a74631d0af491e69a661745b8d86cb5ae35af1202fc87b35ebfd5ec9bb78ada45051e4cf51c8feb46b0eee4454a972f955d57c568dacb17684b0f929f57b54379188ef30cd25bbb7c097702781dae37198e0f07b41ae819314f4e60143f4334ac0db65e0c6b97e4919adbd8c52b33b4646a9ab32ce094f419ba6c8cdf1f882f4dfc86d6ab226fe6f6584ddb72d7429b450749d6ee925394af02f171cc98b8bc99eb2bcff87644b80f80aae21c0453d010733e61e32aec47dfe499c3e5a8f50781c4e9e2de64edc8ef61e943ee2992a545f8135e4d7db889563ba6904cbc80ae3a4cad7db1acd6d377e33fe835e5c5d5f0b0d3efc9e0ea31088ab4f6f10848a0484ee5d5d3d5974fd7539f8f7061f14b95b25dfd493c98ac01b7f2b506a63bc28ccb47c7f1c203a9bdef3019d7b69575b86609903ae9c935f002a55429f0d9d989b90aac0c8b3b504cdf6c74b4ee9311e02bbd5354039ef380d53cc816eede741796a47b2f55b5cd557353c94931b8cb2276c4094c55e356af45596a1f0996ee1c7648c0e7584a295ed96146475a5e3d9143e164b16d43458b7d9b5317929f1b92c07afde2244f426f10b7ddaaa9a48949071feeac63b64663edfa412f7d24cef9bf92c4bfa6f04219054d1ebc55d5de8a8c12e27f2c72139969058544cac20b62de1186b0f872811826f0c518b8d50e253438ba1f5a0ca8f14e2fdea987173080a9103d00f0f37dedf71ae47c116b2df50a960012a9a9bb4fd87551c82a561a19f6fbc0a960210166b22cd1baed0269d4429c1ac812e5e35f23153c00d8a25e775403a7a45fa9284ccd148bb8af4f346d222c1748ba84d470affb741cbcaf68568c0dabf5def731a13abfb81283a4b41e59ec311e256bba51436848ca2c47b5531238c0388beeb48e1ded15b10b2bdf7adbc045aa771f0bcf916d98c1feb4ac7bd2bdc7f13927f3e88b8f12705e9cf74366c825ddc04c957c4f1dd3d5eccd15568860b0a75d424235b6be0d96e0d8c7ac6b475573611ddca17dd73cfcee8a1f9da8249e37e909e2803f8fce0261f73268255b1f2a14427a561f4cff92aa4939af40c9fd70816c75bc0f8a3c21f1d99a1c50154abb5419b56fdfa8494354264284908cc83bd8f1a72583be0dc4a8065b35be4a8e92705b2c44891bedc2487d5a9c877979c213ee61da961328caa8d9e5633b60927f3c16cfbc1f28c04be78913667b7c9968817e126c1cfa37573d70af315d2702472c262789f5d430cb7580f4d3daffe07ad478e2988586cba6a2d781bf7b4d39d96231ab96432c150924fe2eb0aeac8d72794bcf1f21405040d9f1f65b36a5dd3be6b1d33a6ec86a2fe995d68892707f6497ed2e46299e342bae2fa8dcf359b012e54dede32278386e946bb0cf19daebfcac4bfa390ec394422c28e83c368bb98b0e79df45fa19116351765729156798d7dea0cb736277e10040325366f0e74b8738b097e704bfc0824085c5d78e9b25281c54baaf88cdfe8e21f27e40d0421622d676c7e2f1a017ed503a99928924a9874ce378ff6b33736590bdc7811e8a6e1748d75037e7f35ed03c9ff616839d5c59e9fd46a44e38736330107660972d653e7e4ce4991c934c7cda766692402cd78f3d29f381db1484f0c5c3089e29101dc5c5e88ea5f2fd9f985158329968aa2cd071923a15356f74733ebfea4dd54271782d7d75e278b2020501e7339e6281286b52ed787c9441e3399789d17f6fe114949c7f73706eab5a3504aea35b744d3d82200335fbcb4c5dbd19fb0712c9361023d5bf8cfd62c0a6eafd9021e3ccf8fba64f6dbbd161c8e86cd80d647479d7eab8b5fe035b4c9e3bbe1608bf011ff19373cde12d0458157b398c3409304dc7bf8e2700bdbcd7d625c30cbba7adf4ad59fced4caeca238a979725140316526635927b24d0b6cf27c963d0ca1951c0dc53df22bf10392454658c61c5e3bc05a9766b7ccfc6fc3e043f654aff762f715bab3ce0ad6ac8ef09837d76094cc93ca24a3845e871e39b71bfe2274a8930c5ba12a6f10ae8225e29f3864c6aa354d1d5ead802e8ff69fcf6e5d507acdada69ff3a3a4e7d6f6cda72b0141de8d4ee3ed67e23e22d035346312b8a7d31245e0fa46c7660e49315dad8198281b211ee2a926fd8ec0d92b454ce8c609dcac2bb8210d6cd79eacab947ac081ce1ce7b6463620ca67a732cb17e5b9302a0d9a2fecc829b3acf6b15f1f7afb905a2ee217a3287d635183aef57ebb92c917a89943f6dccfa8ef0c1ac4d0aa1d8071ae75d59665aa98634c46035a0241cf45f553196ee04b134d386917010c3ba4dc9d863a50607c0fc4fc2d57c17f8a328b5d42ade99d14d576723489b56d70e772d2314db402efe00dd7b49cc65044ea7d19835eb22ca5c9e2532a70fbfd7962c7b5c54002e251025021fc4775485a2de36105ff098a95f205cb029de5c435a40c4e9127a51966cb2d899e16f285057cc8dda5eb71e5e7e17a8f872e7f1d72dfe472c3bcfb65bf7de32db15104cb260be78dcc08f20ab9ae8dfe48fbd7cff669d1766d7f864282618920c3ee04cf8addbfff57f7a43666d4ebaff9e240a6f17f0e957389124ce0e2510e3590e1a0d749fbc5a01c20ef7232b3f9e21f3ab3e5913b4e8935d943edc4ea014e2b6f42eb3012a976ea97a62e9c43d4fd33820e9da2137d61c208bf9b329b66981fce35780d235e5710e8af15fdca7824d1eb3ed996c97d315dcf4f9d780e246c593621be2675d37d2d8a7acfbc0b1de23eb7269bbce19a81b6411f2ce2ef3ed704a2c2dc806ba34c98c7d859de8d44c5ee2194d73f1581d670957a205b60639728415e4280c234e6a8310bc5b56279ea0f63091a4aa118a32f69dbdc6b2a8335a361b4a968f8fcf8405cdc6987937a9fb8aa0bce51dc8b0775bc5f9f791cd8322a915cc450b6eb979039b2e03d1ad9975cb10d3cf9f1bb384a669ed059450053e32c5ffb81d29e4caad86247d9a8439401eccb06d1057ab30cf458c47c247d05a064ba60ea5549eb1b3c8f47a3df7ba562cbc7aa111ceaadcfd376339912b86f58e7c72e6c1241df4743a32cd5bd6296b34c2d9f87bd63508c98f1735850b621eddb0d1d0c444bde5d2b1555ebda3a235d0ef0840cdaf200dd18142cf9a6533ff27f6721d043b24cec818268448f0dd9518d7378f8e9ec9c3055501901c095524e244b995383b2aea62a04fb26c842d88c33c86d7852fd366f2bd73fbe41808e1a8851c2fa00994ed2ca3822056b852bfbc73b411c6a1eac825e34f0d19199c0da6b850fff9fc286fd09cc8e3f32b52b4e91b9142806b02ea957582674123ef624227ed64be2d919f5c5c5d4c81a560ec3b7b2bccd5970fdd50b7004eb2598c3d9d42da71e0bb1cc681f2fe23909887fa2437a355e3b7f146fe965848cd02162bb55b0e27fea34f6499e82ba5a8eac7cbf2b8ca09f591ba6e32f736706a0dd24c025c62c044a60978cd0458f2a8225cdd7106bdff218fdcae2c2fd99d169f3bfe73fe8fcc16d42aa3b8fe333640ed90c122146c088dfa0d7af2623bd46d98c44c2e7e7b3d0fc40e52387b653286c1ef711f539e1d86ec98911ad087da0e982c7391bcc592cc11dfb0afb12b41e52c758dfe93cad3c88814c5bf48d77a799f8b0b24d978366474237e5aeecacb696df74d453661be14f419add9b1b27c4ce8d3ea6eac3e6c26828646997eb4ffa9265c68947093eed611a4d85f9ba285cb827289d6e5d0d5b16bd2fbdedac04f9afd0b25ad9cbcc92953c0b7636f04544c03be4c54d137d0c2c79ec0a20194e9ec52b8ee0bb204398095a5078b269c2185ee4631602731a460323542e9bae928b4858f652d945ffe741b35f8cf693c44ed41a5e12e834db67b6cfe8e4932adb4fae451070e32000145f1f2900d27ea7ec32d2d7b74deea086c3d1dd1f34cc01850fd28a40a012a2b812f5485cb787ecaef4af54635668333979f55365ff3350ab76063a77edc553297f39802cedc18f62b2b6ed4371d67c69ef68bed1d5c187d482a6942fed6905e3819610cf8d3b4ea32941b0e9dbb05a008345922db6265c5614e3281dca601cd627fe8f26c59f02ce1d9ac794a129dcf3f7532984ef72189901fae6284b22403b103f3f5a4e8c47f267d311b975e69f1f52414ccac4ab509be84a6e877b796c7a4a2750b00a285ebdcb3bfec707b6c25bd93178665dc89ff01832e5f24230b0e9aeebc87f8ef57e0ba925a0bc0ad12da634a638a6a1cfa6697e559d25c328c3017fe3e3dd7136553e424186caacfc71aa18c84baded55499ea5e364968fa0cb1f2b4d49f4fa464fe5d95e2cce51e02024fb5dc0cbb54f9063997ce9bd38fbf2dc2aae23f739529701b8dcd1b66fc3214ffe3ef610b715de2186cd0b6bedb0ea7242dae9c0e8cb6363a6525179400c7acdd22cec5eb8a82295f2f58c0d0c45aad9afd61a63db0590a171b51774e38fe5e0e95abeb8d07c2a647d37dd5065883532a2601f04e2cbaa920e5cd2ae6de2c048c2ae6d9780843516d6eb31076187f484273e5d0ea35596bda501ab7c339f531d71d4f189d86da74ab90d6f6259c8d5c24a8c39498bd866e25809c3fdb8e8666a9b991e08b35af2d8bdb19e5d88277203688c63c9500041246e04067c89ba4495c7fecc746b8d26b75e08bce45b6cd7a39f9f1d902d968904e5b2b0d5a344be6055b4e71352025722c67593634e88ea66b62dbf2b7d323aca470dfe30c12f53bea1b74ccbd93bdb541b325fc225e8114cb22d7e6561fe001b53a1f212ea6abbfd925b45c7a7fccf03dc4fd8caf381e07daf579e0df00784ae00770cd6cc911e95456bf1c0b8fc45a10f04210b03e4cb5ee273804d01c959e4cf6c6aa803fef0e0396971065704e041d58a957b20182a301572241b6fb725b7763c6c2a49234e4b4c39128735b01fb8236220e6f09dd8a8e9122bcd5cf54718cc4f4b52e2e04eaaeb5d3f02e802763587fca1bae06c5a3594eb7034c8b28e59e0e0fc656fd3425b6826b2ccec0a381d09735954054c4765f1b5323c361af3cf6458624b6b5076883f2350be41f5ab1b80feb43dde3f1b2e2f29f59c4ee9b2a2650d4fc7765080e3649a545902933f5082c7f39da1614dbb2d94e986ff9778362699b409a303f44fe0b9d6c8006e6ab49145b17dba34d698a3e9d8dd5562f24f53980ca6d3fcc607da0f6174632921d41cfabeb2ab2193a11021b8846f401f5ffc8f971cb4e9464c7b75e644074b4fa63b5d20109010265b15f0288bb26d1d654409942f86cbe6667a7c5c94351a705dbed6acfab9ec510e70cab26f712d8d1734d1bd3dfe61561d5818b0c1445e1b32ce1409c078895eec2cdb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
