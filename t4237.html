<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"87f4cda185ce87351837cd9bdc8e998615db1b8775e76287ae4809002849e51245916afb1cd0b6df0091ae29eb430619e4765e607ad1aab93959c8aad9c6098d5b3c8b961b7b7dc5f635e7065fee2f670e154877df3971dc4de10898f016ad39d8606a4d8c3f402ae8703a3f1e96f5438aae29271bd53d78ec8c9d5e2554e0de38c504ad027f36400a055faadef55cb4bead62a7358652c41f7f856695b3e930db7e0b6fbe49c3e8caeb93426f5472fbe2ee8263f54e51e2925876e76cce8121c9e6af33fa616739d9346d244a475b1bb870890ca84c4dd1699916ea72108b834e1c19ec6b963753d12a914332beca46fdc7b4bc0323c4b8cc9c4d70f99dd0bee3e2ed75c48f5a60188056e813321934c22abb7ce295910c547743016700565a319955e55f8f4fae722c18c41a92021c3f476965b3eed5ebab252a73b71a591b076daea36d01d94c43adc99ccf16378d922fa57b03ef95c324fe543e1b9c6105556b2330a00a7eab58fe04458d70b913f1ec66f544295138f61b7f8c9e0826e684313fc533d18032c961654bd1a772a1d591d9d239b9d8bebf716d3429b82e9ee94fde4ec0803f2e53a423cb4e1ad99f81d160818278021f7e30f3fcd4e4b39f0c8f178af9b6f6a032c89216249c5f9c16681040a1406db3f58e9151718d915231a8b5c3d5ac9b56f3edf0a76fb443ec49c2bed954fce67c9ec2d44cbc7ba43d796927a6d4ee8b5dd03a15a478f536a0bf384f059920f1aa885a4651fd51c04e1ea83c1b3f1ec74c4fece30a8d3b76fba4c7b142c46bd27f26cd8b061340b1a45b67b85d1571060162a521661f13a97090c4f6518f7e100dd5475f9e801d200fe24e4072f4982ad9d56ae27c4511107330e3948acf00ae47d5b7871405e766b3d6f59c5e8d37f026edca090ff651b7a11d5e10ea993b865c7d5a610b430a71c76e8bf4db04f4a7d7eadcb6b86e91dbec1c225e1c535befb17f22e91ef43b8604f0d6fccaca47874f9cbc8d5f9e3ef8b627945923003a327553716dbc5c994a7fdc0da7934bf68715605383a8443fbc378278faa22a31a49008a187b2b7cc6fb9f053adc0f298b1f917eee1d7be774e0b848d71f4aba923ebe8ac704c3d91c29ec065f565b5a491a720696011281096b7bcc081faec8d7e554490f74a823e4ea2bc8fad1b3f359a4a31e748d520bcdb5ee692daa7547f430b609eaf2ef24cc2551f970ba7008040ffa6ea2bc1d2ceeaee268492e61e9ebfc9555d10ae48419cbbd5c276971f5af3a44e7b7193a2fca096453a1c6dc76b4904d114a732bedfcf07602a047e575e7ab910943a956e543f9f8aa952b39d9ef77e6792168eb763b269229683a659d2fb48c4e94e280ab976c47f3da3be453db27bf88033450649846c78bb0482728155d30b7c82aa120ab229c322aa74b4b8e36a530b694f25197b7dfbfda031c11313972050727857d06230deb76e816ad4ed6d8155aa8ac58141db7fd66b469da8b241140b04b1d69393022cb5a8b09863c581286056b4013b10bc48e07c4331994bcd9980ec394fa6adc41075262e9d57f5adcc3113602c9fb3b1b3bb187f4034e62ef0ee266a4fe8d153eff11b1e1d21fda513b3fe9c1a33e3a43279faf82f8b12a005dd6eea7a9debbbe7a57f9ae5b4085b82c99eebc794ebc4dad72a2c4a31087fc92c9b0a0d428fba1bfd68d40319f4261866d1c901f56e73470ae101f4e471e43603b0fadee0f50aea8cabdd5f5ed97e98eca025612345f614251415e3d3244034e355d1c809e786714677d8e403c45e235c9cdbeaa909c7b5aa8aa2ac5317927f579ef0fe4f758defdc3de90c85db142556507105e545819c4d5c19726dc17a1c54b3c274f78cb55a9689eca3da5d79a63308b140ba482f7f202f610321164cfa48202bcd184ca343ff0f51ef1caf982675086aac6d011cc7ae7a477bade4f3b09bd068dcc44170b6c8a67b705071b6906fe4b3511e2886c4a17ba0ef428cc108dd653725cf74da88d50cc2186836451fbcfe6869a7ae6d977be38b95d079182c3018bf6b9026e4982f8dfb69e089226d45664d59f5564fea5c94dd21850fdd8ad944ffb3845e39f4c323f794dbb6a41b8140c877b38dfc8a49f101ab3095383b6d6514ee736f6148fcd4fd955b06547fa19514186dc38bc8b944484dcb0fb3f50f2a45f51f8377f1e780ed318c7fb33df8a78131518bcfa7005f00f68a31eb45921d41245b729d01cae95607b259f33b3abd3bfee07ed09ae984a283a012f256c323199f1b358d246e1aefc2e943b9402898d6adde0e45e052543e9ba52cc51ba0e39e16d5f5c78e4f096c4c24a8e55dbb3c8c40b3be0343c44ed72bfe254764bfe0d76e4a64cd0e7cdae91c08bf879b99918299c60d8368c2fa4b63d0eb13425cd88cf8dcf73fa90c58322d30aed1e64fa1a73507f1165d3bf50ad0f2a263ee6c1e78b3661f05456d1144344fae81921b25cbf8b662c7d0f961545840a11b0c655552ff65332b9f00281e215eca60bf7c90ba1d8bf961d7c60b7290268056af51df510c6cdf89c34069caf294f58362a75432c6f93246fa9b1dbca12a5633a5d1a955b5e16523cf1ec0ce1752d9ec9d0914e86265c6f25048f4996fcff8b70a12aa53736572cd572ef3268c097484e4d4e9ffcd147ebe529757e0de0e7ec11a028acec924ac091a910f18e3b43e45d77aebd7b484d8d80fa9792b360a98d62be39e53f97f4b3fd42693182ca121b72f86d85da12121ef9ce2b5560d0abd3a3f475b2042b4951553753c2660214fa8b7b81b588ea7d7c7daf390691a77238189af686f615f1efd2e996ecbbbf8a6f895e604a0c9b00d087b1bc3f63630c673d66e793104c9db68d6e6d8fd1379b534bde0fb1df75d9f3b18c60b891d1d9c8a589ea8e1c6478bbf33df3446dc79a5fc6f1c5892649f2eb15b742c959b2d44dcc4de2d6d195b9d44ff523056e2fc5db4c8d3ea8967c1f09feee520ec11d6bf78295d5a46cb4b3f5f9462b6e7b5bfe323ce7e567f017011862860728be633fdfadbb95912faac9855deaa27a20bde3598c4b03d752adf23daa2c6679d8803a2ca9a0d719c543ab7a80a9be500949056452e4730b47d365f25a5e3a422862b9d85d60de345e97c74c3d9811bc678fd6a4cdef7e6f38306cf7ca17c69b49bbfb201d9f0eced263e075795f4ca3084c4ac81a66f972da4ec2d72160edc4fb4b093ba8bb7c77af4d90c0e70e7b254b736e94141403de5d11c96a3486b807c6178c33d8d3a32e0f542f4305b429d0c2b1a2ce96200e7f06e23dac2095565c95950a5a1db806d1390c82a25a88736047e401c71cd4be1ee2593f7bab4b76239acc93f38260e13dfa6b6b5fe0a97229adb26f68c7a9d052cc128c1faebd0d1935f80eca71d036da5546dae03e1f88360a15b8782ba34e68c8d4436cfe97bd30e2e81792b3fb0e9ccd22a15c378e62cbf7a18b8e2eff1e1d3f5dbbc707d6e3b35f54c1dea3b76dc3f6b1ff94fe6134cc9f48fb6c83d580fa6ec84a322b004934e81f326cded7c02e64cbb0dc2a55ddc0ff247141a41aa97779dd360c9fd629c65c4b7113ef5b21c87c49232f97053bfb708f2500d3d0f715a0d479f953015142bdb553254eff14f4e0b0ca5be4072658a66c56319a2f182852e2e33dfb781effeb8955e49f9e9cd9f4b5aa1471d4fe817834ff6aee5bde8444684d0a99158a54575cc1467922fe84ca8999595551fb4c24da81d2d4c105c12092833ec87f5e734a39ede1d4b0bd38ff344c18a9f5fd744aff4fbd89e1476b87e80693bcbe81fa732388db57c4a5f3127fa66d02462e58d5cffeb0483dd99722f60252b07c1c328e44200fa17c13ceb7cb8f8dc32e102b0fb0e0c93daa209f4770d4b5fc94ba0847137c0d1da816bb73274c87a8e983fadb03dca21b65e2209fa17c76c6f6e001738bcd896ae17532712416e9f178ad865fd4c4e75c553b1eb261215ce03b61fa418c97e32f2a014d3a30d108755f285788b07a625a770f4ec958f7239e1a0690914d2f14ae57eb152df2b0c8a529c0d582641cc762f352a4e171004c65c1f986a36c650db2ffcf136d1c2845f711c68ecfe9ccb0aa98dd27f1c824ccc0a7b09416ae569b69df012dcf4641ca8f4af12270cb3d38021dde998b2ebb6987176ed8de165a890c4802acb1c8a9ed7520623a14c7e93797af6b0b024e828c7b2f537608826d2623b124d72b070c564b08da8b4e72782a651d2fdf64d5dfd17f2a6efe154d755baea02281e8b17a84878c6c108ebb21559b94e9bd24823c91e1c0d39e2b430a6f5dc2f37e8a7675efc04a399373c186a73fef424bea7bb1f016056e6afe0fdb0fa7cb3a8111b07d3407bdf099c07f210faae25fa3d4a44232a5ce852d4f7fa07e4620ead8b8178be1b5c0c09be4470b0f8e831b79d51e7b1e76b08e5c7c1a5a4f58c0fc162c274a82bf849e0319c267c21f1131ca59b634416e13a1e077fa9b3f4a38c1be0a0480488fe1621ab44f95ae328c71db1637c081ef2dc322db9fb9928277700a8b87f6dfd074f055a7a90ad8563abace5756a983141451809ed3ce26f454f21e880cdc0740a064e9d0d7d2bd2482367d479c5ff3a98d19c55e0cb39173f2c987374a18985c9f04b1048b7234206cda59fe88a03eada368e3b09e6feb7ceb8d69c6a28a46d4bedba63449772026d3bb96de5b57cbadc62cab414b264cdebcbb57de1e53840da463c4726c2276926ef92fb17649518af91547540dd268370044dd50b49d4e0336823b0fce7c32c244c343281c8fcec0b50a125751b4db8b54b9a5b1fcaf76b668be3c818d013f9adaffbc1943aba3f42a1d2b57b01a0e6d68ae3a945c57bff9d2960edd4c9bd2224a453d29f9da9d9b91a98399515dbfebf8eb4bba6cd01dd75becb3f65107795a3bc05dff2d35dacfecd104f2693c05d5b2134c977700a5f75ed09c7efedda32770f3e50291c91b1e382dfec5747c47f22b1e8f5b5dbbd2b5136461d6f28b4e053f5f88bbb28664bcc025d7ae74ed766650dca1acdda3048005137051f5127670fea6e29223db02a82a30a2c99ebbbed1030b41ba5fe7e572f23d1970d6275394565a11cdd41d4c68c45b963d1842f7ac6b159b8e9182b46d2e31342b34ced653124beb26980e0d6ec56277737168b32cf8a902f2628d6ac104f2da90dfda50be0dc312fbc759e8253c2a90ec88257fee8e2aae6919331e07566aeff9af080eb516c91fe024b1ba8cec03540e363b5cc97d1038d1545701f32226a5b65b59edf451a069d4e87b58cf439e9dbb6a2fdab49a227ad72c7ab111c5e824f9967df41a02aa52f279fb33e881ece4b580e77c3452ba499b7d501de75bd27d53d1d342f2b7356ce8359fe9475c31d452d77ecac3d28e6f57264ff9a8838501146541cf30ef7e2feb996a7830fb44721a65ad2a080e1664299d7f95e794cb23761183f1cddd95ee9c609db984784861a8d3507fe44a62afe6a904523e92b46e4ed7eb8676e7b48c46e3123ae8a3505f9023f6ada00a4e82e38b8ff9b579885ca2547bf81f773cda29e94d7a22160f2f46dee990b152caecd85baa897b610f3fb4ed90256999b8d66c6c364dba3c4e5ef834269a2d2685e3e8d240f6f56bf9a4259643b74a6cc7120741e1832538c9e42520697be56054f2a7f3e3493241812a9890526d7616cf39e923a030dd1992ed0cc004bf34f531f56a8923d8af9d1fc72d26a5a876c036817dc7799a4aa024ca3dfd6769d25f1a61b4135ff32becc8d6d7470175994d1b704c344a4d184755f82d88f6558fd583bc94b0e9452ab041ac7bbc1c57f919dc31f5909f80b1956389ddee0139a3dac4f5e0af4ac818d82fa1d0bfd2fb9794b6f7a38af0b50471cfaead1403498aa5b1ee12397bfb726de18bf6cec304091a2a52cd49446705ce5a812a8bb2937d771463d3c1411b3cebc2378303dbeac76601714cdd415388c4f65b6edaf40d30f28e52e6cc1f28c30d8b56796f75f675c8d2bb1b0f98aeb884f74fa69a054913798f2046c13233b076ff8e0aaef53220b073ea8707d662dfff20ceca5b382d06c5b996eeba654880edb2eac3581ad93a050590410076bd3c729c011243bb85f36431e7712fe1015ddee97e4880c1d02085c4b14e95cdae21a971d3cf451658973625b441d8fda187cfa4c97243f2dfe56d1c91a826d0790c7b396422e922a96590b647905915f1b74d84a5a0928204447562a9982964728ca38cfebb78f46ac9cd9cb80e6a29c72aa02f4a864b275e0901211f967a8dd642e36323b24b5b2ad623aac803cdb70e1930716725ce6c3a9e4c85c83b126af76d0a9259e5c8214ab9b9cc49dbf44df32c7de077de7c52760a4d601a95d4854b25b21665ea34db6344916867b2d683bf7c65117d99ccc4aa8ee73c4ac5f875c394614f83052541ca189e6dce59afb7eb3a9421a63465b14aff360ea183994e996d0c1639824636ec3f99dcc8f170bec60dc26026cdeed10556b815a8ef4c4c9bb2902c85cf5557f887abc71db95ee3a3e8ea46fc729f13517f265f1752dbe005f77d0b74f6aafabf394aac3120c3bb53607622110d2442d0f75b26888388b771940a1fa23e416aea1b3613286cda5a1a634c9843bc3e30878bf53b0ef92452ac8fc9a1fa19bce56f962ce02374da351577ae491feb753fe10625e4dd8ff9e1ab81c19919707ceb10da059c8ea062271df29f4257c60ff0fd3949d7bd406e7caaecdbb41433178e014d12e1f74a0aa9d6b5d96e13fc11168de8de5b6d079d0b1898b4f382a90ec3acd9c2f04db28f47d3dd63d376ae01dac3a2d37e3d438b3ff971a5353d1a331e245eed9491938b4838ea020cb7d019f8cdbc421af6e2b7b2143057ef7be8740720707d35d9b0b26fc3ec8ad4d74594f8ddea026d4ad8373db006bc97baf993c922f90df1625a4b2df813704d71e7cdcf541088b45f9276293ab8aee8395a96950783554a0c6e1ca1480dff06353a70dbe18b9452f7b305867e72b9af08b9b034420c4eb38e19200cbbaaed32602c211770bbe426bf7e5942a47c5ff3f47a004c293ebae6cddd3a4659a2cf703b1982395bab313d8db643aa747d5819ebe9e3c8b4233078a034a5475c7acba67e7c1fa12f7cf041ea89db1acfaade2e9cbae4c91bbb589049cd9903b1d5a480d950c86d9d22247b2b61df953003756db1a37fb2e588d7a5bddeac7e4ce967d16a78ca6a6aa711a58345345ebd5934e689818115c33432ac2565c54171bea38c022a2a74f459fa98691e2b2f211c4d6aed96387ad164e0b340719e2a3f25edde664b4d8f7241256fb23fe7d39d99ed3d8738d63c99ba3e736688126094a76e51842489c1add9b6edb5c803bfd73834028190c12e7d7b4c00b1aa88031a6ea504fcc4ac20fb923b21b458b9ccd6919465c554794310f2a5898de8ddb86e02fa315a56b92800b2cddc1d230c6028106a33ffe2e6172e681852c76f350d2943e71f1bae9a4f9069dc65afae06e288947637a7594e0606c8c6f1de75c4fb6b694edbdb1bc3b23b5e58bd4fac1efe116e6f4aa0a59371d7d0c3a1b7534545e636c2664025e65dfc433ad4a481cc6c889f5fef7fc6c13ecd42757cf25bec9589a24d913119b9deef2af8098cffa62d2b480b1f4cccf52e9247d28a8771e09d2b47058fe156a4ffeb2afc6d368665afacd30b48f97c2c71256cbe5b3e37044dbb6f33438c152ea945357fe3fe2ccba9f4a7e70dc3083f5bfaa035e2b297504e58ad61d59f624de9b5c3291447da0cf4f31a57ae51b7d8eaf1ade757ecadd68679ec46c0676358f0467740c2010a4156ba82295bd02ac2470cc7d351f25d9405e4b9a5d9682f23947c7e2e20a0cfe66cdbf08a1344b836e6ef124ebde9295f5d94f8c154637db232ae9ac3005da1734e1fb93fee0c519c122337d66cb3626356aeceeab85fb21539b6d8601794b0e9ff6406dad12648876ef0012ae1e3b05ef8e6072da3472188cf9e522686ccac7456b8d468326ced80a6dfb170dae248b7af38ea1fec8b5b7bc659834e60a2b565ded9801291e9e709bb36c32be3dbae7d41b7288d7de00424fbdf9dbd183d9d07accd852a8c93f9493a720624b643c1cc5efc70793fd62eb8614025f0cf870723d6e81ad63ac1ad5ae4f1ce9f14f571aebebb0c31a97112e4c29e13a0bfef6fb78c299677e403f49ec1a092d24edfae3479cbd1e5756222b0275fec2cee502ec3fdb29c44522b16e69139bd4ee7a3669c0d233bce7133e6f106c8f54f7c01e99b25e31832e5ba553145b7bd650002b5d46c06e0027da4510e55a8566f50688d8b1a4a811a92a6caaa87c0f2b860020f83bf6da9328ae024e626caac8227b1f3b2af97b5e3423f43875e0dfd224f5d7fa261d52ad6bc55662f48984a9bade28f8edf9d526e22df6347faac75d8fec31289f6030b1e7cb93862a2049ee48b9a2c09d9421caad1a46bcc5203a2481eb220c3930f9d0c3c7f8ad5f2c2bbb59331183b23542e05e596baf4efc96e4cf31a64921e03d4285c23db4cfc58c543c55a2c005b98b3e967beae80d8b83913b9aa47f4e377819c89701b3b9080ccf6ce91dbba9af95c867e286b21e9edbf111ea4b354c065e02f5eba6a68975a9de412ab91e844e21800b00f9421b763a0a75569c9766770ef5098180dcd0364abc5ad340d3e3b7be824e23a1f3d624e530617e6190f1281974b5c2a10604f8755d359a09874e3519ec4ae725e1193cea474fa1ba5428f8fd38a53d75188147c5fd59a764490a902e60a2d4276095a6c6e2990be17dba6742459786fe4d98c4010114e2de9e564d61b4b70d1a63996cce66e5173e29bec2aba26a3304201d9d076dfd0901f9d4d42d1a76294ff183bee884917048763e0962aff1524082ec1e7c7678a3194ceb97435e0fc477704c84b3a0a332a395bd5e4542fdeb33217dcfcf2dbfbb6c331039eb87374b08f2ef312f596061ab037adeffe0391f8342541ed7cac7e5631f825a95a20c302af4d45baf8470b46dd2e4f59539205920ef537e9e4c2c8d6758e407a7f1ee86afa854247c078c8054e12e2ce2ba1a3429cbdd14dd2b6986ec4473fd046e45f430a77a9fb22a196273869940257717bafbec962a4dbc6f717a94d76ac27fe297a8f8e3e99d1a534333a1d72bdeb1f6d9b75fcfd06cac0f5cf392ec5d1a65601002f98950a97ef9643ca1f9e8a1dbefd3ca4fd5f04b70dba126d257c0908e63df5889a92b6e10303498eaac9bc7bb1cf3a1576d8eee2c2aa9a96e4e34f2841f7d3807126e472b6a66581a4022f19dbd8a7b9e9ff3341f51c61be211648a6f832fbb1d0a81863d07af246dc09fddc3aa98354d3b25282b2529c56801f98685faffd378014f5fd854d7b99130b2c2320a12cfec2e85fd21fa6ded493bec11361410f306c04c19ee2a305f541dcce518b9c90ed9ac32f7c701bcf3df6dfd51e3abf5c6d99d8aa4011f169005a6cfe5f85a6d3d4b1842a13f2cd7c068202bf402dd5775386029e0988d53f517afe43692c560fa82331066abc2d4fcbc2964b065eca56438c9c57f7738959d93d87e4e334af715c4a93beab215baa13d504c8861f255aa0ed4615c130065a54399ae609b100f5032ab8106d5b19b7ae45b7a2f45664add8cc3d06f1b34a9a19e4c4267709da81848b5b253e0170a02a0a4fb80222f1ebaad1a2717f32c5b176f96b94bc15505047c520768821f258af63c1b353df600daf5feaf550746034ff9511046ec087d8db76b6dc466f5d2e107d07387","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
