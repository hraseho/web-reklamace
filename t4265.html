<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d413a441cd6ed9e66494c6f16be4d3dccfbe74649230d7a5606cd42593cd8575e987788d7caab2df13adcdfe63b16c01ffe1e69a5552c899ff6a51b4b85113b452e5df972851e3157499aa65780c98d638ff8af75531beb5e9d8b2f5726660e66d85c724593cb44313971f18c7a379eb2988ca2bd1ab5ef9c38b63df30f1735f278b463f86664cd1290aa600c706701a768775e620ed0ff9c4eedfdfb0a6385c6e63f23e852368c934d144735d364424a3bb085ca241030c1c8ba7ab0116632941aaf40c4a21550f58d392b1a60b44400e0c374239d72083a891f8399980fad4bd9605bb8ee1b468d4190c7c0d9fb20db555a3147f4c9c3df0ca87b948d8a41413ef81439b2ad131c0462fa219c5bb3785f8117c54c1824e1ba4858776b4cb60c8c138630568058a9be561f394a9528e67240390e900a561dc529b62af129d7509827403ed33e8aaa90813dae4441c26c45470dab5dd1a770ebd4e6d9a18315ea39138647cda57f215718546ba7d66ddca8df9e2823a58c98ef883fa6b139ba20e3605efcf3a9a982ef79cad55475af37e85705b9f1efe720b4b64d7d59a545cc3d7c25fc3fd61ab4ae664d6faf485ee2ba9646b1d2c3506c73736182523bde13720b3a520537bbed9cb2667b79cf6238886dccd4d677bf6638bab49ece14a9ae0dfa6d2ca47184f31ab9fa690bd6278dfbf56e775fabd342fe14acc8c6ee9976ed052735f9c7978fd9edc0bfdb54a7a3d3d95d5106a3224c198de06897daa90403039c716f9197ff0e81189bbd1fd667e4af51f30123e7594e49378aad94ab60ac61ef0579e5e4a60e4c84d6355bd7af0c6fb1bc313221c88bb32d8515adc5d13f5dfcd9603d8c1d6bcf5490ceb0714c545a34c854ce921cd61c6d52d722170596833d7350801a99def4eb3014db7b6813a12949fa5cfcd69c99a094ad9e3279695aaf9907949087fe9e5e4db23b3acb295bf742448db8eb306d4f4e855976940f2c645f5c9610714872861c4b9d7763254ef06237a6422dedafe316cc28889157b0c2536c62b9cb5f7ea66068bb3d8c0964beec1c6eca66d8b3060d5c500f74064ce914ae77bd1fd4f2ef105671daba274dd9e94e5a29f06504e216bc478bf4e7bc07fff9c112402db793b77092fc99a64adbf3b2747f84a50a6af5d96dc32ab9e8c0ff466bb0790cb712b8693c77096be336076592ddb7c27efd7a3f065f9d0771098b4db31f8e354e6f63271a0cde71e416d7ac041e85618458d11148eecce7dfc2597fa47f39ebde2b19013111e92b6e3496d37481a52060b9c2ab81e178cb0cc668d538b48e4ee9fb0075c853be19040d4764727c88d0fd1098e2cbe7b4336b8636f05f7313d4040bed73c6d7af11d9b553290968d20a0e741b81b6470739ba2b47ddc0e07387ac2036c3af372abc316f60eb65d42586c21c2f861994f9a979c8d8752a26012d823d6475ae99bb4103132e0aa18ace1eb899b84f982283d3abac003f8b4c4e2681a6331586acd53b9dedda730816c721774ec651c08137c51873d6eef68e2da649e4a1e277b3765e8bd08984da8a3e858cd93ebf7d2dfd03c8dc9a8ae9f72c2f261cf8985789bed891ed5cd775a82e4bed12a441531c235b24158a4574d34135fd0d5802eb78d08f58d2e1eced857cd9c48386257e7a0512ca35abdf8657df03b3b71a53e7a19a0fb821b136f0f07a2caa502186f7823b74c61e9e70a626ba97fbc6f5b4d40143b5aeccf39fab561a449e58d949805593a64e8f5fc581b1717d80ff43689ccfee2d0884d8dac61cfafa0969bdc103f4d23a11dbf1e21228335bb7a5e92af79d9d16cf401a9c5618760dd54eb7d3333af3e851d5c1cfca1aba49d311029dfd43b26d6395c582d104d909f34bb10158a32b11a4a1260cfdde6521a46bba92aefe338147618d471d533340b87a9cf73b8e1f16cd0e63acf934d5c7dce02f803bc712dc0dc6d11b575b09bfa2847bcf9ec209d06c6d9718548fa9342583fe21afb995da71c0a7a617a1c786b0a5c6881b0dfbdf867f8c4f1afc227389e76273bfa683e9c81d9700d30998101ca80e2aac3d058a0ba8e2edd4742ab7f3d8a262b3d63ca294ec4571fa4c82539917e46dda5d0a3cc00aa5da0f48e9f8bd5706aac67f4fcfa966a25a58062f743f64e81c708e74db8abdf9df081b654ba0beca7ed090e095c697d2878d85da56255bf1cdf5280c09c094194dd0e1fd62238cfe2989be7c2924d0b13732045c03a13445d342dacc5e3f2ab93f2e911f0e105e7aa755d16c0adb496f163e391eb1027cbfb1d2146857fccca31bc3d7f6aef2ae5d6c6f1d83571805bfad395120ad5bd4b874928f0b5610c27b049f43e817b311f995cd785c91e6dc318a83e459683465b33e92f36fd189de7ef103cf60194ac5a26ae0b7c7140e38731f39cec173975675db4aaa74fcf26a9bba25ef44659d41533b6827071218e5e33d17c35cbe90614458f1ede7c8f270e61279ff716db89c2749ee39a9c4396fa3428eb90d4eaadbc1955835faedea2f1168b9c0c8c2f39758224e9fc0e19d71873244508b8957f93670f869f4cc58aa41860d4dca5b1b13bab2f666a0aa334536e816f5c1494b60d7adfcf8bed00fc05fb95dd745381e0fb55f482b5aa9ca223f719b7af84683a8263478fa15c87db1a5d9831305bcbb083d57a6e51943f98176ad614e499ccebb1bb7820823e816e7d708f27d693a3c0cdda3752261813dd4922ab0eb91579d59a2c25847d9c4525dec7ff4098e8ad144d8dadab4176369238d95c198b0b856754428da45eb04f2c001d5e774f1c168f72d027d426abf57466edeafba820c25d5bef406fd58d0793ea3ea62ba77330615b600c1371512c6be2cd2d98bbb4d8bd97060a4b1f0a5648f341b19f265edc3d8e40675f5a110ddd9905e9881ab68054ab48a21047e15eafe50457b01b38ec7b3aaa277d33c482e555966008cf50af29d26e19ef20d86eac6a9f007e3bd2a0f76831cf61cbea10b2fcb99cec873f3b3b82a09009c8aaa2d69a35f220cb4603f9433c7ca5a1283521d6c7d04b784047db3320c1b949ec3ad5235c2a3c874ef9f8bb932c32321e845ee48d5c9abcbf301895c897583e3f056d5f043ac6c6d3af3f21d1ed74674649026ce66273b68302680c4abe67af9a9343d38bfce6ff8c515056d569152a8a04539f6b8d39c39c9e324e803bd35e95f8583e3059b938ec0528ab4a083a5f43f07985564ed5c35243c53799f685092231e91b9e0dcf0758c829fa1624dc5aa8625544ab0a9a87c471b79b8013d5846b291400a5fa2ba8317722fc703b560af025a34dc037fc98edd55ba8b0d6b6d1d43a58f583fbb8ebf8d49ec3b5a85dbca7772896d7ab161f7ec6f1cbce2ced1451b2ab0deca20a5483f8f1aa2fba6e80375e23ae406b0dda8293d07444379448a9fc453db713b1a283703606300dba699330de1b6b259a066e452965fa9783820c7fc750db85089323f6adaa6ee6601ee1813843b12691a2b63aa007cca8f5981be595eceb281ab200e24ef5efe1cfb4fd7986f5bab07ff9377d2df49833f29ea03e7841ac9ead18065572cd369877b80d53c8ecbd8070562ba4505ca873c477ec4df57d24edd1c0b6e1f88983784a2877a223016baf2ed17c5d1ccacc5045ea5b5c801e0b3aa7ae57685197ee60f7709a9bf162db1a03e6875aa00b256993faaf94ed3b83df3f095dd21026968b49b77462e3e06a20f8809356520296e869897d4af3f49bd201ef1e59877535ae36e7be33574b38171436db253a4c3a09d324380743c63634ac2ffd84c6f5f6322326f16086f300d614aee461d67389d4dcae79f8cdd06609498b41ea7099582ebc63d84814d559038567bc571c0d09f22e352fb0b0d45262c851021a1e928925332c3d0aae5a54babce9bd7c13f6db16c371ad60a24f35ef7ea7314d83c898e62ec58cf4e45003d85c1a17b4a51d0b7616d9176609e77a194e158d9f73d6891e91f1e0bdc2ac170c1fb05ce910c5a078fe118b255e6f519706c0be901f83a26ed1967f4a19397304d200cadb516d8d49cfbef27355fcef193fc7992f6cfb895bb5116f97fcae7f12a9a9f21b26ffd057190907921580387830ae438f126903ec900befae714ce6d9108b9393efdfe5da02f538c96f511774383f76a1c4f086cb9fc17a98ef44de7df36db428f65a4bdc63daa5dad8b788368740a080f9ea24334284aeb129bfa4d0e597e90f12b27dcdac1bb7861937b1e9dde1275679fc55f598a950273f33831eda0f30426412b388a9554f834bdc840d997100041482f3d4996e263b3a4215c2622ff293262a482391e873ad1c37c08bc23845e008f2098587627206ae69d1257002b2da560c76f8f8aad1c6054e8642d286a9d90dd8b130d98587460ffa13ab5df3b7c73e36e66913e7eaff4dcde9bdd614c6c83070c7414c9c0c7b79558126b8e9acadbe0286b782ee3ec72ec362de39a6e72c6273cc8b8da734ab3cb0b9f56c0289b0c96e6d2da146eabffd39907cbe9cafdc588245fd6bd407027fa2801d75f2404a27d03c4b0323646ea391c4da41baef2cdd2b04146da1793e5ea47f15edaf667cccaeb46437ce69590fd4b5ac90aa5c41e8aef95ef0a63dff228026cdb45e8f6383f521335309e0a98a331e029cc5d7adf12adebfeb0e948e37ce632734d08dd1ef8e4cadbe966c0b85e211a802fe306d78a0a2597d07578754e1063111a2538c82e7794861c6bf005fe986d9ffe5b4e7fdf2d0d4f58a07c3587fe6121e94fec0d48a9130becc70f72b10fe379d7ed9a015d894cf02c6c925c4774cdecd8803ccfd106119ba988110c0a747c6ee67c378349e4f7908e772448640fe338dc8627971b187b008621866508fc1583dc9d9e08fd992d97a05a06467943c1045b1c1ee1469fd269fc194a6d82ff5e6770aa88d8c4dfc1bac6cfe36262564a014626dbdf82488967e33f8412c246916502e5ef3477e95f5c753059ebb688d09fafb4ff287947c193b9ae6885084736a996e382321a3443337d237172947b3d62dd0a10308cea3ea8828e4b13e4d21e030d64bafe67025c44ca4a2c2e4d6c475ab826fda5cfbb3882f69e989c01ec38ca66c5138ff13d3d4f1eca804cfe0b2af040971b3c2e14b3e0701a54fa0f085f270f3bf0667a1aef69c8d1b51e4f11bbaf1e220f596f36f3daac651a5d4a5eca4de7426f1c9e8389899419df7c55c6095fdc5d8581a8ec58d5a352d0e4c2b9ee3e94d73b72b45b01235fb64307992c0264dc4b10bbbf17814b37862539444de4687d52e06b0e5843719c438254d8431047f7ebd161a4f6662824740e0aaa5473a6929a3e99b4a8c95effdfcb17c47179ef54e6502bcfabbd40f6c078008f21e3731774c07faae0185753c73f33e60ab5a293ddb0cd33b6f2d81edfa994a15a0d26f24c7e7251304bff490838be44a8a89469116130edbe212c605208f1019f7c345ffbdbb256ce1e4193c209911a639c818bdbb788733933770f22334b3cd673cf37eaf63cc7213e7a053e507e0bc8a349fee9b707b833c9c01020ed38ae9c1609f5863e409cacfe1a2a7d44132c32801082ae7bb3feb919e682bcfe626e710143c17959327a66862e1375a8b57fd2d596e790313d785feb35e12db66dea645f2b13c429d0504ab497906225c11a156f386ca686a3e3c9e6b813977466f9754de68841c4af6c1d992f8e0a99ec9a1f2e3977aa11a0407935f0c2cea50b9340a63d3ce358ae1a2cae667de3fdc97eea1da32e51c0fb45b767e3e0d7813a71aad81744a67611dbe97564bff90a22751cdd8ec04b2293dee1808e99aa1fa854d07d7d09b08116f36708d014a3d044971feec03e72df1ef2945224c3024caa7692bda21fbfce9421fe1d50c10166369a12aaa14cfd01a8ab07c07da524d128a1c68bcb1bdf15a2eadeedb12da93b96bfa21fb6076e9218fd6ca7dbb5f6847e32adfd5f284579c766dbba06dfb15a50c19857e115d4e3ea12c7cd376928cd658c7b273580effbd9ca3bc0f8e49f9e304b7febbaa24255360a4c089b5499f1764fdd11f4357477015972ea420dc2ca05995e74b664bd7bc234202c41856bf532a666d37656da6d0d31935a42368f1d99167a54eac3ea6b4be9034bf5fd3234374524fb1588fc40e5a2627a47060bc88093d46d3656ca0a41de999c77dab9d1c764affeeaef0bf0e29ef624dda3b214b73c8d4df94a714dcedfd396df48307932616640dd7d5677ae92a197bb9ee5600fe4e643aa5fd6c57b9ae8f125e573a3148a48e844047323b1176b0fa8ffc97d15c53c8991083b90a5f0dc30c7a722a6065783f532ea7cd580226dc48112b08c8f6a651923ac5836fc3eb1e427e8ebd7f08a6ffe82abd4a8db9866b529ea3b7c15e2a6ba304197104d78618e99ee3f8df70c6a363134bacd8ed86a0b752798b4fbb9ef087666bd9d54f71aa78b4f10f96252429177b991977d24a8b65926786d457a5cb42928f493b987a5cb1b7598d85ca37110711644e92b0d1727a1fb29ed4361a0d91fb142b4efb4579689f44f2a3aff06c7fd421b21f93e465cdbcc929d8b769fe6c51b6bc89cbab826c444b175821a0d7fa9231848afdd46d965cfa9b2b8e2591aab4cb7e2593194e7a37848798a1ddaafd66e01956b526ea52a26fee8a04b6a78e36d0c0715269e9eda24e64c8f5fa57232e5a4bf45dba10f23af1dc08ffaa4239fb2ddb92dbc159b67cb7043a4e8f81021235b67dcd6f666652bbd725bf4e59a9390ad0410073a281b2d29676e3b1edc6dd4f0d1bdea8bf2222838d6bf82998cce19ab77240b52341375764655b8d2d6018c134754702df188b3e067679e0761f1391ce6ac4d3fbf3ed156f9cc3ef59fd7fe4dd5522952b30fd69c4b0bd6dfaf60bf56a7bd4b7d7f113d3f78531ed4ec391d928c436151abd311f7faeac1621cd058cabe61e8fdbcc6570de58dc98f1b7a9e0312d0c24081c4a6e6681dbcaa5adb73e92a60fd501904c358220fa918cd68b8394d40058a6d65de4aefab434dc8e41441aac91dad6453d8e46ef009cca74b581e42b6b88e53ef7ffdf04d31fa18a39c6c25ccd784c5d578ca2b03cdd7343581e4a8c030650a5d2477f0ab4453279ae683b56850b31b25a27c5db45a508a78c6127f7a698fbaf9d2b279a6933f3402791b1c39c8579b5c656703b8f5ad843a984e24baaadb68d19887d1d83240fcac63d338d14d60114b4a25a1c3bde5c3ec0293b2f21453f3b7ba77957ddb688fcbb2cde71375832cb1fcf859bd6976925e01428f42c5bde06f5ac8c1bd13615c03fd511265cc2df29627f679880e505d13487964a512c038ad3845488aef23a8a4dc80d410024e60d3971128fe91bcc635f24725056d590eb2010211aae11c82ecb02dca5ad8847c2953c07e5f68c474df9bdc780238d0aa2d954e45258301e6f714f40dfb269bfa2558c3c959b6479d10ed55a139d4d4be0f4fa06feb3fbc034786fe5b1abfc751840ac0d8aff73ecbac002a9b2bd4b454b837c2fc649a136d56339afe1b5933b96b8a54dce66847409b9d7308d722752c977adb13002d7a91d7eab16bc21f3084194106ec3942cc7eab5feede691af84aa765cf917d789368ffd5536a8312bfc8673af488a9e4454f36a4a980cd7e2e4d31ea947f67762579a415f71f513a15e70714b9cd81dca60eaf9e8bb9c539ff6a1f5312a8d4498e05536b58213ee5081ccd373608f26c59e9f1110dd8e7b87c3c68f7cbb42e3f8868bc4a48a4bb408fc9c15a72334deaab96a41edd0f1b42297ddae05902456b65ce3908633a1e8e138f2ea3378d950cfb2c7dfcbf2082b279ed0d4a601d219522ef30175633682e4b3bcf345b9abcc88d53a1314f006b776fb46a85e1cb47ce1f1630d04067316046a8c05f47eae98334cd461e69200651e3684041687d7bcb087290980daaea68298dd8ff23a0d5c7438dba8eee58a2535efc5217417c6b17bda56eb326abd0b98a6f4aeb50342c068dcf7220dcd07a1e2ae5630b1d5aad78a1401184e130d682f599620b2ca7862cdd953a9db79c5254b0acbb7197350cdbb5528f5f1fcaea5293eb2b08675a8bafee94fa7d4a0ea24ec802bd76c94bb01ab2ec477586fbc08650f023b636af2423d62da518545068961cb6a1b58f87d076a543f2a3da439ac79881e07b44047073f23b950072d4cee7947e61f142686d53c0be860a268c272ad44808998e52edc032e7c4b2e8733fe6729b3f73d4d24730523d2db1108789425d41be1c1cb42735e2e7a35105721e513ccf7d50f166feafb3d9a8653ded18aa69a72a4832e244d550262b1aec014ffe8f706a8c09bb208db5ef5339a10c617a462d66868fefd84495fd5775f631a64ab26a59b8f647094266990bae9613aa7d23b8a3cc9af6bc4eef7c8f8ff85b9063beb91b2991461dcb637df80f838aec97027c6a1f509bbe6718270b64a2cdeeaa0b0c65665993ede61448e108cff1b43c2c7e5d6a9830cc65ff52cfb44dab6b6d1f3ec8d199fc48b13fa4dc6bf7d8a3da63940d5cfbac6df8df073bfa5cea3a06bc3f71ff61c50cc75347246a2f7978a8586aacf0a3e15240ba947476f6ade0c2d03db3298d99016db52fbd873b4481aef8ac58e6f1055ee5daa4b70ce4392c1910071bedc1f690e56a2c3562fe61f1cf30b5780b1154be4ff48876ac822cd77d1ab428f00d5b52061b2cbda5224c089ad4a8aee80cc2a9ce3110eba642c461c0ce92d144149b75e16b825ef0d12306a33a6f80e9c63969c5107f8c4b6e642673b509c24fce85db89d29ba5812cce70ee2288b0c4dbb12b2463c26e82733abf9743e28197e2cadd351f47fe34c392a746f7ba70f41b26ed4806b6e10544dfcb54c10466bf627037b77eb3abdb95ce3f9c43549e607dbaee08a5e0eeef3fe387e9b8fa989ac2df0d6179217ea76cf492480adeb9a9ffd6a13329b02eccfc32dac937fe8c847fe7a562f30fd1ae72c4a509d10a87662004117e8ae73ce1dc600f3f293824be16dbcc02b0750da0bc1601e5633edadcac99eda974f26f97a689015d990fa8b17e8bde48f4bf5c774ae9460129960fb45ade30f24e28506eda3baeaaf2a233f5117d64f2fe8772172f4e01c7c08526c08ffb48573163092bf1ecbd3aa9cc119a145597ea66be7bec2a79dcdb6b642ce0294dcba77363d7584cc7d233af63a76384d1ba99f1998279f94f3dca3103b3b5b9444fccd9b8a7b31005c6d3288d90e6f7f1c0febebf539e6e899b03a87dee809003081d21970813a9272622b5b9f6212352757804b0b726192b29df80fef5a1b2e01b82078ee50474c58d6253313f2836b4bef63c2e0cea4dc45e6cfe3da7dd7112eeee25abca8eceba1e088e78db1545bc12180fb56c2841258c6fc873a93043aa20ba1c854bddafa35d80a35f9d20c709b65846a96b410501910545fc289b7d02f6543211f19140e8a695670b46083bd1bb1aaff18c01bbfa5f24871945eb506cf928070a500c1e22109c4b86fb4a51d4593e4f9c0014c64b56e00adbc9d747cc272cd8b4f5505d999131778f83792c54a0bf21fcb4bd4bc55bf0c23c8107ac2d058bc67e1b3e9682f8546933e7711c8cb70663e40617b3cbde51d453966da7b39fd47e2a57368b99fbdf00c815be028304b9b047359c3efe76791560a7fa74a96fb60c21e305e823a1487d70beae56ea173d1e3d25586f22658287ff5eb2af4e713c30decac99d54a3007260dc6416577709e48c3a6b983c8cd517c98289f2b8544eb52b455784a61f4b46493537851c433e385e5006c74121c9e5319e0fbf3667f1cc54906b39350b898ee2ffc755bdd97f8965b4ef06b70a7ae6a8a3963319d38d3611e27c4eede9ee56d280afd30822c1ff35f978f2dd934211bbadee33ae2739801b306d4c6d10afaf6747432c60c6a8b0c015a43eb90f075a90da05b7b678a07af9da97f7eb9ccb3576f908f38c5acbb600588dc97c3903f0a1640a1ac3b3150afe783ca43108f3192668648c4e033041f73cfa19723e481b2e3566e9c36f06c3905be5c50ae9a82152fb1a41e4a5844e99d95d2647a5e94628963b417e5fb0c6c322d22ea05b8fa9e50bcfd4fadac011cca36b72f762261302be653b96a137d72ba1c72f42e64e8de5d055d6d1013818fdb68cf9878f6cb9e7b16605d6fab6bf4a7b0de7bb2d90298c0881b9b4e9a64449afb0a0098247403f9b3057af67ac7f90150ad101db273250e5c090db2c348610865628b20974a51b8cf0baf922914d7469149d059f22ba1dac595581af6f39a309585072fda361f002a8c73b9aa702eb51b6c1d22da5223643a75d7b4f382cc2f5c3ae4589912cd43621e8d69586c2c438d5fbc3a3a6ee9b8b99444a045b65d9e4dfc67aa3626e7a844294e4be3099928d778a3faebf81b0e630172e7d169809763f734850ddd384237e60d2dda794fccc74ebe22724db478f419b3f99817bc393358475815c8f23953248fd53077c7406bdc25281b04232825f956bc631364c2d643809127da4afaa880ffb5798adc9b7bb675cc985c3c67ada689339cbf91c79b6f65fb5b2ce71f6f20f2b9374fa948b204072d3751b92181173236210d68d21479fb1736b80bc0e9c0ecb5d1b8cf30679962c837ed7e875d7286d3f9e70c8654140b71141c6d0587d62e4e932524a2848afabe875583f6d277f27e93040f3823385ef8369c1776cdefca7421b1bb67f025ff8988cf1f2481f7cae46084b587e179e35bad440d01ab41e302da80c2b4f8a3ca5d938837016913431179dde1e19514e1e331618e1b25145dd1170978ad2e07948999f8b3af6049daa0b592bd104b5589ce527daa6ac09720468a47f54645a35dfcf597ed2b905ca063cf30a68249ab001fe9d81c4dc30691635d656cc6086e226fe3eb663f40eb6ba8305e10328bdcad4b035b9b11b408c5b45492a47eee8e5567a18845850cfa4b1016af989e6d6e4eac3f344e7ece4147930e3ccde1336db2d08b4d50ba053b32b37587b7b2efb8fdaf6a2733f363975daf50a86358fdf0a6e3ac0fc1ab1324ddaf4b60ab978e4bb4bf6f05ad1c201e805c0e7fb316089f877089a5c59452bcb872cd8f8beb4677ac8c1760bf9a5899033e88541334d1b180afd7297f4b51f89e37bf316bcda0387cd5650dc991eb38759d62b1c1a32333db2a856dc0fd2d571e934b35d28d9a8fe8e24e5333c587e7fdfb801100be3428b5646558a6fdd06","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
