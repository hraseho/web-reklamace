<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35b39e314c029343dc7b5a4a6228ed76daa0fda67ad3c910126c02734bce2491a8227e51cf50c8cda6f297eac27f3ed93b1f4242312d96195abda3e9334e88b09a02f2bd00fbfc492ccb1500e695bb56f48d53a90346a0c6cd6b68934952345aff4431c23487e18f1cbdbd61f163297e67440d934d8124a5caff06988656abb207c78bb90fb3766cf932a67eea835783e625b68b5afae93801214e4135368428a67165717713a1de2e6ddb79ad1b36ef3699404fc2286f22955721caa3eac5679f553fec3eded3716d46e0c53e90483946a83c7d05ce65ac603b9be2a3e1220eaa7c7f0d485f1fe0fd6faf62411f2c5107f86e942dc8f2eae9eaad7f1edb83fbd168359bd16c6f6d8f103cde57d1f7ae7315b366f70ab4e540a66508fd90c39fa7e49f78c4d4adcb179470720f39926347a69d6ade68a2aa97dae8ffdeb327a1a87702d881703fc618cb9fedb5eaa7846872515421341079ee4daa2f11a4d5c4d6058bbcb769db8792b066f981d77751e6095875e406c6671ae6f7daf0f91439483698a7bd273b427ad29d5d35470fe611ea2678a8835301050b95b984d7efd874e251b4e1be78303b6dea9d501fc021cc2434a9a8bf7157fd865d6d7cbf53d51847aa6684cd2ece12afb270a6a02f596af2d2491380f45a7d95dbe96816854d728b725947f5ccf8e8fccfd3123d628cbea6415ce4776a9dc3f2135acddf351424128ecaf630609edc2e44538fd2c8eedb0b10131cc63816f34f33533ee73654ff60f134e0e3ef22efc23d621fb57b42a65fc94e2ff09b50f7e897c75eccb0185587fb401fdbaf25d804fbe5b430187ddefb635018279e48d25e04a60c4abfd895b82fcc6e9dc09b76cdfc415381860489b375c07f4a4b251bc54e73b22c09a9fd56aad86032490f3f945e1f93e5bd9bb5f1c00c2032d65cf3bcb48dcb93c7f1ab76db3b6b469cf3810650f3a64ed0c805854c165a2eab63569c0f0ebe33e10ed1823058d99eea0ce2397038d5c53d92d14df3568a76949bd548631b6b02f1e2b8d6a8b4331692a735db8a12c6f209a5ea84c249fa727781b481b4b612f9e439371186a3282b9a4c40af70fc290842f138f3029be8c2aa2f8c6bc1bc3e774a608148276830a3cb0d3c1b54347a7aa00464d50efb2f8db8a8a9b48582430a90098dcd2a85bc652cd22a45670d3e58675b68c819d11e3710edb7a808cbc4b1336d9e00a68a4119c7c042ce3b2976758cb31800e6adf1a0a1f891b00b2527ec043d5f059bf5d14940662ff9a47bd3fc97b7a977e2102a8d94e5d8aaebf90cd040b199cf334c1f5ba3df698e91ecbffcef7ea420cb72825aa217191f2cab034934479785c9e3d01d4a46266fad8a7edd33ca66a676072024cb34e1252d956547fd0d8939b40cfc7ebc1b78d3238ed8ab72dda68681f88b38177c93d0f3af745793b05600401d053a654a45c551d5583a83718f3fd340ec4c3d6c49a3ccfc474ecccac0c87712d054a6ee977c17311f147c8a852680ec2ae3a818d0b6a20078a252b24ba1c9101eebc60241cce0ed9336da627e7676ca188e6028196eeca529f0c775696b2b85d4dc81fcc1c7c1943d91fb128de2bbdc43343e8b7e5c018bffc139800487d019fc25b3456bed0468f9c01ca7b9c15ae9411603aa25d412095c5a4e5791b58f779ab1cf62659e4c411a73577df6edd929b869715cf234927fb7a4d8ce7c43e1e26c4c5857b8f8c0a13532d19e2d441512354afdc33bf01abfa01b5310a5c1f46c9335c6087017474b8a647546d8be3ba134e3f2aca63587a013136d12bf89592253ee6eaa93084e598d511ee42149291eb00aef3d3e34910837c106207ca0391719f63fe2c09d4290fa55c6a82444ee86d10046aca955c7e1b66c003eefa344d4ab1e9d86ed410d193d89469c37aa1307fb170033e3356819f52721247c2f64561b49affb98e8846d2be0a7551509ac01509bfd1f1fd8f3d859b210badb2387ec6fe4ab12a34a178b5486c3d29865e2abdf40cdc487a6f1a8b79dc56754d075bb763c7f0236fdba61f3260e9b649917e97a3e79bb65bc18ef7512171597e6ce26a2afb78166656a1c71ec35cd745be997f2e2ecd3eae8f635dc2722604ffab40e7b1876efeb02c15bc11c155e6ab7477af110edbf076badb8a0d03b8ca47efc1524a1dce47a5d87acf7defa8d1dac71f4f39ad7c0197a8411ba0446ec5b9dfd7b2d5c1a9643036010c7451d28255d0ccabefefe78e3e3f9f3ead8a1a58a120f3057c9d2ad301afb0ead74cf967cd917d7a6998a2b5815702d7230c8dea4737bb45b6239a307a06cf805f449b019fbeaa9df3d8fba0c722cf41804a746733e396500ba2e814c6058e9574d5b7d61b81ce4b9ad3c3843b6f392bdfa74e2fec76442969fe75cfce1be757c8e6fa4cb6032ced094a54ebbb8fae54d18e1b3a0d122a461de3cb7b42210b948e700b516ed791bab627a35c1f2a8caac61d82a3a1a983953280478ff770aec26432f18b8187314944c899a6adeb39be566dd43a7b48256f303b0b36cd00cba3fa3920830160ffa87c7c4b0e4c763ec844d89c2a373320e8789a216bd509d3c2480d1eb6c910460e7b9e6f17b356a37aeaba2ddd3a3a584d827d539465f15bd2da423f5cf1340a1dd06f261da57fe456b573631c820d835602c804be69026237f5ced90eb9e92914e78a4eeb633864b9908cabd75d6b37626afa2e844d4adf319090394c13990fc4195ace9d3076d4e9966757aea80639d180d6aba4075234d566f75408d64ec12b83a50214dfef87efe70d3f974de776bc782f12d3ff107153c3b9eee5ea0e6e54a8dd9bf10860d025d2802fd21a05487abdf2086de7ff0e074ec1e429ad4109dba04cbdf9259aabd4c88193fb8a2cddd33e650deba1fa8026d4337980bd8585f6a3bf63e16f6ba8b47106a68a7525500da23a8f5b9b7b303132f8c70660c9c28b809fcdca2770b31b8d94f89a2986c226c8f1fc187fefa4be0a7ea42091f89024e0986f5563e7517250ecdb012dfb739ea94fc78c99e4b9d8b56842b61b0dd7fcbb9f1556eabeda3cbf5ce94e024129d83753b8e00eb3986213ab75763f42c3f7014f0c80602d2c749a41895a953f122c39a791cb49adfc5819d1fe8da539f3f70db648e4a7d0af2084125ccf9590beface8c7f730073e7274cbf87f806ea51d2d33cf1b3beb7d662c1183add89a20e3fdb4119ae9650806a45c886177ee82eb89c6cc2052892b06666fd531ee1b08bab7e864873b5e3a4542df2a9cdab3cc517c1145d45fd4ae5072cffb1e817e04f58481a019b5bfa1f676e088f25653a6403a4cd8333cb5ceafb334ea4fc3294e90cd8cd2eca604ea1da793229257ca94158be0ff9f1fe4b9f775e0e9fe9d1791439b6d6833cb4b905373cf6b080601b2209d8d8b69cbdb76057038d6837d4c3fbe131c0c158be1d4845bdc4b3d5d2ef2367423a3321a5695f3d56891ab3d10b357416cdeea264190ef58d1261115fc7695005cc2bec15bf78522574c81ab936bf143d914a7071453d8873b3f6b74800916dc205c052423daf660cfaa52126c53298f278b36ff3bea6a59365eaec9ab3dee2a67dc0a981ec57054cf35f7c3ff82207b65069e7518f71aa83a0237eef29addee13b601da20adfe79ec10f842643c729e04b1d0f14fe8332c4472f241d34266a420dc3227311e21879c5132911cef136cf47e612c55039f76c43c8ea97938ac504418dde003890b11c983466e36bc7fe23afa21403b2aad5d5336f4b73ec0b7a7946932b184b5250dfdb82cf4bfe4f6c371bbb79d2bb93875ee3d71eaa3cd22e4bab7a30aa7168769a8d97fdff8725c0793f93f36b9c7a3bba4a518aca5ef4ff1b11503e8cc4085c6d4a207b582b28812b48e09d37dc7eba0d3f4b357f2917160c1e56a47ae922c417be008852027ca70d24a4ebe781860e04ecdb19027d5f8ff71c4ebabb674f61de252380644d3d3602d47a872db41e6c4daf14529084fcb7d8d5897e830176fc87255cd1421f6aef781045aa49bee42415d121fca3a44c36d96de073c478149f52d5bb65550ddef9f0ee9296fbfb6ed2bde9488adba9e14f69e52b4e155db67cfd7f0c1c355e1ca8cc03a70cb146b7e87e697d91d7f0b5efa4283f43776caba9ec56dc007a81a5ba96e640dbb810b628a951da40a878073978b24dd857ef5b0154c950d6f3a1e2fca59d8c7705dcaa78deee7750a4d3aef59f277ed09a70ec76532f0faf4c831782b87e930493ec74e58ee072653294ca0bbccdfb5cb99c61888aebe6ac7e98b7e909d1445bbacd8c0c015c36db7e6e87ec969715ade5022a27888faf741e26d26439320d99848c1f7cb8074b5d922df92ca3a125c89c991e0254e84c9f2f398c0cd550a23e3d44d67b36c859623a49b0f5c098963b759e249600a2e441479a17737345be260e0c6a80238e8a82ccce4584bd7f02f10c27c9503e22f3618bd63cb23d44e6d890773b0e14bcfc98b83083492abf3adac460c725106ac148d0412bba6948e49010a34e946e192f63007d88f0c563573bfae4bce1db96ac22a07cf351b10b98ee029b31d1677dd59954e7ef52f2ce0510d299fdb7614b9e7dd672f631cdb755f825cd2d2996e3b121ac6d386ad14d3f81a1831b4aa9c7251cf38cb1dcce5b68b3e6ef8d6a58f956751e20b4bb4b424d004b8da0adc908b9e4d46250d73c9b2444790ea94520dd4384a7c1faa9cbe133cb182f96717d92355989c6089f124dbf18b50c9e2bad39df0f1132c017296d27683c6065eaaa2991660dea3893d9e28c4d2ecec5b8d0ddb1642ff507023af3be6a5f311cfcf695dc6df229ffbf8262c1bb261aa0c0d2d3f09b7faa4a05373b888165b5f2295d91e95e57d598beb1b9245d6192ed5d44e87648f90f53131d70d09998a9ed0fb596f6a1ae41a2f79cfe166bd5493c280f83625be841c5a842bf43e5b5d9eea5dd347b20677551f614ce699753c2a33084f7960680dcc35fc6d5aad15e0f85c23fb84662c5806102ccca9b94a952327621fd39d6fad48691e6c3ccff1f0c066d4a8061c43ba149ffa56ceaa89cfd4d4da51ac01831699bcdbae2324939925bb2e5915f4ff5d73d872bc0d6ab657af331c899488eedeca9f00385456d3577b0e5d82478e7a4527098b3572e54554afa38a6111ab8e920c808722dc9c59b17b6d47c3e01dab252fa5ba450b230b3bcba4e58d157b0fa51a447e535f3b888e7f05307f99f3f5995effa9224e290a33b5463a2bebf4de70fa5d85a495f1ca95f38ccbdc800abe5db95bf55d4d5da388c8aaba25d456314df741c5abb09ca38b062030dac2ac58e0c46103db4febb523e9c73205b87a0ac6f162129655ab05a0a8ad7a1481be50c0a66421a276be53eb473694bfe1835f7148d730f0aae5612ad6c36b0b3735dacba83cf5e163676e7ae1fa3015492aa4007745321ccebfb5b5140220d14315c1a5460f19a9dcc276ce65d22b00db7683bc95d6d757268877d5a3f19b40baf02a456f432faaeeb4319025bee794edb14ed0684b8dfa9e8ab015e3f3253385311be9aaa549577987d8f0785fc978ed06b28667d1e64f567f2defaa76b5dfa06c14dbd7b2934ba627de4498e2a9bf70d73bc4ce72cfebe2673882e0558621c6a97452acc0267b7f08d4ae11ad3bfdd4dec64d3a999a85ed53e4965f1f1c9fc6d1b2c028cd3051f8c9d68fc63f4a416d674cbe1bb323256511090a98be9ab89616a0ce3ff7f5ea4d82f3ebe0485e1b2c9c3736053c8962e975648eafbef100ac71f8b9c2cfcb183549ff5f816007b6619bcfea33e7efe4dc11818581b8c6a3f3c237e965d71e58f6b575357476718468ced633a828d53c4a3d6d26ae3ec9e5d93ac753ec212629b2f0adc085ab281ba37cd1ffcc72a013b1ae15fe6cd00a7ab19333e05f7f359331993cfd699916114834f542eec93f24d83f12ac516bde18c2ff659874b82eebc02879c8711f2b74fd473591c7a2d818c785e1bc4c6b76c242571e8b2e59d43cde0e89bc06db8f01085934e9de30551525c049e3171e5e53a3bef9ad8af4942b66ed4c67845317af2e9c5c686dff049abb29b993a6e97a650d3b11df86cb847111d22bef21663657c098c830d2bed6f61570c89cffc15f0d93f823401d574dd41ffaa339e84a2f5f1b3bb378b3984102b555ca0195f2323aec4821e354be080ad580e1263517be7e875cb8669f410563abd1b49dc50a91522b06e8677b0982638bf8ff7a1f235cd4418ff3387dec8251e0fa338cb15717170465b36c733fdfd4268083e18f5ec06ed92659cfe9d69c0f18ca93804302e22cde49c7cf39418b8d1d7aa49eded2788d7728dbe8e83c981b2cfe8e78bb99c1f17644ea06e2075ec2abac005bb83a176f9ec60b8a1b8935293fd976a31345874d4a69b4cc4b704a8c55e987f29d5cb9f17df280fce7a1104dccfb925d4eca25fd8236c698860e383015c1a6a6debf50411886f082599576991c81283da7ac70704a8d703a96e7f9153cda5ffb8979ce29cd6afadc133bc6867179e88a41a55f15f03d4e7753a7f6f61d0e03520c11f8506675e5f80e297f49d40921ef4618a344ec9fbb05cc7fbe762c2c59aff19fe225b2e7d51a03e2bcc70381fe987457a67eff364cb9e1fe15c2aaaf5b953cab88c33048741ada4933d7406727e32a82717917e05f88de41a2af59019db85aefb0bb91e5c577b253fead833fcfc4bb6497b73dc0e12d14dcf3c89e968838968d1e98f4546c5ed8c02bae5ce1a65b35139e13812947fbd290afe75d4b4b54890777667128063ac9758d26514ff2aa98a57c5d206542c0a93cd8e042298c6f449ef4d6c53ab3a632fa2271a1552d72a42b9a869c7fc4e91ba54875063c99aeb47ff507527b20ca8f7db1e5f64aadb2bee6128ae95ac7feb799f3ff3fe682ad1b5eedb1101e6ebcdab59fab19f2c7159f0ab86ce0e04dc0c48bdae62180d978ec97704c0bdd095b7de607f4edc20caaf416b3b23c06fd4a98802d191e0b22965a2bdb1660bec68e887e26ad060b77c48777ed3e6581897936197b313cc1e26ff4291672ef783ecdacfdea77f46b9520d2845248e635142d7a4f1d53fb397019706d454164b5f93bd160fe62634aab06c4eabe8210f22619bc00ae3f0d34a68305224f22f1271e586fbe9667d023902efee10d291d29e70ef25579e01058c81b8507e324362c61ff7d30dc5dafd99718b6491ab003a7f3be26d08daab3b76789f912a4ff865ec9d73e5f63ebb6ce21178b0dd1ff51dcdb9477b50a90fd43045f7e1748312bf59e378f124c4aac9e67aaf954203e916e2669864c09306d48deb105c3691199087ff5bcc54044486d43e72c52ac38ff74e974af34f536768709464561a1b4a6ebfa1619206f196504f13eab6d5041a1a2106a7369d9d7226f82396f71cd254de724007d05768978d24228b3dc3f4caf363312b2d2089924e180317ee7e67e96020565000bda0af0de0fd934195943fba617f8d0d3fa524879329b26693550622f1a2bfb0b8425d9933ed630f244b6236a62971a3084124ec64176172239a6963b4280404e440ddf8f7ac73493aee8fcb20525e81c3d1969e2ea2f91fd32a4ca028bad78fb3e0abf3fdb9c2336eff17964f077acd291b7fe1a6e5d7ea2c6feb91a33ee28fd7c77e36ad3a592871590675ca739b47eb5c9fecc5d90ba9d50b9f961897c6f3806066e16e7ea1015f049e8638b3978fb3e353105dea34d4e43f72dacd52df570bec8035b27f5d61837c674881ccac9f342c9d7a87468b03131c830d0a8b8a23fa94e2559c3ae3517b25750ec5520a7263857995682b13191fe6bd1ac96de2d67a939a74c05e3644835288ecae4a000cb7a87a5da87e233c1b739a1440481e0dc3582090bc0fcc2cc7b6196773a6b9202b849cf784dcdf005ec1a088da0a09d1f6b0f535c5fdae6dddc3d78fcbe65ff9c9a74247a4568c669def0ec10d2cdaedcbe25d625f81f269ee56d332d1523c2b156eca0ce3d638fae1afd09df55dca525cda6d631b929b22dbac6ca99d675ac8d023cbeece99cb401724b88562627c345133fe626580a630b0b5e2e0c454a36ea6940a1781f9b8d5eee736b42afb8812d1bb73d139d1a10be8e97fca3f6c11ff5cfa2ad8fea2ae749ae9fdb2a153bcc3329f5d231f04b47fd1190896101abf1bd56c3b59d1f15d61f2326a5ba69162a15f139bffa615df745b04b2cef8df02c968682caadc821cb99bcbe81b7cfe44ecb37a4da7cc5d275e0e73413b5ecc0ea96bf049f7398f9e570bde794814b68ed72fd03ee994b6e82fbb8f6bd7fe53314b1eb7261fe39c9c31f8084399022ae514a3ecd28820e5bfa4261ecc9a51d4fe9f71c98b23530e489a1e71866153e0941931b159479397b4ea01746e1b010a7b203c8efd8ba186e74e14e916417d8b2ed781b68fad0062e77cae1cbda46c200663848c3cf7e692ab3bbf98cf1c75fc28ad58fa89243ab8f7e5659a292b5247aae208cb02e7f2a741df1517fe89c87fb4fdff39ddd328cab1e36a430175b38eddc9bc3f86ebcf06c7ec37610eb566d42af1ce7ab3c97013141f244c233a05cbdc71fbdd2982e19c609764596b97f23a951bb621a7fd66ccb0f8ea08e48c286c6cb252fccf93c006f0914a9aaad4a57ea915c9b11f9a47f53b5fc8d93e284a729df5c37950372476f479f589a48df427294388a6c7ac55ae0bc8c7d1004d111e09742228f6e383444142e3ac5c0e215317d0cab1d3c20956ba07b5304fa7acb806a82daf1f3f53890ad1949b1c786e79f47007140268682a7fd9874ac9a2104ab1db208fd383795cd2b21363f27e03bc77d516d37abf98b8fa7cc84ebe1b9ed4c4537c5f9d23da15c4ca1eb44714e0b72a331c3d112e586b4532f3580ea7597f1e7ce21ecc314ca2db70fec0d352469f9888616234d4956554d3e5890e3f29df439d872a80eef8e73181c310cce6bded06fbff8573abb4e7750b1c8e1699682871c86f8f7859f320ebcae4a823f35829557469451b0b7dd7679b262599fac9bb897623ffbd0496ca43fddcc5e5e5ed0e499ae9c614d54c78218e361120dc323fc7ff0f97581512bf1d8f9bfe4465d67650a61445a26ef7516e459c633275b3a06ba64f7946e2863316a58e7ec2dad1aa24134013a05393f8258739fd7086f87e59f49e0861959276408aa005360540a4f65e37f2ba0d042ac5ff25afe0b304f4bf10d89bb2d701ac0e1ca76d7560237454f1a8f4571cdf81a7f1159b6e5e62c6a2b390e6412205983464354851560de95af72f208983bfcb68df90643b161c450fa79ab90b304a580c3b495252a321fae13ef4bbe40ab2650a7040a7d8f92c59411835163ff0e7d94b5c540785ec47cde09ec1dcb2f0f4c838c52a684765b793c14df62793b3f8e0bba6a136ae5cc678803e07b11fe9795b6a5cc0e99e5b46d4f460da469e2b78b7042db26b2f3e751c8b9f5652e7a4e4f38623be391e4294192248313a4ec43ecdba2d38e9251aee82ca8bfd510b09b310c6afd7b33b42b4974ecaebc42339ba0cbde5d1f14317ed465f452a30056140d39996c2286a134b2423ee41a8dab7d008c4d935f956a2915a123ace9272be00ab1fe597888cdeaad82bf98ded390440ef7ebc933e90b267d4791fd1b875d7836556b635895fca839a2e7e6b664b1ab1b42924641fb2cba8372979ed1cbb93d1acc1b021d314121dd2290f753ac1d23d5d1d29406b59f850f86ceac9e618161a1c8b7117c8ffa7c31420f4170072e0ecc2dab1fff347e171acdddce1bef051a0723a6aa93dc065b7f5dcf5c6a49662e3902d2bf7b5003ae6ddb6d216856f19415031ded661fd6a37aee0f989c799915246c524410ddb51cad461b2e41621f051821e1b6cf26765e2537ec332928d75ea23dc4552f4aea2737ad97c3bbd7eb77a78a0f422b44e518696dc997fcd264871bba56e7416520e8448265a8eeaa414943e441332e63d4b5a41d93703cdc1d63ff01c18dbaed6277313290ba763c6271059ffcaab758b36068920a7d3eef94669db0e0fc3f51c4e11b65f46d90f045a5c24332e1a19d3cc51ce22867ff83ea3b6225dc4061fd17fa45659aa2e67d26099434b24f86db55132005a95ca92eb0fd00bb608b3a02adf67a0dd63d2cdda48c746b43b91cf1eeb46ab5c6449a9bb1ef03788c02aef7cd7630582118d2f7e8703a095688f2c12dec97567791fe7ea662f937cc2eb15205a9889d072d91978f269391ce904b795ec924921f236f742335d8e8e816de1ea9e032dd2dc871b3fd52c724a89f1fa16b7c2d448aba4fd47532cf3ec0e72f6304643836d105a32611b488d85f71a0cdd95ad25e736392c16e840897c53b4dc7b8c749ee9c53710f4a233c414e81d1f0a744d5286c2a0bef8eac6c4221329ca662890a297b0eb0413d58279ad9b3e9b575a96127b9e413b3a4c749cd282d46dd7e516815ea6ffe07341b307fcf6b229a3723109da90af12fc4f4133fa74a28c27e5ec7e1a073ce1b64f8126aee644e16cd613ce0b68cb33fd8d5d6e770d6e3d3d9c0a258289efe2993c601668248ee3cd8c1535e8fe913958554fa3dc784f2e15003","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
