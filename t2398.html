<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83a0745c8caa8e220e055380ab2fee49b1ff61a4fe089fa25c453120a46bc94ff068cfcf036e8d06fea174d88b61bcda12af3bedcfe6d3dd13f149f2df3362046185fa97cfc78cfc90f0f53dac1220dc7a9ecb41729e1fb8a65a84f2f7b3bad76c1edbfbb91dc73ae742a0f40698e8481bb7f2d7605d82c102181edaf1eab752efb79e22afecf8e2ff4e9f14ae25c8cb2a79db4eeb974117fc939a2fa23246ec388de34180a2d3c053603a934f5eab827254a45f242192c3f33357cf40f1b98d668df085f539f149119b19371df795b0687074dd70d770dacf13ed2a3b17def5edf8b590803cc7bea367d5c809d1217ac58ac81a4adf975c55823b679e233e8ca4d86f8d6e79c60c72d55bcec79a95d2d9b4457df621fbfca456b75addb802ed3faaa5acf103c1dbdc21945f89528aaad4dacb064984153413face77ac7333d5c661ae63410b2b2d22ea77e529dcf7c30c44849b56b18d5bb51ad0991ac27edd0933d536d8d460e5496607b270458337898d79332a3da76ccf1e99645f136f392aeff9f8aad8521ee6439b646824c8a10f267e94afd0fe2310a2ccdb4796aad2f22c2274389a29a8ef48540919e18081de66a367fdf4bd70e26f8782e96ec5b5655dc9a93ddaed2b48b6d79ec367541807c47a3897651793842204dbdc43f88f2f0a0140d68d30559d78e5942d6c535fe5078d3c03b049d855b91434e4f0449b7311cf209647d1e60470cdca97eab24ae993c62c41e3134a9570bf93bc05716655102a974a9a01ecfad37d119ef780a31c09b94cb0b5a28c4fa88fa8d0ed6b2e0d9ab2f54d8dc67e8779ef0e09fe81894e0e97d6495b794107b01d776465d084730f4ee97f60c1434770e6f64a473dba5f1e26e2b042a8129728ce96e8d2f149e172fe0424348153718b64bb9ba8a74750c74df1870fa42c4cf324071308b440a2c032a563b5edf874bb88b08e96bed3bff6b7ba02277df6b98a531b528eb2a455d0960b61e117c24268c8519fa2c6bf25dbd3b58df5a7fc2ad60b6f9c54639883905ac55a3f2647a0a993f90f51372e287e1bebadb38ad270064265b8ca868c9537cab1800f141c048cac342836644dafc6f77f760d07d274c3ff2c3e722bac08ece268cdfd92380bd37c7b010129f14e33c245ad5fbe0a55a7734fb3ce9e4da3184c98e74c433d30b992a2aa2d1b1634bccee39e7043d4db008ac6984ee1f0d36a80b96c624172b184bb89f887e5a562f7433f40b3baf3594ef2fdcca9a5530dc8a4d9685da6f485b8f84048b9113549a277758ba6ead62098304bec2e7e1dd22caef53fe3f8e52bf844a46dacb7ac9877e955dec905fd3a9154b43259fac186bbeda1893cd69e7a666f8df1d5ee8a99c3709191515a00abdb3a7b9bbc1d32f95fc4bbf300e928c16e7748dc78fb58accd745d3205d11cda4b488c8adb795a86114579106da93dfea504a1a8213590293aa4e48ebe2e3fdcdfa7e76adfacf1a5ecb37aae0acb3de22f9dc67a05be4f5ffbe3819d6776f1abfc4ce9bb8348c68de02f0288439ed174ecf9f8ae236c496bfc8f6f2d6b094acd397f5bab0fe19d1446c81310f980cf912f02c1413398d3bc03a793d16db959c61fe25b903fceafaafe1cec96cf66ec4da74ba6f52c386f362c76a5074b3f4602ff641bd5d25ead66d96473e723bcebc802b3c99f2ca0edea094df6dfb47fb5675af24950dc2d900a5772573112b01f36c6c16653023a643bdcd9f6bbfb9c4386794e3e52835a3ee95cd8920c11ea02a0a855d97ee9772d05ab67cfc318dfc09d76dc2dd515fb5d311658f0b8228edd9a588326081efb3755375f6b32e017851bcf5237a57cb44c9c203552271ce95c469ba18b33635e7a36b63b5c795bb498f0057a3fc429b9d1f0d7fb6ee057a7c3a139a30c8b239183f412dc1945a9763d102bfc3f6f338319e036b2c57aed8f68b02a05a613361bbe87562963ddc31a0b7e6d24efb6aed44dbcec1574061584e957da3389c739b3fa8df6a190301077a7f8aa9f9ae225f639144f78d83c8dfe5ca6914670476f816b3d9644227d45dff13db1abb15ad095d6cbff758a4aa1e43c88c45ec1550209f5783418a729cd9887cdc3d8db8a904ae418615277f833e41f8f8e2e2e8ae8e60ab9971be1fa307fc6f1ac634f8c67113f56f0de19ccd5744dad5c07b5ec46502c59486425f15d5f4e924ba190eade78d2140c93d5adda22b3234c108cfbbb5ce65eea9204d9aa95d2a7c3852f6fdfcc656399a9edfe13cc87f110679e207544010318604e9e4615cb2b018af1398aa9f35b6682f0aff3bbd5eb2325f3bbe60ef74fd828298976f33c1b6087980ee6397fbc0a180315de8998440609d4cc0cf4f9ce2ca1fc5752215ab104b26f0a0f7def14c6c5d1c3e73bf319b66e9185b3618118f3d69865bd278486351ca52758d11b3f08d861dbd35246686a359f05b98cbd834fdb599ef04cf434b0858732820b3bb50531088fb584fb5b314723dfa1fe2525201a2e2ac331ba9b799a74b90606961561ac17e6118f01235c7ae26deb1c87fecf4386852ff7a6ca1bb8b6538cff32e367686926683ef723b4fe42587a08a09ba0bd94effa3cd51e73215a513e86b47ac63f209a453515afe7b69162ee6cafcfebb180ae0b889eaa4394ada565371f08421a3289c332d762dea1ad9498c14b08efc41d409996190a0709fd2b4d39524655c93c08d7abf92e23b0a1dab1751bae14185cef6136c9a4773c3efd88352ea73377bbde8443b5639a8338a61724ebc2f8ab915e088e5179978d641c58b0e9e29afe03a3e2b6b06b35f59ab930741ec702e34ecc0a758d01b9ea5db449b8b72e25b60c30969f41fbf30c2087ed4dd343ebfde542d3f5c4c1d8de125b8e0cf299f5f62c1aad9fec64dbd54bf334d7f3ee63f8fc855c10719a0f80a142d4f4850ca6142368f54f919d9db36f8e05efdb56ba183265a40da19158f39cdefb834693f24ae166e3c5f1e63b336ff3a8c81913f751cd300b2abc9d61f033ab3c23b099ee24c903f80bf00bcae1682c409246387949a809efaf600b1d49702fd3184cccac530c82fc9c281997a4f9b110d56079c372cffdc276512c35f4b867859a0d2f2d54a0b5e10367b1588e6af6f7709b725f9607e5f150e9c36d182d62c63e69ff72c1500522c265614360d1f30df1ad45a277fe7a7d7da9d0be277a10d19ca4d1201e037cf08de05b4ade0822fdb5385f4deac2ef4435d366153da75a3696b9f64897c7cb8d623d1c2e2cabcc8bb21290302b3b156cd8d1da01aab8e8cb67c78826ab0af25501cd61c18adeeaa7df5979177ca4b1531e66a80684aa1bfb3fd754ef3a3447e8f7588e2335206d08751372e685a3f418edb85649da6b79783a77bdf3d7975d9035ad3b32d162c0e012aa8ecbf5531e195df545afe6a00374751a1f5ee6f4d29990c21c17f1ca23a40bb52d57e57ade43460d39646b9f089c1a303675185b9166766eecc1d95dda32dd4df325afae6eabb62eea404109d80ec6213d8bfae74d8ee42f1ce14ebdd93ca1556232b68863b81adbd9b2d87852a9fed10a2ba384857c64a64398761852693758c697356e41082a53285cfae4235c35af9c4c4665905a7989ca0e84530af09b3f864dd7108be294a52c8e59caf4fc2c1cb276aa0555b1851e0c616e2372fea5df1a8406ee199d22548424876323972fc56b48f737eea7cd32402761b2f287d17ed8358a54a48c5bb83071ec5d55575f9d9f79e5ac21f94acd4063ab5e7ca2a41782d7981a7d3405e269b18a2136ee7e424c567822590a76976de53334c38103a97af0d07bb443fc62d703ef358cdb0a312882c2e0b5c870fd51979c6903b1243e15d2dfa69ab9d2a783d74ce89a5c2e713e67a241b93ba681822ffa9b1968cae5a12e7d20fb456e8196b1f34b8b44db5077e32162f0c727c83b65b6feefcc453f8a2550977b8fe065e2d43cfd660bea59b4e85c34550566b55fd88ce9e97d9b63a6320c9abe81ab3e13fda7cb4ab7689fb930d7ba8c01d09c1bafc44088a1d5f5a7ab49289dd83103d108679fbc6a32a2d1140d0b758db9408a4e9708de948fc7c283f0deb1ff7a515f802a6648ceda84e98dcf6c7962311869d51334e057431fc7725dadbdd6d95b3a2f69b60fe60602934861fcbb9bbf16b992f4b4b0578976c62347aee506749c5f1d8c4f4721baddc7afd479e49b40c0e1c8c24f7dbd0f3273a764825564473f81739aa3c91456d04153b951493689b782d6743cd94b246190fcd2ea2fc8366f6be6e23118aa3549536f64bb32560715814d4e5f1ac8f792cf18258d71bf8d9151adf39493f29cb2927c06de5f2529d6f54e0dd5084159befc88b062faa8991df06a0fb64794e5df975c1b6301bbfabcd2466b916dbc8ec37c538a5cb8d87a72188703d0d5a5ef9f0ddda9c9d4ad491992b1881b7f2006736896bc7da8ab940291ba4ea2d79cfef154926e19270c2fb848fd8b7910356ab86ec09e21217b58a05376a0a7ce0cfe4ce61d002bb7205eaadf6352b6c140f40e2b46e4d3cb3738ca9b9084d9c8e431042cbdf157ea4e9a256596d3d273b1454c9ab63c4b1d76fbf33e43052fdfe0252dfc5e7f6971a5560a65b5b5a029da1687e49a7bc5b2152223ead93a9b3ed0984558a9736be5aa9edce265b797b42d25afa23d1c275e6baeeaf41b2c898fa0529cfae28df7ff8d81736f71f5c9d33644ff52d49395ec91e0beb1725cef8d0609439c5b2f77a1cca539e9bfd8c22f19e704e728df128a6cf3a6c7756c17defbd22ee0415d16bdf9e823dad97cc4f261a0a8e3bf2ac24a5ab193a0404507bdc6e570ae569a28fd232d5d32046b6a2623ad209c7fb01e457cfe67f67ea15679e3739e5c9b8ec90a24b6f7f8cac8312c900bac1c403c3cf19bc99a419916cb7bab565f8a3eeeea3235f224ba3da0ab5674f9fa56868eeb0d29b3c3c5653183ab94401499aa024fc127cd77937f8d318d770f510a5eec804f24a961639d0126f781b2539ab3053a4078e84a4d2d87e201e12fd671c14c22ec9749ba8748a091629772807718f037c16157618a1d25725d4b7c6970a80f6c104b27f726f5c16a6f1b6e4cb5830eee4529de6abd0677adfe863bc23f9081310a3a892b323c417dfba2307ddabd7d061016c21a95662d93926c4d28fde7a79394fa7ff0f07618d0612632549fc704673b261f339e9298dacc6c330f5d7544258a9442cb0cf9106e9315223ebfc32d79332fdade5c343ff7c48a29aa8d3c010abb2c37dc42cfd51692b9a4c465549adf2bfa8360d41512c9d07bf8aab11c8dbdc24d5ca946d894cef88784e3fc2068624a749162b0b39d98225ec65fbac7dbfa3e949c309c095dbf72993ec7d76bb24e23f3443114b7e96558becce3489605e3bf1d9dae6a361c22abdf6984aabc597b081aef586c3d417a9f7e409a33155d17fb26dd60357ae02a29fe8616726a91d26b15378f5a140856d57425b29e83e60e47379d827d66dfdca224f83b04e75b28a69671f7570fcd0005613d305d0038c10ec1cb4898ee66b60d5156348030bd974e5ca90c85f0f9e1bee5a40bcca0dab1149f9db653487d172dbba1666e42fe6f95dbdae1778bd311dc778f57fdb2a84edbbb2d359b3bb0dc911a17c0747bd96eb4079cda85cafc8280cd899a5352149b09829a84aa7e470a4d8f66152bb530a6a7af20e4e21d6fd1aa42c4e2e5bbeaa1291bf191beee0b0c6f9eda68fc1ce874e1a7ee938ce42acc529a446c3f0edea429dd3e23847abb4788eed41a199b82a7729673554627584d2f2dcedb9dfde431f657c89a372268dfac1cb97e93085392802735603b982eb439428a6f391c730b729aa888dfc1e0550fb2a2107439815c5a5cc030b200c8a63742da61f799ad9486fbf2852098a51fb026ec9ab5091b5f4a5b1548d7ae25736a274614a8b6bf9682e22c4f423849afb3b12db9b32c37fb70a5461c816c1819981d84fcf328f2d57f880478a94a9bf2fb6d1f4cdfa64c18441f8fc94766d0c21e81a9252aed5af25fb56e086677db94717cc06d04c6e808504e42269d9611c263479d158447492359c14fcf57fda1f1a8c5dd74c78832a10d579e57d74a7c22a330b09010a2b48c25f7e27e65be1013e5162fd8c46eb82becedb063ad253ba2898e85dfab1fa7a760f0253c3d504a8cf65dd21f30c6fe149940ffc69a0b6c93c5d04ad3324a9a2efb0801f5f69d42bb141f50b90fff1eb0e2abe7b6885e4883c3f3df199d6d32bd35befe10cf7ead64494a532869ce296199c683a03662e55c520e5ddedaede126fa5890d3942095d54329065d10d5c5cedf4c7f75e851b4a563f4a7926bfbfaf8d2d06427ed0d38a718407bf33fd45c4dfff82f5ed3bd4b7cdc3df97ce146b9d1e137c5a2347e22807d1f5a772d79ace991074fbff089e63dc66870abb338244238a0951556ed76672cd7a107f5bbaaee7cd68f86d1af7c9937ca1c5dceff40f2c65d437f8b22c01896e7a39ab81967d6a1ef1ab308af775a63e3724b1cde06dd191f52b070cceed56046cd21ae68933eeaf32771bb279644f92b65a51ea907902c365c54533131b141c8465b5e45e72c1e86c9d215262b1e5e054585ed3edfae52a92898f42a9c8aa258d145c7f511d02f5e5b373aa8869e24cfb6f13abe3b8bbf68fe4f5712cb154416182900684989177d7d5285bb51ea8b772b7e035e0267fd00b97dad2af5a44a2b47a02cb852f23c1e331f00fa1afaa47e910696d3ca6ac62c474f3edea3e151ef724fe38042728c08fd63bfd9799a0512a8fdfecd5c4cc6e8bb4b668bacdb13e75b81fa6b26b7a0adf6de6318403aebe1853c7b8ad68140e78f27fcb108cdaa59afc48a3d4492ab86854758bb49d8ce9038c0461e89e4f291b92514f86f866e727501c7397edc88ad8a7bc68ac7f80638f809ab9812e35bc7e72660990ddbb0bdd871b865c2d7361c3a1c6d8299a1aedbe6e2a039531c304056ff323a2a6ea4151b8e94ac36cd40efa4e4e6805dc48774b3b9b75228cf0ae527cdecf4cf62ce04b24ef2c8be7e5048761761481afda27cc36921ab05c20c921d351626959aa6d4171fee50ac259f6ca5d05b2c8e7b4a4039e68b5231a1dfd5dbdd81edd699073b7a59873ad76f1e3e0a11e0360d2c3167cc521b6e3ca69cd8cc049cc9eb393428cd90f2c20eb07ce897cf3e5dd587403521b7fee711baa0beca41742e0c176ec6a2b57e12ac94cbf26919f9f4a4a2c0b6e3e8018303487f111ff8ee2431f2a56d87e2bc33eeb1340cfe247afbf78be8457675707a2e782f3d9ebef56888f7e61686dd4fca47e65713288f346720941f34dc3f7d0912b0f4e27d5de267af7a4f1f2cdafd936bd9c72bd9f9ae5364937e85d906227c020ac9fbf0480d582394b8331492ef6ff8fbe47be77a303e31e365ace0cdebd9dbeff9b9bb180bede55b1a0feb7176efe833baae4569d6b995ed5bafa9eeba8436d43dbb058f2447ea844c0a6e7b0e0e18a2e9c33a7904e28d1a4c10808523cfa9ccbcea260779c53ed4a1718ee8e1518961b06fa0cfa0be647bc2b7f0dccfdd4376d83e8915076f487621a6d94bfe1bd9dac3ba083e80f5c71ad8edf32a13f61c40f9b8c49b5c95333cf2649abd442930608b05affe00e6bf7c4d42167ce5b9131f9c97b1f5d85c8cf1aff7287883c37300438942eb58fa9e63067acad2908e059d15953eeb32df4d9fb36b6dd663fc49ea6a4bec7b79e653305cf958d195edd54041777c5291d4d702f8876dfbf39f70326d3c8b74f5b1a8dce244ca74bdd95102efffc717bace7244d75fab32583ba85ae7ceda4f52c5f51ea5c8a6cadf4bee1c88e5345501ce963f073b96eb355f124062d9964b6fda0fad41f2080ff6b86089e746eb3b2dfb6073ef1deed981dd46b816c82518943cd1c15e0cdbd1e8feaf68cb5a260cc076b291ed79f492139650347ce814fb443a625769049ea1f5a92ee47ae8511416f6a83481844539ab81a302a52ac8fc32ac94fa93f03325852608112d5d51aa2d05b75982d5d96cc8735abc71b92ee50bfa5c63e3df3c8cce36d711605a9a807bc6f77df74405cc55fca8b60ab00b568666996f58bbf1af57bda5761ab63a7a40a60f7d455849b4b3141d80405081c20b83565ae648919db7a1be7ce6b6e51efeb85b3840543c6b81e4fe81edacc5ed6728f04a375d90868d31fe55730e3b368fe5a3f85e3e0a18e83df103ddd116bdaca85c3f326d3db62c165420d9cbe42dab59358976b51c98df33a24e8814d44cc44f11e8545947e3435f6a74b27c3b4c0781124f1ff461cb5375db14eabf0872d944b1df30809d6aec8f009bfce841408eb23dac84961756e1cf073f06c760d1b62792c90e8ff5c38670522ce9113f40ec06038d1dd0880ed9f7e58eafabe4b4e5e853972a2205a8e8950c26472db7d7ba43a231892a20664fe0deec6ed3e2ad2cd64312505ba230ae973cb9d73bd8569d4a617723ea6c6e0dc35d43b8764c7ef98d5383339bffeffd0bc15132d1cb3ebeb7399f13ed37c8bb00bc862dd353779d60024f90d854b7554127a2c07aae48ac5dcfa9528ee9f46faa39be9449d5b37fbb1404062af2e138b608ba7680cf2a09826bbb6227bc3d16a7aac9b3ada1e3e96d200379eeca8edb15daffaf6e7e65b5e37080431e6024601d0f3877ae8919be1b9ea786f8f20581883a08354782623d80bf75e47ee75e7e2eedb4af4cc5c21a3438629ef3f49c4600ddfe8c62c282b5cb816d8faedaae8d87944944fe6ce5b304aaf0d93b3181bde04b4c3ec18c2e384d4072464681f029f2c9e5d6f1cb5028edb86cef23b9bae9477a89e82f6c031793a98690725da1a13f032af1b1656b2a0c9a0a0182259c5a213928537306f0884fe4bb36189be3ac6cd6a3c7e99ae38b37286b9fd6c6e6c86bc4b17db4451fc40c9ee730e3f35c021cd00c087cff72b3fbecd709d882947bf4edffb50322e003846a8fccb6b81e41b2c1250d71f3d5f552c7b2bbcb9eace588a8d8f906193c1f78f53c7403df19e04777b48a56f9d46fcb349cb35d79aa4d431a6d41a108e37e4a68212a4390bcbd74c27d86c26258312a9c3d61c0880b77c13b039c57f48aa1ce4ef4bdb231b71a77b6d6312d2d97b858b770fb33cb02170353a83de57c7d46653e1565e65a9ce09ce6488f493b296bca377e0067d895341074ac5c926e35524ebabb7955362de4d2ee61f166383d44ff98e507e1baa1a8e06c2e8c706bcf3e1b052aff59e7843bc558ec9eded73a375157c751e0342a27c7fd4d2e82e02e57a082a113e8946a9c0be6f5445d7c5de52e54afa486bca5bafb857699d50798bc0068cf07f448a9333343333362dcf1ce20a47fbda820d7ca4ac862a5c9c8c3e9905c12f7d57ba89c88b4efb95b6f9ba0cdd80e417d7bb47d5552fdf69b2e8169c7fd166946e3538c0d907575d01b7cc379f897c6819b86ef9f1d8eaa96929cfa100a8d08c7ba476b8d04655eac381c8a566c285d9726ce2a7660d95f4b51126e5309de1c6834b587cd0df58fe50ff61ff651260733726d2f1edbb2b88fa9de2045758f02f6a832b1cc0d1a99be1f235d4b6c3dfb16781cdd9493bf31e91314a5a7b8d73d68ee80cc02624e99fa80650c82155fa2c4ac54e5f892cdc857144a6eded3542756becb33c65e621e4bb3d5cd32b3a1702c5153b0f43b0c3d7d4e5457252f4463e5d6c203532531d9516ab7cbf1177c18c64da99f73432fafaa51563fa62475455d03d52b629401e2bd63ef37d6ef4928feeca3e01348a6324892826deaf76fe07cce0f3b712a6c9b4f1c70ee01298c8dd7587d3dc153b3ea35301ee7b24e6c2f5d40d8390bd1599107dc9f18f873ac58ede760b31eed5da864ac80045cede523eebec4ab0783d746de2406b98f8d6353c1c4977fc94cdfb92901cccd82f437483d80d060d955a5d453026249ae1c705798697a11e46e8794d157fbce56687ff6dd9784ca6a1c3bcd8060261fe59f6b69aa60cef47b26ef23727cc7f0ac37c1fe8c3508d9bf6144cbf5cbb4826d67bc8074902b039a632ba1fe74e64dd985cfea00974f2dcbe811028062ac1a60a9464d645869003ae1b0755c9b66b36d2d7c74507392b2ee529a21e385a6bc46b9a1c186839991877795b652d362b8c1e0ae6cf6450c308d817b23667279006e11e4eeba819daed327477432e0660a97aea981d4af82d53df7271e9b0a58e894eeb3e07ccdc02873240f1852e9584007bd363a0733e27e551954b1cc6040842c04fb04bfb0d3302866eb0b8169187e77d2f90c0963a376f61bbd8a9a079f0ccea3b11404977d16a1b53550d45e16d87f999a1a99837aee65c03f97effe3bd3751cf6bc721fa44d1eee5df2baf61770cd25b30b41e06194f723160189b62160d400f39a07e30bc2015765304aa29adcc4a440183f09c614651c99b431d40bd6ac8a00e85008e17cbd62daae01e15e07e72ae69ec15c1c8761996ae1120cb6dda9706edd18fabd1fe8f9d15c4492a7b55d17a8a019e80b24d4757cc26b97b9f4918b052e0a12f7d5a06203b43c4586951d72faf0388e5b2b26de330025a214b831c69bff48e0f18d6b844b216056b2d2aee5e2386b43082db0a69453cf4f38a947159c2adaec1fbdfd985fe505275b1a4993b4fe8d8697c7a36e17460d0d1623b3e2a72e81a4d29c111a6548c6497d6f6cfbf8ce44f9908321a6d891833ddf25382573fdb09fe1e62ba2e31976308bc9b8d8b98d127fa15179d17cd4d879bb3f7c478bcae5664397fc68fe506e95c76c944aa3e46cfa9eca9a23c284759b6d611982e075c72c7dd97b2d6bb0bfcf34b19092733a1318c6b799a2130dd6c7e4d965edb39b6757c1a2406e07b8f0027c87bf88270e2f1bd98ff2420b983ddfca6e5279b78f22cda62cbef8342c50f56e171e13c8daa0c21aa37660d086c9d58680b37350bf00bb833ec23916f366f4fb9ee2bf768cdc8eef7c842d7bbd29b2da06bed7eba05ff97e04e8a6c3f1eb01ae8cfaeacf44d00d010127bacfb2a40cea46f8d3a24b20a390934727c84cc1b76a2dad14f7794ac27a7d65819f80e7d18ac70897a8c24ee023db8e0a49e384ee4aa1287a6979dc99b9965bc40466a604e2e44cba64adc67c6fad0b55d668d9fbb14ff28a8323884fddec014fdcb690c2ab60695795f69127b016abfdead652dd41d2294e3c5122b9bb033cbc0c4cb5b82906f6d27cb4f47ac2d7b884788895583d8ea065dd5a7271b3661212b48603ae722284b16500189e62","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
