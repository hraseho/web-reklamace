<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bff6ea29ecb3bb2e903646c62b7ba10c8c072850cd3d8b30dda2613ac11af1fd911eaab5cfaa5fd04aafb4c0dd795a184d8078ddf5ce990a71f7625dae8d2f9036c4417392ef0b93b8b5a059b2adcb04a79ca6ef5c4b9fcc8f6a06b00dc4d9e6a61dbf184620dfc3931ca72d58ecbf8b12654ebdd79fc80ac7c26ccbfe6ff99b6b2ed81e62fe779e8eb79a5bf55759e02413ef3e77ee4b1c52c26cd893cad727cc826832629564c9da99ad62e07bdff11cb3f9d6561bab5f5f0f78043bfb7ab66d9d068db262df7f53af9879f14a82f97c2915b4216ee8334f16645af96c0558863f40c809e520a86fea693d1b13053d4073b0e16351418045bac7b90e558adb668d2d4d4406771f69ebc905e8aa394c71a75e11276c37e863824ea387be0b777ab7c92e50f8b027f7ca71f79b220f3ea6d886c8ef017917e181e79d12046eafd81c69994892d3f0c10c5007995a13b00bceaa82ece672105586156a95376b79ebe3abfb1148550c2ca75e3da0ecebde87702b7b3aa66b70942016c34cec6e4ea7a331c4d44315e544965640dcbab3b33e477b38ee673b7fd8bb47bfcee7a2884fd568e6a4e510121971e94303f590d7ec0cea229e375ce4a5490ba7a8598db3560c828d06797b647a3f00a4817fc5b59d944013011473a4ed1750b983567de3f07264fa5d8a73b5f566591f1a9bad7c2c75163b7d9078ad00ab3b1cca0e0d64351c123f9d2a8031e3e1041480233e2e2593c1b97ee0cfdfa848abae1483f98ab5b67eff1f2635a70bf191f9218534e78d90fc3b70d14ec04f1836f13786e594be3686fea5cff6e44f8c5b834364f3ced68e744f8a29a0c9b700a9c2fb3ca0af679282aae8722ed94ea320214eaa04af554a86b27554d651b982161dc40d414128b437fed0801cad9052db1aab2347c819236046a53daffba6cfb46778466cf65fb6ce9d851c4400280489a45be2dedd839d9a643cbc5978b56dc4fa7e4fe7f4c645a031d1a34a305da0fc5a096a6a505832bb2359e8c25c413cea7bfc4ed3aa0e5cf6ee90c8e2f9e76151fd374b4798d71b64f7b7c3305e78485f96cde3dadb5e18e83d010a64642dcf809e05bf3d248716136e492efd022f0bf3f2aeece5aff5f9f03799d339bcaae6ca7c17964a766c27ae5d84e073e2a47eba70d09f13953df7fc2ed04f3cf39a019fd828cc68765d5476d282995943dad23a583d8f2cdf4fbe6db35d8aed81f472232b9c0cc214f86870b0c5e14d14636e9253db2de186134b9314f0e45974e3c0d222396d86dd74429f43ecc9ff3ef8169c215d158a50f0ac1aefb55ae272b25bb01d86eee00292d4c42e33ec352fa3209db10a002c62afcef1c6ce277a64905b167409207d69370cc4f41da801d909b62c1875bf7029d967f8d7ef4fc6484ab4810acf86dac4d2bfa6e0d2d0c26ca0639fdb8fc395843286d7b30be17fd5fb68beea762b23eb98e885353d26fed789af9d0070e96b22252980a82927793bef18641df680ef7d70593856a6b98e2b2a36d90ee40e0375b83b0bd0e6affef8d6da62e76dfc367d670d3552903238c154101da59175e9bd201b592e72ad4eedd7be41e5460cc2b9c3cf7183887d7b89b8aa3e1c690e1c016644cd487b8bbff298fe83cfa5b891b71aaf931ed270e09075c95c8e6e3d70d14ce34efaedb46244bfef8b69629a80e25db78e87fceb61caee91bf9d58dce7ceffe9f682ed4ed944f25eaca2a741967a17b0ddd5f04b44b3163287404c6204a7f818cf85c60f38a83650dbf8afc5d96505e3fb5e7532bd8fc198f6a98b4575ef5d702a6f8bd2436873d1598a6f49c248b8d1d2a977ab989ca45527f2e06ceddc9597772eacdb11261133acc6018222aae0ae34fdce1d1eae55133ce73ca2c20343609aae9f27a37d0283bf16a6fe7dc114d6211c50c6dc9b1bfc1a31142ca1be4eba6256f61ab9661955e528505fc3f8ee6e87ec4bf201614ea5c7fde2ad7ae132d61feb017067d6dba99aaf28c0c0af87b713985ee027535d970057e6453356d2855516d4e7b112bb1de04320e746194b5d3ef71e9eafed5d486862a573d34a2aa1698b45a4a0e7b6f09949f47e6390101814a8133b698d2750baf9233197a5afc33f26fce7047b18ea4cc8b01d0191d2ca2164d0028af2d54f8e60b850abe41e0e3c94b27c45d420b25a05da4fbe68a9b75325768f10c7fe637079969db587097d705cd111d5b904aacb75ebe0969045fc2d57b99e569fa70f3ed5fbfcc973ae57c8667362250e3be1cc5d06f2b524f17cb42fbd502d7505148796ecc7f22565d2ee67a707491893429f59a3db0177aad6f72b81f5b5268b71a7c945281f91691b4a24b084a127e6118d955881749af6fc4168eeca48c306b58d6a86d015fa983c864475d0679119bb2113fbcb7232831c1f862a94218b58ed5d9058d7909c3da65a60d5e54a16dbeeea90e15d7a1375de69a61489c7ef05dc32f9d50b97f76fec0713dfe386a4a931f4c3c3da5ecf84126580314cb904ac2ce9a84c1be3a08a049a0798d2d25793ff36bd3a5af5ca4cf1f89a96fd082e26ed0ca58d92ec6d9e4e27f7f95d33ebe8252615f33793f002c28100b9ae67a9d7861ac183a68502dddb24935cc9c71e73bc7c9a6fc25ccfdc238d95a4b7b357d942c554cf143b92ba19e91be3b1d3d44460d21101a1cca4873c067d1fbceb0b93306006ebdaf2b685bb4522f7366febba29a57991dc348e30555a62f1020c5d9e86f5478e92d35550c53911bfd5fd7606b302bd1470373992fa513bb5b61f5449b5e995cf60b273da6b87f9a9b6036b854efd347103c24777f094e1f7b0612443f84d17ed26e003bb32fd9994708749e5567f106d9a2e45a8477bb68d3cbdc2975252c1066d90b7e22b058f63f69dc44bf1b0c08d3c315094dd754bebf87ec7eafd24f371d299872af0146c6b2cbc27f61a91b04f4b39a44a422d193bba49dcb044260a4106145a289a03dd88686202b2d2eed747ed432939b77977e2d620898a67a93320214b8f23770e34965b6b9b8ece216d4ab0b5c0079c52ca513336a1481d9e616d7b4cfd1a2626ca401a64ba133584ed6f5cba5ea69f219896d829dae4ef6a780cc0d98169ac6434bb926df4c05e49fec7e63a58b800e774fe37835e851150b8f79a659e9b28d33fb7fd08598bf9d104567475ea1d0fc44f12d17ff5ed72dfa8819eb5a01925ca783bc32b9dd2221211956583366e910197db2377cf58900e6947ca1736bfe824705816aaf70b0317dbc31344c11040df93315b94f0267baaf2bfe34bc1f66087ebc5fb5813ba613800219659cd7b1a7ebeed8248aecc19e25610a034cfb289d00b98b901f3048b0a9ba6345bfda18bde595d935b0a60b189b41fe1d206cc7c94cf9d818b1b21c5cbf934f8df9cb27a3a3a9aaac566961f80e3295931741a13e3202c584c14efd7a033a37e66684dd1e5802f058e4819bf256605a8d8697df64a6de269e607f613ae5a486f18edeb80a9ac6060fa5f4aee16555033c779c677da3bc1ab21fafc992787ac783815dcc7550e5c0b8fb7875b2d5c77905e0e3ce3dce5eeb784b88ab6e12e13def625ef06eb12da35c8234095cca4f8484bb3db4fb61e35cfd3fe1d538d2a3e5c00bfe1b17846c742a3d84e665c3794a0a4d8d925fef2c62f3f4aef6b809d85e1ac26978a240f40a18b18e6eb135848b26419e225c9895c224341a03a1db6d85de8763ee1191f4a1f2e20d30dd70cd09eab1cada3559ad94ebe1255695e84a6b2483f9d370c49bafef9a65a07d68ef1c38b6a4493a85c949fe3629a94b4ffd7690b3f4aa610b94c7064da3235341fd5d1d54d480242bcd5414f8d57d2bdcf8d68472a5b6ee40696a4771f45c9df955c0cec0fcdcc64318ea4b6cba678f559896acea928e4a8d5958bee8a7a9f1363f744c1443b238e04fd595589e765f0471a115d2f1b8ce1a2c66f2fb19d7fca9fc1fc84170e4790f948685f80a661bf1039ee3a7321583c13bbcb6b8c88a7f00c9826210b7824b1a65be1738927eb3bfa259da5c6b6d2c2104a588d2145c7a79b5b5828d274c80a15b999dcbe1bcb8f4bb480dfb1d102de60091e1bf59659a76cbe35cd27226ce1886a2bc78c5a8685faf467c3507b6a5192f27f4e62c5ca51f45cf109c6aad87275e08fe6c8e39974a134069bcc2dcecde56b91522fdfa66c4c4658be9d90afcc652095e785db18c072bce5b41c095ccee6d4b4258d054e11833b913e961121f89cc33e99246717cea56f0ea730d0b265c3a94008a29164a2f95e65875a38199358ebed0e84b59aa57471dc51d880d0acedc2b20699b3f27039c24a65f5e6a8f987b8ab45ee805ed919061dc68dce983b02c6800c83bb7616cfeda3ff75fe7e4aba9f3bc74c30db7c8eda7e5d7f801e09b6fc8bd9a1baf0b9caf46c3ad2df415c71204f21f62c814e252cf231e2bbff65b54df553d5bf42440ee8b62df1e343cd8a5fe5435cbb117c0a82c50cf099d6b275c1d19482b144e4643b5d7eff6a42839fabfdaf59172bb1c8a9b9a8a2df4c282ae215b358037ec21aa34bc5638397246f5d7f003fc205694bdde196a7883ad2167fe7887d2601065f6350d5352203a23546635ffa23e3f9399f7b6920c05f31d469b82857ab44684ebbc6fb30eaf142f8775000e22737e655fc792443a71a925196a982bbaa9efe9dbb67839771d7dbf93ae76d65949864c6440ae8ab5990bed60bc2e4390e25e1580abcde5038a07fd9bc4a1222bc7e71a7dc83d9ca5659f73ca06d06747c22f9045c8c33ab596a26e6ff52823213e2fde2736e6d77084bedb0d5e4661bd8d264614590e30c60f9fdaa5812770412554ec0128aa1a26abf452dab90ef051b24d30b585d8731808b41e3ae70ad93b271da5c69dcc6220a1e6ff49b8cd8f4f7709fbc2bfdcd0e4bdb5bd102cf4172b7ace7f2ddf21464f79b8da594e19b2d49e731a2782861debe654753290926df745405814cebe524a1e46ae12b10dd8af6784903f54f4b9d57546a42a89891fab2fbee3f19d694ccb903f237c287f98354d99871dfb77e814d5edec1fe81d907004c327f64d5c2e41cbadc1165f312053891b2cd067389b5ef8e06c854f3a7189a6e28d347b59ec5f958909f186bd099e740e3e671a9f5f882567de7262260be4d88f9ddb03d05ff7a59daabab2a76d874cf8d17b0ea5418dbfaef9f9c90eae0cb969e2ddbc9dbce1d30754c65071d6adaa7b135fd73ed3980a89de5cab3ad0e91921d3490572725551f120df5afe0d9cd603b2a402da0bd4fe02112f2be97eaf963c4bd5b878125b27bccaf5fcd12c7d8db786e196f8327b4fe56b0bc4b0b151406377e5cdcc26950c169dcc5fae6f5534c2fc8fb1eefbc4c9950d0f9de49b9057b6c969ab6b59fb10bfac15a03a7e1246836a330e263a83938779b6d1b139492e556a041ba7d01d68b031857d5022ae8eafe7eaac2fe6edd583814ecc8dcf7fc8568e0eb4ea4d6255b92aafb1345dc78c96240e77b126e8a430f9ab35476ccf171ccc31d58043675c77301811a1c14e481396bc12cf712d2c161a2fe11236a895949f4d651085f72ef241928481f28169ca9ca6dbabd3df83ed83812d4c88373bafe22edf276368dc55c6fd7282a373194b386b95d67e48ba5ce7f1770f50bb3ed9c342ce589706349a5090f48661b6f09c193092b182e60a08b6d5b2e239f69250fbc0bf20c0c9fe5a215aa0b830655d822f7dced9f18b68284f25c191fd2aa907616a470f3caa1f843ab53258cdc786b355f9b5325251635f79199940a58e80436af378b6fcf1020066da6b1ca4d38a6790e26d943b269144f0d9b0632c7561f75dd8b54a07a5fbe0ed60fce244570e8f7da5e6988243c5978e8f33e260ce9182e4f186a0a353fa6048102cd9215bfb640f4edc61fa3c239fcbb23f70c81d02907d40d134496b83ddab1bea4a76b1a5313c3afe2916e8ee0fdef8d28ea4031daba7cdce93fdb33a9ab5fd50eac29b6117ef675fe29286d417b4d48c3b01d2372cb364f110e405e3dfabe83b37e16ec6d30f53afc9865083bf12e631358818f40b76723ac3abae31d9f919e8b4675a58fd87ff217443cd41c008a3f315d01cc3640c8c26c708e6a5fd568c92cbe4e524796929cb0a22fe567d6c7ab50fde4e13b801628c7ed6e96651042c4a66a67f34926b683edaafb70a07ae06ad0d4473466c0199345b8246b2d9c0d8c9ab9138563c9037335d29cacb3ce4b6f34896baf06992cc629fcc0e87fc0e324d1570fe663a5f09d50f75e6f8cf54a3bb691257103150f9d3f06e14bf6ed9cadb4938ce7455877851d6cfdb24a7cb41bc30418798d635eea490ae462daad7f28ad0549e5cd7e79e4f2047d1adf1fd7d27cb16ed12518dc57f6f5fa9ecd8c1ecc85918e22e836549ec34d4c6f38e84feba5256e1377fc8ce0a8f5a2d0610d2a5268e2f67ae511c25cf17a436cf167d1388b995ee31e0d020b10002d6e499cdf3ead0b58f8dcd4e2fdc8c0aae789635cb355a41b4db802ff46fa78ecbffa6944de8a3de3eabfe4ebccdc09121c6b63ac783f6819f4361d15c262781bcf7d930112e44a44a7f40ed884bae74873d55a20c010feb19845e084edf4a459ab7b7a6ba33cc1db9b364022789dcec773abb634373ae20f2da1db0aa10c8f728b3541787d91b96b702440da5462dabe9750d247ed151f84fe5e537854210d955245c441b7bec7dc4ac125031820f2d9fbdd54ab7cc0ed3274f0bcb370bced70d8445161f979bb0605342b58d83b0a1f5bf32d2545fcfc2337c4788f27c186480433592ee0f7869fe014f56049495caef392c08398dc2e9d839fdf521c262e90fb0a6480179d6ae6f3e706d0db86f7de1f5737444146751ff9a8490541ed2b711bf37c04f55ba937b0967c3842dfee3d81e3ad5c5ec7c7dfcf1b7a09a192b278ea5ae03991a207d7a800822b8334cfd17e0c6e5926ab23548b3d6dea4703fedab0f3e8556ee53c61e719c05d0920b898c1dc4c6e656f07e049f2c7e645a30c1bde495ccbe8235f8cb9b8c55e37e2e9e24aa1ba21d73c38fa451e96c85dc66a8780174786157357e265dda966d77cffe5d0d5d4973d782be6fad917ffbb81f439ac4a2551bd8901fb1036de08468074c3e03dd675da4c9c50f4864a289021fcfb611f5db4c1439e349ffb62882f0d12cf118dccd5fd9370affdf97c0bab86f467e395c083552f17190235d6ef45ca3c5529c882f27d8cf259ef136b923413ed4a1229977429a352175722af3601bd7841ab7b8c9ee8053faf47d58c33d82931ecfc725f911fa0e159fe72e5c3c208e5b38eedc092e28fc54a1231b9076fb2f283f71097ef9a1c3fbf55c7f49d85774897408f5a807989459c385c875da78f3a42b852ed8d5e9c023ebb38ff9e956e4f9bbddeb6e07c15bc543ed91cc4479957eb795b1cff6b0e2baa200de9c17b5078bcc272f5815564677ff26adaea51173421dc024b1c2ad820bac5cb5a633b195784e73789dbe0f4e9b823d0f4b10f010a711e30ce35ef6dcfd89cfa10a8cc3fe635b16d93a90f3b042f39075242a43405cc325cfe0664cc29364c0c1041d84a16577e517aee9961a7f38c47d9a0b274dd4f6c6102fc38ea052b872e22317e040443e89e2be3f11d8b9e7e6eeb0ab1da1aac1efe28ad6880117173f1e0ebfec0aacab969abca3ead0e2ec45aed87754cb690893c7d15fdfeae80c41b2fd20644d956d8b7e5fd92b71679e7476a9c147043e05bed1f2f5f605058079f87e2592c77ab54f1277a68690944a0c80f2f9f27d5c4b4008f45e4c726fe2babd736c9bae7aecbebdbb59bcdf766caf2fae9a2c3438c636fefcbceb9e73430742dea2fd5be56be59da62a036de757add3e0711231acb37b437709e700d64365d4beeadd07effd2a1d0a3f97dd834cda8a7e527191858876272f97544adb9795e96a0db5a0f08c9d7c4c05b0659766154b7573ff5fc2b0d1a7aacaf6f14e7cb24868b5d41a0b5dcdd7863fce650ba824959b33a18214424fac9babc36a9e1fd2c5f12f8b4ac0d3995e65405865b11635ddb0e3c846a4f28c0c714ace80bd1b2829140fd8879c7be9f91f2a5dd84f178acb615960c6ac7ef5ef993289b287dba6be903bfe0d43f416d2d1656de57461fc97482fd6f8d7ea2747a39d5647b096273c96269021dbc15096e2f8a53a9d1f254b6747c35c0375000282cc8531d6670b95191a3c3953f11157e8066784da2a9cd662dffe1155bff4597fda02f482228507ee01450f28ee0eabc2f2185841064a2ef37c5633dbc0fdd38f2fdfc3fce4454e3c975d2b8b2a95464149449e06c48c248ff3e241c3b76c06b15cf06003c13fc2805086b07322f16310aac9df2df5c28ec494e71e793bf49d56f3cc4842dec05f486e85910e4b32832947978a83d7d455f4c0464d1869a62c3d64ce5f93e0f301d291e434bfda8b4c0385418c470520658651090fcf41526ac792fa3b88119dbaa0ff62d8a3466adbfa2fd1bbf3b1a94301bf1bf70835220f0ef2d8bb14f92f7c4981d794d218c0ae8638f69e5b0d4a5f878a8cb8277b73ea8d836327dd96343ce391f4fe912ddb0001802a1fe83eaab4e4c1f4c99477a43ea0cf3af40f42c000b8780b9b9a28b9b55a1c90ace7e6c968dc851829d4546d1a972122e9ffb26f84b1ff7e0307cd71e0959dc541b394dcc706dc4b35b3c6a8099b0bc24be151f9464a8a55383646ab2c5f9ce6d9df9a5044805115560bcac04451a190bf7c07e81bfddf4aaf216c18bb220362094724e6b4fc54f37fd5af2240545991f57a5ba2a75660d4fdeffa32075140d0e52fd71389f79c611cc7838b995e338f7d6d493f200dd3967748121731d7d5b83e6bd44d42aeebe24e9ba75ff84d34ec8cba038254cde1d15269a3aeb10bf996ac991d08cc1e5fbff2de751ae18db3c4c4b30ea8bfafe44db04ffd21896729acac20a9d076d5cc9256cd26f8eee209541be2cdf3e46c2f46ebfb7314f6d6c5a542a231fa1bd2fd9ce6313a3b4de0446e3397f7ba992af7db6fcdd08cd3d82162335a9cd2572a6e0c300da27d0861cc7cbbe47a8e03e2ee38de78e5f9b4ec894e14711631a7911582b829e2dd4a2fcf2491594b89655311a1bc91c3bc61befaab1356378a3b4559219daeb3412cadf7f66a904cf6cfc5006b6fc2398182f76836feb9fb026a15f510ed59b95565268f647b661bb4e507e2780494b4b3b5fbc9ced23189e8636a40d32d93b5c33ed80959bebade78086bbf97e3bc3d34fd34e9a78146181c457b5a0b8cbb1f2cbdaaf38d5533a09bce24292f4dad67abbc696b4788b9e6aa93e40fb605b099db1f547c93c72fbbcfef306191b0918a80129f995e073f6cb2f535a6a96ae9caf73ab406136a7f8e078bf48718325e184489ed828e8430156c75e5a0e6b0a63b7b7f80d5fbae5538081411494d12970e2847778e38ee7919c3fe28f281094b66a41e78a8895827a1413da7e275ed989efd1ab1499926b917abe81781801a5f8cec6ed5e35e75008db27aa3683b288056f9cb1d8baf887c2a2efbf0974092cfbdc1402e056dfce58a272d4211e1c72766598a20b2d667ba765c1b4df6a8ddf6fa30e7bc46b5a0989c0dc62d44855529fbf8c822a5bfa915c0a81fd35f964cc2d9bd9c0014036bd2e730107bbfc55ce80e3632d47c8908c44d830473cbd3dea7928997c2eb284df51570cab9c0e25b9ea379f9d8e3e975ca3a637e5a6afdcc76b820aa4fa7a8065a016303fbf18dc33f0d8e06f2df80a52cb3ca8e9d666c1cf0ddd1af4852f764f50603a0f217db412769ee5733381054043bed854eae01ca54ddbefe809fe09a738816c69f333f749c28998a589464914e9c666e4fef6e0fd589412a165e71ceefb7e1d9dd353d7710bea757b0c44a9fafd5965383493ab90d2450185e1ddb0da427e8476102cf3f0f71164af58891c356f3381a012e49e3ff68a02102efae0a164a6bb952d9644872f0289b697dd5a6676a8b84e1be4f802047a20af6fc1264f9f376ef2847686e511f33f0f403878d6eae0ce08ff533ed0972d887c7246d33a7135ad31ee6e8a011042f857d6c06e80530445cc61c134cf661fea8b22a6bbdfe4e25005015a48dcea9b024079bab797cbf50954c877da94f32c8de22e415bc0fb957444832f00c2625ec943013583910c1704692312a731ecbe5fc2f10491078a89a0aee6ffce94fc9ef6bb3e3fe186590fb12d539d696c6c1d7e4d00ae6bebda6dc3325d994bbe7befb3c8429cc7deef3c4a8ffb7d9bafe046af291e15aa378b6c01a115d014c242403e6f04fbc15d3c3890998b63161a2a47fbd6dcdb48680cf449770e3c9e9028c904293eca6eeedd0e1bcc4241118bc3be9806d9dd3bc31fab70bbfeae6ad84e63f322cc82f5e7e12169d586f362d77cf3a54a1fc8a8acfe210b2eb36c7abc0d0f45b758ae44a66fe7285fa1da4bda442dbba99b0a16c35711a6a857325b5fdeeaeadad7934a46dfc856d8575e8da4b01ffb6e44a7b3e7f035e9c2cffd95a184887077ae85afbb8ca7318f1cdc6e2b0a254feaecc67c733cedd14cbce7c34bcdf77e7488c184a7b85623b49011a4e3233730bd8207ecd8fbfe12240de70f644032f31a4524fa852674d267ac90374a0ae1696bc1d758ff63f31851be4b2988c8f8537fdd0c350d64fca611337eafd6c19dac25952da66e9e8a430e2d63584f55531e1cdeb468e7d291e0e680cdbfdeaea4e0da55ca2a9f8ba5628d548c11ea16be81df4eb1ba8abf7cc1264fcd11d9922ea1bf9530dd5131acec3e9b2386b8e7172002ce55fdb2c3cdfd7b655ca70a300ae17b8e9ef80bf0800deb441a623c3ebdf998d91b06d67c4bbd45af4fb43fb3e6b0ab2d82940d9df706a8ea7dd75d481f5507def0c5f95d951ee4d5b74a0e3342af7b68b6dfbbeda73731821a1d60000dbc11e7052df10bc26632a7917715fb372b55e30ee7a68798ee41e2e8780952de91ae40835e6a666de92ad3bed78c35de6f4727baae2c117d80b5a508739bca42179200896325f8ad812b51507a7ca7d42e873f94d5924d2aab872664453b5b6e964a985adbc18cc9baced500396f6579c540f809bb31604b410b46c2b9dd2fc072eafa86170c053db8480528b91a6faadc81dd776ef8073ba1af339251bf2f75835f41f34e52137e617c40e2805e22f31e84201d2c97e769cfc767efe9aedff59ed92b9b4d67642c39056ea6cb9da747d091543c69475ca6c6c9d697d19545275975bca5f912a29fba6c26bd0612252a3c4aa4870126370b2405ab9f8186cc9a7f6dc86cc9729696ca3e20cc23d7100f360480c1de29855ac95be4c7fddac4055d67c4d61897864f5d6a88770c4a1ca8313d2a032f964eb94e4023a6a85d0d3dd2bcfa7dfc6e906eac5f4ce448733ab2d44179c8cb109551f12bbf572a566e30197272d06fdd32e8d85fa6dd9d5660943179ad8a68f9a51914a8db29f0ceab59d935ff23e9dcd443df9e41c91b2ac625f576b06eb94ada53a7b92f2683bad539a57e0055b557870d8d2147a8c8e99b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
