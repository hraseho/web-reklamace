<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb7b6a0e49487506f3350af825bdf260b4489d6966816816578c1492cbe58333297b5bf4e76aeee819a627082279066245827a3e5f75972d0ef35482d2f02bd411e6e440cd611f0160e0fcff32ec939c1632f4203afb331ea75100e91dde19883cbbf11bb135df0c7ade1bf4323f594df52940d5339a3d73b75fb6e1186da7d8e0e048a9a516f401cbd72a01016196d16fc16a20113128adbc339434f524c715d848d870ecdce1be025ed4f34f33bfd6daa0feaedfda8931c5e6230a92cf246752747202ee7a259e6221887820ec16d108c8b8f3bbac5e9a50efd6878bfca149e661034758f1720f484c2dfd0f5163db105670b4f2c57f06f9ecf938431238a25c08d186c694280c4e543e0d808a0546ac11b5d184f64b879f1df0e1e076eb44cb1082bf7d94959ea98fb97bce581f9fc69f2331d5e1c878e83fb7e80afb7cfd27dae5bf000c998e394158fe7b5960eadbaaa4a43296bbc18a9644455447aea6a9298ca7d73420c559e5192bd3564a92cb40cee06224d98f08fbb013663e7d9079afec9552eefb075833b658afa4a3ad92bdc611b3e8e43a316e6421ec6bd3e77aef72e5fc46e4a5721bf1332c20482391ec8a81366867d29a96de81f990861e5251f1b140bbbb2dcfcad42bf86b1d8cb281891b4255d6c4ebcff9713cc845838f6841aa8e91114bdc7c1316c3c1f49526f24a35531300e88debbf61e92b8d03e7e17be028c8f82f23da968167faca362a03571621090a14f02e412f2b5f9410a6403dc622f4cccb0682b1afb857437dfb70ef6ffd58f60a42b559120a2bff9be16f74cfe1db5a5f3489c8664e74bfdb0a3a100a8fdae968ffcca72cbcf3f93d9b1fc59f0f64b82a07ae5264f45df9fdcc4efef02ca4f89105b3a729d5de05de060c725d29ae321a082233a81d4c64a323c6b3d5b9790ecd0386b3b9ca7a5afdcee6de5166f53d30d0a611aa0c78d1abd2f5f2b62d0d821552eef927b835d41c4ea952e19952203b840e84f6b15f359f5cfc9576c2d9a0e4a33f47785b7d087dc76ffa2a191bdf3d373b7f574ed088dcf3456c971a8f48bf92694ee4187c81b7feb70d302df4f54b17001d8310f74ff96f7cd9c2599206c76ba9310aa057c7b9f023ecfb70868ab702a534b6400d3034d370ec77919651b9ede2106ab54b7ec3f2610877374e846faf32ee90aae207f27c1c92571e08cd274f8329355a7c22323e18a09d883fbc65ad61878898890951f88ed2f4e2a66a09bbc81807024249ec5984ff7262ccecac74a8712027fdd285c07dd38ddb4a2368fb3f85e5d1562e27a67cc6fb482885b3b0e52ce1190d73323dc4f3d19e003d5aef2adc4f8952e235b54d681b4491c1d861170fbb07a31fb6b3d0120e2161d218685ae2c4ff1074631d2d97cdeb3b6e3a46ee1f0b137c473930e0325b537d1f8d0d5f3185c607747e88ccda46076775abd2eaa99efe040f943d254c4b665f368d6b1233d8742d8bccc031519c188680d83f6515e034304044dac8fa21b97c1174e194bf07d1182b3f6a1b1bb2a0ad552f412f23393ec23f50bec0857caa3b78c52ede781d4f13202ca5993a5e51189a341cbfe9f28dcd6a8cbe0bde1d911003db62201bdc19819132706954a18b28d19a275643cda3da946fed0a56e0be504103880d9d50706f11431c1aa42cf1dfc39b1d4e03dc673ba1e7026036573e122796c5e0c3f9bb3a6ac493574884e6668d64ab8152bcf460f788d2ff983ebeb9d92b9a3499feecc96c3d1a254445bdcf45e58d88a4bef44c372f5ba6ae31c2a3d2cc578b94d77c03c30087033bf2735bd956d5f5c156b9405fbc52f3ea912813d0ac65db012e78a1065955239664a33f881191bc1be7829dbcd5b967e47d0df6ce0c47232e62b85689a87aa479d290a6c8329f527164ff9b6041090a869096e15af528a4f40164d10c98883ea0666e20fdaeebd0fecbe0dc2ea38c23e27c351143b80c38b2153ad762b09a994ed121244f8965c5e2f3b9fd4d794b19356c9677e4267dc553db49b2d187a65b4edab98c1a4f19c53ac0807606252bca1bb10da2c26bd9d7c4737ff7d74d8a700b0a338a604a35e01c60b929ec22ab8439090110d41176954f7d4702231215d9b7f797beb286cf38e0157846bdb17ccbcc2b8f37c739f5f1eb0492bec6b2b7a16af25e3466d18465c9147bb79ee799b6939cad956af2c163e04a73ae0a8713457e6d246a01f750ced8d3ecda4877e819f64a06444a3cb3e9080dd50302944f5da5b2a1ee3307f8885a0dc258129b78f6dfd5bbb83d47b89f264574c53e97f9e714c9f0c1e97e9f1662d712a3491b071bcae7a010aa8d7ca8dcc0cf7539dff7c437469472d045ab3e2e30f556f91450e3d65c88fef0c03f28f659910ccc6ec26aefe65e9324a5ce64ceb0978be9a88330e15234ac45dbedd349fa88000dd14aa811db7fb6688f36a3adeb56b0af5eca9550c3b0123555f7385210dcda05f2ff408a80d5fa82cb57f5e286af59c88bcdfbfa5ec2b08e7251360259d340c65a3087f2647812548f38b0774152e55231020f1050968fdeb269f0279c24f8c197089101f59c2d3169984f135ed77ac482584a38eeb75a9d5728bb4f1e7316221a3b6a18622b55c2564e67db73c1810926b0d41c70650f23a1e3c7942f88ff31ea3851b7d44421e0bdc2ce8e509a6ca5f75da988f2ddbe5644554ec654c0b6526cffe08e9a1a98178987a3df351ec8a611deb69eedb19454e1058d292e648773760bff879b74b4c600e24f584b71a6cafa1b4afb613f61862cfa8cc9bd897ef71e2af95b58e09850fa62450d96ea91a35d24ec5250fa1975e5fb87bcc93d391966f6d18be010b0329c838f463d5efae9f65524b2036058dca83adb41b708b35362f4150868cb17cb9428c8f44bfa0c26fd9b98ac61d1b7f2e368e1a24dfb6527275e68c6e5d96ca28c2b5cf037aa44c5b53b4839c5ca9e824c06207d890f3ca751522a81b6b00dc83d7b34523d3d4514d89a8053cfc3f630a9c30534a45f821b77422df32c9294e41db3164422d411b620a3822f557713bb195044e10a89f6277a0673c65494923c44f9b1fed6d7d1164f7c30771007937b909b710fa2abd49cdcfe3540f7261415a5b46f090b361283ae21ce3cf6d3383b09dd6cb2c8c8b4eae6ad68d8edd3ce87125b073fbec15fe8dec9160f9b895d64e8f91274fc89ca9629ee9db976fd416f6f9fa9b7b900ca913997116fe13fa67ea55b53cbb49506b776afe88e33dca5f6b006c95eb9708d45eb2ed363071534862beed48413e5e2a4a36fed1c5e3725a5aee0ad7672626d55df5cb72ddf9f71972b301317faf9c044fb0289740bad99d176c2a5ab88f81486a4f89189f4a752fbd3fdd6feb61ec60a924c644f763d703b9c9766a570d27866f30d565caf3766bbc166b10149dd79926c15c34eb3e3c2299f8ab1f73ae9e6ef628f93072eb9b277a5656b448daa772ada5efa12e1efb46c69f5e91035eceb989dc2834c550b6cd56d87f9404d3f9b2d51189f6a6e3029fb47cfe8bc6093666901e580fd646fbe3b1297a6ce310abf8d920acb141ad05a7f624f6c64b2996dd6a7c4e6e07dd41dab360feda62d1ae7681d30e752767a7ba634afec1dfed886d3317183b6693fcf92b4323d47223a56dc5b477173a1772c3aea3fc9bc23adf22c38a9715b11281fb1a4b71426a324a90d6c73f086a231be999be2a4b7fd2da431f6e715ec95437926ee3c9ba2356e905051b46e7288cdf03abaa87ae23deeafac00102873e191cf38346a1863960ab1e06332253744a2ff3e27623831a31538884de4581944408f543dcb68ec0109cca444d9f6b276394a51ade1685af6ae2f1060f925bf2138e186d9ef8e24a4e667b00c399aae2236b115dc009aba75153c810306f30e0a2baab8363f3e6ee091a77bbe92ccc330a2ade7f8641e0a44aeee30f7d53fb99c06e12bf1455bf4bcfd807b6c607c9cb8904e0c5b88fc1babc9f8b44185449e0289b657e7e659d280c3df6d31b57f3255ba76282deddca71ce9f9a9fc387572f74b20fe2a0dc80b92a063465c5551bc76cae60cec97a7231201e1ed739a3110c0259c6b7bc2051a3de4b6f945fa098f4ed3a07322f82ccc59bcf9e439bd40f601f2561a27acc25ba60af66b58af36703dddca8cb5d8fc26cf3b9b1f04fe10c34029af302c187f1498f2d38d5fd1bfd0c4267685aae098d7ec8298565ad954df998f01d48311f0e40ddbf5d7c4d3d91ecb41507c36c01d8a95aba57d3da6903c4ceb74af880bebb141e5eb8daf870ee72d49643e6fda188f442e9c7bbeaacb49ec1294810c94e905ef5b99b51af7416eece3203c26547a5837611430cd52f6bd180ab86942910adc3a4e315c2e6cd4ecbb5f4b53813cdd42654e04540de5273776f91bd404f97e1e216b4ccf9fc44baba633ecf539be56b1bf091918c7812a256136ebce628ba1b264a2881d9d08934c7618f06a66e64480256ca12f958bd9e440514711e0887de9e1ba44199786a9d020abc03b7f4eb33cd7c4a3fab78d1a03393de7e481dedf6306b366e0235ce2fc86149f248ad47f2f2458086f4323ad4d1bca2efc80ebbb807e34b61bd4b0ffd199de6cfdfa8e8be85740e01c452285e4e60ffd9c02273630c0ae184b7fee7f6069181ba807a609395f93fb5d76bfd4add42d024c42cf12802b19607909372603541fdc55dcbe0ca95f7bda91dfb51985deed6d354e7f107dca8959b49c3dd4aebc031b4b21c15068280bfd9a9bd13c743bab0e9cc29b078e55d7c943438f21e4d872a7a439a348276a7def3be7a2c32efc01310cc35436607162de99f673398c3ab728501e80e01f4522aeefca75f77bd2255a5fd798b5ba616d43c24d0aacc17b1ea3c533dfd26c4449968f6d64f4b98a3716ede14fa242641b4c88fb34fc3eac4940827d49cbebfae6392e1290fe8cd7dd41456d03636df86e3654cd32bbc5bbe4dd6877df48ac6ee01baa0a4cb61bceec3230279b881664a2910561e19410efd017897c343e68a8eaebb2ddbc5457e3175bb8373777bd248b495107e352b599eaacf5698dad43404f177c46d381101ef1b63dc4ead5481dc903467496410efd82a016a6546de23ac54eff8a43a97a0fcd1378eea12e9c45b262a4d6ce4379cf12e121da7335a24d05f5d8debf427068905550796762e9b708c3f144b37225b77816ca5bb898ad0e34f9e941861869c1891099871ff0bf3730ddf243f210f7bc2eb2e84435c2058821c1ad0c48925bf4d406fd53e754e3488b20ab7044ec478cc6c2d030e895ccb44846286ca010e38fc64d4cdd2119d92c5ba08811814494c78ef8f094803868c57d6e17ecce078f988f879b7bfe6e30fe691c346ab310185ce9d7dc648ce83c67a336ee3c8f6af2ecab9f9618f4ac79bed28c1996a3ff7d9d4678110cddfb1b8e961a40ebf80801ee573ba827417671cd176b742ce421d4841305f8bd2f7c145f4dd6558d845c120e2afdb374bb25043c294642b2dd74abd6818db378b80ba3d0ddcb3430b65458fcf922e0df1bd39d814af222428d7cab47db5af386af229eec11437ca14604268c0b720b9dfb6599f4d27cc0ac73c9ff6f8f71ab69cb0d814bf10c959f69d7f3c7a04981068ec17129400debd3a793cdeec735e1789e908bcc177fcd135fbda401a6ca25e0475175079dec0c04202434eb2b1abfa8c478b40469047c87812a3084df3101ba74c085f3af4e8391ec8d3a3b2ae28da477d8523ea34e1db01d89b96813cff4689e9ce1924b1403dcd1938317fdd5908abe5eaec8474bdb1d7f13dee273e37095cca5be9461e2c6661fb2047450b277f4cfb4388f6b25166ec5a225c63e4e6d70e98039b5f514381173439d239ae1fb3758ee46ae836aec899a8373e1085ae8aeea464bed6ca5e18ec5be80bcd247d76acd1ca680efa611260b5a0b0fbedaf5719fc3c504df564682e0322d137190689247595688bc87f631c83c4c7a8166e06b8aba88a74810336e6f5900f035e950e07587b528a06736cb5bbcd3a5c863a2e8e18e5d2197c0d92acb7b403c03e917db8fc4c503f8fe5d7101fd127602d407598e94d83cac032cd1aeff5d20e0897bca8087e8c02fb4c485e4a4f008442e3a7e72620b69ac130d6953d5201b183003a1d785ba5fa06ec5f0f473681c243bc75cc93cbe34c33d6b7cde463875553e13e1580299786c04942faead5dba54639974e54bed0dab86bf082769f5072a46d16bca8fe7c94dda29894589d3227ad60c14da34bd74120d108536fb9c2cfd2fc0d972b2c802ee52ba767e0414cabdb0e170376ae7148b091a1d53ffef2eaeb087d6e2bf71a26334a6a2171a1e4b5115cc34547257ae36f2ebd3d9009bcb41724c62adc83339d306ef96db4cbac3f56d9434f92795d08a81f7be5e2cbe045a9c2045199f4ee7963bb9f043dc22cf06923ebeefce6012e305908414bf5adb46c2662b8eb33f3cf78145c5cf1d856c158d38522016f507119a6f6ee34c8b0528489097a5b4f6313057302a561a05d1d049035524ed17194b467f5ad674a953b87243136337dd6fdf47b9b6716aa7e682a511e6b717ec8b9a49cd07719887b988d293a945521b0ff64d4a8a668d4b555fe962ddb859f6039017d2f114c7b9f6c78d0dff708fa6a334a35893a350dcfd2a10ee389ce31506877f4c8a30537aa7122bf47fc34b874e50a685d0a71f52468ed6cab17c60c9e927090f65056eaa897f716a37f322da196db95967ecf5088642a16911c31e5ec98eb2a8a4ed8dd5be722b86179c93668002cfde3f20b5e2fbf08ffbfb29b90bec12ff56342a1a63e9153f0a9d0dfc13a07bcadfceee89459711f7d96974550db62b90c782a70f3ec125c04f3effb25da11b7a5c76a20f4bb3c1a72451599a27a27dc117d6dbbc6e89a7e0dcd0ee9c6d73958ebd6a3cae86efe3dfc030743e778aa2ad2a68d9093f6bf7424eda5037c2df3e52926902905ed958a250c35ef31d3e58bc47576b7837e4758c8ebc8c1d4d7235cec7a243b21a766d155453239286eca92434f0f09640516598e367e3b1ead0c509b36eb4cc22be0b7725a961a1e28deee0b6ae69883621a2b2c9a30ff50cac9e03dde1eb732a95fae919ce0ecf45f79846fe47169701f8b3e8571250b478bf9a6b9bb8ccbe481876dee168c0bf5147be8f5d580327404b878fdd69ca0d88d6a957a0db83635c84e494588fe87c55fd1993ad9f53dc898373b290b2fe01f67edfdd0c52bbbb57a9fb9a662f4f8281dca00fe07a19df3aa34f761c2e380241c634b9442922fac49e7fabe940467e5f0f52146aca68d9fbe01aee20bb63078cee980116bc9726e08b9f12a78f08b3f23053e3c3175f6921838e5595ddd22238e0e37686ac891f2257b9ba0fc1d2d2db76de9212416014aa2c1e46d06bbd9459f3e040d9945d65bdd584f1088638c3092285fc142eef8482931cf830dfd37cf134a4875bc17f2f2271be31808a2a80b1a6da51fb844fc63ecb5df46578cd32a06df1b313de896a1de1bbcb70a6580430646af3e8cfc32ea351ee6cef999ec3198e9704d563021567c0c5c452e709cb323f84759f75924929578c92fd696bbeace11859bc3cf8b74801157e167474c0bd7d4c4025e7bc97b90620986f5c70a94a4c427350233f0e71f09983c966d56a4a17befd8f8e6820e8dc5da96824c0a94c5915b7867c88bbb5f57fccb8454451a9413fb4bbba06eae5beb38997adec7f1c5c2a9caa1f1fc698338a58f125d67d620da7c20615733c396ee471095b698bfb61b49a59cde31e2827260c23fae861e48edce1408674da25a6004d2f662a1fbe4e0919a82a0388118d56ce9303abc88f5ebd1c0fd7a26f62513bd47ea7ef16bd01dc36042cef82387d83f7b00190ed8885e572808d190234a48f40940576294f0ea0d825b64a2593131c5a9d1bfa7ba625859d3fad2001510a2b00696d32c123a0c54c682acc889525dfb41acba8308cb575672ab838635ae7ef8610aa1bb1e5adfd67e4d9885b83bd7799c6eec28d13c4284ba1a94ed10bc53683ea57326eb2432369615026349e4fd25c10d21fc20dc9440b19d3ab0c14043a9e91ebd0773d30013bea098a5fa7b4745fbc8a7ef68169a5a45292dccce64689d47052d632a525c1c2d8647ea50094141bd94d08c1d7d3466ad9c722f7774023219ab98ac6f66017554509f1bbdd4e876af0e19a3fda5ac8d8be0a9bb9b40cf0f58fab9eda639417285ac56c4f2a01268dd64d6a5a15c0e49581fabf42803f873c3b84833eb8bfe5db59e72d48025080f4d8a2fe093043c5177c6d6737371a87935cb31cb9eea0d6bbd45cad352c4c3d55beb01326b1bfad5ed78b8a89bfef0952850a0ccd087a9573e589fe3df511e46b6a1e46e3a50c6651fab5ed158a16df4a74010f7501d1faa4565a88ee47223b75bfa626f78a248f52c2a98b13059a705d2ae77d2656c3bd68dbff94832a9a68083cca3164fe0d5c31e02be240987433d4bee8d8f754cda1ef4877167cbffb721c8328dba9e4a6c562b1559ac5f82ec181e1dd11aeb88b7e87fc92d094504250b369543c9017bf6b95007bf4e0c6ae27199d8ff47b14461083e8dbf8218d8bf69db40a516892786ca729454a20a645f0bd2776db7d91f39d6a61a2b7de1c85377efd9d87a0ff26227a0f24e72103674f4480d2cf7311c6e6201583ae60d815083471a2f54b1ba9876ff536b9430f0a6c480d51412c9b58f915e217cdc38a886cb2820df6d4e8071cd576655a8053b900ebc55e3be47fe42a0005eb0c1b52284150aefda4ccecde05dabbbe372f86aee78dde3911a07bbdd8b3e055918850901b4efa5dbad590ecb9d0616175108b35c5c1264e27def100cb986788a0d36d3074072d9135b46bc8feec105baaa83994094e0f755b5999030830549f95df7e0c551ef25c20602c47c7a01440345a810913a7d7f9eada23be206268492bfd252ac37ea4e94a76fe5f34ca61241a27be3bdb9416503605617cb40b7676b6b683ecc3b9e86630e883fa422154238abaa1d93b48284659862c0b2d91e0f6ff7a952596962d65c5f04a85692fe8a110df11b43d9914884e71290c19587e0e4b3a362902e935359b3cf134b1691289f1ca0f469e8864e8c302449ca7bc40cfbc61847d6bf00d487a29b7260fa77dd096e7d01c067a17808aaf66ecb28fc1c82cec8625f68ae4a1d68601ebc1880d86469ae084849942aa27146b302ef9734bdc0c27ea66815f11c8b611058d25aff9ecc85379b512c924c7a3fb6eab72dcfb04e886cfc71adfe5dd3b44df65583c854081210f93a774b5fb26752f5fe1dd8e549967b560fb028e65aa6149b1b0d08147f607a98192fc814dd39e554810618090176d1f23097865af95b59994953e687160d3a4b96227fec84138c9c0bc272e828fc94c7af6bd5909b33ee92d73deed7075dfd39b28566924c65aaab3ad3b1ec52108fb8a04d490b4431a451562de6df0f5aa8aaf79761be536ed16ed0cb647ff0fa3ad37c8641214dc034e6362a7f5287a76ed0a3e3a86af780b49323cdc837f273e76d92e1b72909ba204ce4cde74ecbca59dfbb19df7bb3cfd420aa981f5054343c456bcae2bd367585c30a6ac6060c36637a70f51d289664568ec7436a6549ab8ff5bf251330d117fedc54b3c80af634c975fc7584fdcf2d9ecd4d822939edeb8c8578c9a61f8051cfe8b20a7655aa826168de7a172dde508862b9050c4a884f3ea2f726e6e077df91f06c2c9633010ee4ade6c785f2de1644ad76a16550eec664adec5d561af53c3b862e694308f20ce2cf87ddb5af7688f5952e45f044a8b387aac2e62a0194e55834f463b7fb0f6308bf0ba1f5391892829c5e965913edf470f7939d6fd971cd2072d0f57ac0e3a71b47f5ea3d5d852cdccf44286654bfc7b550a6f7b5fa2fbba176e8e204eb20e8aadc12344566c9e1912b371635dcf17602c9e247294526a588143716e84d635ea1bec63a5d3d811d2b3ed3fee23051437b910c71697ea954663206aaef05a9cbc8a4ac2c5c3ad5b468ca217f2f48808c13b3c5a0c854f56460872ae7431839df2171aa83a4525ab378b32906c354bc4631695dc8adafe012963baa151a17a3689385e1a98b1a64a9f6d5f4c1944f3561f2f0c3840e8f9457bc8c850aebee49d2b1f6b91516e3d437018cbdf3ef170583e42f1b02e27454cc4463e39bad85cbfb217ba40222b096dbbd839d6c09ec035520f89c7fe9a2bfe0ad2105fcb35a35aba3199050b04273f26e1b796212d49e4bf92ca7777d3402b1a1cd3d98c8ddc85a6bea025707116015bf988957379ff96b393d6c61b957a7e102165a0185d4934df7bf6f67f945c92f378980fef046262736e6582786005e014e88d6aa262a87f3e304ae3fa9ed90b66f0bd11ff72522e42f162a5664392409b062c1f0afa04fae392d347b414c0f3d8e6a5a31da34d2b58b335cfbeec8241d521d878880f27d890f1b15f0f33438cd34b04dd33691ab9b9561fcce2296e18684be2328597477fef4e8079ccc39b95aaf3309265ccceacb3a04342c11fa193378d0d1edc6732dbec2f1e9547ad1de5f4fc79a8c83c3aacad4afe40ea0247efc86deb2ac5815dea1f108dfc16aba7b3f1af1b56e7ff87496575adacb3b4d23cce49e5c08f59959ad88fb661ac500da1cf6efa9c8d8dad107422718e4c3a2f9849ef407be9a5843b158c8770f079c56e3376dcc2f7bd3d61a553da7403d2d6687fada45e11f603d4371e1a0392bcf719fba05c60b4c85dfd607d2aab519ed7690bfcd5e42e95ddc75d38096f949cc3f75b005f68564ced03d6fa4e7bebffe192c9b5c0e7b0d9b37231a25ff9dbc2c92bd83f31d3ebc67f027590fa9185d833fa8dd8716bcd4a53ad36c1caa8db2fbe68def24a749cd767452b48bb6c380e4095396f8657af7a1a000a6eb7d55f10e4f55e2ca6889215","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
