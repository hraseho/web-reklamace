<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43578bef593a4a6b3f26109320571df811bf077b309e9bca30ff2ea6beec1484c3694fa0c2e2a30c40d8a9c85da8e46aaab467651bbc926baae4c365da26e4bd6ad11bcf533ca902148e368691beff9344723c0bc00e2f715d0d9ccabce2ff0f33bf1c9bb885fd114663070ea433e94b9920c7518389daf45e624b485f2aa6107984b2357a6d76d20ea48c7df21f43dd9d7f3cbf3acd9e40197f168f5d8e8d89ff0490157ca2cff96f9b5ac1245d728ab8db37a7ce03f0bd0ca13bc1e6e9fe4d46eff19c9bb0dc638056d27ee3999ff750b7cb0eb09062a8062e28be9592c74bc1188d62b449dec40c94790328ad3ce73170cc383d858dd2b5a7f94dfa6c7174f18047914f45692f67e3c4db42857b3aae549fe966855e1f4ed6829cfa1c04ae1918d8a5298aeb9f2bc2e6ac5782d3c59bba1224916eaae44768c79ce92e99c4e6d3d1749a8a3aa96dd03e32cb7fe4483f2b3d1e57ac6d6de9eb795ac3c5b885f4d2c9b828e00befd5335add2e465e6f5ab6298d45e4386b2efeffdeace6fbf4aa8f61c44d9d478860ba3e9ae295f47b40439975534a73e4c0c14a07fb7df6f5aff9e2811def88da405ed6c9ce1fd909257006330b547fe8acfcfcf02c06d87ceb68864e9256d402fcec8c968523bebef8088b7ecb1d3c6b5848c1a66d5a2c0015f635cbc2cded7a992c2969e2f89ebf50ebfffcdb630171f661e9c2b92911fae81db82a3585efcf4e03eb81181821dedd5219a923fe2f9e07f8faf6a82febf47e9e9acda4cb3688dab0b57215e0e787adeddcff1f0fb2249031efd90cb012ff564e03b728327dd4f4488a418eea6aabb5d713b4165abfba7f3012e0b2cf7954f4e916892a5b956a09ca8de868f9642a1109de0f33bf4fd31eac508a88afb5be129f9a793d48c5d05eafd25645b73feefa9710300a356cb519222785e1aa0bc48d9f3a50d82ca5c035db4dec88ee092ea8b3e2c12c306a50a904e1e41da9950feda4916e527aa307288c1317253eae111d340ea89b964b60b41856d6909e60a609ea40d3c3143ce0b8d6ece0b450dc971f240db296384d1deeb175291a18d34bfec37fc79841e25c4a2e3b64a760cdf48d915416a54056fecc963b11d9ed4d60fba12c961b9cb71dd0633c829e290d5fc72afc4531906c5eb39dd5d1fcd888fc112ea63cd5042053a52ff4ebd5031aea2dab533bca297bbe702aa648746f478a77b5f4448a0e06d98aae45e1057069cf097acacde8c647eca681b4850ab9f4b7c41c0365b836a9b564b3570c9ac7e1fc997e2acb93d1e741dd7a5516d4fa98b1d24257c39e25da97163a10838ee411861118f17e5ab30d51700dc4f9fae6eacc77b644fa53e53856343947ae4967fef3136a4e99dd0c8b72878c3b078baee9a1075639e0b280359911c527af5a52a5ba317363a902f4447ac417d89a725b65e935c14140366a21c28a9447f187b128ce4ae59a7727184ef7ca4f0e054f10837143437ba7e1a17048d6ed4f6fa4fb3ddd443c1f2b7c702ba11e52dc3ec9dfe3761f283a4bc64c6babcbc40a6b2c5c98ebf50365f37357799bb43f21a5a92523c18115b45e77cdc372e5df4e3e8442fb5a1d3b568e59e60df1418a7dfc9874a8b935feecb0049bdd90ffe4ab9a4dc1b24834e4f33a2b40891634f4a8196c38aa6adea729b9526970b5542976677b59d7bfdbec652aa83e9dd97846cb819366cc20447e888073169fd8c807fb77e55423336115775ab6715a66f37c19e97329443ae92b58331afce63ef3a634e62f225144e651250879dea57cf9eafc4d77b5e36cd63d270b38add8c13982cde67c49e7ee1a841b46c7e8345742fe96e23a06dc0e8164c6a320c75d16d39b24d855d7ae326a37550b9ed0066ae07f21b8e78ebbfe6deab152c6c557bab16b51f4d7a13e1009c64a88ab6d3a8d181c881cbf7308ebaaaa14ded44ba9c701fcf79339b24efdda8fe32e94851b9a756f12ddb136385975ae14240dd105bec2152bacd379c9ca496594f69111237284d0664eb0c7b00689e474632f5c2d443385a3976ceea925c156d91e888819a2d5012b5db3bdf5bb5337b3b2cca591aab2d5c5986ee82c758c3e6c0723b2581f6ed5c55408016441e51c04226ec879d55e7fb47a407198ab06f0734d511f3c360882b1b00aa7210ceda90c9b9977cd606980c5b5c740acbe42c1b71fc7d97bb481ecd846a06849256347c0ef833cc4b411c43a7be4713b8c7e535193a98aa58254952f10d49085ac35384dcf58a04e574c06f1339eb96945df2077a98ce1e150d2975545cff6663c7b0a6e66afe757b08f774eab6a8fb9a99ee3f10b42aef47af785050ea446e73246528cf06be0516ecf1276e979b0c699ad60d49cf03ead86d4b5dbe39e0a9b6f1102db60e5db6f5aa17b6577e937e822dea2a5594d48cdd277b8005065cee893b39c00b7934a7695211a4d12fa5723d4b456365fa7f80646a0e79e474ba227a64024bf84db8befc0385da4273f16e5890fe3362eebb00f4b3ad4f683f27227e228f722e594f52f037f9c3f079a74277fc65e2e907cdf4df98e6177fb6f96b9167bfa519d4f762f23b0dedbb13a29e8e4984205cc5a826101e578aa3d237dd0fe67cb9db1f58a5da2733656d21848bb3ab52c7125a1bd89bc1c7f7a1e340e364c5325b7aa61ae29ace8e360bf1494a4e2dc0e28ce0399f2c81e4b1dce3a6b206358a3ce3638b02788f200838101883d47513ac16a5168827e4f2cc85eff4cf12f2841e7f5aad444fd61261df7f59e80601d80d21f3029a18cf96eb85a11c8106cd1814991ee62e40e3afc5c0ac11a61d0b00fe110e0187a3355bac813c6bd63b774a511e8ee8bff0b8bf7ee5e2b2d0d93a3819ddd8b6cf77681e71e82f4ad528fc3f4a594e73cb04dd203ccb8eb2feb2c06a7f60aaf7ad95153964e274145a22e7a28bd2e5db66b6de00bda74943fa77ac20bfcfd64d03e20df5ea53d21410381ba794776c3920ea1507d898c9aa49c723d67740569dc22ea78ed3542982311b201c4f7e0c70b84b170cdb207cc4a684c11312161102e68bb3d4e188a3f23fea4f9a8cf8568cd88b3b42e8c83412fb9b8eb0b2f783c8a2237ebfcce3db846212ce0f065355bea179d119e6e733425ad7faf0fa7a70f132b3f1f15ee099de39ff21a49dcb71ea853444c31ef5202f47b851de157b2243f979d06cb8f83ce463eef240df2cebc95ee254c98e7e52e3c84758a56038fc8129c1a2e8a1216ce0add6b4690cbec8962e478104189e595d1bb225006614daf43307491a1927acd8a2bc46753932f00d2872eca4bc68413400c49133c05530d2e0441580019472282c1d0570e1df6c8dd0ab7c75dc587a2b7d1c03ba907abc652f52bfdfb72115e3aa75207251019343764a99e2d5f556bd2caa90ee42940b0c2cfce30b14885c8142b5ca39d294f0d029c4fc34f7e567332d0baf83f8ee321b806da6e7836a35fbc8a889d7647aced9b490cf16ca97fdd8294cef42bdcff088f11caff2fcc5ddd866205fd588cc13ec7107f6694a920aaa365647a10de35217a939c9f6108890a22c2fd916df88107015f8476aa19812760069a4c702dd4954903a72fa0c71f9c1f3f6ac1912a2923b233ad96a44d9d2b541a7e5c22b0dd8e7824c7eb40fa025b72d80843106a955af35f6a27d973ebb791c9b7d848028de24b3619d3eca042656044a4aa2692027e626469bd94e4d03f773c4c6f6c72fd0106019585c914ffcc6284474d25d58f23a6be5cde5129c69ceae75e348152d4b1867b34bdcceeb305ea154ca0c9fd254469d3a6546bdfbdc4062970d7c9fb1c0afc075a4cb553b3234434a2931428a26580b22a2f5cc643c37585feadcb402562388987c452639dc9d94cfa08d151f347e2d8f38cd7cb9d63e071e9bbad1bd8214152ff6f84d6b5f405be995c0fe66be27bd4dd4010f79bb30527f891d0976c3cfe3171e80b5c45c1a95bb1a29045d7abe72e7aeb77230edd5851380274b871e185b057d14bf9880ab4cc2f7ff8639b5d94f5da4d10f6d51f04c179f74c04e5da307a1803e681ca0c3e1c46addcb1c2eddabd4bb37cb903b7a520e9f32abb05816dce01bbb3f10d5330426014671a272fb452fab1b609d24a6f58901b6281703911656f29dc7ec19e1e33bc4ec50a3bf534e212a801298055ac182eff75da048095e9854dbdf046f4761091bf7e8c8b9211177b1d749878191d35fd9c68b4a917fbc2263d51f87a4625eb8304292f008d60315be9e4ecbc08ed046f7886633731e24f7ab91325a089f47bd206e90d70071a439b1da0212fd6035fea93cad5dc11ea696d94c523df0494f31ad2f529a734968de22b56802e7ebc9b57c6bc62fccff376b059492ffdbb63b3023340a99fa7ce2ee121c36e9c43335f221d43087f5489260528f0a453a7437756c48ea5f783d4fe0993c51cb076c3950e24b5b96b495fb62129b11205be112c04815cc6ce7dc3317becf0a47e5169f4a373844b02fd2c07210672d194c55e30874748b9e04fdca7be2e1ca06b9d5fcee46de400368b6ffdc7e4e3808c46fc5ce99ba5d6832d9a92d341b91265668279045c8b6828326c252121bbbffab5745ae2171aa4b37025b7bb8176c0b55402fd35ae558b6d3cd2ab0af39eabf618b25ef57e4f1c67a96fbf9c13c6597b581cf11557d767fd841e8ca3478668746adf6f6b6a721cb9c9d0c9d09a18bf77a8560e7c6ca4f34fc4a6a90fd169ea9afbf8ba0ae86e6c266fcef31d1a29da80dc69ef9b6517ceee09a03a39929cd707d3f3fa960fee965a77ad7c5833951d8991178712e0e3802c47fdebc990a5329b945f77e2e71275cbe047e0b8493ea9f4a48c7638d8ab8368e89e18d637cd1b23065cd198b1d0c9c2d7890f00dbd901f34a154bf40210e7006fe92689997715c52bf874a3187060b7900d0f2dfc5ac00a5d66d94e015dfdbd9b38c61f1fd5116096b4f3ab5a85ed3cc56d5582340cb16509b9749c8926c6743b858b0275f147280bda691b551c9839b94e9ec381d9441b5fd6431de81434e4d3409596e676575f83491612553f9f9239b5473ba6948050fa9cf8883fa0d524ac80ce69db26a643e82b82e55b869c770a4a673242fa4a69566e8523faf32b73b299c8113ccb461a88cff3cc411c1847575ceb60d2b6f8924d45a24ff2ab347a7af2424730f1ef01bbe5d5087ebb6b84683925e95586730a9e8806045e49b1af2313e0f9f3ce698ab7d08c020854ddbd0e0269b77eb507156fb792f94cc92cb6cfb9c1ce823eb6a7c1aa447ce4a7fd6a35b734f401f2efc9a062804bdff60b1256dd30f58224a564af625b61233333478c5588c0f52d9a226ca3ba510269a55c2adf2f90b742bd5aa66069becd1607fd6ae7e38afca7a3ed0e7d041f43c2ab7d7b4bc5ad8ff7daf0cc93d04493fba8676d4f93f497b90b5da8180caddc941157c07ff549363e3d471c707be808c97cebed804da341b2cf91ece402e38791c15b273a8ae75f51c49bbb56da67b86009d44c9b811552224a5ca546e0a9e2a9f3f217a7b3026a66ec3101f105957dfb8d3d47c4c149e90f63886fa8a21cc6758fd889011fda4ab1acade5ef6f7ccc9400c98194eb597413dc3f368dcc720b59ce024a4d3079efb9654d324882b155c4b0880e7d2d8c869483074e1e6f67230fa6760545b2d369c13db82b760b792d51e2e30b61cbdd7c8c358aabd4f0deac5d591f167c4d17813e2f43687b1e895218278fdd554d79089216eeb5d93a9a7c54b1ccfd8cf42c23d4ac4b18c7bd154109eb2cc1c02278a3acec19d7807b2dd8906b31a5493d195e1cdf15ae49ed2d98c00d325e47f4f7e30e955b882df1922efc6ddaa23915064f28445a25dc3428057a70df9b7d15d250c02840b412b1bae01995754295ffd305b58104d2ad699faf295f86f41b9e26f94c21adeabae17a12210a9579a13ae8ced0be1d58212143410de2e67f3d32b26df78f0c0e58cceb3021da675c3794266e80a0e97ec405e5f063ce8ea57d9f2a04bd504ccd85e1ff767e378e6e4cafe77e91c9f8c85c5f85aea77a11b9c7b81c613fa9c1c5866fd0c0f680d06474e5ff6436a2718903cb8d4a44afdb3d97353e5aee41414f4ea049424774eed48c046a7e10de362438bc45a3c3bbc86499755d3c281ac4948c695d12fefa3cff2023a7fa02cf9c9719bec035972d87bb40eb4512673b95a192add2fcec78a1311799e08f033ccd7107425d77b14a43f6283a8b8242542b225c996a34fcaadd40965b06b3d2d6df2ecb91800e85fba21662852d50328a9610911d56d57393304fdf005a5cfb88f4349dc8b09bbb7663546b4d77d68e4b255bab29ff82203031efb12ad486890a417cc0464470b5ae8af07b10923cae48108bee1a985a1ee821cd53d57d94d565c56b8137db3a836b77108f32f6f534a2f7b5f17aae2208febbfb7b88b71332fe33aec5e2cf40c66b39d47daa5f186d53f47ad290fb88d5ed4d06ba607072eed4b358f2e6484a16dc6bec73799922a5cfad0f48e1f02836f551f5326c902f4011004409e573b5e110365724f7f4b6264abf036b2a7e296a6b010d2363da69435a2c0091e28913fbd6f8d57029f1786f7ada3b002adeb0152815396c4211bcf0139df5e49d07f1e29dead3afed058dd14310551562781d6bd12cfa281910491099a0ddb3b286698e7bc08927496e46281299b3a872f4bb156544ffb15e99ee4f508283f89a1e8a795439fe74a4a7c8aa98049adb699e91487322851bb7179096ef329a8f116cb9bba240f3c888aabb7c1aa44e6c424b2ed95afb99f669cf229370697911ee53c40b49ff122b917c72ae9aa283f442d6760647b229c482bfd15e4f9fc2db92fe8f1d364f8b04b598584ff7932efb9a910a67e2d2ffeff9df4359b2674101e78e1f28f1d0a06ddf15ba9d76981146460e99f527637cdda7e4dd17e5fd7a012a1951ed433f584f2aff0362320dbd59fe9dbe397e39fd18f438fb705b4e464cd6447859a003fcfa66b134b9668902a355645e28597607443f0389e20e3333bdbfe7b7964a5b9a4cb3faddc72324c1ab3ac8fbe4d6786c31d6d41b77781e0fcc8c164a78b155abdf716c7f13618b458fa7d499c68edb4c1b9cf22da6cb027fbdd3b44bfc11f8cd92b4c53bf53a96e269bdb5218a0aad66d25739b914a7763254ca04c4fee218cbde27fea40b1b8e7b5118148aafd1c35e0820905683d89042662ea7abf858f73cf3a171b7fba51f2afced50aac9cc026d222ad43b73487b86924db77fbb5ce021440c69e7fed218cc5c7984d108d0cfa907e82b94a719ff82e09c67e2f0f6a2984af831d591f097be8e482c6ce855f27bb40f0909fd2893c21967daac7e7343d8e9caab60358c35747af35fee800b12ba057cda673e63b65eae34f05132984b8051e9ff10d3cdc50ae2e437ff0ce06a7cefee119242044c92c321dca843a3b46d030c7c579995ec7a0329e2a2c779bcd2dae83e34db1b7f19bc4c1db76ba287d1429064c75dff482bcb70e80e06e18d3c700104d9df63c15e4ba28554ba0dec24b87cb8f620300ec34c880158fba4170350236a090eff8a11784aa73aaf797f0e653500c624dee9fe1a9e778951b99f2586f6124c6a936a7fcbda308b1a4b41cbf27f47e402b88004461dc8dddd2079b0ed157159d3a3b0faff6f24cb0903a7d71b16be1edaac5e42302e7abdc8e6d726c663ea0c3f98e88ddf98cd24a0fb2c341eeae765f0b8212dc0dda035d1f50983c261498c9aeeb058652b48b61955d385aa14457ac40e055d6b0c5c7734091264c87de1792cf0fc91dce554f7dbcc6b1b3a8d245d95d719fb23212d2ef349a7db4a9ff171e6a971eb774b15d431053b14fe0a13f60509b203f1a7c051625c4ccf625c0fc8ff2bfe15a66a0140468ef1cb9050fde6fd3d90e2a91e18efcdbecb772c2154de1219480ba0f8cab4367e425186fa97beb774e4f60df66cc16c3f55c0abe55755cbdbc9d61b4caa25323299b9b1ddaa5d68fa967e6b4a6f77c808ad1d4d8bc8a6dab355f6fcd9d5fc6658a2bdd3d8e906ea457592aea3231fcd5431683929a0a63c3c6f07317ffb652d971f1f3f7da99480a70a27b40db057b352e0a9726d6eb05b447dccb0e75c215ca8a382dffc87b0adfe2051179a76f5ea5e295b883ec04762434c5ccb37edc5e195e7855dbdc0f4c19f8ebc0ceb833da042e3b6c02c4138035d71b3ade45bf68528099333539bd615180fbf1f759c0f3461879e263d24aec6931b17224033fc5942ef6498a6ab81f6fb143d842b797289c3015a24f7a3f461a0e71a73fa8b0c232810838c2a5ceb2ff3ea04f5ca700fb864b5af372342cf9293b9f4b0dde064375f070455fa0b414ffa4321a3f1cd287a6c9218d72be13f5dc41eef53e652268760a7bf4fd308eca1c59cd1575895b14ac5e3c2b746c8d74a709f4768db0954aea5f02a59a34ae4011b316f1246468616eaa55cfc6d2e2c87aaeb2f7c6e9b8d2a6a7908a5da5defa955a85eedf2f49cc5b4efc5cba432bbce533558a8d5406dd87df5077ccd5d28d5413af2b8ccbea99d4210fe7900092081a0040b15f776c3243c3613d2f744e6b933a09712f6252d12dd261f78b04b8da9c4c9f79413ff5ce493c37dcd79e729a20430e8602e8312259413d5bb6c8984d58ed429530e05d1771d7082d8f3f63be8ca40a4f054cb6a1f1e7be1646b67bb0bbeca11a603214415ca738affa4af0ce93a0c3dda51e00b02f5805f6ee64af1cf7bb25405a82f7b4a6847bf7e66fc84ea95ae5c73985ffa42b8f966fec48cf197e75997935a97b6b643a31ebce119b2bce4a475e60bfbc893e719df70ef699c9270100d912b2031946832260d0320348c1ef7f2ad7d9f8078f71883183de7d851f54cd6893e12a78d8778bd6c0d708879087776eecfba71eca36a5eaa011aa34f8542ddb5f4be40c3185aaa88188e0e08d9cd5a55e273491d63d7bac56313bac30f44a622b4f9076219fa93169d7139a665666dabb86dd5b3b4dae7e0ee499de45af0fe8b5df9deea3798791f461f94b5f570da0cb738220c396ab392f680dc6a590978bed36144bd1f310db6a3a28c25bce12dbe446d1514d66d513a329316e471575a7611b0e2aa43497c47dd5aee88757120ff787af043c838424120a533c08e13f152156eafd9a44336ee0210963d639d728a806f16a7bd0b7d69a67730031e8a65f20f8dc02371b458d7f7879a05271e53e5fc9e17264dee25aa9597d36799b344261d716868c192ae52ddbef295cc87a3ba43b54511ed30c36c85876764bb79a4828f6de2960dc35f605fb7523a64042222adbb8ea57bc7ad1588414801b0821ba76bca74245d599e90adbbc6ed372d6d68eb40ac4c83b67aead7f7dfb3a7c23833cb35248f4ac423564c8debbbd01b1eebac508e04cb84e222dea2f6c59c59b774e561631ac99db272382684e4661d7e031d5e74d413a7d28fb37d6c39dfac17a0c42038daf9353f0b4d44f89a7a0861c7ad476f0b1e822465097a0fee5bf25ace5bbf1b019c4812fe3d54b62909cb315ee060127d4eac968baf43b800474f520eb98b03096ded50d42b8bf742dcd1f55319d1e620af42caa57a412b663bb9eda87b9547445a6a9b04ac12c7b030d0b65bf075e92c58b9ea78d51dc863615c1d5f16ff2e9c1d23a111370a5065257222eea5b655579ceb27b482bbb44596a7f31514b14caded69da9eaba2dfc1c1c4fba48755e1884a69676d2519cedeb0439761afdea70c006f20cee0d06ec86081f1003dbd895e2f9c3fe920eef3a60c6df5e2f65ba232ead7a62e7d7fbda05cc564ce9f842e77f9e060978b640b03f457d637d7c94648cc82a5a44e1562389bc086856ac37661a5482d7f190daf93ba4eca85d5b2bda4e7552171b593a6498746a9c6c4ef713536af0516c38c930e17c4d1b22e5ea17ccee790c1b36b3fc199c4530a76b4cd6a096501806496b6e93241a3b1590067b7dcef5047befc46acdf789c661b93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
