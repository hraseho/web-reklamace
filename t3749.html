<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb4ec00cd88f20280e04d399932b773060a71e66736807a972f746c46957315bc2e3c01548951e2091c6caa7514addadcb4b1726d4c3ea81d9a32c16155b06ceaa62fdd7695101d1a314659aca6fc07629c2ddf3b508b770f3a616b9235833015f941ad0813a46e489d9b9e07faff743119eed554fd7f0ec48dc44d29b21c5aa26c20d53cebdd47b0eb58f20720f9e86bbaeae37a53c9b4645ef11ad3ede1da24aa4194855d2b7bb07022179272dbef1e83bda81db3ab67c4c7dbf4283402cf17610f34d2befb39662dea473c1156bf85e5f3ab7cb0a59beef5f517cd7697bee3c9d49cd794a6019535e9aaa438219034b5cddf0810063ebdd56d628759bb6be690ec824ae8e44bb58f85a057711e394a192acff60443c9cc77546b42f5477e856438fb28db3847152112ba3dbe304983a3d17f0ee4b680ad8dd5d960ce3abd8c3b2c7ff70774615bfb389e9b30b299bc602a8a58984e8c96a21367e26f1870f669495916108aae162f8b35996e1cbd11eda64856581b791a1169da7f9b712c27a476916b643b528940a9dd6999541815b92d5fd7aa0c06d20faeddc516274869f70848056433997580ea637ac8618f0cccc3b389a5efbe82aa09fc749f51fd753ac700178db11bae02f30c2947112fee3b81e4f4e9f8b9a74453917c0f89dba20f71cabf4e69d47b837f50a8f3929e7e918a0c9178f5543c102fca145ffe70fddaa47ba43a8c41b8cb68a932ce645022d902555f81f3080c5072e3835f3fffaf00949f9c7a9f0eef683c1d73c45c6afa0bcdd770e0693d6932cf1be3595f66016d31120fda6b6e68b2200b2d8de582835afb03dde741eb4f7f8efc97f1867bde9b655ba872a9b2c6221baf4e9b3cccaa96061296cf50fcaa00a51c57b7a783e03f3e3742f9b0ebc480e6629f524af6170b476a35fc18f73503dc5c29311df215a51a735d60f1965fe9b8bc19eeaddce1d0078e11c721779bf2acb56a9c5320e13366f5eb91a3eed96a6558cbe86669e41a77369f77c1a3284c1cab1e158c1ad0fdf4fbb2b7446581930a7b2259dc722e323b88cb575963488f76a8f0cb27d586a2dee40cf31be142382b98772e1dce135b2b053c99a6e0b1c2b6fa382bb3c94bbbdbedd9caf695b43ed2b915ba7f01f1b49deda03567df637d67d3dba59b970874e3cd9ba342b473adf71eb6c6c209bb990d07042dde9ef88fc8b491723f461df4399c10e17da58ace7a9b86905b06e5b7c4145aaa1122413c299ebb3771e81c28d78cbd3cf6d4150cd0c2367dcffbbe3f032fc6d2a8f89191f6d6d3e6aa86f86edf2261ec5d75c5e426511754a902deb410b5304d1ed447d051a8f3a0cbb045e95d2f072a39a7f0fefd503cbc3139eda2a908ecf9681e753ba0b51b2e6a307a9e372b63955379316cde59d02e4c47d912a3ef8a6dbf9528d856e27b353687f69813711510ca92c6950c3d1f420b9f5f1382837732c7db4285c40c2ccb6050e982a557888e213196cebd75726283a1b980e854c9536dc9a111e3c9f8f2c056561695caf3f9a45881f735f59a27bf368a62b6ad62e0c307f293c40143a21661fa1a6377c5b8d57a803f4e8d05fff91fa59ed1c5da80ae647025abc2dd53f5b0568bab70e15dbc67e2ee3ac0725eb75f9c97588b911a0ccc2146f5f61c215898931b1d2fd101c93ee9d1279bb6d9e474c563cb50de1ed4cb9953040c6c410ca2c1aef9cfc5eaedd0f4ae2d9946a443c5ded0d5e37bffdeba58fdcfc1141d0a8cdffe605ef0b6e0aa640d58029b97f5384c1d4dd7a77a111707433a1bd94da7a4dcf0ec39c4aecdb6e1384431e65d909f2cbecf0a1ee9975e790a1357fa0c8bebf8839e555070e13730278a6210e170777d303db4eb7cd17ebb53ab0597728cdc4350c7db8798031900e39cd426ddb9e208c5ec2007376da1aac516da8c00ea9a5d01c871a55628a45d4c941b430d172f558ffa57ba91fefabac29c88bea9b335d78a70a7be91563719df05286fba5e77cc18b5f3e7eaacfdffe32586ad65e74b23b04e16460a11c2c10823641b51602d252145a243f2f3a026910dc13044300928279d817d08e51f2bdc8e4c2e7b295fd66a3f965220cfc109490f49f7eb9ad60596f9749d270d98c102d95e68c0bdda9cf70bb8670b39a759ae06331bf3c533210e02301c59c7cccb60473065030e07557a37373ace6b7f26afb13fdfb664ca15212190f20d2f585c2f92bd0069bde72b2caebb1bba503766a9c70f5bfa119bb3cac929cde54aa5d1a074ba3ae4cc58a4d46e24fe85c8978b6001c8dfceb4e60ad6dee56e55035584535c87f86a8c362f93bd84ba504f5a48fb5ec538335cabfd6f800730a82191113bc36752fd4e33e222c61a8e7d0633ec71adcb521c54ead0efd9b66627cb6db2d19d6843e9af2aaab9c16bb61e81df38d80e40fb89900593f85048922aa3a66c708aad1c94a55dad2a494144e32822a55aba4579748ae46eb7a69814822ef86f3375abee6b5b2cbfcc2cec6a11c681470148b660e36c2d76fc9188bc0c0944b6c58bcc01d92b26b39f0371ac8bc3eac01d33dbe1c2e8a94cf82b409400f75be55509f714908375ed195c0f81335066b88f3eacab0f8fcde202c099a4a26079c4273f95c3f573d2ef3acb1b4ffa36ce5a18b3d05b4a7fba7bd063e1e5dbba217619c2ce8a62e1f77ee6c74601939511693ed190988efa64a1b30d81a79f4aa00c95c0fb50870244a69eb2e77dfc1f8bceb44bd633144efbea251e233835e2a90ed8abc54a7dd8ee8177936856a149687e287d1af41d0373056d7886ee595ab67e85881589f8b02c83877a15cf38a8991068d297b3079d04a970b7f0043ab22e4a7eead5c7157044b1a0eb74d0474c5e10fb32d6c2efcd0e7524e23b78d0a28d6ce1620e177c69ef75d50a1f1c04ab3c1aac6db45b7c355dc2b64f9677c7454282cab2e4bf158f14f0a3e91788745bde1bbff4f65c3363da0aa29612b251759239d8d21f36087e21edeee54c1ebfa3c9902f37620a7a6643f611b84c287e8f200ead1d399a75bc1deb294e4d809dc11798c33fc9e3c930ec310f401d24aaa6e98b7e80145d949860471e62c7ddc2262df32015d666acce4bb1b2f4cad0e6031cf9a1016f807b600cecddcb76b5bd19be1ec592e7b08616d793f149da07fde14b95229681f62c0aa44db46c23af4304e904b513044e896f505e25b0108b6562ac6ee5928db0ed8060527cad449f5eefc03d31f683a2b6df5fde7629abfd0018a4350ce532e95bf91fa924465cc50bc57dd37ce3c49cf057d31798d6ca4f8aecf4e7f66d2983a5b9499d0e105c45f2de10045a8a7425ae7dfa554b0396a3308dff96b30679060373bfbb38b927463dedc941df83ef776afbe5908a6c736e726ed3a1d0265573f2b0781d1d191a47bdf1626beea0b41cf3538da0aaf1144fbae8f7974b5429cbe7df99474ce734d651ba6c638f9fd17ba90c074ef250eddeb3acf3a0ee6229556c4867a54e50714eedc39c6f4504b761182326a2ba5c4e6f6bbc493db7a747a4c053b499daa26f634ecaafdede2fdbcdbbd3b72a5f0b160c6661495012388eabe9cd3d06c060ea4704291547dbb501e5ea76609bd4c6f4d5ce408cf7ed90cefaf75aa512ce2e8871e5f178273149268c2196e3c972c412a3e981a556dfbd692a695936c2946b7bac1fe6801de21b46d251563068711479d9591e5c5c67cb418ad52b1e385e8e40181ccbbb855cc37bfa3ed63673098c45bade7bd1f9e03ba8beae43d8c54e6eaccd54383f70701c75406d5f218b1e63c8ef53f6f94ef44787a6200ab7749423d1d65e106060da305694ce21ac9828e3a59b63f2197efc4878aad537b893f47b33ec1f0c09dfee88706072b7704ec8e4f01264b1444013f2e4daf3420f6321dd02b456b6e391e4f96e1c99dc5fbb14f5818492e5c96cab21e8d7e8b471b2283fc878032d94c1b787ad65f29e9e526299ae4a58c43bd139f2d28530ab00d07ea82aa4a39421c77c2c8b8c1c76654b854e3e41eac660e65db1530b0e2ee04413a0a4a0dcae4ce978dfd226ff5c86bab26ba6247bac104d37f1a5627e97879ae40b8e7de278423bec147e11f9006d03d75539583d7b9a7c6a9a20dd36d1b78e0ac8e9558f6c9550c81e91ca449172f2ae1b05d7ea0f894944a3fe11638bb8d854d87cf5bf343bf57312e50238da3eb32f1961beb49bd6075d04733a4f7afc6b076398998822afc63ff6a3cf74533497c4e8322e76b1c3daa334b94912a406b4642d334f0e2756888c8858a8a69b54cc3e3594e255c9f619b7d0b42f35e3f92230431cdd6d350580d5b4386dddd891b264274069b3ca3437d43fac0cbe194f5fd533e5ef5f82eb04d901c47f9734845340a1b85eab260e2df456915c27c2127a823bcadc5537aab1e87773f272842d502be522e7260e5bb8d2f1b9010f3ddf756d3f91bf08abdc787e94b287701bd63103fb83af414b01997993751b4dfe834bf357dc7010e2b84e40dda4ef630cbaa1944245226f5b806c392f9f2c7c2d09eb7921dccd8b473e3910e4d827fe09d608cbc9d92cdca061bef78665c5f308e8ab039c00c0ff04058ce05b929036147f52d6269ad0df291cf23495c1c777c3beae6501955fdecd8a3324ea4d4dbb0c9d8ad2c72288326b3b9f8282a34f333bac7029db3476f3dcf55235ad8688a4e579928659aaee2fb3d8a998ed4d9112b637f0f8039c54a81ab176f907afda5e6d95ba3448dc93bac22b29605579e0a98c6cb17e0ae6a0b53917ccbeb0a5e4923898106c9fc44cd5d3d8aae545e07f7cabddc33c7f1290a28296dae6a69518ae626f8ebe814044d69d0e7ba0dacbee1163be52b7a6fe6d5c1b541e2366fff60c54ab2ebad82bd156dbdfe349689abb97a1d724fd85a7860af5a5ad47d1ba95c6037cce528b7333594dce277e7f00ea03e1c4dbf1e5e1f76015bc53ae21845f72e44f4bbfae39b895109c52ecfb8ee8143a50c25fc5d27b5412676aff5bdb15dd9aa8e66d26050314633ac2ed99fe30424d5dbf71a62d4ad594f1d082a01b83277647e7aba224b0172417129941d5dc94690336d66439d09d5c114e9961e60296977d2694995d199d9ce00148da420bc96cc2e6d26a24863705b1102d3650f2d7c53a8f3eaf55c339418cfd2f07692da3ffbdcf4f50497a774409129a729a09e3604f75665775551e6e33e085d3d536e479d3c9d9a43bae3cb942b970f525d81ab6fd2cfc9ca85831045b555c5b4488f8f0872c05fd605466951fa65d750007c36c85b7b680e53e87ee800721f07c2a48ab63723bf9c62a4130076cfa76c3f05284e028ebff9b0a8f5aeca9f48bac9ccf0055f0ebb22514386fd318fee5ab7d78c81d32cc4bfb3af07c7d2168d53ae28f05a71850230df621a8a06e58356aca0d6dfaa09c30991c427279f5386ba62eb44dd00db069cb6e08a9f1b6d1858f3c9d48772c8641847d2d0b436673905e64fc5fecfb3c8c306569cddc4f0f5a7860aa66637fd1e196d37bb0ea96ad5e5bbb653aeb97ba2ad2da054ab4a29f35feab1b5339e9a3a543a8a2b5536738445034ece2cc9b2dd892582dc2a99e2c5aeb4884820a49d618369f0fd5e244c015e9d7985fd8569cee5ed33f80e2788dd0627d14a096175a38d422a88ebe77344ae6b388f739f5121ee8bcb98c93d982298e497781bd3794dd5988b77bb9731d34f2086d2d8fdb3994f22969808396b4ee7e6a19b7d5b9497a3cf66ef76648859bdd7108da81fdcb700d1d533eea1a50c5abba3038bfa963c35c27a96cf471aa2bd193b4a6795c089368e862da59bf99123ba03cd39fc06fedc21f3dec63319484011ff83962913fcd8741a38ef1c8df616ea20f87c8e26a7176d2b3502666db1486f15368f48deceb6cd2a1af05b63be04d2a44dd477f1e8e82a5fc2b201207576c9dc20b12b51de66e65d42a6fd3a05b91d898b76b40c6c203632c9c5448ee01f5ab20125f398fc43d7c2ad2c4377c65a67cd8cd8c9e398d5a10049b774f77fdff4fcd7a26925d2815719f8ca0043002d570896406826c3c756d688b7ec9de360be86ccd070872189ff06e9cdd289a9bf1a5f263971bff33f4c1d841328c67b12f0bcc033c323343023ea2b877abcfc51cf396d12ad0d1526c6665f428d4f5aa86d7bcbd46a752bedd35baa72a792b6e8a51e6b81a5eee15910141965a00b3044ddbb5392c2e890411a2fa5fb6076cd78e5168ef03e45b9b4e91bd510e7606478c1e16a477e04ad90510fa4dcf2ce522dfca66d44f5d80a2a723bf536344962173b94a9d88eedc3100a3afc7bae89b7937028652a79d54e5561166c7730df00145cb372ee38908a65fe601c05f183e138932efd1b00ee57e6f11210d6b56e6546ef8ff560bf197f079c2273354b12f81a5c83d7011f4bf6826d1acd26b9a81257a3f9f3f292de27ee0a132770c672fc58247b9348ff41e5af42930b2f57447a4d54b715ed1a8775129d4ca28cb43dd9d4f72484dbab1dafd7f0202a62a11345795e7aa99f7843146cd70536f20265358276eb2c312d290c0a19e93d82df969378120437d18cbdf4330e5f974920edab0ee9760520631998f48b69947c738433195c952f7a8acf2206bb73346ef7270b754b77162d12e432e85c8e91f0c45674c4511114f2d63eaa70bebe1f990c9cc5cb52e6bbb6252f60ad1fa9b65a22292125d48e921faf0a63ced7c862f22d0f85b5f3fa31573fc6cf69c2cbd047134f45e1fde46dd3a7a85600b231af597c9db1613e7b8a5a5d86376927af40ba5eae232d265b5831bfa98e73058ac4d121631bdf04ea1c879b8f130e3ef04591bef095429cfe6442aa7771fea3e21fac603b30cbf4555813d4a5a8c80effb75c0b7fda745c16b55a3caa1a3e500cdf0c07dc83c8bb8a65a0725fd444d1ccfb302646f9a0fa1a49977eb10cddf9fd35cb1208b9fd63a7165bd9fdaced59ac365af9e1b04e7ea14cbdca45c3457f9f8ca70cecaee08572e3a5aed37df2cdd1f5f2606fbbe6a10216295531a2f3af74c6e65fe44ffe0647b83a74827f1ae5ad301197b4048316133e7d26b3b6c08e597ff6e6f259546f683d3cd18d92b557586df94f9561f40df9d29d84943443dfeb951696f73dfae5779a6df3c881bc2192bd8aed2322c7dfe9f2a3f888e0753b0a0e2c4c8de068e3282679cf4f41606c025275613dceeda45ed0f8f22392c61056d043a022852e7e18bea4120b8920c09f3f8e769c9ceb693dc67a9d5605bfa1b99d649ef48e50bf786fe9d8caf6e3991ccebe3bb2e81c884ab04a0a488c2066b9b75d6401b815e07fb367d174653b8072e034ba81ced980ee9505384e0c9868b9c0d98664bf80eb5fd4b7ad37e24301b14ecaa8f92787e26a8f2c5799b7ac18306bbf3a80e7b12e85d5476a2a32002032ca9c014ee28c72cde3a8343e547710b763e45a068ed3cd77722e3629b0da409f8142525c3618b6286d46dda842c6be56f9e984f7d0570ab5bacc189bfddcb352458b8ab8570834b36a9fea3b45bafc39e499c1268a074c5bc477aef8684c1cc4f2f327ff85e349af8179be635c37e55a775010aab6e8fa31580006a93715137452518418d204bb3d1a0b0303619975448877677320d9cd841982cd3408e02696791107d796e88eed5c28ddb2e90ec403f1b159ff647d5bf42e89cc2b755b401ca03d725576d8abf642b34f383b2c34cae12ca3cb674eb9c43d86ba70a9b02433530c35f53d5f2bc9275e23c96457f39e0ce35d463773ed607da5d77f0e9529e1f429d705fd707feb9af1d41951be8e1cea04dbd52506a62ff8f03bf70902aa5e4c4eab22e266c55553871b1fb2e525e5e1c9e6a58c6fe73c9a139f41610ab07ce97939b9544f8e6d46d389cc686238000a3def639738fe63a08ad6ad4272daba3cdd6895d822e10cf0debe321d129eea9883f74589dacdb0c526bd4f925f50b51479fe117b78778b341753c52a1e585913ec2ca21bfbc7c885e7d4469dcb934728711b5545a514c56c23f4e36e6b7d9adccb163dbdf532e0b17e99b692bc17838501cf5c02ef0157b8858ac58743bbffd4bc17576aad4f31e6a755dabf796e2220bbfef8e497d651d55498af37446b9e9b84576c9d30e7a83dc26d2e79e63987e4bf1ce45f91ef36c8da3344d3a20f51928cbe683ae2e0c637abd45b8353b7da7d5ef2a4d2231e2f95feb72e0eb3d3c1c4291be5f1e2d17a6b383272f8732b338f0cee669b25ce83a1ec64d98f91364c98f10fdc557b71e0564efc95f5f38acb15595d5a17b04ff4da453c8dca0ef5083a131ad2d8490ff7e0e6be9190eb848adfcc7d7a38b435e1d16eaae99b077bbe66c8223e925b0e09a4fb94b2d94d4aebaefcb1d953b7ac8877c360741734041f9abeab300801a9555b829bb05f1e0172f757330737c6a67a9c8b5cb91d70c21c1d5ffe3865eeaffd4ff1e6519de473f9c39e39f2ebe2b2e21428a8a8b0dfb863b3dabaaea188d49150acd0e746cd721be7f2afae6a9a541035954d3ca288074262053e43ecd945ccade2ad8cd6b4b4ab34df7d1e52b86f5226fe16225392309b9b5442b8a71e60872265146d4cef22f6ae64ae79a975fc3f76ab27c1d94c47e7faa10b26593ff5636d304fc0ca73197651a563b01d2841fe9e646ed8a5a6dac89195d8c7b58891edd382a890dc2120914daa3306319a71f3215f100446b0dff0708ca41f5323e417e1fd487bc326ed3f70b26d6ef8002b505b1892d4ad62818110aa1d265395f7ab96ac1e6a21f13303cf6b85952966b8ebf205f05d488aff831be9924b7dfcdb40835d247c9a4c1bbd3207a182d5864306e1fecaf9808a3e24d707660a94ce4196a3a0a0c08a1eaa487e58485371dd20c901e24e6b45fc8966356d9cd9c91981ceb027caea30e4ad754d033de3833755ca791fa2bbcc99e094b1260a40e52b83d43c334b9f140d2a9d390e616fa45f1d643dc8fd6be9cdd31bfb4e5fb51718698c2ed2d9f5874056a197da0e49556d33663c2068e28f5bf256bac17cd5adfd5534bb83aaaef7caf2b0f09d1273bc405e27166b578ad02d7b28d76462cd9f5c5c32154034cec2064805f51cad91631d06564dccd82d174455f83a9b1d5b43fb72352bef8ec67a17a4295e1e15bec39c5e6dbbb04404666e75428547a3ea4e5a6b4818eadaff7f6bbbe3356feac11db095b4889189263208852ccea3942792b3f71ecc5f0ae0ad7ed3f149ab197839a175663dedd7f7358a951aaebaebef5558118c494c64b48b52fca7bde75c8a2ef9da34f5f5fa70cadef0e96ec84a68186f1015843e7e74f53412420fd7b82575569182c677c63c1fecfb5261b6fdd4b78f63bf559d6656915f500e4b2cf63398256128ebb4eb8f6e86cf1eff64658513ff9f84be007c508a2cc8fe5682911869fa27e504b5de473669a33b8df17d0cca90b56b257202dcad1226a71075cae0e57b2a775c0ca539b2ee69ce84cdd85482c6b9446967ac83581f3d7aa62919c4e0f9dee63e653b510d259a629442ee9f867d4b5f6a4bffb2649a19da6c80b1548d41c250e7d63d829b0cff86308133cae0d0c974bab4edb20701be8f595703d297569ab7d34bda56b9116cbc45e19e6e1b7ff4b810980342dc5c4f55c9a7b73168cae62d4b37c95cebb002aad42f3102eb3f9cdad3b9152733bac982eedd6bd31888f3235e77ca4750d74d3e6ab5c752618c5d7ea9dcc2e89a80bb81e0e2a1b6ad047eb1a9ad852d8d1f76ee8717b149b97bf05a3bca765673c5cd992325b818a53713301ddf8791038576ce3b52e5300caac6f9cab696161cf23433c8fbaa5f3f494d7f56246c0027fe24452267f8c4a3b798e40c2352811f6d7ffa55ed9889d7f6c21967bcaca49fbcfa7e482b514a4194ca2a9ce118efada2fa814d7f80708821702770c8c506196bbe62cd444e08a8d85c74767130ec5971f67c1f23ac399428ed5fec1ab9bd6761527de4aeac42fd2a6deb9bcd3fb016f512c5619a06ea8a15b47fd9473711518e6f7e9c4573fb99d81d238eaa91a404f7bf3dff606d9de78ec4e7da756907d70511adc8316c5ca01d3c15215bf8be01b3afcd6498236cc1612ff62f1a63e178d11651cb667ef503af883bce22ba2dad45c40ced8916a74c7dd772e53089a12c247a5b7431812cdd3dea736b71c75bf0ccfdd91af1ccbc02d8aa910bab33c2cc29b3c6c8b939ada9705326d19338d0f6cf2958bc808ab9880d5050606b746f411d3d84f9cd545ab62c19216779f08a0aa52f345a86a0a91ac97cdd00d2e1c1f963b7c70a64903faac1e311b89c4e971d909a9d89699ed4dd721cd2db237b6f17f73b55760354f67e0928cdb90f797de24de6405ccbda9831075af269257ef800ff0d2f4f1ae11050936c71de203499fb012311f0fe9bfe2480cc49685cb71779cc3dd8948f02409da7e5d2919d2a03cdf926f93888499b5c864e71ff1c62928c47c363c67bf06a7d51883b465c61b5575217f544cffbb2e0daa51f3a802fe5c20596c725326d4b8822beabac96d2333074aeef45d09d916e7038b194416c2c5a287645c0f0d892677390ca7f3db874061d0876403b6016ce2af3e352b54cd446a25861dc9f00d72825bc8c65d4da87f30a26832a3081b799f9cfd8042cc162791586bd4290f6a9433548d6a14736ddff95cc916d9609882b7132f3c29f8e582b053c0476ab8b3d01b9e8f18be2bb4135563d28d292e9eaae9cd2d8418ceb77020cb404ece57ade211fd991cc62cadeac435ca78310a588b53d50c45ae324d70fe4358c3dc290712a8432ff29d702a257ed1fcad21475cb95d068ca67c81e05c0ff3e8b4390112333cef7927f1ec745efdb6398034fd1b83cd47f70a753b8e0a311dcfdabc0c8aaef741e04555e8d1ca6be2c05e5c63be3a94498a54908600593aa9e85c71143d7802a45cb2bc2f3336ec302825cc9951f42dcf9779e34cab27b3fbce0e3b5040a31c4420977066f6ef05299219574cb540c56e386d45ffcb3296fa92070f22a787482da8c1bf6d53de09b8effe13a735aed3cb8702ef8316f4b4ce1f0463cf44e2b43076de055d94755d6f17e4a36523d52e2f6cc97486672d739757aacf9184e89301c9127dd300185ab89dbc9d8bcea4904063d1b60333d29b67e55815051759d34a496552cdc789b06499cdb700f8307b3935cdf832609179f604bbf9e3c31c34a6556368208112531833d650067407786f787c8927977dfcd4bc31fc8cd073391656d11ad623f091b9f0420c2cd8f78a70529a8854b59961a814310fa27f04eadcf788739ceb8d08cf1289e80c8377e71e7305d735a6dd594c6efcde7b03afea0a60ad78e5fff2dd3da7957c583302f8d9df915e6d49d4ee6e19b49346cdd68eadf303096a36c04eb0518dcdf9dbe758f9b399cbf542a916221bf16ab6a6110e1c599d007e5f827117dfa412e0560278611435076953b570fd4520322912d4683adead5321d1b32fcec052a7aea835d9350eed58ebc478ccf2b965e2021a85958c8a93168b9c1cd15a91cc082618b19b7dc6f5818e670bd68ca12d1eac005a17428d475136953973d3a0d4b6bfa455c8a8bc9cc18531390be8e7f22ed6021725e6c44ca2ed5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
