<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"603641438ee65c63b371bc04e1195ede5369ff045528a1bf2d16708cbce3786bad1b0e019d154efe24f8863c9a37d7af1a41714af0c765fa8e331d4b2f13bc3c1cefccb70addea0f4bece61d69e23803afce4d21ac9118ce96cb7f81dc69787fcfe24dfd9eb1a809636939861bdca10f737a7ef6c781e0b2814dc6c1f0713fff10034e493401ad6aaba2f195ff38622b9df40cc24015547adbfca5fa69ea188ff9ee2dfd82550e0c8ce043c7e8dd24debdb277b75ac59b9eb023a66cd7c9f9533a8fd5925333120850dc16d5689aa4888b516942e1df526a2ce6b49f773c3d58cf676348be576accbef53e86ed2eb5e828fbf33f53dc082b73b4d2b21f379dcc96f1bcd4444f4e2b304966f2f60d37d1b126ca7424ba800d61ecb2c75876063a4a68595de9d8dc981c0ee2d9306374452091298a24de0452e268f1c298d36902049557b216b8fb6ef515e942d3872707df78f1aa2d4af99dd253c153c4a8325065a82df344b34684dec663e7e355c7f3a2de58571e517743e281ca58ac5ce39003960ad45b58427ab3d63820ac3d8d38494525419e85a616d41f86a32393426a5b1b14fccec45d496d14515262d71a48591694e7da2d055d6c18581e7bee0714175627bc7be87b1097e6683a7bda61356c8d7e8ef359fd564b3095c4c6e051a395e2d226e5a20087544095e7647eae14965fe32a6d3f959453618c491610439c2da04f19b2fb4424050cd6ad26f4c437f2d644be489da0413c8e203b6882fdd3d2755de2f69a6d14d2727672d18c7e45a618dc9e706205dd1be7059ab9e3d42cfc5138fcb9cccfcdd32f2450a05bd9dc62ca44e41cb7b4e1204c8dba0e617e89eab7c8343ab2319321f4d60e72abe7d7dfc571ef504d266e99bc8896a2ad460b5e882effbf738746986a1d804cd1e7067b33d307a03d8b7230d29f12eb67eeaaec156b7edb4e3799b9b4222138c8af19f872dc4c5806ef35a327674ad5a175daf02a7396990fb88dc7afb3f517f8c4d069ae1c12d59108e193f04da68649bbba00400e33361983b605011bcd819a966a5899a19f92a3cae4569a166007af97bf1b6f703afe6320609183a908f0732c8f204ac12c19c80b7a0d36936ad6e0903defab751b6949feb9ca371691b70a02e6468ab8f89af19651599d26811ad8cf0b837fde17083d4a78b1ce2ba5816b5745ea266b04df1cbc9d3f20c87583b5e5359961a8c7edbd729f0ef8df9a059126509203b4ffbb6099eba422b409cf57c5857f81fb54079a3a51aed219e842b5d7b6c10506a82320e579cab7c33336738c417ec1fc1e2a26d06ab23f0d3d41d26e50a60b431f806960ce495a458acedf83752f044ebdd8c939a23433efb75c36fc517e357b3e4b303a8867e213611626ee36050770944a9337abc002b2fb3fb0dfc73971135b8409f4e2c45f3c30bb8bb52ae0cd4fa1245c81f92f960b3c527b3db81bd573c3c561f75f34ec7bd6ab6581d50133063507bb0175006c2af41e74eade2590db2a37364fccaec0eb8c9b1bb97c5cab148229e09e799e4f1d5b1367327ce0ae98d147fa9de047ad6fc4c827fbe9d72765cbc2ef74927e8d8d3108058694c604d97d894e0b37c01a9bf4d94c4d3f7a25c07ac02a2e68dc376a1d6181742f335d7b7549eab7d076e00527217c279c8c67f1a72b8874d7b19ec93c76ab38487c711aeb488c171caded05b5a4c2b359ad2170ac12d1003fe6785cc20cc40cb49fa47f4c7ac5fba71979c480d6083ae28f547e5b76cb6b83d90583522bb4261f413c820cc24165fd40ab860440f9ac2e484a81711fbb0b3d2ac9ddaf5f35149ffef0844d8b524e3e7e79fba2b20acd9a4b3fdc32264b5ccd8fb281782cd9c4a6237ee26b6c93002a58a78941aca268ca84fa92dbb231751e8082afa1356ec1446cdcd4bb5326c10428eefe7bad1f72e3ef767289199792e5827ff0dc086b99166f5084863d571a6a641499c72a1190188ed405bcdb734a8110ab694c80c08ba2a6d9c37d464ce56d690307261e387521be1e6f3084ce8663a6e3e8195aefc602dbae3f4d0fe16359b2219963a5e312d0a3811b55a6f6eb353b4a1301a1e9db2189df8ec465e16e4c61786f60ecd124d2d6f3519c017bc55a4f32347346b22b3cdb6fae7c73d47f7006a8353bcfa316e9dbeda77ae9133cbfeffa23e782d37ee0c75e39f78e91c68a38a3152e74534f17ef281ba37a0c403bb3ab8ca0ae7aebf2a454165ab5a3fb6982e689f7d97df7006d23df11aada69421298fe77428aadee57f44c6036c5f3558aef019becfb8227a61b59c3dd1f04532c41816539c0012e9f18d5d81dec6425dffc11044a75830392eec1f23df0d86c9acca12ba7146ea85821757034b7029827620b13425b565bd5e174209817ab4383773ae3163bc0f38c9721d5821f3ac263c21223d4ecc05dd92c1e6e74c579786fcf6e7e71d43221e32f64a3cfbb63f1c3270fd06a430eb4f0fcb518460213065770f344ea89f527e23038f310b7fc4c0c449385bc77087b4f95c7129329c2742a4fe29dbfefe676abf08af29299a2ddf9722730e7d056b3ba84ff1f7d7329f1731bb9ae7963c0fb811f27c2d858009c3f9d093ea3453d4247bc0a87e92f1dfd63cf2c846697ad505d6794ec829381525b0bcf9e8551f3e4d38f6aa70147563cb16ea267d2d9caa1a56504dd661e9ffcf98c227957f661215387760f82473af5127260b58554a127df1cb923dff832074beb55e2fe57de2f751d245443126f49ee3ffd4b23919d0ed099d913ad79481791c55dee15d90c21aef6140c5c9da2caabd3dceddba252591a039f281cc6fe1eda1189f792a92f4e2dd7b7db6820c01b0c16ed45203a2637c5631678022702fc59db94d9b624b48db77cb22311e08b8d2eccaadd606b8f02c5f9e5928a32a90fec9a577f8c27965fdf774e12d4c27abccf24f755cd8e3daa494fff85784c0a11e96432388bc2a424596aa11681c875a03b3d2b49ff49375e742579ce097a64a03f4ced1d7061e2a5ebd1ff988c363149fd4eb53dc73f8b7394d4085496dd1fa15255bd49021bf969067109a7ad2074599b75ec2fac9405829ce3c7ebdd358d711223671f858d30a937783c77bb7e9db597257227e1d7a513b224608de8f2f470b19573733aa1fbbc45ca0c271443187a389374adc6be7f58d296376993cdbead9575d8a98fd789737f3bc94140792bbfa8978d9a9ca979c74e94d50dec475433f91718fa0a59029838bceff0392c193249a981f69b76fc54d17aad38b6977ca0bb91dbfbadf38873264f37e83c80f679e5667cf119935d617d44418e76b46424acabe0bb0078d157ba91cdbe006b28acb6c12e210f10ef0e81d4c7601be5613c868519cd83c4691cf803a5b2c83fbe427addff855e4e12ff5e3ab4a0570f433b3401b0eb0cbef4a605bfd242fe252c30a8e8a63679944cd0c476b1e6ef29a41c137cf4c03afa7bbb63170385afeafa0358a4d216a8c075bd86e8a4b98fda721e0b567ed22a9fd0725c134b845938c48547922fade39d9eb058d0c4ea4d3f1d6a704fd67d18e081b801b7dd431ee1d476eb539d4061239a5b3f5f3ad52b116fd99dee9f7a6cf81d9e11b2d25ca43873b1b2ccabf04355d561b5c60d54f79b4b459b4298fa89cb7f73116767c074b0dab51235f78a18158b6f67003ddf56c74febeb1ed9e3b69702c71fadc4a75b83179bd7397016ed6e21d4eee88f55f069bfe8c101d93afea52b6e24c92bdf1b1127cca02833419ed5a7e589c3ff3fbcc07990b55bbb12623cbc52218a51ebb5117b0852b71de8bd4d4cf507b7fb8b6bfd20640a9c79fda8efa3e4f436af1112c36afbfcee6217855467f27cea10f624ba417d039a3ad811ee8143b7f5bcdad97bb782478ff22723b30b57cb722c8febdd095da409ecb273c0e8f3d506d84eb9735a6b2603c9366cd606c5435b8a2977d47bf45e826b5b3d537ceb4bf2fd17bd5515747578d554551a2749b0ab18884195dab5e74fe94b3e04749aa133536a0dfa0ad816e0224ea4832aabfb0e3b040ddeb7e291254c032b1c1ea00f00fc248bddf410f04b06348e9334500a27acff369e0b1ef453d81552980e5316c23464727e58ce1f34194ccdd4a320e240ed03402fc3b696dfb23b08e13597e985af20f9dd9bc1f4edf97b1c65e3667d54ca03c84c852da25416d346ccc810668b661c4b1f05c69c78ab86c70a597e803143660be3a239933e56070d15016aa9f98de11b591183c8ae3be41ae0ae31c63f2efd21255a87b195c164e3c6c3266232a99395ce8d28fd97af5a3002f109b7e623342f9f38316f30a677057d8adaec55d66920c2e18d92cc70fc754dbaf841cd85f0f3bc2fbf82da3cb61108862cbdad947dccec798280d959c4c9f7b1db2abced019db40d3444afb62cf7cec80717c417a4c1e1e4a5b20c43886d5530dd8653627bdc169fafb6a6aeb2c3abf1fe00efbe66bc4b0f207fd6d460724d8753a83cf46dbbf1940463d38dfb78a354843551141c463ba811de3a7755a0d8f248982467ff6f16089e7f62894f6a62291858d51b08e23ad314117e3b61fe9135c4c50728bb604b82337769b0833169c13089dfea9379c7df7230aa36850ccd1bda22ed31bd8a164397248cd699d8c49fcf2f8dc163fa5b12912619b9ee529dab2486657db247a1c70c088f93a9d1d303752ebd307df314005ca82983f0d2309112f3e7d46aa9b4d001c0035c484cfd2abea3c68517be963277d8aba85c1c37cc4808a78d7ec5215d334e66e6bcd24418973ae52b72b3815b369f82434f50751fdd72bee03cf81837143b7f4df068745de0e33e9261fdfda9d490e990d1f2be6e83341fee4bc33c026dc9658f9844cbcd0940e3d10bf73811ef99a8aaca5bf9cf684006ef1425a58b5435d8e1e7dfdeef43595e4c1af907b8916d2a878e0e7e3efdd64f566fbe0b7155d0292f2a96e777e908fa2155b24f70bbfdcea51eca4bf9ecce7baf21f1cc921b8576c2eb428ddefd4ea7a4cac285408c27dcd9bd25739860d146792772dea82428423122ddf274d8db290a3447e45dc63ded424395b7d0b9d610f57046be87e711d7c6671f300bd07f1e09efb910d3d2db4948e78b0404114c13d5ffebca5859fd3daa40f8f2d5e01a4a6d824b379012b5128b2f46836ce607d8f0d6289f74b6acb81434212cdcb22f8f8f24ea4d243c2c993201ce2c0810be06396ea37e73195636708871bc73b52b9ab66f907524d9da9cdd567493d3298b344e30f6894840b2cd2f55323be44d1770c33a1999c15c5745010604ca151316caacb52307cf6e770f51571d3fdeb39d2603d140c3aad8261cdfeef975ae793660830da93724eba901a3a3d41b43ec651b96e63d5917eeead63aa66ee8d3e5091921106dc2dee7beaafebbdef24e89af42d2ea93af0fcf824b3399bf6862869d30af772a59da99a7819073828a38feed3a08393e5f4f4720906e9d086c854e1528c01eb15c1f8b7f99038889c377691fb5eb2fbe5dcbd161766ac372be8f75cfb7301507003b7490390079fea9a1893d20736e97ce75ccdc77d9048a740473f61444934a5cd301e60e50fa31e18b85571b46b96c86d7a499fca020043f9f5a0027a6f047f2112316a838c266782ae296027426b592906de671629b88dec3809a04b9ff4f7349de49171cdd14c47f171e79dfa219f3c522bb46db3336d646b59919b1cb70fb2e4a7b6198c7b8692081a98fb335ea72e6dad910e6871fc511cd4024ec76f4262eb0fc7537e0016905a957366a9df2b722a7817fbc7826f0b0e389f69e9c41986a6ede8de16f267269a52bbb3f972394058dc6f6a45638772f01e20757398561e184dd4b6bd3af0574ac74878d0ea18c169129eff8592899a6f8290589257227946844a4ed06c7c0fc55a631f38517f28813ce5e7f665fb7b556c1e6a8e591a48ceb1e0782b2ef5452eefd3378f2cae224a9d2287f0ada57173cfe62f32e9f8d81e60950dbaaab3a978ec9ced946ed7d1e34a175ca138b7e8b2c55eebe3460563ce8862bcf7db088d04fbda3764aaa7fa7ab9f5d30eba0a6b29fee044dba425575a89661b6bd4d47a7f1f41b3ba7ff93c490f17754aa1c8651b6c4015bf56789cd88afc367e97e76cdfb3733be65c49ec291131d6f9a14f5bea10c20724a2f3ac236c6769262c768c03182c3a7f8f4911df1a8ed2c6fb45c7ca7b4994bfc929152d6df9e7605fd49911d22ed640344ad65ba17828d647de6835e81a6cbf173a923194b8cf64e025e542389c54793cc03b9291a2cb0415357ba32435fd2193c8fe213637dd17903e60848bc83b533d4bbdbdeb08d21437264558ac9ceaa1dc06a24ba7332500d67ff10baba7ad6890cb6982a8fade09671898f07252048768040549528848a154a6f67ef762ba70eb642cc472ca11f516b0eda66f5ada17a7b943210eddc1cbb6b39c39e9bab62ebda79f15fe5afcddc1db396849e3b37d91515efda5d89819e98a7e0703abaf6733bb130b83033027e42be7e32bf5baaa630f92e83bdc6cabafc220c20891ab81b370b8faffc78720a3a2e4696e1c125c9ec022668c778e3fc9cfa000482bd4ea0287464d09d0045505b38f3949f9b21feaca8a8681888c37a242726b1e7af93b4423dbc49ae7c5e6efa3ae75f50f152689582271bd367e276cc92f5cf73cecead5b1c487fa6fc7217d182dd06617b2d4a8252163202134dd28ad6fd4d05e3ba8e93ba43bff2aec1af6357bef853365a6db02666ee4142ab8a422381957623370181084e9103b5d60fd0a27eda27377ef455a9eab539c021c9695e82920bb740cdc301df116c273799c454c3abdc051cc3e58470a6a19144eeb44f2f4e507479c36456d50d110608a8783ccb838f7cf03c4db0df9ca6cea32321180ebf34a8442474052a054eb723aa518f931bd81fbe5a5b3a48228048a9be7f8df8c92fd9c948f7921e40af6a524aec0b67127cc2a750d7e66668735fff69b6fe1b1bb0d181862303775e8766623ad156f9e5603e8d74adbd70329da6e8b565a2a8d45f05d6843e7b9f42061e5c04ca487f34a877f9da8324f36f6d5d9aa14448b564d3e2b9f5f8b0e63c5e9e4cbd53c027c4f63d48820a84035a9a7249cf7b5d5417696394bfd95ffe0bf4a40a41ce3ef09b9e3c88976694ff6cd025bd1e61cbefe7a2977719c640f2e19b9d4adfa9f7d9f62041957abe1f2cc249e1026ed31453f0e800ebdbb582439be440bb5dc858f0fe6884bd498588b36b228c0a4165896b8d1938162fbea45a6393d01ba7c9d4a2c7069adb85e19127dcf1140f52f58570be8acf3507d3617f55610bc244d9833458d0ca1810db095346a7bbcdb7f0fb95ab5894f4cf7fc99346249143b6991b2f478abf400c1eaaed4b875dd0e861be7995639c9a861437778842205a38a51d46a0c5f47c3a116bcd7d367dad11cf2b0a9baea370cd94bbefc6125f69302336758ceb6cd3eeb632b0c43358edbaac810ef46b75abd89145193cb4e8754b4a3fd9121e45d57fe42891f28bcf0adf8512bf26f723459bdbe1927c24b312bfaf4dfcc4001cac3d79b4497962f975ee63660fcd390f1a1a18a012427c8a0c23ce1f8b1739e9e3aebfe5642ea0354982f61833553682cb594b16275383880cdfad01e7787c63a8ba6bc6a173705006611d3f382eef6c6cf6e1e4312ff85cf8a0380b9c6e04dcf011141acb7f10a4c3e3f7321122a0ef08d0db085e20a619f6be7b46db1ec2fb25342bd42eaba0a8a012cd3cb97d5d673b06384847c6ceba1112361ae84dc9c4d29916346bbc5faa28a7b54ba95ca5d670baf5b22db06f8e82d172dd86fcd957c6e94d222d9fdf0304c7848bc3d8d3e5a6085d9eda6ba24e121cbbe0d14b997a58c4d3ca8097fe2d659fcbf14ce9cd76b02623f85e385efe9271dad2ff7e3f5df3fe6bc3aada0210dc4c4304c82f4948bf7cece6bb9e32cec57b3eeb61a967dae53c08d7133c7a66c4bdba7cb5c6fa7892cf2c32ddaa2e59d0b2fb98e528f2ee92d06160d1df93d85324d0c2a7f0f91f02ccca0ff58000c218a3cb4f13bc730e03904dce44579eca4b13d4f49d687be151ea79a68244fb4b6f76271c63cb80d2c8ac011c924cc37c97dcc2528a7e45942fa8ff9b5e132efc7314ac147a020c718bd0ef2525b189c2e30bc8dd2959f2f33f86179f6548664dfdfc5c48a68da52bbcdd7f6ebda335aa19035b427b766018f25c7ed58249be902e21d3a34feee9b8d9174765c48bb8ceabe98f68f576d3110e470fc44982be14b5463c96cad48c5656f62a736b74b6de5a7c7e42add2a0217ecf198c7e91440ff49c70bdb9a648f6b45e6f081feaeee3d83a8a9ff07cc6def3ec20876de7863c1ccd7f72b37681e939573f0ff6a341d3402daeb88bf33f690b305a9001dcd99f33d580d63e9f9f48a554ed75e2a6a6ba4c2c8fc671cdcd0468d4081a06a5a52b0c0a6983a3e3956047c59591ff959b0edc617bc5e92c34da26ebe336df4d7bc4af00aaab2529f2cf4c7e0e01df5e7574e4c0740f48281fc0b37591e5d47782fb27e9584bab4d8066e24626660ff2069d3316f00c3b0741a09e84cd486d87b4a3df28d8bba203e0dc41ebeab88e64a4976d362911f9b393e24ba4575f6b8f8ffa188b55a9207391435df294ffef1a4b6b99f59e867f83cf4652a9b0697657532a080691760bbae6bf1595cb9a3e42217bda62b5dc3f88547078fdf2c5db02a1401c0a855f84f557e3d7470557029f20e1938742315ef56ee46f91bc249c065f95119b3bd5025038bdac72945538752b12fabc64c95378db6b77455e8177b202731a80c00548a870e48809ac319b6c7cc137d30e1fa2240e19568d38d18e7fdb54d7a090e5e660d1daef9f1e4f11da3e2676cbdb6929004352a7d26f4138827f12d173e6cda1eeecfdda6ac614528d0235e7a881b584510651326711f59fb698a49053aa0812988d6553122fc49d1256d3b8aebe88ddf16a44231029de73c5a01d8d9efd7253f6331a9e2ddca2e062c2522270796a757b9a2a15f61a3b591fcc34854f66b874305cdb845738df1052bb8537e8fba08076c19b38970bab82d762a557bb73525c49758b64611af3e9fe1df040aacadb517ec306c15ce2e9c7d13abcc2709cf747089926a2cab9304dcd542d9fdf88bdcaf203ecac6bdd8bfda127442724997de8d34c2822bd0b46cee58c22ebcf3af37b9a1020a397b2e2d80f63e3eec091d8aa5d1ebd5570a7e5e2b2bd576bc2ba7a5e7063140cbf38ede2a67f6f30fe7703e5811ab2fa97df7821ea4b05d055bc22ab2831545e7d4f1bd4a91c56473461b1d186aba2a5f95697ff2509c0cb3e010c916e7628f274b4c64a90e0e30c199569916ee7557e77546dc000b7650160bb8fdb6fced4f1dd8aeaa2e68162a64110fa1ee4c11a89e87d5f3012d4bcb7150fd38a180b3167f81d1b3468ae68246e386ec133403339aa9e1f3d3071c55f53da2fb021b0060df4cb54d761d2d20c958229d1f2d1b875bf87d2949c19242fa26815352f397cd250ece5ef048fd07d215368845778aff82aafcca8069b77f2e95e9986eb682177d27267af8c19831b0237a7ca0f8add7b1ba007dd8852ffc231beafcb0acd28bdb650d588bd71ab086a78465eb864f4ec077839b4c78ee7d5db101728584ff609a63d83873eb95e5e49ce61e3be5b24f61e2ccb4630b9964a3663f15ecf986769b26b1170e3639993d90d9e45211a370c4fbae4a071eda2dde0cd56d82b7b10d6f840b9799eac32313aecbd3b8bd3ec9fe0eac3d00100fa9b1608d33bc34d6b7c2c4e8d0b79cc696acad9a5862b91bd8b67b180b913f543347db16ff422b4037601f3599b6b673aa8ee23cde7f3ca3bda28088c8a63cc5dbc7329814915a267c4bb4433b722d9fe75bfb0729670021b265789bdd67e6e688ea72573d209fd7e28a4335ab0f2fba5da376f06c4284bb7f6277d88935fc42996d5c461a66647b4607643cec53d3788261a0ab344fa69510bd641ebaf26bf6bdbd63dfb148218b61e48aa4afd3baf151d9de7873ae0ac7b031bfc3bed4b5da103caaf14c1b434747e7246f990ac307824c3774882397385f0f64167e45a79b9508098a55fab3b771ac711398e5ec54e39f515c2d08f1cf75bc9461a4a0e95a34c9778ca9b277a01d52ae27b3312c34b4833c9b0cbb73a4c1d6133316f513d1cff71a2456eba3eb0c4c130dc13f609d02503b1ba21dc8d067f3680a425dddc3ff11ad40477faaf5acde5e6deb0c2d44741786cad7dd27b73f66d118a52f850daf4f7d613e040d595dee7d4aed5bfa0d5647c132d5b6d2f666ff7ff8c5dd7cf9f1ad0d5ff02c3885f760b074fa4583009df3e74a5e37ffbf04e9928c7c03b9795a20fa8cc7faabe358b481ffa5329e9b3ddeff1081a7bc0e65f78ed0462aaa581456235a024f4a8cf88ec67a3094cd55f2deab0ba902ac474c796bbb44ebc466d4445c43a8b5ec8c30892916ba04a7e24275f5e24af75bbba9911655efd48498606a5e32dd024302fb483a279b2e59a77011a71748be43a22ae74b1c7b390bba1ddd5140cbf5114fb5620ff91a397827cc73680f02c49a83399da0e5b372b66621eebe2d5bd8dabe3469d6e19c27b20fd8095846946fc1d5b3bd59a8ade8abf5c6f8c801d2e1e7cb6e6c70d24acb45cb3263a8f3add6e9a6160886d06369bd8aee8b91b28730382065ab7710483ac1aeb677dde06355e3fc9d33761d1d048419ec97484b7b779d8631c76a48233fb0a3c31caad8c27231dae09eaf6a7d7b71fcc57d36fe464de8a1620eac77ef00ffc2420823537b61e7e8dcae08fec34afad2ca312b7fa0a3e5a6a35e7bfe68301f103405c53ddc0696f7ab6a6beb92a0f4a70dbf1ca97e0967723aadeeb84a864d8d311c78b391649b5443e4b0ac316ae0fc1143be846cfc0c5b5d151ac14487cec4dfecde5a852df7b3499e564d2c1e298100ae69aa63af8c3f27d2466e91f81779f7ea4f41a34c49f4cd173be6b26200a51b49912007a37fa1cacb98cef6e3ffc67f171ad43ce56eec8304065f943fa1f97a3d9a19518c1d84afc069e32233486bcf440a662023045a7159ad48ebf692279f3659eac241a477f118ce2829cbd217a818d92560da4a1221f4d25c34d8ab7b9295651deb01cff1ca912d9b593c7ce95e5e235a0dc457184ec3dd11c671e23dcc60618813eae86a0f1d9c737cd390836e151fcd0e698d7134d536d66e6663fbb58f4cc0079a42e2a71aa5bd58b9b9492d8b9ce63b09511aa0a9d8b07fc765517b73def5c6e4295b4e89b8e1a9c755d1be0a6086d9d1dd1f16436229d70bcb42777f50589b5fe080abc1b68cc14cdfa56ca3d51009aa08fc4cecfa54cf6b1d8c09e30c38847c0739a92030aace829e92470c4d192bb018c2f45937d5f5874625b3c3d9b7d70da97fb89860cdbedb28079a8498fff6da3590fc29982aa2da7b93459b1af4adbf4578a03c085481c3b1852c6930c08f2cad7e8f450aa062e7692bb33a5f5b43df9cc033e942b7daf801368a3a53910cb7044f6d06fefdbd6c3340a6555fe924a18e2e82041fc7cb4764f140d62d952d2e19cd36ad92c71e455cb3c5a813ba0e720e1bfc2548427d650701c1eb6ad8f78ac090cc10fd32dece39d8221010a0653e026946b08bf27bb441fc18dba4e6ba87e67f35fb4ecf32aca179e0714bb266374e07b8d93855d5a65193150ea7ea21ec623ff0a59ddc6a65799227739504498039663f858cff48fbcc3467b2e20bfb3fdf5a41550a246574ab3def895322f7070b685e9a7dcaac6528d35e6cb899d131388a3e5f212062eddaa12a9b2f184908aef3cdce5ee2cf270108d39b2879d2058e73cbf59bad6bf209469992d14b29a6649715f96bbdc1d234b9849608aa7ec0a0640546728ae45e185abf645b4c9c7cdcd9c66626c2795163f41520fdcf7d205ae9c9aa737cca08f780e40e2489d8db181a146ab7facb963843076ab4644463c3ba3d4b3ab510f5ab28627fa53d0f04a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
