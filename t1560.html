<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"473a2c838b226fc424ecea13747d603c8c47a19c6aa27e6d44f932b6734f75108be1f833e9139594735acaec1f712f2d2ccf106cb835883aaed4345fdb89ebee9454eb2fceeb09a8cb2143ff4b6d8bda711feb49e4bbcefdf6976ecd2bc0e1f93593cace5e52bb33d5b373add47d8c89915aa49525732e9b110b7d5f5b8e461cd943603193ecc77e1262a2337c243a1c63fd883edf26858eccc8bb46573315812c216694662ea774b232d4dba56b8bb9d3b9327e1bc64173ebece2abe34bdadf7f36ac659c97699ac3a795c390c4125d42e6d4755a530499f25d64a919ae3a32568aa8256f8936b1bbcb5ad269805a627db071b2fd40f459a87fc54e7c7c579809aed1201f43efeba0b6f12a0cbf90a86761fdc27a5babd8ea93e3851900c835d0ca686735f7c6b2b43959ef4f0d5af6f711cf6604abfeaed06be68eff7adce3522158405c94f3427178b6732b6de7a77df900b2092e65c253cc4277f1fcb3d56aaf424cc6c986c110a30e858992a898b3b543334681edd033e03b284ab387dd649dbdd7b73951fe1a768c0e2dad9e84574519de2794ab09b547c9925590f7d93f10c44327324be1fe736965aa06b6601a78d03e938902165f28c0fe17cb85c63ce4cd178505ab48427a95aeb8e74909f0a4dc4c374edd44124df1f2c9d868c86130901a56aeec232ce41256801d97791f15a65c072a0de71a0971a76061ef9d9bad29f3640b6c8ea3ea59dd9852bc5767c99c8bcb18fa8e0bb061f4a5529d724f26192dc283e8884308af991210655aff7630a1da90c8d1788648009bd26f3b06191a6b7c45d5794b470fd4243d4e22f0c34ec02505e803c398477d37a97aab2cac1e8b2da3fcfd799dce3bb2a6a3268f8df5b7a4b3b27a26d46b6c105b176807e4134c9f2d42a18103fb6c262e80885586a7673c63f3bc07fcb541171ae85c5f689e4b44e51c786bf12074da0488003d29bdaadc6394544862749e139d7048e4fa645608c00163d378227f865e9780e6917c7561899bb7debf4b4a708bbf0dcb44d3266de64c44e676f89b0d92e5ed2c2d2e10ef1186546b37e2b77697a573b6428081954ba8c135c89c172de4aadae56fde76e186c1fcab1384ca8b14882889b1f77f09c37be8fac4e71ea56f8f14bec9cbef218a7899b1699696c23c4bc17c79bbe2820c0fbf6af3c7f8f2e6f1ada6feef7de64b378b40c4f7c1d4712c6317f325368183c8e492a2b91f33eb44c900fe1c2534cdb732411bf1da4f6e2000141ac08fa5f1189880f5bebf2fafd0a8d1ae8f01ffbcde28ac8f8fccce9f843fcc461a3aa73575a81a2d39d7bffc772247eb488661b00af92f5807ce9ccddbb112cc3db375d1201c5c0fd57a8b3699c6128c785ad9511f03b5f5ba194850678d0f97b0fc77a4069813f75f9210ae7cbdd6dccc26990fa8efbdbc93b9ce630fd617f2eedbaf94c4312390e901692a72d1b4b68789ce4477f06e05a5e94dfa4e14d4d8b12569cbdc9ec29f301aca70ea053182a01151888d8f00558400db60783ff9b0ab309c793afb3df51084bde750eefa5402c20974a79f99f95d52a7a87d210945f2c46142b3e2b3f3becc4887a7ce84c55c2e60f68eb33a4f1f9481ff921d2cc670882a7b0c3bfc98c2cf9163daf75f95a47eec578783b78ef68dda02169553a5649f97a4ff65ec110da0ebddad2d5dc8b31810bb79244a148ba53ac1aa63c90c9ecce2c6289d6ed1b28a53471d14704753cc8a06b7c6dc528fe75491e360f4be76cedf432c68fe4fe032cc98f6703861598cef10acd439faa3e1b8d7b23ef886f11e9f23c0b704ff3d5884c91d901ddbf305b605653178c20edbd71433de33b3ea3b8f0051c43ac6c8f30d170ff2c236c80d53ad160d66ad9c5283c3665715037e57aea832b2501ce60da39ab943a3fb3a455591a2d4c9b10101203fd112bedd40465713e5762acaa11b1ba98e15a179660aaa020eaf08d258a79d0313e42bd81535a3d17e86aed6be87060b650fed09f2e508c138e9fec3c797d08827597653f5d750183fc6188f2c9e5f63aa5311e9b60b7400fa69f88749097df54e4f635e9a223521d6d650cc8a12a92473f000bca2f22ebcd733917ade59351900d0ffd3c14a395c45e2aaaa71d4684347f7e4b6e54ed8968fb50e15c84b4ddb09dc74f0ca83953ec6bcaca0ce6aafcf5c3f7d124ad5c0751cb0410e4e661dcaf29c387a0d93f3fd8974586eadbfcf794c19d6af954b148abb5908ecda7cc80364e5ad196efc874446ae8812ffba337b8ccab56950d68f6e758c46fff74beed2fccd5ea0965238f71be00c81a96b81ea7400a4c2cb5ba16430fd5202405a2eea3bfcc6a160f0bb477d92329f92ff9329e6910b7472a9d97d8184aea90a52e87cbdd7046b0912003ffead24a8954c2d4e547fe3192a5f3e01588d9d9374e55c12d4b697726de790f490a96390a90cb294c038169a14d27f43a738f7d5c5e87caa3ed81948155da2bd1b4f4b2cb8e149f939121d378f5f9ee2e4598be536faffb44a74879855dda5340499687b396e12193a135d423eee76b14da02fe526893ca92d8794e221f36d8b4cca79c45074483619b6b2f4543c9602e4a4cd3ba58c7a247fd30fde46b5483386f6300f256820c59c9d91604cdc1fb1e4ea698e37ccaf77bef82cee2c07b3fc00b4a77f26d6dee345f68648ac1769e0cf85b40b74f065b669e636a7a74707db3ab3e81ac8b66349d624bc4bc012524f65dd579e89bc4bf10e755be5c101613eef131b1acd95fdd9d69bb5c074f0ec6b6b5caafb38d309308ae947f33864e1be14c0cd4b99794b1a0b15437a78112729b466e544afd3375d6eba3afbee42446c14d97125c7f03b1de3225618201e4131e1b44ca71813740f8aa2debd0e191997bdc96ea8a156ed853c57a12e5b47733a5e8105ebd084d545fce32ad5ac6d4a74d70ee352440417f153c025d4e72654000dbe392240d72f78095005197014aaf685e064c00b62fdc7cef2739ed19e598ce3ead7c1835326adb4efd677f1846fc4b82de268a9f76409f464b4028e53153536759a212dc2ce5a70f8f0b99987ead46c47c0f5291871ad7c3097cd1f96d088b80ce59d311c8677a667f057b84ebad8e7310ee1b0a86706947e3c7a4f77fcb9e59f8011b075e1266836e35daa28a151426a0a271f15b3e28c11ac5d6ea1b455645112f8d3c19e54b9841dda94c55913713ecd7913e7a10471a4f087d946133dd72f039d5223dc11dba97a18655156ad80ddd17824c926719e00c07e34ac8c4b5b58959475fecdf56f92e2ad58c1315f30e2d98dd846acb60560416ffcd08923321581a49c48af990ff307d0fa55ee3265cc7b628732d2494b5cc984d2fd1625478f905ede4e0ccb85e9d32ff01f6b74b8de5c679f1f22a4f57bd88c8360dbc5ff92c769bba16a0ab5255ab33d36705fdbf4348718b21607bfd6c4877e8aa0797d8ab9bc20f68fb895991bd73a6d265f5729ac05fa1a711b1be638c4885ee7e9ec7993243f8eea47de077aa36bea4d1df4e140b872770646cadf3141d3c4617daa8df0abdff2aa0c7820a62454db3066e984912168caeff4bb1c8850a9361103784eec690ff2135c366f8d81b5e99d71af56436a68bd52a63c3ca4a273e716077acef4ecb594f58c3caef265149874d41fd481078093036d82c74b04e8b87de39e9ab7d2531ab7b3a8bee4873916b1d112fda0f18b7bce8af834e02be30a21977830f7391b7bd737ffd8f1a33f1eaf18960b919a90cb7f302c81812959f89cea2e04bed2e4779e903921771b9061077bf9c42f827794b8de90f18d56e02b07bbd1af804a99540159f8fd479936f4bd23959faaed8c906dcf815dd65d2b9b0f2935c0be68729f203f65cbca3ddea87da98150b6bc560516f75b1fedc77cb6e1f9cd762183938f0b74d1baf955cc34ad9aef828d5a9f343bd64a8f471aecbf31f9422663ce99c2b9d481fa028427ed23c9fd0d53e2e96d5d1d84913519e57a2048f9b163920f82f50722774271b22078df534db4e64ccff8435363f167acd34e380bda7c37cabe75fb161b226a72729043a8dbeeafe328966daeee4f9373572f8733e940ecf5da57353972e547a6cb2a0c9c9e72cded1b9123a5888abc4d572098e9dcaa45f3d6670a5b5f2aa98351538361f27421e99ca180275ae4d859646f64acecad07a97deab9f39b668f4879b7e26018da3b12706c3b4ecaebd0d0f8905e6cc365f519709262e00ce33b754e023a39bbe46a41bfd617bbad5e2f90b21aaed5df6b2ee55cb5ee715bac10b59f7de8c54f27b6292e997fb7f8d32f5805b853c49b45708062b37fa8f692363740a1fc1d612e03c89aa12257f515e3e013812bed78f08af2e483ac97d68c0a98b04327100d525aeb816e42b9291a5c6fa535404034f333a904141093c97a86cb9d110715fec15c68bfd4302a0e5ada4caf5fa9779eba05dc73e4381112363d9da9348273435ca549739f85a168a60659e1f44bdbaf5dc0548e2ec1ad01e155827637f545b7cb23be90dff6cadd5e8393d8ef1a91570ce49200924ca5164bd1dd196d40e3c9f9b4b0536ece0197d5d7da53f835302586a81d277b958077dcbb0b5d655f1373b2c971f72b87770739c990cc4ac6c95fb1d42abc6f00ebcad2b033b27f60931654dac83f35ebb0bda06ffc1128659048bcd623c8f22dc9c8c6eea97e8e5fc88825e57f30b82c5cf6f039856a4207badd52eae1e41288db1c38b675ad670b8f6a069c3c58d45c2560d4079fcf02b00f88ce91575358d0d17102e4c59e41c60e9ac263dd18ac716c7a2b7c8e21ef62d5b52072f36dcc1874d74914049a1f4a3e5c80425c8c42b9738612a86d88a6da06acbb94b0bcacdb44a286afe944913d2ed43bf6aeb9023291ed3d31b3170cff0cf99f70ed845edde290173280c906a0544fbc9480862b5ec12bebbbc948ca12c3fc2deaef0ac1aa4e66b1d2dafb5a7c636ae36bea697407259d0ccfa4c29210b37939acd493d72c0d0ae6d2b75306529fbe29a87e43da82ee91e9778b68fb883a965d0b9f3cfbe55392414869ce588032f2297e26a5982da803bff6ddd3b211ad879519c9bc56be01f9fa0c51a801563ce8e165dfb0fd107170fed0aab7c2e850117b6df6bbf6471ce8a964bae70ba7abfeab4d4c049958b5ad493cc7a4ed8ca31019722cd9a86addcf005a5a6669a40be7f8c76b029b1e402e039aed56e4a3dd86e8341284fbda2202522f4e92ce0cb631c3a78bfd0dcde805be4d0d9a46bddacae271c7101f8399539e4154561b2a0fb0237fc08e04c74d5ec8f5b7ebd1747cac55a9cf67a0c6d659da18db9d202b94fcd3551b376db81730a85e72f057fe0baa301348f71d292c256f6357adfe57fab8b4bcd6b321e06c7ecd07176c17122343fb2d5a705082d8c1500e96636bb15d1d36a7b542a08d04613606ec61b9f2e6a91990d3ca5582e8c37f2fb6498151bc16dba2af6ea692eda4a625b9633e092d401dbcfe2bb513a1a6ecccd861c2d170499063e8e3d70b55686e86bb03b2c1177f1832224aefc3cdfa502f0c4ba718be88d3946c71e00090a91b7e8b6271d2e798832293dd9246de296246e62968bfd8576118735ff73dc3c254d12d07c132554b07a4baeed0d49f6905405c7c21a60be71912fdf361cb1091fede58c2b888062be1c77951cd99d5fe2bec5ca5d1d1415c862c50cb1aa15a51153b5575515b71588784c5009fd363c2bf7617775780712219517757b7fc52e6d30360dbfbbf89c71cde06e7ee3ea2cce192299a63a41ffdc43573bc1e6a04b0d712b0ad0d0c1e0f5013a435f11b0f1610926d7d53cde3041142175ee07962da22694d1c7008d5bf79924ec31c71db74acebfa54179441b6ad831e60c462851c5b54de8ac44bd24538b029b86d22d2b02b9bba193378198f52650eefb380448247d182b68c14af18ab1cfac290c9891a1d48d80349acc2e89a3c0205ede915aebdfdd36ceccb2fc02d28a198c61d97779b607140aa8ac0059af5d1a93ac75b3b3b01a41d45090f4157bfdd48646e211137165bf5879b0064dcbfc1a9cf220b7f178e6dea49c9db955dac695bf1a9af46c91e1e8068db03f77daa5af5ba0840cc91b88dfbe036c2481eef5aaeb660b93701c9c9a1c35373ed844f06a9f8ab7af2af9ba57d80f520c5c298db85b1ecf3510c58140125b166f175a1559c25cdcb2a79ba2576e6cfb8452b093fdabb1b8521d7a7fbf26b91d94fdb5728c8c50b229b93da94b21e88f15e3808e9d017061da1a35238322c2878f91ab5edb0d633997271a1b6604c038ce11f8a9586cca62868727ee3e097c97d6f9759be7e35ff8becfbd42434ca63a347322bfcb33e550e173cba0e8a7e9ddf138d29a74bf41a94c2127a55f9639f0cab12683b73dca0d2f8927399d66f3061ca0c737f9409b87e1cda7406e2412d5c131a9a66f8aa706d4206840db9a9337c0e47aa7f36896709a66e2137c93de7b5e5e9a94f7e1361774c0ea35a11acfffc8d18211e537f94b0e6128e53e7613c1b12c97c9bbdce6a15d479946e58d722f1d5bc672062bee1c523fb5c4dc6a9a203176c629b9d1afd7db636971efb84ee22071f290ecad89e753bb43d27d88e4ae86e40d59f734dadd29b61014e46127db5f7b7f2b05cc4506cfd4fcfb00cf8b75cf096deb4516261c6254d0be10693deaf2176794d0a63199523e9a1df902817bd66833275c4e08ebe506870e531e4658697f364dc71993bdead8e3574b372f0b764d93cc719d3cc0725e69cc349cdedcadc11e84af2f5c8890b44168c14e4d75264fc065cd0cadf9bfecd1c29fec710bd324421eb74829eae626a7fda788ca0eb28fb1c85d413b00089b6357b122fa67e9202f468c5b660c0c56322d0cae229fd100193a1e86c49b37cde177fe6871f80540d225a5e76f11a386b1090eb60277bcd740ab4c815bc8decd9e9391e79b6a315382717dbeb5c1ef0a02f7c01202f6474628da7c683d2316645b2cad895c4b2e34022986d1075e96245f60d40057573e337d82ca2f984a364ffdf4a811326c327f153ef7ded94f41756d4f182bb8180c957a8ced856e5e5688ccd91ea0de27af1adc544f85683030844c8e0c9f9925c09abc0a6a6b37a64e86a8e0eafb601355e25248911be962cb15d5aead7c1570068e08da9aaa0c97126c8ee38771f5be6014f12e705bea5e6210db48308016e9bbf33eb72c71ada0769f87f6cc9e32f12a121fa10d3b81a73b88eccd4e85f80b684c7cbd305396939f82033708ab4b402a499f0eb482910aabaf11e7dd178a3b862f37690f1ac97ced686562819112ee04342b3d0614b9338bca74d5fe99c6bc62d45422013e39dc18d50623f6e00c05c16d0f432422c844c9d1fa9dcb6e4bdde6307151dca2909d45feaebda82c0c4206a136d0a8c8ec09de98f45bb85724bc517c44f2827b899d9f5dbd465a558bfb4f689c123744e8b026d0297f70059e486886b1d47fe6dcb3f804722b0b2d364adbc4b17f0ce661f090d07b97d59aad7b5e3380d59c60b3f473257a6bbb0b93b4897b1de818a2df7e02c684a873b1aa2554b216523598a451d4704847b34b858b9e8532558d32a328b6217bbda2d8001d23d7e2dbcc280eaa10269922040ecc7720884f2c4721dc250826734fa1a13481ac767ba06fb4fcce389f26e67927643afa05bf7e0c13d866b96046356328c655b277d971ce0720bec429a02dd9bc74dd701a6d3ab1a0c4f88b3fc915d80716f74c4b4d7aa4a67dfff020cc05542939c3854d8c11adb7f7eb00ce800485a3347671cc8c631e0d3f8d1ffb80e6b13cce113fb80172addb64c08d1329757e53261f193b2449b643d93b3b74871a5e16dec10cb391356f85c539753637d51c0f3b51c96f08455e3133aa0dedcd3699bd83c01a528a91e865fe868f1ee4901de0e84bfa037c195db722c2cffc483518a8a5e4bbb09a99cffd2a8e696ab9b75baa91f6b64fda7cb2d101dbc7d560a91122be616a8087b2fe08cac640e882bf5b79f229d892b2e935f4805024632a8ea8744e03db6c14b2d63bee66ce00a7e51b98fdaefae888164d6311f98b4644473631a05ff0766ff48ef9ead5a803c582a118ebbe41466150af5bb53e7a9f96b8d248cd82e291eedc1459ede1e5b3a0c5db3bc52b0ebd3520f837730d45c9662e521548da09b30c110cc36bfc2e5d8f53418ddd0ee3f3897f330f4f0b76f395fe993ccfd08cc1e259a469d3698149a16d1b376d9aff2cb94c648df24fd74baeff6274f0b1230aa5d6b5667997241bd9a44ceefbb311d97d844eb3b30e640bb748ce7321e0ef8c1f40d9c5d8060948bde1e9f3f59265d436ef9938d23614ffd90c5d2e08a1b3c7ff3c35ab63c11ffce7e69bfd7cc2f9b6484748dd6e71e3967bd27ed73de6efc35a7e679d1a47eb79c989fb7ea25911e3dd3571763af0297d92b1e6a3118f017089406d370d29f7408b1e1178a2e6eced4becd56324102af1bcd03a0d1d7d3d7938dc09d23e43fc3e39f5f43b2e2f634e2273a333d052f98498b986595f2cdb9e7346ecadede1b6e00d031c1c0fd80a63322f5bd4e01574837414bead17cde3f0fd7278c964c7752faefcbb5f9db711a9a058768b8dd2607f0ebd1394f5f689ae3424041fdd5b69aa39476ee44f34fcee3d78e096b548588582dcd59b47b55992e16c584b433578a40cea7084acd2f9df54d728fb501970806d8bc59eee2b29c3aba79b613d598e196c4e38c035d7671928296797dd4561acbf6ba9f0d7d70f7ed37535a91e6e2ed486e0de9ece1a80cbee2da591e05447d71c9d98d1d4076df733a4ab698a78c833730da700ee3976af3a6fb22e0e281e152cf8511d01ce56b581e4a799beef34c7c12e5e5caaa310c99db0f9382aee593d91b170624018901399d02b191dd1b0fa1f04c73e41bded083c0776ad09575b4827ee4b332ebbfcf66a061d792b21652fc310832ebf212b130e10f5860577d1186fa1edef8d757328a61e403abb6d0f5b088b9f489db30b453e19d1fb431b40b004d9f3d1a118e6e7eff9d2638374fd3e34119d0907a4e6ef9205ab63afe9b7c799a0d05daab18229e815ee79bc61010aed2eb4e283e5e13581da011e52dc28a6535b91b021be598fe9c94813f27ee276c3dcbde4ce089000425da5ce805c77063702a6fea7a1c748b8b87cbd18b9fc9f56bd2a89db622a7f7783dbf963b578fcaa49679d8be870834d9ac277725de84a84d3fd2730c00fa1936963cf529f758c676da818414c4e63f942eb48974285be3af4873eefad62dd8b5c7572c4e4b02e544fd1b28ebfbde57fdd1ae136b4da1c62d3d9292e916ef81c2594911d1f65dd63a72e211af1416ecd1e9b6346c311b47868d93557de1c506a1c1dcb58021f7ee15040c68842caa6dfc16d7cb75f046547133940ea5e7357e7c5e84e09f54dce5f5318ff0786200cf53822f1eea6bd15cfeaf7c7372753cf08a45f78999a74ac9b5d5bdc007cec2a4d45cc9ff23275ba364d3678341316c7639324ff696006553ea34686124fed78fc34b5c7cd38fa188c80b9ea2371d0bde1a61a48b98345856223bfde5734c088eef16d3517eed72c3172798cce699e9b6970852675b001f98aea4e14de5312379dcf2e75fe798826b947b97b57cf822fd10398728d010d44a321a00a8cb5abf8900847b9f6d18c769363037ce91391d890148fd6d4539d752231367619769a8a8341769cf082bd86cafc3006d4a366460e1b5d16028d50853e0b537149d0530d80049acfd4646be456cd24b2f7f2e09ec7e0957e36c67fbafc84bbdb42135c8dc2fe01a455cd16083f2f452655f67a4acf1313e5cc31333a8db6f5e7a6b6afd56837d53a1fb4eab08e631da5280ea90d542dfe3bed9f08b643cb438d2e32fc7268211c84b416e9f2dc433f6908d399942aa6dd8cc8043ab470e440868f03af59581fbcc8e2854613478d2a191d561f35c6ec9fcd38ece7c72b7f7bf5d78b8ec48f369b782b09a3d90e2bc75623af8ccb623c77b0dd2f397518b8d5aa783ce892650cc749a4ab6d2148e420bf7ee7a80b4b24a2d669b8dc23d7230110cb0000ca8429cd76e23d29792bf2a4ce1d6084b47ee4793d394c52b66f43c1f6ee916d22af7c7cbbfcc6b6cd48421a7a18035aa4fb5159aaa31c6ca17bfd4b9249395b875ec62cec2cf70f532306bd609d807b62aa3d3855b8a3bb51c77010539f1cf1ed7758c668f885d2cc3d72aabedf0414073a4973cb930ce78e19b62ce6b87815f8d0a96e50ac1c31faddb5b7895e94b58e55939ee0c00aa22206a61f783568a3b86c764a594a6f2cfa590951042815f68d47ca6ea182a574640a82e4ac25b326599e5faa00a4a3610bf9ed0a6f11bd0f71c2ab55b38913ff81da520d8d0a1997921cb19ad0b35099d223963dc34ade71c96120b46b4e445925aeec969739715c4ee055fa31d337a9ce28212ce6cc436a2f0b65f709ee9e3808c549280b4bc0e7f4eeee4fc03504f05292e9022492429cdb892f5df853c941c1a2ca965361cc90b7219bb91ae9d6f73ad28dda7fac1675f8c8d1bfdaf622ff2c354c95d06a52090e04bd96b2b18257b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
