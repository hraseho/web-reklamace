<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f81b5a97e47d5d25b1737342b50e95055d6b5fc68c74b5d27febcb178d2dc6fde7f45adc5dadbe9b0f7cdad7a0db801c9475940e7c7d570cb016b5fb9f5d85793e5893d555badc3452c0d5d2c90f2b66fa7f0a3d005717e64fd2171e8c2430c9e7d74d1251ac0414be4204bd0df4596b578cd39db94be29b09f20ffa6e8f7fbb316d2833877601bc2b098dcc8c914bad1124c8c9e2575897bdbd79f91b57105b5cbfe52e63759cf3e489b5a1588b4ab9192453248eca2a262782d2f25a96a8dd88d980c8b6e696c781795d3fc4580216be69b69fdcfa2baab1bc4382eee18227d34c9456e9462b7e31fac5b0b71b3255217ab0ddd4a1323171cff8b4301b923d8c00ac342caf7bbc0493b1c154b7aeaaa744a69560ae6870792bb2e0132f6feaf11f6c0d08348f57c074521ba64e4e40aa4a17515b7d8933c225c58f9570bdda75d52db92b48aef352c9280324615e8c78b0f77fb2d6b5df38ecfe3228eba17287cb180645fb28c88d4e61e93e405451577f007099e62aa6aefd73c65d24c78080579f971ac5137f9cc049f29e5501033ecfc86ca86c5d65c0e76dc10912be239d08909af718b89540ebf9adbfbec738b75b298fd691927505b88aed1c56f44834dc02f02fe215f02423e9b72553607c8db45c7d411d880034c32c74c9face83e1f945baaaded0bf12531c0c2dfbf31c250a840c993cca2c1769b4e7db2912a59da9fcb4e36fb4e1b1821846908693846741a97c50f153d39a5bf007b050eba358fe6322f6bdbb8efe18d564ca4ee657b0cce0fee1ad8aaeb638f09f473cde6497630d6ec78644e0579a2fee111926b0d012315fed2b9f929a5fc1660425c3af316ef2b8924529ea22bcc2eb4e57c00638acc4544d16a836a67b16969ad0570c93d6a310055a2deb065c5adad24c95bce9421be65c5f7bc9c1233c90a3356955d2ec39b833d7daea127f70a266482b02f78e4f01cd388d7a008b52b8821521e77634e4c739eab2b47edad7d4088543128ef6767e25bfcda068945b826a0acb0b062bbc149054ad92c9965b4b561327d08648943d502175baa15a443ffe40d120e29705fed913bbf5e5ba4eedacfeb7c9a53192b127df5ef9b270f8ee7e329dbf5a3c0392b5f4963df98bf0f7c58912b760f35a3cb960feee036c4a842dddf1402d9a102b745a7af49a8293c5cef5948b54eae557bb2d2babada2e2beed67f26726506b061b4523b49a3a1b580a0587bfa3d7fbab746873805c0296edd206ab5194def7265be0c9392d6efee3e7b22d400cccede714ffb3abd257120dc361c18211d47b03ccaaca802f21837c90f73bb0003dc479cfaffef0b936d93910d1eb7f7e37aa40a91984d05a104ec8a3552298ee2f182d334d536f4f92a37d51ca40ed99ff9012b2740c847036c8a8ba3168b4db8bc4d5f95da740f848095ec5d977297b775b70e662243c5963935afb3bc6b7cb329bdf8dc58fb2b76e2b94e50c86c0cb4c850f02da8a3e69c99ab5425047849e3b9888ac8282befa302ebdf6fae455e61ef3b42823b777a9df925fc620076d36c05f4402e68ec04b94aa03310ee3aee41515c9db56eb0c99fd1239377306bec23ad2469f115e1990a0608c0e492d52d4cc821fdda39eee03b1538c8b3e0916bc0df04f00bd14ce5c3b9a0f4536da465eb26b8f44f6cea46af2c6b2f6ae386ef58ae25231c4c4779e84fc3ef20fe9fca0e8bc1d40b712d9378e350f5c055cc879b1b592f540ba515c16fce112e702db6529872bdaed296e792705060df76709b5ee0014c51828e199cacc72df7ac3901b309761bf0e18dc989bd3ff02617f1a8107f0f18ce3db517571e61c6107fac9a146ba03a7b0c4d79181e5b056de042eb4a7d19439a1f39fa9b96aa7a266cdc057cf743e3e05d3987183e8907e72ebeec876a64ee67596bba9130d80589ae832c7e347d972324d5a882835b9a0544c783fe76e4f9fe25503634f0434c2fafc8c8896cbef789290ee3e523884e00686c0022483b955feaeb6766818f75fd87e948b1531685d81f98800435a5866a2379f69cf3c93cef2dc0536f28403cbc5202a6ce124a53cd8baaa04268fad606521d7042abf050ae3f050bc81d28fc392f80808f759db9635b69fb7188f432f4b57fae74e6e950b39c5cbfb2256ea1ed7cf793d478d234697bf343f8263d2b0ed7181a9b36274912bbe41ff6375371c5d18e5bd021a31bb8d39087d1d6168bd572b726822aad843940872b8751e7f158bf9f688c8de9d3ecbf81ba512fe06f638e873b1a972eaacd337f37e12d113e7e296be9e20514b66f3e2a75c734200a242db2f4db8b05ef7507f6ec1b1a591aa62c6af0e8383575317b0cd9a758388a7268277187a28ce20e70d5594b41508e201716957d2c9f99a8927833de6af105e3ea858ec8adf2c7c2c6df4652fa2787803749e05d4ed8f3ebe56055b1fcdc6cfd2a12437921ffd6617213f539c42920713bb85a361d94bf812b50a8f93ea27c9fa28e4e40a305fb817c360523b26b5308d4e834da4af3f15c7d6c141ff8e43799ce181ea6bbe58eb166d64629fa82e73f7a89860277c1fd7f5a8d8148dedb8f6ccd32887bae9b95c316d795b3e8ad0f8783bbdada106aeb261aa3d1cd11d678b739d7e572335fb49ed81e6cea7de18dd951569f6827e01b8b8d4ec6f644e42d6a776f3884215299395b56b0dcafb60355815e16e09d3521d47c7be76186dfb507c89a382edcb58c6c11a3716e38ba227108d75e857672a1ee95b9775f59a7a6367eff398f4bfada1aa90d8a2b5c62de8c63c9847a62e9462533f4d74d0edc14cc3d1015caa2dd1f6ce642b4bea6e01ff95ffec5928a4b891282652a098903997efa3f7e9b2046af6747ed946834415f5d05fbfd6965ccfaf71ebb30893003e53ee72b67c79875a0f4fb2494c6a2e3b7bfc75b8414ca22acd40315b44787ab2aea5627ca160f9358e905af2122c844d50926b400c6c36b84fd656108e9ff28466f4c240bfbb3e17d95c66814cb454799050213267139a9ec7ee688498fc89ab3a7552d0ce2a4624aadd3bbcc48b9d307a46ee5622b707806c532e7e0b9df85d6f4ef394c079c400965fee58afcf130f82fc91004e7d7f09386e95a727b4eebf9db2ff9aa0dd8fcf1f7f2c6f78d0884da7e899da71dfedf3cd2afe25afd38f61a910402d95bb65267a8b3905e2cc0a38b4e5ee70d6773aa6bd68c1660536c81e04677299dbd443ef8ebc9df342b45ee9a24102b08ff077cd79ea48dc1a851c4cb28008c991376feb0c8d3f5ce81d2f2ce2db1a60d266f9f944ab1bf579db1a4383c21a4d120ca98375dc391c7d538a3c099a563ceafd754c8b0ee6682088ed0aa2bbd339ce8228a0ad85cf20423930f3684124e5a42ffb3f7e96f1325d1127aaec3f8a90846ab3685f29f6c18388ac8078d1c97bc8426fb89b66b25be9c922d017a32d93ed1c03c267a04d3a4a936a0ae31ff99caa65eb074fea200919549755f476fc802f128abee5bbbd7700a81e0367f2a6be7a1e1c6a29cb0bbcf25f9c9b6e6ea9fa9036824528be008fb8fec5896d9ba67286f39f94997666d3e501919d6eadd741e98304b0143c4f00f8f5fa1c9bd6e2d9a5881e2690397debbf9b71d97b3b0eecaa46ae963ee49a6535de031aa6046cd6e15ab0adff752f1231905a9bdafa8dcc639c267fabc9edd5b1228496cfb465c41030a812e192478c1eea773d620724c1609acf55c91c51786fc9d6b9011662e33b3bac7f080cf3471bdbd265f6f8e73257f6a744baa0aba2cd575221245840e8d803c871f53bd87251e87912d011ade394a62cbd184eea5ee4f83f5d2342b3f30abacb0d645b410d705484511b4b0ad7e8368db8336c05ee1ba31d13590dbefb1b21f225e9ea844c0cdb91d3c9f9e937a82185397dba6390383c0cbeb88190617638a8d0de3814facc987603b790bcf415b3444ef7d62fdabea5bed09b606fb77c71ebf99d1a8a6f29d14e15974eae8a70d388adb2b07f06dcc2bff13a9542e748b67d18b2cdd0288494cdb788e41d2473e14cf60db2766b92fbc617f5899b8a16db050d56f00dfd232191476378d91337c065cefd7fb679c9c49f30d85fdfa4a872f5e8db4e7ea9f7501f6800ea808a1035382201361d742cfed8ab9dae4feb72ea96e455567e507fd048d204259366d6f9c0c64895cbdf18ffa993812f7370d0f884bc428cddd682c4b060384e5815ad649b828c5b147b73f56c809497309dda89e38b95bb26dc0dcad271c4726662c9799326ca0b6cf8719baada41eaefbac16f9d7298fa603ccf8d5b3ba5f3de5a41c38ee2d53fc9921788ec119bdaf81edf0e5d1afc807795f22920a83826701d69dd695011322e289080f19aed012ef44732a3b2a248f24d9d6d674918655480f48efa099b6ce9fbf038783429f36f566e82ea1121c0bf2167ba88745cf32f07acdf25c6e36d52151955d70bca987e3e5c58a93523feecf79851f83af82040272cc8003363664c4984aec88b3b12a9b00c3b90fa3bd0b0ab0f85656e29cc2f5446b0b069819b6973230180b1ce87046ab38fa3d0194443f7230d4bb865f544c7a4543d26af83032fa26049feea67d070beb9c77d728d32b7038abf3b6b8a617d73234b9def244ff9f0d394e8f170efc36d88d5a18ae5ff2ea3cc89fa9bb9dabcbc56b27fd965f0ade089fcadcac9faa447c6b2664137e3c0028780bb96fb90e4ca282bfbc20dd4d75a977bc4f3bac9bdc25ffcf37be2147334560149f70c1920e6b10082ef67b4d72aa33e3a18526255b9d28a216c94d75da66267e0fbf28776281970f7bd5e113bdb6e22f9d041e22d1f8a013ed38048b62de032b769e1e4567809753a4cbfd02578164755a97e04e20abebcb4f0f0e5bbaf311b8530d4f6bb82eceb1268d9526b091e83808a0bf89c231a7fb83402fd2c90884c0c6f6951f97d0413674742851a2ac019c24cc3bdef100df037c41889200484cc6b3f749a8600e06bd4d2844c731e7d31b77251abbf98b8624f84cf505297c3e4d5180c3c9baa33b9178cd7a195bb7807657972dafebd33ff96e804fe64140d95ec9c129134c66bc6f4a26409cee49715290a4a3b47d04fbc9379b8ece385df75f965bbe576743f440fc1db3c318f1d4e20a86ebdbce9461b0818a989d67de992ec73f36389580b752719ef8659d07bdc30253e54f6278b281656ff23a2bade6d3bca4730d93d057125ba6a685c6e51966198cf15283b41714b531fdf06031a286fe6b742f3410311e1aacb43878041c8c9990d8b4d26047a3e7866405351c62ef1fc4c6470244bdb07f5d6caf4b20e312ef38219bd8a6334135fb2062f87084804674368ce164e0cab318553e0aa474a3ddd2c76617364af5e33d03f87d97e11ebdf96d7134f1e7f5adbb932ae54300534005eab474da205de997035104c002a96d3414438a15230a1a628594ae70549d38472b72faa3cbf563086562b9ed6daad4710de53a69e074db2a3e500d7e945860d45b4cba36706630d0fb4e1ecba59fc0a0e4379150ab96483546ba5989b0508c64ba954dc7c28963517d3a67d4ca6cae53f2c1909f01eb6a9eec3051e03bc43be9a9053e293e6522cc9f6242b9d88dfd52b4353a91f5fe044864ed4c755d1d4d9b0d3ae22fc3afa42d6c1812f970f2c4a5da617e42466fde21dfb7e121cf63c743d2f75fe87bb043d96bed57be49559e16c756d889b488c733bc0a47d2ed6f84764263ca4c9f7195a1079d65fb3a2a9a0acce7ee0922113ccadac7872c67880cc59cf9127347f7e950419a474af8c54f1a0f73368bb045e1a84a65f7036f4ee15bdf35f9c00a539aa9af9dc7b41a3d3b353f17a5233ed81ad52f7fbc7f0f91e564f2f4530a88840d444279266a825efb7433ff7bde2a27035539d8f6bac36cb50573d7b45fba7e27cbc4d1f64061e8b19c0636ab2f3c70c157426aa67e2db71ea58183c581835692f6d29252008f908324e13c36d2f0808efeb5b7e19a6ae5bb124e076780e33787e79f697471f4b2eeb57b3cbf30ac7cca56a24748d1abe5f11e4af33313d24f40a200493c8f1acc6de58152e6c7a5b47547e4fc36f51f3369d8e3cfbbc0b9f107adf2d683424e280ab2d896cc61ed39f6db58e9bc4db8765710faefba1a7b6b6b2c18c143c82d89ca667779a534e482b52e7c08891502b1b954dedbe36a717ccec3abf1b8d66dc6eb9098ec9d1ce615e305e64949643a5c5ecf4ec153303efd33691be8f0a35ba38364ba258a0be1ec65cc063d92a53755ac2fcf6560f9503f16157f2b5f840828774f07fe5257e5ec595f9724555c95a769ad9bcfa14abf2986474700b83771668ac014bd9e0f3eec5a864980454847642df280cee18639fd21090cf231e74d289945481fb816499fb9bbc6407cbb23726ca80aa3c7d59644a372d5ceae09f64926c0c0819559f2c4a801972143738863737e12b595543e2cc6277423c8df4d3ae0c504511b2b94861a243230513e3ffce27746cadbc7261da3871b6ef957b5992e67f3ce911f77cbb21cec0e38fa0b5c18d7080b0877f28f620e40d6a1b8595d74ee346c27644794c60dd8ba90f567111f33bfa1ced3871fa1baf65955e3946c8f922021ad307bc5aaea1b9d995f8c3041c60f01a8d8c060b9389b9894867272e5c757043798029eba3b007c2cb4d6ad79c1427b4f26dd864a4bd44e21817e574242ca0e38e87382809689c930f8a45107381d0d580eed25abe452046b4fdb81554fe06699ad6e0d2b5b1791157f46e7ca57ff697aa0d5859e19c672b12c89f3df0c0ed5e276c41a51a9d0bb665d09038a860435284341e5d409fa54de601a59999d6c3b8d9ed55dbe555af499d0f359e9773be8f80f7a2f742f7dea7d765546e9ae24531dc1d0410d38a7bda8ff30414b6664357c9fff057430dc08c956a505c72f9bce63dd212356ca3acda9d0123e6c6f861bcd09476cb5c75eb15ba79045ecb235ab2475cbe0d5651d1ede848b0ab3c0395692b3acfd6846ae027a776acd751b8123bc04e037f6f44a39e167cf4c9a30802660d4b6fe5c468a67f1780c015e69a7b8ae4471c212e8ed19645755e7816c7733660a63e24417141ec744768a5f12e4c99be0582388d5a9c9a13944c61cc8a0258bf0d2aeb1fd9711b4095836b80484edbd8d1fec61b6441ebd5abf1f3047cfa2425e380d82893971caf88006e5e8836f36db4a3aac80855ff6ba7f74cb4c18065a0a8086ffccbb983e3cda25401950eb9df5d555284e114ae36ab3abdf65aeef9218c8b03fca75ac0fd067b42e80c299604f64b1dc6aa43eb63efc561fa3b2fd882fa941bfabfa9d9f625f56f840ac01a0224434a0be0d9c78b96e28a428533ed0d705e71f8ee79bcdbbb74c4b8a2922cfc5387b4c70d319597ca0ab6fd543f7ee5c01fbc9c7524666fc19f028fa211a643d125b91e38b0969422117244f4f775ecb4cb25ada557c6efed0cd7bc0e74e748a033232db06c475e57d06531a0cec74abe29c482d7e28974dec596fb86ee8b944e01dbb07b99b210cac430d91bc56ecba59736a882371541520da491829ccbf59e3e73bd0711f2d417b68bc752a740911b3c91a2dc5205adf79861e0238262f72069cd9706db1918f5e1eab9c52425c02f5fcbeb4660f9b1a3f23de5e063bb9709cbc625c71913e1a1a9d95483545b7e6a72eeec0c5013305aa96bfd2fe71c762f44b8d6a4c38963332f112cfbf3b3967aefa5da565d62d34b2f9dc7223df8b7c138e4227a1ae1c32a5da5d6c05ee4cfea5170d3dc0301574d72fbc2c0cb082671a4055e2f6d2247dc6d21f71f15333ae1d12bf30e17766ae4d27e2cf9bd4c4fa2e05f8b5a9908892f711cc5471745f68e19035fe05e2d991c5477053b89aacb57805feec8d8f447c42df713c049ea4980250a263df2a956df3d3f3c9297108069f70e645945086ee9204165616b38b31cfa2fe3c60f7de361b49980c92a5b63734e474ef9990b92690e11459bf1210cb6ca232f6db57a6754882772a358996f6ae349525b756cfe7d4647c364a2d3521bca5363fbb92a73663b8747f7ca452af98b7ae2b89eccf5cba692351c0f165b3f49d04627c22bfd3074806bbdc5db22f512fa28f6631de5f4516231138393d6121d4a42c24849db4797c35deb798400af30c7ce9e8434a8d233d0cdd07e5c4c6a90a9c23b2014905bfff21478e2cbea567a589672dbd05f360aa02e4e8a53d2a8209c7bdc4245f28719ada3c0c980c02263af38bb7cace6178755e14ed2d9f11fc75423763384809c66fadfe273807915641601110043479aabe8655493b955a08109c1db814b9f31f81852b416f208175d562a1b717729f74f0d264e1e9ec340dde5fcba601af5401c500b53af7ea8713190c7c3577d635e6d8687e342231d359664a2ca226a038c444944d1cd34e0161aa0014399419701b80f2e1feeafad2af28b2836e42278ae85f4c88c50e51238bd3c3d702a6beda56b83ba9b94bdbb5e131a285abfa3096a681bcfb1705d075d663e039027be2407f3d3b578a18acbb22e481deb2ba69ab9c3eda5a1a967864571a70796baeeb2f34ef90eda94d124c37e8c7896ba03a6cfb64425b50cfd29e1d81186c275d6e5acd2172c2a74afd5c31df149cac8da202b668028ce859fffe30218aa35b6a970f3c5666dd8ac153fc62412960b1c331a41efc8aab7e8f108036fafd3b981771ae7fdf9b8423281fa64c0be1a2fcbacced4fc7e10c4b859ce19e53b58d81d0a8611196c38ca7ce31ea9b0122629c54fdd57a16193044c4b30309fe7dca544b5067b1df51e5c027e6934cf5392dd50016d2d3e5d808685e2bf06d7edb983313fa6d78703dd2638711fcd0a4fce4402f10f7fcb9518db6a6c371e4b4a37895047f57b99a6305d6dfa6547291cedca3704121af0873734e3fd850430b58335b42b7588dbec88b77be921958b4247062bb9beb0f4cceb354c8a2aa1b53d0c9a2f5abc3cceb02250205761092f225115435fd4fb9bd53394405513c447f5c67bc5a15cabe8b791bf65c273dbbfef8ac15739721131ec0a5e523bd57013e4d61057c6862739b18d8d0b8a66b9d2c62c527cbfbc6c07ae7315dec6b19b4a33745ec4358f93782cd52d692c511d0be78d98d0595f1345196d8a245d01fd2183e6639e7b9ca4ac8e476a038062e6c3367969bef2a08dba581334299a4e309d549a9b6a5fa28aeae79bbd258dcc164ea195c18601748c53aa63ef8c9f551ddd1f8e1916c73d0ce50ee0780da7fa7e9802d6249636328a126c67a1fa9bdbbd93b9600ba7db55dcdafb69d1f27ce984d6685b0ae6dcc3ae42db136d8ee3023a6b9cce82ff5431e1db52af45e5a17006f3ffd726b26d6f6fe3c616b9b71970897751495563f3ab67f0f310a4af5eafa2d7ccfff5240bdb77fca6ff6ebfe9ee9555f2bdb9d9a1805e0e82ca98c00746cc26f5727bffa01ec5154a35740028651a779fcfdc5b559931389507d2c398926f8268075137f20361cb86251869ef845659611b1d7212cdfc53940820a646b7f950757d4f5719ee022cff92bbead63fd1d5d13d1e988170da2283226b53b9371350bc31c7a64849c65508b3dc52581df3ce25fe56d5272644ef4ea0a9539b0684685d79b3b47ec401c960469f2ee947849fbad2116a2e085cf3ce726293b5c21a5c49d2e324d2372449c57002bb57f56b58fc176e31d0ad49124accf9d37c0f337f63de26437b36a1c4028ce27339679ce0a817aaec8647f3fe1683d205d56cc3e2cc333d9091733c1ba49a42a6176308e7e3ccd1dd9bfb020f5ed4505b75c603b7ea83337692ed3c7de3d3ee15d4582e8e2357662c313ac3bbd2855a4e4bfc3e9f0db7dbb3855c1333fc1baa206cbb5d5a152b31ece089dfaded272e26cd2e20138276e7a2433a852581096aab61f4d9447ef50861f1c13cd863332e5055dbc5a136a7e60f0ab1fd1620ce5ef5571aa7e9064ef69dc74752fe3581aa2fc36b2884bbe5c10e4df1c4e0f2848b8a5a38768857ac1a19fea363809424ac0ab94f41dc542c1529f8ce5fb24d423a41cea688b62eeb03fa532fa30385df60275b1d10c32f15249d09648efb0ba26052712275dd135ba43452f682ee31aa7b37df259b9065da4b670f1f9f44759085dc56a9d72ac833e42402e8e592ff6ad103df6814c33e3bc98d774cfe54c401aa33ce9529074b37a3dbe3fcc01d8aed3e605c7bbbf651c9eae1e02802225b1413cc4b4b0d6d60dcb91ddbd9916cdb3a670dfde64c0cac75ba1a475fb52c9cfc0d795d21bcb27b29d79acd22e8588b7be56083e92dc45616007b20f7f5cbec44f9f0dca6ab9f04a1a0b79322d115f0950d1f3c1ec0a5c37e71f922333bfbb7e550be1bb7ff183a6866ee84c5a71c7aabda015d7837426d3bc7da7729db429c458ea1d70120deb0246dcb3ca08af4a6545859864d5a9fd1ef302446f9503a8f3392913b9a1b0864c05ed9f611cb9ded254502019fdcfa5b38cdc6c4678c7ac81dbc7ad67bf6b41db06745d39cf481761cd53b10d667752775f9c82afeed6df59adebba01775ad815e80fc15552e189aa73eb0a87728eae547df19d4ace1973e0dc690b54905fa39b912ecea02bd2c2ab2d36174bcf099cd9131538b704cbe748d94d6402c44cefc1b1d4ac189d049d2a39ab1b99c45c701fa15c29b56e9d946a809f2aab5e6168abe36262137502939757f6e282ee63c67393f807e6ec1b9c59d4085a1f29656449d473de4f63170885fb95144882522588c34ce35229786730d77247d1d874c3a53904181148afd6b3ed1435f1ac6f3bd230beb6fd9215a9f4189852410d3b47788e851e895413d004aaf61009936749c85254373e0f9eacc794aaa001895a54764db609a23cdcdae51fdceb617a27bd9d5f67984357a32ffb03665d56de3089a34fa5b84b97cbd39532c3befbc373d25dfc1001c94d5a8d69cbb734d17ba95b2a02ea6beb7256d182e0424500490166a045ac57e36126a2d412e65a8f44d69344616e3d20a81ec2dbc7331f29aa9052d4d4e6d408658111387b925474dbf14dd7c031ce683b4a4f98740679cf2aa03d26d8767c8c1244e8450b91458fb20c15e472c1c38974a3ae6ecdcc0cb0c175e1a8dce387ffbb27210b6ac31b6eb672c5170801fdd568db50ed8d796b375f6d2b91b01bf678c50e16d9c12c84da7936c290d4f77b7dc8931cc2c1ea89eb1d5f5a022130798f54cbb697f78daf33342dfad9f7e6e3f8f3717cbee2bb43c668a4f9c2cb2c1a9eabf3c2198a2a2f5e6de164f011cb440c109dea87dd65b45ef30971694406bb31c940e673ab78f6dd457fe3601b00f5d80f0da840897cb0d0e98218d9ddb31c07def7b16493d036d33f2bca7bc7670ea5ba527679278b7f1ae6af9ab9232098ff05e504946f9ddaa4453f7cf0e1e8c8129ffeadf4f76b4fc7fe67faa552962aac026e21d429975262384285353c515bac851526e3c18300330ee519f980ea474d792ad385942c4d5749078bd49f6e1430a5a1b10a44cb7f12143cca5cf4bee62554e80ab310b93d4770ee025cf3c3f1452515c3b9a585a9843fcb0baf911a8cf6480d4718f3780e385f9770fb49b5d495ca7bed41d43b659db56e0512edf01384b8a13ce25d182e7b3143ec3fe6079c3e4493ca2db5092a08c81a463cdc6fb0979144fbfa533e69378e9b33ae354468ad132c67c07846eaf7b206cd9e9b38e39694ba0da0717778779d317d23febcfbb54578194051e8e51b850bb75df4e094d7729d0bcafe28692c5184f94e0ef8310f4abd531a6be59252296b1d5acf7bc922efb2838abd6e99d8c0755144fd8dcefb47dc69160d74d6da608687753357e04fbd5753fbc0bc928621c8a4a63610f49a214c62b9c0135b7db00fd2668aa8dd20351f081b8354e4a7387961edf98a15f69644658fa0c78c2683f53dd67a07eeed9067716c45f78bed60e093147f6b35f8bd0e127fc5830da2aefcb50f249b29f08997e72e9d74b28b41ed574d95eefadf76438247e3b20c0af7c90623cd260e683f2d8041ec1e63a851a1876d75bdecce7800648bd9cf8b356870fc0b593a92d07777fa790666125bbf3b5a8de58ac01e07460c0438e46efb065c5b7ff2d19e52f4922780fb0f7342fd6238d8e3b868ec1cabb074f1e033e3cf644998b9be51d7252a6c82f8b92cd816ffae9d3eae468ef00648b06dc379ec0dc3952583a25246dfb350fa8e01a83c47662bdeb39b7f3a191561fc6e05310d88e7bb690bfe5ea1d65af705c3d8fa4a3c52d49328a1b40ad1f8108c36e64994c4d408a9debbdf38d57c724fcf7bea4c64313db982a5ca4364d16cc47041c2b0ddc66e742721b7cf9eb967440837f98cfa73d2aa8fae55ba59828a4561593484e4e4b2a5bb329161e6d7ec6c5439dc6270fa08637605859ca0a26d662d29a5cf38fc19cf2d376453e99419aad149ee5b686a70e37e0f15e6a4faf886e377b693be91fab4261d9936d9cb183b43f52956000f1fcf034a96b92cd0e44c8e5b82111562a02e82d7a04b7ff7d7574342ac50023f01b1a25f751be2cf4e666244c61b0ead19736b5df47df3c8df5feb142d7c3f94864a533c73f27187bad173ed4412f42f8d0e9e31be044d0003d393f049aadb8f0620973e72438d7966c4341f153965ac014cb0d9a7848e740613179299637b413198de90e322e5243cef9ab16f27ef4a57c469ba1a14a76d881fb869773c99b00b5180104ff45cea10d2af35d814ca1a06449fc974c43ee616055121b979425a8414eb7c98b23af4c557ff522a13d0d50a130da755999cbbfd2e82e4afa580a9fce220d54fb475f3619fcda97850da07bc6e78bd9741f501ac83d1909c208513d6b6421ccc84ff7bcb7f2921e043ed98fcd9c909c694fcf9a48f22e7ced376c3af31617011dac1b8c39de608481cd03d9de6b63f6a1f182d090e26b37ad56e007bab677cb9e6734892d6b6299c4641118cd27bf92a084023886bbe9536156ed6b6534f4f8115b12cbbbd9689172225ebebbac31db11235895116f2c331b7ea26a587cccb990f1b5cdd592af5063cc2dd098ad92512f317893ed7738787f992f82667edc3569788d749463c61b9cbe81214e8371eb639685fc4b164391bb195fa7d6dad9972970c8ebae2f5237f612b9e9295cb5ba89a11d759fce136b8661c20a4214eebab2fb78d1a074e703b762553fd057524bec5906b15528757d835a8f2e9ad272cb233bbf0d55d33f8daaf16811c69ed028b23b0531ca3668c2645b20d7593c46b952a19cf841dfb22a8c5311dba66defa8e6bcb63846978d96c3bf5f8fe3b2f45369d73f922e1076ca310817e08c947de2d9654131a18dccfcc8a6fdaf1492b7a3de2fc1d08fb8bd64766496f36d0213e8f4653888b80596ff80bfd12310b70737660714eb430df1871b30ae4aa363060d159fde6edca290f01ac90b5bb2ee0670e30de3cb3ac37ae54d0988f6a168f69a114aefd1571f8caa33bbb9332d000c8c7a381d62da4a37ec919721e153f085f0a49acf77e40b2055694c47e7f8d9093499bdeb85286c7e63f3e35ea278b017088f998ae3a24fa2911835fe725e6373361c70fd7d279e4f9f2a8d9a49ece6f8c22f71f14721bfaf3552e8e3acfa51fed6ce32333a45855dd091758d655118e94a4913d981c0e493680af0ce70f8ed5f787ee199606900292143c8c834859f492b692d4e140ca794677fc54f0e40efe432e9c85fcdf3023f37d95a821a06f587a41e5311041ddf3f6576fd714057835333f40ced8e42ce3d1e723b48f757bba9b526e1f49d6151d2e15155a55f221c8871a93cd23162c86d09a0c50683bbb9624f6d3ed0ebb5e1cf6ed430f1a5cf79643cc3d3296d61ee045491a7c86062b444bf976561957e49c7e6a2174738d3368b07e887f2723165c8c4f8a994366bded7ad281a7596578a4005cb6d4583a1cf8ca79b4c293b36cba91067ded038e6a4149ee0af5d147026ebb2555a852f98ffcf47ca0590a022d43203adac76fda58eb5a0bcf0bcd3501651f3462f1dc53d4469154394d291a2d63dbe25d218f96b59113a8b096066bc9f78201f5b5d7f39cd2d31114f7cb9f0052bb8e0b75cf9f86f3888453d5ca1b1b7436510f42f4220f30ada69c1afdaedbfbc9545d8fbf866c8f3617eecbd26cc790889fa3a53de33232ae71d498c1cdbe41ed574466a605ba53fd77c21b6557d3248985be8f119e8e9342aa43043ad344afb1e71f97ca8378ec32a5e96210c1746f3b4272877c3ac217ca3d5d13d2e1338d205a08cf536b5da96a7127f11bc70774e0fa2edd33e8af22ecafbb17b2c99b3c8819c1810bda076639a78bd4b842d449d050cbc321c8f1a06129ed5f91809dbe2b352ef10b73191609387fb919f38efbd345c6a7124e3b61fac2df51390e4c5dabd7cabf23e0ca3eb395cd7dafc13f2a1d5d3d8133ed82e56dea3989fd50586ba2084d9a569979a5d3d061a98a40058242b892888b9b1f8f5abf0912d31584c07f46757e7adefa473f133b47ccd8d6ac614eee7d3f1e73af4a3d348bd964cc14858419152b5c78a346002047618e2b0d11d276e76bc0e594f6468ec6d7d2ecf3664a8886ddb9a67381cf51e402a9fa6a62d272ba9aa1e3281e9e5d0412092e57f6ee5075b85c466aff6215b9cacc3bdeb1384f6f2c85ed46267eb54bdb251885e9f740d98e0b521b03f1128f62817d51d9d28f5f14168efecfad275ec72233766beb01d5889ec18c746ab69ad9b6f0ac0afc1430d39c2529b8383f42b033eb3e7d094673c1529fcfa75e58065f6cd0b658b3cab3b6fb33d99f3dc72e4c25eeed921f7629e92da15478111ed059d972c83a3dbcc82a48a28d0643a3abbb57583b6e2aa26edad7732bc5fc8eb0bd5a73f463fb8473a31005859cf1587dabef7568abcf932d40494a95de210d9f1699a13285a828659762345f7ae8230a2bfcc8116796bfbca9071e89b84b19589cc5ee3fbee9f58cd819bc54d585b761d54a7fb9647dd71803f4878d8a1ee57a6270ef1ae654c794b4024cf5803f76305e46e4aa914ced635716f3f3d94e92a1be8d55ac02c8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
