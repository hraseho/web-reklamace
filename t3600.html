<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5cada8ed2c0708139391a72c2bdc5538862d5a1c18b9eac55932a3976f471e2082221a8ba98690cd4fe3ed0bbdbf436dd50db84bf7024d701933eb14e0cbd23d34ee65368ca09f3a9e2d77a564b635fb1376673b5a4924beef37f3717eb6448b7f9e96fd098e481ccd1f4a371c710a7b7a12187d7d906db1bb860ec366d121b10542d9f0f875d8f54901782845b925406399bbc511287aa98948e34c11ea83133d69dba4f951c78a69d720d7aad957124245b05a252ada91dc44a0fe7182c72a813c72527e4dbdb735a9174c8830e98e2cba477fa36b0e63507c7581197ec127cc603e89507d4bf77dcb97954057f6d2acbf0bdfa343ff972221c18bda822a537d9a0b9b046a727ce6a2a24fc795c952b56f323e0ac5289e5fe1024052a696cb6c8378e1c51783ede4b5d4e14a594101d1da80939a4ebfa7a812d4983b7330618de00c90b42888a26c048d34fa8c0533ec09e0b60872c548037165aa76b5a0d28216cd07bc3a496c8724848699c05b3a67f5975309f9b0648969527d48948455fbf5b9f048fa3b7764da79fbe048b85f88fa7dde83743ce4f350b69d14362f66906db497e1bac36283dff42fc9d140089e4a0150d6d9355a38ca7bdcebd3f9a6390f425cf6d2477b08584d5b3df4a7e1fb3f538e8801bbecec23d291f06008a4907322c0981ff5a9f8b91282b19bf37b9ac4e392cc0fd5c3c1f601fd142238431b8690ac925d0d0715a0beccc2a405714b801215d09d467071d7a7552647313f23d09303adf7373cce97ee675d15b2eeb2ef1d3d31555bc376c15c6013f909e935460c0e428fd9323d71216b1da0ebd73817fce9ea07290389555de336b8bd79a0acbd18fb59745e7c166c6314f479d25fd3a7354edeb2d1f3ea475df74deabd09941c69a1fe227806a7a10959ba5d489327d4decec16b52a4100eff30b86e76b9e98f8b8cc9f62914b457af8b58ebbbd9f82a4ed0e5f0e9c8f40b7e792030999c93a4f1336b2d452ddbe8048550d58f3cb72010fc81d69bc58110ede46fcb4518202fa7796c6873dfe39bef65f20f250aaf6dd75413bd212f6b19688cdd3b2aff6071f872ac0ffba3a13ba25b117296e536654a9e20192ecdebbfd64f1486703932e99201fc4703d92d35ae219fdb3d07400ccc511be5579a6f49fb9b71a410f04accef360869ba596093f51f9eb13034fa736d9975193a7bf9c5041d4cd6d1aaa70153439f9737084e3365b2a9c02496abb8dc61b9924383ec8ba446ba642172c210d5e483f106f9b1fcee408a90faaeef6bf5cd7efd28b2fdc65b9a065cb455c3d966a0cb20a832e34ad9c35c13d0951cfe31b2e2005907f118094f78b390c0856e976485a6b11a5716fd4b540d5c6f9950ed77088a55c6aeb152129846d58a57ed1aa7c2b26291e7a88feafa0c2692f9a022f9d83d8af1dbc1dbfd32f2b0149b5467fff68032220061ce0361c96f15ac15a23a7d9b9c23e2fb4ffdac35a7b3ca3680f14461d934eb8a29e39702590db0db638388cdf5e80516ab855184f8cb791a115818a4196e4d9649ad0981bdde9a3333d33fb45f0c7e2df4ea86f529855421bdf44a5a28306387ec934f3eb362f0337c27e0c45cef7a0d381ec418f94d10cf92adfd61ed7738ead70a2297ca927ec17844c5e1a52e96bad5820237acae767b8e8763e14e57660d3760b9a5e8e8d9cd8f482ef7018a1e9bac6177aa4c6e40e6f8c15eb7b89c9916dc48ec4cc954bc02e1bbd29cca2b4c91125101384831992890a1cd25ebb4c5a3bcf7d3224c3cb1b876ef09f9645d27e754cc03347607c994ded85feb89d3eb5ccdd912ce5c87f91c47fe74b126cb65b303dff894fdfd439f8a39df07b38868305a4944053acbb28484e37060e74fc74ae4832f5665f6e2af524e6d1df20bc2e4f16b7aae4a71ec4999d484edd1472522ba0dd6857acfc1fc81812f22977db717b7468ae8d481755d2577e1a61c674e91ac88073c07e94026bf3188067708db332987aac6ac115b09c1c71542568f517f99c37c295a7e482c80263f768241a4bf4fd0d067a7ad2ea33f80359eb13fbab39666fd522d2ef2d8233c9915786195a704d3c3b2279380750333e7d60f13a13330e08228c1a778a331a3e69ac72f19ed0c4d3105a4cae698051920da88e06928fe70691a64052c2e29c1e30cc9a261877c5a107f053fdcb7e9a600858446477b9183ca3292e2e7e54ab15ade0f9cffd977d302e48ee632bc1c328e8c89a3d85bd72bbdcc6ed31967a9c808e6ccc7a6a9284c0c1bd0a8dc13f2b0280c82c352effdc2643df5bc2cdbccf50dcd11a43a7630df226ed00d4eed2781274d771a4db5fdfc6c33804d325429f58f0e18fc034b8bb39aa2e302be434cbf8afc659a1c13b075289feaf2d7f665a980504eea4d910636f50d4856d484d5da30dd5e36c1e9107415be056e65e01bd160c9773bf888f546a8ab7f64844fd0d0a3beb3ef8d8fce948a8108bd58a8fe11e49d5ba5ad46d155ad1410515f83e6c0109a11049a3c400703a1c46469821ed5d9ffc6640debaf11519b36ab0c476a9f815a12acbfab722706064442f97745e81c6bd06b2137ad66551c7f2ac1595eb32cf06bdafa10e0c0402a93c41309915c9c13067132180635c6c35b7ce1be2bd94671d5e46ed2ac3227b1326ae54c922b4f8f37539bf095887f4a38a3c6f0176c9a4b8ea6e694d9aa36c8bcd9869fc19e5091b27f57792fc3d77c95489407eb3bdf5fa0d967ab3c7de4831ca1d8af863aff629122a2305bf72c3b7b255ef007ca6e698bc4b39320d0f353a7764fa05d6e4bb4282d2a6329728c980e36c0540481300449414ef28bcaaf3c92fa8c439886b018b43dc78dd0a2503b402d85f90d08442c37f7abeec957d9122fae8cd9b05d46af6b77078bc6b04263ecfac51db20af6189ec59a3539a7eb5350563226527d23c193807776e7c7f2860a67a69680f00638273f7c380e85dd158b8b91c214346c37022456a3e27a944f8d282f24ee0d61971cb3709aa2c0c5dd4274a966dc43da45789158a84a019b2795124fbfc86de01181dab5596c25eb0f86c569f997623ec9a1ae86baee7271683408286ae56b7f1b0e93b60ed49bb8d99edcdde162f8eb9b537a4a133bfc0849c49b84009add5aea1da435bacaaac144ab0bb502d077707c863b94113b351cae436be0cac929e3a1289a4bfa52bcd09628b64720db4d54ed46441c369c8ea2d67332b951ecdcb53c07cb9a557c646871340fb585159e49d80e05a46ae1974f7d6d1edf4c6087fedc4069c18bb029e424d54b92f64008933311a052e4ed8709c373ccfcffeda1d74f95f961097106880074545485ee2822d53614b9c0e5d9cc5e5beee4ca28019782b0d063b0fdd5c59ecbe65f579bf40cee3187217462e1fd462c2b51d79866107a14126541cc93086b80c7eef3f41972d643ed55e5f316a9b4dd9136b0a77b795e4fbc24473bc3caec9e26e072a5b806d34aae4ca2cba0c337bdd4887e573f2557e74ac670b0414414eca47d17dca58740f2cd0f68a19e20b98611f89fbc7773d7d2d1c99dc3138e1de81dcbf97c5fbb518ee7f2fb1c3947cd7b6c0bd4b664f198f1376d9dc85d2cd3581248b4f61cf4fdb7e4cf0f57d4e1aefdcca591946bef9cbf966cb0ac337c475329e4d173224e7cb1e015f523413827160350366d86a8b69652d5753324c172f8e38ea1233e8b9295c3c21421e3ce20f71a817ca7b5add5a66d7b95946b185590495fff0173dd47277f5ee4a594512e424026eea9fad79b5fb4c005b097b7da2c991ca64a9ef38e15ad95fc9983e83269656593415871e5c8ebaa1d2b085d4b8f85c1e7d01bb311318d4ac9481ccc5ceab9aefcac3be0a260068fe90013b75b6867284084e1f2fac83a557080f5c0aebafac736dd0d5775abcf29b5d8b425265a1cabc26d37d68a0990e3d6727785e22102a522627c7d7cf69533cc7f8f9189d487be4d486e2d781b656474ceffd760141b9bc38d8ce7e1671b5c7358114181c8565bd129fb05e43837153679ed5d45887cf71a27167f292c9b8770911920abbca14d23c89fdf6b71e610c5fc7ca6b49b1774758363443c1bb3d2d242a75d4265c9d4e3ca684c11dfa2e755b087fa2218aabedcff0705fcf65d881caedf38a54f624418b7976eba8f84c0aee9b569cdfb945adf667abd8ed2d1663394e5cf57591d88b001d82bef2dfbf78fc7e2df9f50f73febfd4a2fe2aeab8a809cf984d27fddb7bffd219b2bcf7c22b8d94a479cd93449e7f310e9be4523594b78a3ef602a8d88d76707d1eeda6765468cd832165054a0a264593422289ae5eef701388df7d684508318b3f2b884eaa1e8d97b0de099fa75b5bed406db38ff7d26ea65a474e1b48eae24d732e4293facec539976d85a3b5db80779b889a5c08676227799e53d6546eaf4729879c5fccfc873792c0f9f3147534ee53d4bb9ebe8b94d70b48fd9d0d57dca6bd4882914f1950dcc310d93e8ed5bd15668d5ba6dd4f396985c241cfd2ba7ca9f584f5dc52e477513c869737730c533d8af5caa3019c4e6bc3d4c4de58f4dfde924b270d12a74b42d11e058a51fc97157119c685fd6ff0693cbd77f850212b280ed389d7a346a6741aae83cb58a641077dd1d3a15a3aed3a2898c826b5e8c7aa84840b17adc59464f52c674fdc8f981960ec832697d8da1da67dd08618a16577250f43e642c9d857dbb4de8e432a8ac2c8a25e2e64ff453302fe42c2d90fb1c55dd0c09bc0b3ed807ecfc1043d9f4407fac273c6ff66070f2feaba3433995b199bac70801eac544f061f6b0205ffeb3e3bb5ab97acc05b45fa26b1dbe66dab88aafd3b09c907fb03c5c9d57c9b95365426df955baad3f945dc257d845958fab96ce2215ac1625e729cbfafece2a94a6105a266250a4ea1e9120a2f93749cf90f4fc84b06f5013174e88a06f108b6d6469621d9fe017b9ca5db0abcc11396c5caf549bd1692d3c53d5fd7a67ec0e1a06395ed46065815d77bf5a75e61eae574c443fc75853461beb28589fac301deb435e92d363aaeec50161c447b506caf623af3bf545744f1b9560d2517d0c242fdae38632aae7d4f490d892d43357bcad7f5200cb3966f023927fcd2d0d8aabb9e7ed3e282972221324f19860c9ec5e3e1d825505ee254065b05e71ab82b6fe2165fde3c6bfa3c8b1fabf4ef74be37062e21a0017da604d331b60c95bb863e75e13ebb10d444cdf124e72f48c850f69904870d98314eb3fa21fb8d2688fbbe69eceecb01b0e8f9ebeb558bd81baf09a565f73b9860cbdd313b19223b2700f72fde6b1a374680f6830507a485ed2af3cc5824e40eada53aa93740b9c22606366b4273c9caa161856e79954833d35c3a8bfc77555821e1b9a2fd61d7aeb526cd58ec7277dc4fda6f09dbc0dc1981e77e4fc6a27a7a55adaf722896a2d7e66b768014b5d2f9e8a2a48c54d827dd10d7b0a771cd23433d56ab2e47c6a11229096ff6de12f93fb8d43741909539df3c8eb9a893c1d533fcac468ace66897ae8733178c9c47fc45c89daa126eadfe32ff712f229b95500dc6996193b7d7e288dbed1f17bfd0215ba8027a6249b5f5b6fdc6d2bba791db7e21235d01743bc12527a9ddb7237fbde273022a40ceb48ed4646a96015a53321f457e0d4e098b6fb623d94ab28761dafe4b07b478e271d3eba9b0c800762bd563732c466b8be035bc6a3152e32bb448569068f91664f91bc2751d7454d09dc612d451115804f9ed882058d9b8d368e280dd01d37f47fdb6e3126c856cf4806cc1e0c418196efef087dd781fad16403d2ee601c73fbd2c607c436059e6dd336dc3ed380436e06be188eb0f0c7b04080cabe0327b8d8ae403825d9a23f443c5d16c3d4183df8f5bfe1c756f3a5abdcfb089f0a9c02e8e7f26e89227b4be5b78fbd92c518ad7410edf84927b6e8bfa594b2c935996d173239295177227825676e55ede3dea263dfc39812f29dd572db7cb6eef69845b352123dd12b8b35030f6b72b9d0e7df83b3c47487adfacd3f80ef532921febc5466d3373eabade162b13049fa7978ec307bd8439cf33c9f58388aad12d26a61ac0c7edc525b85737240262ba8a8809cbf54583d7d9107bba0b3670df96132efac53d396cc81d584a8c0843f8406eee99ad2799a52ed290ae107c183268225b0cc048e62cdf911c3240c58b5acc447fa0da29f759ce905b4a00b1312e17b83ab4c9c4b1d4279132180a547c24427dd4a3260cfe2c72d9f802c30d86ba189d0102b31c0922a7203049aac85d6f816bfb2cb72da5a44e0f3063aea511789a036d24fa5c00d480addfe1e3dae5b8e3a4c042d7df63042e83b5b9fe30355f15b67cdb9fe5cb528670a007eb3fa172d8a03bcf7899aa42d185b4f99b50e8a59c4aa9932cd07da2d6ab40e5d7808991eb96880d5e78a773d86e3b762405191165e4b1daa222ef8463d5f3987264320440712737e3ccabd6adae929eab2784bd445f2cdc11ed5150d4c0fe7259dd7ed4838be5cf2412ea2edfb75230956112be986ea420dd2f70fd67a25e70b5feff4a9d1a804cadfba974eb215a38ea5046e2f095f64b2d5be85ce46520798db1298a82c750cf3c9635fa1c76eea753d2fe77c0a48f4849313a9eb7096c834eae08562d522815e1369f6665f8320a3e0c056e9a5624b4ff7fbbcd33504bb4a11986b3531785cce24af2c453b658e67ebb4f57a787be9b196f03d873da16792f05d79e4d90afcdb311714c69dbdcace9a647d8fa0102bbe6586f8f4adca227e8db7e71a981c70319d3ccc0bb3155b7b16ff482217a793f1bbc07c2655da8ccc28cfee8b93df80882a9f8ce7f46002dca4a87abe6afb2f239e7641c1e6567c155c761a2227d6564d920fc16b777990a96a3e7be39e61128f819e87bbfe42c56185c6cd7109212df0b1c23d15b8f89f6222c8ed04399919cc17553428c3225759b69f5a952d2eb159fa3b3bdc532fb24aa62be6b384dbf7f94ccfbac49b69ebc6a601d0bfd40d48401c0dee46484f1172fb0f74c8141060b8d3cf597dff5de8b9f614e7e9c28ee6de65e8b255466a8f0bc425d1703c47c9937e1536397227985414871ea46944c3f82cfa214ae27f998ebbcee1bf323be1fcc32749a82f366c5cc077bf5e171eb8f03536c6665383c81fb73368d46eb6965d016740d3acb5332eeb4d342340273f0687a8f45f8849f05aed2ca8d2d5907f4586c81c7a62ae705971084ab3ba963f8d5dd273897286188c0f6f70a49db5e651565762395329a384db1476dfba3fc80a04ac3bab3441e870446c2cbe0250db661f3f5abcaa7f4356851eacce5eb86d1c1bbb6e9fb9a34bf5b7581897ecbf27296315a90824f0a9a289b397ef28ff801010989ac7feb755c66f0335182c89ddbe4464d724f36692ee81b78ad88f56483a21a886d6bf4f9fd0e085a8d4d6f85b76ecc8a4dee7dd2e5f223996a9a16129a83234610df3aaf22092dd0e23780be92e38c6dc2b5ff67a06bb1d2787f04876be486c999015debd6ae894350e2aecb8797a9375ff5cfe5594eba417322917113b75fb7f088a4042da61a618fee9cdd4d39fd9f6517da23fc8231b5c9365143148a510f3baff6805b63dc17a150fae396ba225f2ad008207009825b9c369503244af4290d1da8aaf96f1ac50347ffbd86a08d64f1ca0711885a1d26a286046d2d4e01302a6e2a1d01cdcf0192132c62703516eab14aad5f4a08d8ca838240fb009ec0c6eb18d649a01031fe90824850ccfc2a8e37f6dae3f3fd1ed9615b0e925a933c10cf37585917b801d8a6521c23504d74e53669c96a17f050c3ab080efb39a7a3504fcd84fe93607af4ee7c2cf15412408828b770ccb540eabde32caf88e13686c676222eb6fbe8ff665bc111068b5c41d4687a7250b6e6c08f275e7d6969b27d946c8e2381545fd6af6451dacac606f7f375ff1bf3a988f8fcbb3119d5df500560a674703df312d3a5741b47fbc8757bc8086f3e1febf94634ea5c811833df956367602f1a5f2c352a2c029b6b08c834e6b7eec491e6ddea787c9279da6b31615d6a864fe47b39219ecb5ca94d9ce6f2c5ac5f92200ae3a1c79a2e5ef882f57ceeb94ca72c5b03bb72ba3a0047897f2ca83745372a64ee10a3832fb0fa9780dc3fe460d7e69e972873b9b8b50e062352aa7b5977701014c6e8e92276a40535122fc66aaac72d7ce3e68a816cf8f778061518a6552de2552aa4814dd4d1b91f7339a33c3ddbd573ea0cbb70b9ecfaff83edf968f8ff705d16b7df13c8444f1e2f7093afaedb6a0ac06e4cf82831e156403dec3584d772fe72c1cad88761d18c190713e5129516faa3e2723a1b7d9e151a8da21d2a78fae48b22f807e2a8d4849dd9e6760c44b7741d6341b739deb1ccf9c60d2d609b095b1cec542775a7a8116a13de76eac31652585443f95e18eb605cecc1b0d53fac4a05651d306b784771231fce9406931a2c44331b18d26db6cfbb78e74776e12bd57fa019e9e0233a74324d0424c2a62d62a235dc385b4b192366a99fbdceaf02251794c324c6f5f8ee3f7fe415cef34614e253af55c07d7eb6942578e063d81126056aab39850fb07ce5b5c359e69918dd338cda5b60c784360f5630b0505228c9b7be195586ca5aa74ac02840ee78a34d6be71449f22648e3a5bf1a105f204bb377c08cd21ea5acef0e94ce0055162e327b96d42e2bfbf6120a5b1bbaa82401c424fd2b8aaee2c0fed5e9f4e0143fdd963f56a9a4d7b315ec738c4329e06ae18df2461f11400dc5bafe286397212803193adc5b1efe7ffb8d4f9085370e92ee5f3ff918c3307712fb99a74d050a00d365517971f297a5b17f5f90be190314fbcfee8a8717edead249a60a0f4ccbd84008599690ace374deeada81f7d8cb6714ccc14e5a0867d41540a541466c5ec8c2f3ee40f93c8384dc8f69f4a96ebc3b4c1a183af6401774d8cdd7e51f2ad178871973ac974384216109544a380043003250a901ab0dee97754606e09a11df6bbc9123363b6171aa6ef9a1da014902a2b1aa3a982c97771133de5e7689473574229bedb8268acb27b5f12456b1acde67a9a6ffc98abdae719bee7b07a942af11fac0e74c5dda1e029d22c40b1f2d596d932f4f4d88fd83dea0e6344537df27c07fa86f5dc1ba6d35dcaf3966b12dbe45ebdb103f6223182323fd2bc083fd319a7512b363489f432bd86d230f1fecfcdeea8fcc55c5f1746e38eb3bf7a2cc2501dc1f3699af76810a3bda781f72dabf619ece54c53435e5268f233333a08b8528ec9bb537931255034d380d57997dfb38a7b23cbb62f3deca0423f1c879ec53785dddbda5d7fb25dad9f4246afba3aa5edf2e867fe4791ab559bb9db00aab3ec8332eaa37e1c0d96d4c08c26d476addfbcf29a352226a7ff73363bd9317b52b3238d3ad4725cef9f9f9d7a260986428e214fc3757b50e583a7e4853965fc1830c46bbae9f99c445e9d92c141cc9b76fb1b375721f1254b99feeae557e7adfa71c6b84d3039437e5ebc25dce99891dff7374a76dee7adcd33e36bca7194b0d8d3a259f8e0efa5e7592b000aa596c3c456fe5b75e2f72f59043826260bb982dedf64b56086465ebe4720cf67ca3a686c9a36a4080d9b5ca0bcab7cfff251bfbf1cb925fa988e90b7c145780c150030cf4bda86e639d9cb8a05b63bc7e7207d4f36e8c1687db9d2416c635e17f5c0df674b44b40a48f706ff6e7b1be6d6f61a6bf716f8904ccaf4b837b11c1eb293bbb52ff2691bd7aa10b03d37a8a3f21170778db00a43e81bc5890e84d7ae35ca7a3a1ba62c74a28ed8af6730800d32e6420a65afce2c8f992281859f86f3a5e90697fa73c6b9f577f7cac909bb6189187235c6a10cafa63be2169c7f95fbefcc95c166cbfea85bd60ae761d99433eea863051a40b880e9798d5b3da20b0435462b9b19d45d4268afb335e98905cba1f8ce49edc9eddf8a02ae284c48ca67ab6315fe3c747b26338f1839daeae800e994028947b9cdf84c299ec4ba0e06077ff62d3dbd683ca72dce97db401341340b23bf874652207d9ebe4dd982d3735b88a9ff86b707594331d24b84dfcf2d9569b35e29577597beb3c5b7caa63d4c11430ecd6e0ab0b7d8734b61c227f596fa588fa674e5da5900eb4da8203a929309b97fe9a6d043461ce07530f64505df76c8d18a5ea89a4d1c25937542726a722117fd628499692b45f2dd8f7b59c857f3ec068f2b6798370a8d248273543c50479c2e22102e6cfbf6a54abc87d2a2a05b0469f8063880eb7406ead6aeb4b0eb3c45db5073e135a7588480766f0f8242ec3784b9df96923c25b6d8c697471fb3f0bdf0c645d286511d079ae870224280c18f740310c7319f552d646ec3777f854ac55f060994e5af663b5ec9733005806f29c583dc95120eddba7cba376bcab5d296ed46fe43d2c4248894be34a0c2b76669923b91a6859e4b4500c643f36f9575f00503af2629928c2fea263b7d40a469538106fbaa676293aa8144024b12b4693f74feb0b39c1fbf8ad3ab641daf0d52b48b9e6ad75a679287a3eb18097b805e613959bb2af28d2dc67ea0ba6cf49db566cfca322956a7642f3af902ace8c574e830adc4e5b7d50116d638e074e88e9a18e6c55a43f43af5c1b7221281237516a3d4e787a0ab2962b544a83adab7f521b5fe6d249545e359bc6f48314b110060096fcb54486aa0271e3f5fb15c8a55f8645beb3215b32715a82a2d135778114d5992a5f729281915efa4571f07c66a45c26bb29663c3bb1b76edaec15dc22cd582481c0cd0b60c58bb0d403340a7a94f1cff9b8fcae9667d6b15caaec8bcccd482b5c2880edc990b7c907da36ee5514c1b0a98beb87b2c7b8dfcc124705261a6439c987d5fdd3f8e970f2cbc8f6498a74216357e826a6e4957105d52ea31beb62bc8dea25a77b1aacadbaa379923450f7574488fe738d6dc64edc53f26cfd0a1133c8b6b6f0da1564a9df3ee9dc1d06095bf3bd91a8405377a78ddbc86dcd31a3d769989eb0812654995249ead17b81d5bf02239daeef90d160e4522cafe1a7aaaa1eef2a4314b88829f5ce2e4b64dd765ed17e884a603827f6f5f9667a9e85183731a70ebf2125c063b48b0c6812c11f84b776e5b4c3ac6e7bc080d3c8ff9643ff8f5217f76ed2e96a9db6262215e7f04d065d193b5e067e59836a6cc88d93d310f70405a59312a393afd2e1f1b247ba3295a89a6ad0e5052027c19307918a86b96312f15b02ea0848980b11ce45b50a85c1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
