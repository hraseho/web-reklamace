<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00cdd3e692a9039a82ecb4c22a4c313b1184bcaed969477f9602bd4f20d8f90860446d08a1178cd3cb903f850d9dfdfd050e5ea9814ef723edbf9b21339f458747c612bce7b15c8ed10ce7b55d42b4c30ec8ca063041848aa7661f75b8f0bd29160db40893410de9e7b373efdca1a1784e9d49b2e3ea34b2afa75ca89085479faf15cb81bf8de37175e01647037d8ce8b604f51df424aeb7f4356e1e90600d8e1d102d3e2c2260ab7e1ee3aca0c2177564399deb23ff609cdc71c1c26704beaa7b819a064156c4e49cb64f03ea8363ddfd906a16d6320df01417d668ff8cc40a4de5b7f07d52e9aaf439dc65e535fa1a77b0bef068975d467e66bbcec584966c6c1f721e2ed520cb2d2ea960d6d14c40f81700ece2d6c7a700f2e8567af42f0a75e8e7b8576c6ce335efd42e8f54545963a6374e2fb4c9425420a63d0f53440e60c2c6887a7e158101ab59f9fc2a81f8ac4816c72bf073c5029bcffbb58b41fb69cf839f02880f7451c5e8d13d1d03dcbeadd889db16e2c1e09bf8e96c15f3d5f75e56f6f5ce588e416437d9abe90cecbd9a035436ff68299ecf8f50a21138820e86ae3326217e66ea3a84f73e2616faebc72f4ef04b3a2237c61c1ab178556a276f06ec863730bdeaf1298dd9178ce5dd0cbfe906a0b1620d0e4e453936e3dc36977292480bb277d9ac3cff3d294222254855b7f7275981b28a9e19a68543d8169afcd1cb3997be789e744578deb9228fad9088c8fa12fbb1a790bd9cea790e3c198b9fe42768486b0469173a4a8904610a48b87f03f71e75f06a1b8002dead28979dc37c89bfeef4576034082efd274ed8d9aae7c13b39e8c59be49691ed43b7b561f824fac5724072bf6478e27cc643d75ed4a9ec31d42d028a063f90cbba7a05aa243b4886fbc7d5f1745f4526b10a9ec3ee3bf10d73aca7a169071631219a9b4f8afe07fa96214103898a276eb03176b0e73396cf5053abe4310a1d0e55ac4e3fd6ee70afb15c94dde3020ff0076de0fe614e073cecdce80d86d48c3310b9e0ad99a49d07a17a47c1ee767f281ee0faee54baaccd3eab56c941c5991304b63898d3d481e4f773cc7c706112d557727288ea597d461e7a0d3db460c97957b963f3357346a98754160b63366e179158938b4981bccc7c0fe5ee0166012fc665b388eaca2084ee26f50e3a89710124f9810b54a8e23cbba224889dfc62c0d368e0e047a1158e889250988c5448cefb0208cde8edb34954e764c0ee05883eadac67ed06110f68fd0cc7dfae5402fd2b31735bbc32bba605e7ff8e600c8a9f4807f38666c9959650bba81272bbc854363ebfa818c1af3a14bda1d08458df16b45426e5c5fc21e330bac036261429a934321e0aa1fa77332a978956b3b4557d24241939e81536a270485e19f9162ec5bf26a23f6e578b8ea933584f38605849622c311b9e7eb90fb851c8a4a36b7cd8c61d20342c8668fe4a9f68960ac6a1e673da681c719eba92bb730d4a88c03afb2837b614004ce2e611d7f1797075c930a09ba8349fb9d7093bb2389a7c12f4a2b03c549e3ba4792a1229171d453052ddf0c1adaa461ee82ff9ac7b66ff61a7902d4f06096f029b31a378e0b5defce0ff98fc92eceeef876f2beb4ae70034b51cebd41bdd096fa3e54a35b496d21dc09ea56f2138a406afc4cbb4b2c37b85b89421878a1ffca4fcb6f90fac9dfe53544c8ef680cadff8df962ea8d263d1ed2765e50b6b2a2398080594c4cb47c592d36d1517e54b9fca31befd546ca5745cc8b97c2d5cb384d35f0907dda971eb7b2f0ce5c79a4064dea33e9c91fdb13d4f362a489895b5cb490488fd4373a0f16ca5c3478cf5484e07fea5f568c2b681394e76d09d14c93421454c06036fa398dd018a8e4f22ba668ace8a1d5e343fe430f83a3d4844db7b6aa046c41a2afc4a3ff87a0496f928658f0887cec787b0289ef89ddbc7ca806d0a46ab0c84f3605ef78e8a05280924976c0fa5198b7edf7466440909237d2413076340fd30f07de573b8c203b3fc014f43495006da11975a7098e8bd898c61bef6b8f4087f9b2e5ce27fd5535071d14d7b9d1182c8dee84e476ce3cf00ea9bccc458c7c64ff98332f6cb647af50c111cafe058d63fb2f4b88cc7e21fb025d5a7906a9288bd7ea621fbc3f909bf1ccf76e7cdb6fb66214be36370f0d3b6f41ec4b6d185730e6d94efe327d432fc0dbe75c601595b01b4f78862ddcc8e31219deaaea96e65a2bf74f9e8794c19cf53604fc1f7eb1249c0175b0c497f4447d57c8647f63788dbd0db0d4e24072c84d5d856315b559f60def8b529124b085ad534629149461acbcc76e25c0b0a6afc3e10872a86b7b8a882415b1c1d081b5ea420614108d7e5c1037714b3cca534178f6e453692a6e6d40d4054c922c6fc22785c68c2cf43ccda067fc3814d2ea939b827bb75d4a43dd127547423e01f41540e46202a82a8f4bc8db0ce06f8500cc574b45d108c9b11e206bc28b7fda5bdcf83f4bb00fa6cc2e7d2ce20fdd61236825bab226bc98e285f64838561510fd6575d227b32ad89cc18055d604b6a8a09e2084ce9c290b9dbe49ea6455d0e6b9959c2770005650e9234b007b813d22e11bbcb56ac4cb30ca4bd402f25f0d364517e58949bce87c1807bbaa753c17d062c2dc004b573352618e703110765f637877cc3214343b10aed6853ed575772b0f9a8dd0e7742f337e504055ed0ba10bd678fcc1d2565a7bfc0da1ad6e4d4d4857620f37a867047ed9164f60ca7c8080bd317d0a2c3ad218dfc6dc18a25e2ff622b8ab133669319ad42555aafb0c7a08f18679aa14d8538a31aeb7fb39bd06669c79783292440cad39a611254a43fb3b254c2532b738edb389ae6f41e4767cdbdb63ed0cf8560259b7f4a04646b8107aab8531f324b08a8184b46704541fa5b8c868919617e67ced24d3d2f37eefb3e626d3511cd4caf81efa079d82bd9c97770839cee6c1c68d7ba05953024e49f1dced96dbf724aa3ad9235a81a4d26f1158c11b6b823d73c912fec3cf4abbd24a3d62970fa5ebb93258f0f6cdbef9582178746693cf5793517a2b42fe469e09c3c7d075762808ba1039c49d03e0657ff7e8d99263af84b29ee7794cca0406290296fe1e5c51340a22e9a62a308108fc3e572418a6c06b2822f036eead0bb83a2ecdb5a0a0e8bf3ad675efa1e8ec49b3200544d9b27542959a0aadd819c3768cd529ff4d2b6c5317031bf72512b9b750341d9b1b6514d68415ae64530c12cc1ea232b15f9f6792631758bf40867e0f13a145824ec09a6dff2f306866fb7be068320b5f308f9a0ae49771ff70dbdd399e3bc428868f3b3fc4fb9abde180dee0ad56c2b50cd630dd74b0c04bff4db164038c45a35b1484ccdb5d6a38e2bf11b63e35350739e25224641f558e7420a6709ba1b4a15fec2497c331bd6e39e56783135eacb42d8b6ad69905c2f060fd1508223115ba7d5a563e9b62d6f99a86c8cbdacc08247bc948420767025d9ab5c8ff091468fcad5ca9772281544bfe23a9ed66f36d8621cd554a86b91b092ed9405e5b2858ad810ddcf5ccd6d49e8556df0c01ede088af57f7adf74af2909a657b7a6424a68b2e9e33567efa962a8d284bb12831f9b1d5d86b9c6c0a83bf7ed8f6f9682541b0b97af34c4187b3d32141c94f549518f1985196230c00d97e4b64dc50824818c57cd6eb4c030641f97b48293ca83a7dd03964bfb0d32724d524a7ee71dc9154cd16b68867c15fdfded74f2be5b2a6b660e38c1f0ee1926b3dfde80db4e344f8a31dac618288ddb27c1c859eec3a95de1e550c6e1af4ad0e2820a4e00e7a2890e4135c75ab83f2caf68c3f0d7977c5f39bee66ffccb08ddcb9b76357fa0991c986fc31fc26d95191330237c683b5aebd55c4d60ce42733ed3647b2e048b8d256b151ae142b302007b462ba0c9810e4b1e10f31194d15eeb74497d5a2fa1a7a43561260d9326e44694101ada8b47cad4749801a9a42197ad1c3e72707a057a6b695a4af32ac4328dcfd27b71371fd1ed6f944a0d086deedc6f6c59f72b1636ed5a923740535eed21af11e7847328f1b07b41ef893d1ea7ef71b874555968e445eabf29d8e2281ea0db23eac0fa7da51587d3fa12d9ac294fde30f011bcd18f1157e67f993c32651af53936d61f9438005faf1b051fe8638e754685cd647bddb4eab343f7d35e33bd468ecb0753ccb8755192ffac038b713bfd917883ced9e0f4b58dbdfa7b5103ef46cb83085c0602a14fe120a3d1bbbd0abda5035a1e1a109666bd49f907660c4c8045206346bef0090de56c534734de0bc28c100de157af9fecc5d3b7f33c6f6d3078e6ddcc4608e478b6375c0b89874e0848e708b6b047e3b536d9dae1c274b04a1ed16ac14b60ae4aacc930295f7f7a5552a1f0d7219c28a45b8020fe9e9d078e661689e70f321cead5f76a5ea083d7f53d07227ae83ccccc1f397d9473615067c698756060fc66d3684c21065120424ec84dd9debdb8f2832917441bdd16f5a296bc67d0fab5eaeaebf7bb9b25512c1b439f4608cd737ec26db77c0840043d8a5dce394ed0749d2b077ff32aebf9813f91b0205f13c4037ecad636fbd7ccf669f62e20fc97d211ad893987fec712c5f6f5a7945ebc120318d42388b4d3b63764d66706b9c97edf7b86acbaea77bf527b730de424600de9bf12c9359c496b2d61d925050bd6765237254c6bbf5f6cd6c15ba170f99a1c393a28d05c01802b06d918d87eb39ee38e3a6e23c84cf100f039c32c7b81c3050a194652b19f51ed942e7db00d470471a4c6de9d96d772bc59f3f054b880619a7297c4cc71770b1af957c1464798f940bbaf96071b1439c49c7d9b8979533d20ddb2915ff0103747bf5ecc0d8385c718423d2cdf82c1c1c48a427e443181e73a31d562bd25e03fd3d056c631376f61fbb89888cec79b45bc100219f1409ee7489948d9f58a5e289eb6fe661094dc737e99c801ce2d779693f5672aff444ed5d45dbf7aa710e28d6aa1f4c4ed8527dd650a8a737767f510f9c549994413843c95057d99b3e511048fe114b50fbafefb327c9cc1fcceaac0041c5b80f6fd417a955f14bdc55c1f38e9916dd2d6ab4f010c36b2e9c031568d4f3dbfe9517701d511f5633b49cb69b7c45e2867db9a3a442eef5dea76bf86706c7d56bf493a9a1c381796783093aac6d56440a4559e09abb8b5979559c5367ddd3df70c83622c68be3f12c44f320a320c27a219a96546659ecf978c9a9ecae440f2902b0bf2ae581036edfaf6daf83256d9f7e1a7c0fca25140eed788c9682b7d390fdd934dc86f7113f950487068a31d0a621838370c97b3555cbf14c20a5655a36d465f771e55c7a218906a26e02958c59ffb219e0628c21850e7463dce33f3978645a4ff75ebc43652a1ec726ebde1dd97c5c41100a8287c3ee036edcdf2f1a7ae47bbe546f6c8a0e563de3f64b93222513b19d2927082897dd7efaca9feca5c9244531d920a5dfb6d01248c07e5f404bf48ab1765a9542544d2059c97c41c0546c59a162334fa76909a995e41bbf2f59e443ef0433ccdcf9fc8010176908e3baf406861022faf2efabf40d07c32e222f88b5bfdfe352b269c3f46afe7435496461c817d432b1070780d8e0a7eca1370681251ced995736e54fa52ff7a82acd0f26482ab5047d564a2c53c6be75929141edfe71494cd357fa29353167c398c42de5c047124f5cd16ef28ad55d5bec44c921e2d05138a1389e85d001a30aaeced36e0fb910e283281c9c04aa274284f781487d121950fbdaef7a7e90f1142a5f48c4c137464e098feeadf705c0f36614ae2df4e2be5ecf75b940c402a8080af7bf104b3c66f694747afd423745812eeb80e235f8a37f01829db7fd44e5ece62125294e8352bf54dfc4bd9a1a537aa32ed8df8be404911a88b2994fd72045b079b8dfffd0ad7936793c4f937f64a3bbc82797ee400d04c5281e255803bea37aaade5d845379cfa2331dccbaa27b296f759871ff328fb163219a527c39452401dafe67a175a0f3c9ee84705988c215e95a19bc84c8dd90e334cdba273e8790f07456709d124fe7fdd778b1c0ba34ab3cac680554bb93dbd314ca025696e1da5087060e1fac3e8017cb80a139afc963d31f3137ffe8d48d631d1b963c9763ff62dbf1bd53608e9aabab44611d58a47ad25275953f8d2d714cf326879ff8d80b48649dbcba670fe26510d45dd1755ff00cc0cc8d18c86bafd53c9b62b07048c38d2ee2758ec683063c701203f8074bc5da93b8819ac7b21d637fd51546bd7915d5fd483a291608fc7f481b277651dd0b3e31c03900095f3d1ad9c6bd1f7f4d637b3a281a7c54947197b229fb7085942f3d162eb7d2ce9bd5462bb56528a7afb17b3e6f4f7fa5ac2ff7e2a8fe653a952e5546cc520d97dff39476de854f1e9ace51164fc5430f75827a1d8ab1391f5bd5037f0c87f4b8484ea76ce5cb704cfa3e9a44ad3b8787559503ceac49c42ea0b7ac044be4e15953f3a487dbeee464a73f5cf7ea72d4c73c3bd7248ca759bfb6a26974c78d5709aacda8bd5dacd01cae1b5a49c371ebaff60e15299676bdf98a035b915b992735fbd20c4e41b2b680fa27c739f2321f00f35a373c9d0a2e17229730f9e96bf5789fa1485915acd28eb7eaaefc4c1faa4636029125894353dfbbcc09dcfb13db28d61e0d1ca41fb39fc0a1e040313fae143bd750397671ccd68903a758e4ad6e131f521a8db249f520667303c37e0f7bbee851ca430896292a271afa6ce0eb7272c0c7819fd07a92aefa95c9c5c6d0b2c45e4c89bb071b3255728d8b743170b08f590871f9c87484db0600f42e31ca1fbc6b613616541a29e1d5df32b35eb66734ec10866cf3c6091ea409fabfa1e87e98f3f7046e26c340605a5da7fde3557bb688458a4e95cff4c51858e155faf1e3504c0e091de237165031a862357e42ca132e3019a8e9d1fedbf0d363984338cf834ce8c8f18acbeb3a9ed95b2ade24c98b23c9053e72f0e043ee2910194023d2e000d73a7125bd542bfee1938fc813cc7369c7f18e8b702d3aafaab96f22837f3ccbae7a132e078b5a0eb6671f353ae0e2f7617a1e13fd2f73739038214bfb707a549003ad71e213042443c135b032bb7a996fae2cfd2b380a7d22de29fdf096e41cff2cafaa9c754494ee4ab770958b68e7e5fec34b7acde240e3ef8f2af350efa0d2e0217036141e3392168d4fd4c3826dcbe6cc03177578d8e7928acf4eddd95a7565eae79a78f1773bc4b2b29ef329abebeafe5aeabf20f65c865efc8a70c14c966bb5c7dd5be941271e2ed9e3863b5727566d1fa432fdb8b09687b17e5f1e3309042c843cb8542d6d0b4f2df8b7a5015fe68a80a3e8864757fc69c0499c355003273da6b080995a77831117f72a269366353c6e7165f23aa08f27a6aff0c2bab8f55599e353ad8cc76c2375e8a140ffb327d610403c7224487c41f8a7ec224b6560f35e104c76d9e7670229884a36a23b34bc6ed23fc2b2d5acfc9fbc644958af77a023a55ff31e43e08f1fe9f2d9bf86473ec021965960a255cfac7fba050ff1321346148ff71de160d9108c5d4558587847064844364e839d1b40f7a581ff6d986aca7cefca2bdd47646483fd4443988d5a1216bc28e5ae223a8a40a7de6cdbf5b812652fdd0363a5ed90800196eb34c11e10c60428d50550ad69c3fdd2fc7524f2426ac2e5e09cc7d2d84fa05ccb631e7a61a9abb0827e371e1a64a7453a3d7375015082d44144e369cf7c1860856ec03990b7c05fba2fa0d9971e4e3c864618e836747711e963f97beae8bb811bcdcd4d5e3978bf60f4fc1887c65351eb8772e2f51fe97c3a8f3423dc1d3c1543d4e26796d85324a33e301ec30b4383ca247f8d833edeea3f3257766e79a89e9a544ced1b55ff18ce4cde073eb2b420c40a357540db0d9ee2076c8053ab04139355888cc60340cde89f70481d8cbc38f531e8f2657ce7670d4764a72afac3798f7320a630a50ba97cbd7439e56e7d4ed3bdf848b8a0eda47dbca28389841a04350fb68625b90bdd887cce3e76937bd76140206aa5e39dcb4f9eae3786290d675a464418d5975681401f153f55bd00be485ce0ddafa3be330e9007c98463358ef5ec999f47b9dfa7eb761282074f54c4880fa05d6a0dd1cef9fade1b2dd62160179618cf031803b1086b95347025f7c16ccc4994e9ea7f92d965e22d876674a2b7b1a43fe3eab0d8a1cd92ecd8151ee0fee8f675ede233bcf9a2b0d3184ea9a1799ee0b7d8e053a877d4146455c766b2ab59d3b81a6ea07c8321e6ca91300efb0996ee945def21992e2fcff9721bea78ba8b37d4e16f57560e2fb0a49b2f011a94762a1785d11524f247a01b84b5fc7f225218ad95c771c6b68669f74222e85965dc3a879dfb6eb8f44ecc0de650085a4130fafe9237057994e2210d07752c1fa58db8d1cefe6e15701fb5f8aee554ab572e86bcb8ec0c3d08f62e2cb3084040abd14b497630f7a77ab104e3f315f1110ad3f8397508b4ae35b24d67661706076aab4eab9bbc74009c61687f42de976c8ac1af14fddc51c50bf9b0c360690b57f7de80dcef1a01b85f0b48ff925c8f8ee9fead9f810206963fca399928f8332d7d6f0f1f8975c653b5a41c65789e9a17d631ed3d7f82f4632f2093ca30eb722ed711df491a0daad7e4a1b08f94bcbae8662d501100e637a01b6450156160dc692f401ea523cceb17807999ca5082a832477490522f0b4c2b0bfa5b8248d3f2b923f77d3b05e4412a3e9bec6e7b8362d8b9b6c4babac17ee5b9dc76c7ae8f37516fa75fc8ae14c3b55c23fb474366059a735b5b4c496dec4db43de426c2b5b62e991285029b6278cdffac3e45e22e88fd273605342799f887f5013f4a95d7cb7b0a0d5b46a5394abf4c98fd8ff2145c719d991e23c647c1ad7d3d91b52b80b23d8ee596d9ec20823745a885d70ef9ea361ad43a821fc53357b5eade614f4cd73b0d60454b0be503efb5d18ce77ab7de5732f638ba6d79bcdeb02f263eae48ab8057c35fd4888b2125b62609410faf69cf37cb32d99552c48372f0759651f2c243de66d06adabefae1688c8558b934805e262d435d25677e65a2a0ea0d263b744430cd88d84bbc4a77367679aa55d5990f8d19d82d92103274ba64ed566173f828cbf8b197eca223f8db09ea05c878afef5c18427bd0d39c6e65c1eb3f0456b4427189c3afd35a60a084775666932c9e4fd34f920cbdc7432d5c67a0199c8e8dd473a06c3950fbeff44d1b771b85753ca97193333dde1243764519fc3a091006c900bfb571af9c484014c7c7f3e0b113a95f7adfbd3e04b46b42f3d285b23c6da2cd7e3cac52435014ebfa8e1456db497731703d2ab86eb88762a0cdb3ae6a698dc7501eca4a76190e918f3f9b32fcfe5e29ca44c198a54f793f28181d590139d9c9885acdbfdbac2beadd5933bba27a668d2e42ac61c386e720d5b287c052ac5202f19092f8063ab195404fac4c64d18403aa8f867c82751a1d243401572a7f40f14f8115f03a2740ee2dcf2ad9cda335730a15d0681cb5e73c1fbbe100d4acab68939df01e0f29c2db66f722a6a1bf22249ba00a6a6bb6e33d07742597813acf29a2af9ca49679c817099239a41b631ba315daed00d2203fc46ebe99b78914429bb01838e229fecf3cbdf01b8ba0afaae5284e0e8d92875a0a1b818715c61bd115b1401f70c40442edf58d27950d28dc0b153e0f78054ff9072da43d4bdd636716cddcd5b886bd31ffabf1c4c0726fbc4288fe9d2b5b8a39b8f0f8664c2fb848a0fa179ceb738c06698c857e6f11f7a3a4f9c7767761b6e21e394b16fc1eb923ceea33603c23cf8a24c3cd711889dd2d8b2f25b5284835e3d39971440cff86f563445d472738f50a1cbac6aeab994f0bdc58f372cbd6494ecd00db1ee74e23cfe1e500fa7f35f6f5835eaaf131e95281f19aff01d4ebf40e5d744099e40bddeb7b37ffaf0334b0b4b82f98ea59575b5fd98de3fbeb274dc6e409b4d343ba5d337e1bdd2de3d72fa07ebfc8eadcb00e1a878c7045ed580","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
