<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"045ea1ce0d8cf682510f72ddb19783ab8d5a7e65e29a5431a5e797fe36419e06ec5caf13c55dc1d9719bb42feabab3a412fa63aeb477fff1aeac093ff4cedc183883e7dc839f31160d663cd61d34e28abb3b810a6889ce5c3b4a4b51dafdebfa095ddc9147dd94ce09e25ffb096fa02b7a2ea8b1f5ca6e5a17a1564def05b929da9a24547bc144318e4351b9458722aa53088b92134747b720b38da6f152923c4e724822a39f411867538e700b431bd2995cad93a257823314d3b945d19d965fb560755e994aef97877d159b199a55a92d3c093b2b1615eb3724af3bb479e0b459284a8ff54c723091fa72128e253589c48b489a422856e83a5d4472ab3e8135d24a90a3645c3abcf4f7d58b23035ef54f7c9de817aae7fd9004363d4ba1e409e264c0f7355da30cb75fb1bec55590e27efaac455056370b0036a6898a6afebc71ea491a4aba5e1d566a4e540447fe434749ef77c1cdec5992b063c463e8c98ddf8b9a11fcf9991d416c13be564af936e4b1376fd08d67ad08558caa2e34f3019b3b09274d5f6b405b0a020d5806c4ca8da210923aae074089569e0c659a366b3322ecdac58da11920a24c522f1df8121a792978aec7899b870a7d229712351f765791fd5b96372fa22bc964e408bf1e9b396790c7f2dbe854b796ab638d7cf745c4c6a10a88762c6daba68b161167f7dbd4f63914e6ec76a3d9473fa0e25ebdec0be19347642f1bbae58cda68ac87f2e0cdbfcaa00eec9a2e4a1e77573660d03f2b7ffa2a6efdf09dce5c2bc1d4cf4c5a992262e630108e2ff922ed5fb880f95a6b9f0e4bf3065454682aa3db7bcf42f572a9e94d8a525dcc31b32c90470a5e6e18f56137d77a3ceb75d4a5072212bd4913ae8d0e431441e329ff8e0177418cc9f235dd9d18e890aa4925588367169839ba0bcab5179228ca5240cfbb85053195d5b5cb54b8c3762fe0c2b85d6a9800bc10b34392ce750d7c7d699b099c5d7eb2efe1f1babe503160a68c9a9d62f65db4766f0f49e59bb859fccf110a510de4bc332e06e4d405d443c49ae5cb62632febdc5069a1c1e248f5b8e96acd504d6f08885b394d940fb86e9d941f2de24ade2f22095e2200caa2a72037d89581261c7b5b04f1f077fbc5adbf2a5cb3331a7a2425c60cc421c42ec3de5bf9667db757198e13ce8ddbb9a94dfd47b59e8ce010c2d6fe8fc4066cd526de1e114db7e5df2170bb1bdac697cc72a3f406f619a2f7e5a573438a39d30ef1c8451c856718b4d6b6178ca2060c6df4fff8af2eb1852564e2af1247072a48b69324edd5a65cda28f65d56c1f6134ca9b562f083e3ca3a1af3483c78cfcdee8c9ce169f46064634abd64f687560d87beef090b7f98983c910673ea0b73c28c1523f6358b9ac4c22991a12b8f78e89aa523db5bbf8b884b16b2465d3d03a03d4d87e340637105f80792f93ba597b8ed86fa4471afee85b7046ee57b5dd06777023ff098c945e46799b3e08a6f7dac9ac0d7aafe6e28b560dab233ed7856c1f2958a737813afdc44c40b73f8f2e6ed69396b946b958c9827777d7801aef3c1c33a841af52f7f87262e793eef234c4f1cbc53b737da5001dcef60de3f16eb3f530bb5f2e9296c4bd5c30a72f06295f14aa0a46708a41c409c3ee8830b4bb58a09c3cf3ae777aafdd6972fc79249ecadd76df704fdcb7b6331b05b0b10b9d75234561e6f71dcf28b0ce42caa1896c58dfb3559c8ee58ce3c30702f309fc2a03740b89766f8fae44b2766f2c61e87b5c95625cb9bb997e3955a7c09ecc4432e1f10f6fe7f27df3f17e8621c0adfec71db7bdaf2ad49a38d5475208bdf55154eb28904efefd4d49451ca567e237d9e3148b7ba1e5db9592d820e928d1e56ebaa28edf544ac95200dc11266ce9cf37badaf7b097f77d0a8a4d65f1de249db35204aefb4ab2f67c044f566494e4de8700e1c6ccb34c2f38f063437c19038990d8c3d6833bb262f37d394513ca3fbe504bbd663710a6fc94a8fbe8fb5c6e1f7e72e98c3fdffa2abe20e418fda2b15a225a1cfcf5eac3ed7ad817d07c19286f7a0d98fc6ad847a801bc929462c105dca48b6045411205a3f58a31d86f33ec4dc586934a3675605b279a51c9b477485c99a60df360826068187ba6e04942f8bda46602df167a89ffed2733e73e3c94a54dbc90f0a4bd3c269797b7397f1841748d1cf22345cb0e154dc0ea1a1f24c776a0e038bb96d953fda58f0bd5d4a642384fb163442f2b6b1ff52c52a91274ded0cca0f166fe91fc3948359f1bfe81d7f57954312a0e36a801d7d1acd40982901f3bffdf89832b60decd95cf1f2f359036ec8e81b32116f3c0c9fc17a2d052c184b8abca59cddbf6e13695972c578ab7e7fc4a55216a462f4ebc8fa1de24ff4c926934c2d0b3cd8eeb3a0bb1568b95f76cd211a4ddf2ffd6aedf92c9137f68345a38313147f20e2d5bc20fe22b4f248121e18ac70dfaefa285759056899b536563b934128fd47a27a7c9b3d98574c5d7bbbac54e64056b3522541fbafe088635db2804417eaca7d0a549adcf0a7aa3649165d6a6aad6b6d7e490181a5f95e8eb3502eb37e68cb1f04cf1314560ce2fbebe25aba7059746180a2c80a3d4cb22b62c39cafc44d921e0325c8894ad910c613b04d80c5e08b69b0a4f66ee95f881f4486e01aeef18a28bc9bf01b73e667a87ce7261442d270193dc45fb47f537c3f9a636f836e7400b502cc6a88177dce9f2abceaa8c8c95c2b3a8cb1bc73b82e314f968f7edfbb6aa042d0233e1020425b4979efe9f3a3a630c9e16a8afebc5ad900dd342c9f65cb176510b29e49e9d69758fe9b221b4aec99f68215cab94599a9b0f1d8404c234fdb8386589d175ff13cfe364ff36339e52408cdd6afed2e9b6099f96fb20bd2104be58e1221060ce005e03f3e1225bd8cdbb65ef75b9baaccc15465a9feb969c3acf904c1a0a263d058c613795c69172761f59ddd0001284e1f1fe2649a69a2e3f6129347d11462617e9aca3421c1e852779d54d7363840c287c301d4f79079dafbaa0ccaa1da6fc5d497fb42287912aea75fe515b655b35bb3d31500f88b8938f89523910ca88d9939b40b0c2f99512d9cab15a7bbf5082f04f9b9ba4c081febb663b86acefa01ee74846223ac674cf9b055a2d8140759f9d992198690f1aface6c05ba0056c66a0f76b46772c18919b65be2b8f1b07f229d8fdf6961729230b943a249ed0c07a53170f2a095ee838e9299a8321b37531fa8106a7604128d319fa520750bac6e0fb8e4fda66b5d298994cee309370b2f929f1d5646492d0cdf2e1ba9b5b4a3c5a059213d2c9fa0b2631bd1740f2c820d8b6b85e73d4a2bbaac69daed729667e80227aabaa33ab8409bf3b615ce265be1082b025575bfb4529e4ef5f0cc32658514c4dff5233dec2745a57c2a33c44c0f281c715add613f30d895253dfe650335a7b18bef50756d942b4534014148c9a0436bf80fdfd667e5ad83bf95610dbf16f80ead9750e68aa5a980246a17fbcb70314a9d6ded7ffd813108bc160eb4c64e0fb4b425f4eed14e6ef8e7fed7526961f01872d7d4f0edb58f4203f91092444f40239cea4afb382ebb83d1c9a410536da8529cc4c65bd9c183c61336b315224b7ebbb50a12ccf77c50efcc978986d19928acc31ac0cccc8134ce1ed3e018d3de27975c574174be1e44ae2dcdee6eae6d5f9e238946631f6febe546ebd4063e23250fa21ff00816b3d1e47af85cc0caf67317aca2781949df3ff6c81c41d8deb07c02d1941e7cae57fe2e1bad0990cc2e511b5f135d3466c6dc9bcbafb2957e8ccbda18e80c8194204facc82726d4f53b444d851a71fefdb85e82413e9160dd9a7a164d833a038674e4a21e580d5b13b58ba00bf9e03a57356f0560ed73858fe7a01ecf4e5f09229fd88a672aeeb3aab0ac5456e9f5984c0586d7a53ef50391bf64bdb73686ac05b60e7df5dd1da6005f263130bb5117dfef3394ad0c5549aecbcf9b7aec977cdfbcb877b4b6581589373bc79347beb5a45e93848b77635e75527a2eead60d4396616fbf954f9a3120b0c1c496d865879dea413ce76c834d75c68486fe9b0ebf39d53996d9a14adfd9a92e9831227be52cecab628c53d40c9c220c2d44319542979ec844768d46c8b832f2ad1d315ada47e6b5bd5a238967e4bc398aeef819b2d781065787bf56a2db59323ada5d881511db470db0ea7089bca36eb27d425bbc3f27c4af4b48da419835d1f292e6cd299f773ac9a7158472c88a91e416e281c1081f54f4114a8bab996a1d15ba832507789f172142b2eacc04d095c4e6308a8a532d8fd15cf3d50fa44ebfe2fceb7c5c5b225fbe8d0ea5bf4491f9445f1da88476398e6fe57057cb8fccad6e6f66863fe2b3deaba1117baa3648eab7bdfa0d7ae4a2195c06b02e9846ddb290e0f09e825e28444044188bb100f3b08816073b1f394c5f02f28e1f10e16c2a150964025e5fade5433c9fc558bb0a40cee99b982f634329a8f79d00826d24ba967060aac3491ad0228c88491e4681c20221ef53c8f496bd315e4b2738ccfda001c275ac3390991cc06e9ebe5351e34d170aa0a90ad3b14bd0d61bbf48981b8a402cba7e345b9484d5cac0dc7e375894d6283c452f19bfa6670a938809325d9385568b9ff05aff9d8e2f2fe6a79a3a4386304228bf8cd7cfc2dc41a8a8029ad89f0f4d254a371350d432b1feb58b33a27ea51c688b91666d268998f8d73d513cf1e41412f53f68624652bfea6e49dda025c6bff2a242e82fc6edde36f1aada43c2c955591d5d3150798d433887428bd16a312954bb8ad7214627a807fb897d4b506ad6b759dfc3f8e0b6ea3fcf6c6cf452f6b2af6dd9452ddbc56e5982ba1ae66aefb2826e69fe681a2eeaa4c9bbc6d036776d68684fd6e2fd5d9750feeacf667980387dd13b1efcb55398a73856f197e790ca372800d77d8f8b6cbd4773ea48102db31d8e0577e037d26a1882353e898712f0c63034bc52d014c00ea86eb7af892e6d3175ba6c04b7a6760620a3289ab7767b9462ea72ddb8aacd2b7c74a68dea295c0e987fe4e0aa3137f8e12dce72f55236734546c312b39bed87319cf40281560b85d37e92fdae6602d3f18f4cc363222f014ae8b80df246dc7c95ff9cc2d651492422ea3fe9ecbbc00d2af3eff80dde976b8f8b16ccacf57fc6890befa2cd0748f8827e1071c51f67834f60ad5694b3d9c785ce904560381fa9053a2e09a1bbd8201432dbcb10b534fc6d80fd4ccf19f14088734bd54ceeae069b4dfaa5b43855887ebfc48e8ce96113e3d8b436f9b60d9839b447a7efba45a658c3edeba78433011fb5f50cf238bc4c3cb27896110c0fad32b938c86633c56e857ceb2a448dc5465e502dd8e7c5a8cc86c2384bfd9818175486fc18abfc17043a4ed05b74e948b5ba1cf665496963625ea5732139b608812c4ea724fff1ba895e6e91c0509c75b7673de54d5d20d156fe61282ba779f5cb27a4326694bbc14c757be36ec6473a761361bab7c04c260921f57b013bc362e29ed4539597441c1c3df839c3aefca56f113a278954026a7ad1986bab6b480242abb4760bd640b4a63e82fabda88b73f48ac239310f4c250820ee9eaf5157d5b32ef244f6ca29dd7b68c388f8b4c1b978d394b55e6c0d88c46438bde3fece1bcfc69d5548ac93c419e5c45603faa771b05d81a122e848dee5cbd4188079a2558fdbb7d2c1cb353ef442f80976d6d2d496ccab4db18fbc60050b8fa6c8dd61aa2749ee0afc418dba29d75713a4a01cc6fb1be29f3d971ecd914a63d2068282edad2353e31bfbae76eccfa4219099b23147237024b0579d475b22581d3f58690e7ce135ed75e4b3eab85242f2b1e7a5245fffaa31e37571a29180464cdb672ec6a32f7a78d19dfc0a049037823890b98ed8f6e0f161cd6513b5b884df29af7ef85e2bb0e06cea2fd3a66e9d496f321e852e78f8abd57412af3a5a44a85145ed153f25297f45521fe58b84f3425032dd5d363ce453f8001c1047b0bdcd98223bc8129720e31c9f2458c44db6822787e8eb8cdbc288694053b1d8d73e5e2c3d04c92d04fe4f1e8591d3c0293832b17d534d925ab5af4b10ba8f9670618b084cc4d9a30fd58712c975832ce82fdbcd3c1ce024be5fa019f195306d9a6bcced71d421110b3c011e69cb92746e10760f11c0359ca320f5a9c40937a4fb099566855e25b5f47594039f3b9cfbe4e36c4bb61a38125b2f09658d4600c9f93b170b5e6690271c7d8af4719a7602e943dc4a766e60d949acea7878d4bf497c04c0a9dbe456453038441731849ad3cc48f63c7bde9df1031a504d94cdefdb056a3f79bc721552d300bee3116d31a83c2e9e0884bbfc2fe86ccadec9ab538b31b1c7bb83c6801b1d068969a43c2cf680b21edaf1fbcc8c32b9897a3f0f7103028a56eff10aa91ed81148e047894af37a165b854159cd7cb89f9b04321edc305db6f7e6c32b5177213550b1b6d5b0a8b88e7e8674654a7ae7ce9848e6d61449d9f3ff17527a2c00435e3ad40cc2c8477049a656313e7e9efb8d97441c9e8d4a739270705b6cbf7d600e5453e2be6f1bd13e103fa303272f90c940f8cae43a0a3a2d518bfcd34c16c6d84b3c1504bb31db3171a390fc911903b43d7548c2d7e30b6e33c3e0867d7bf470b6a34b230565b685116337a0a08303a1dce0d9dc28652b72fa1ca9a329b373f25ab0c485b79a15f66c695a52ba37754edcba28581d4dc42feafea01df0cc625a457130ddecb69d98705e0ca4cf136c28c59422c5e5cefb8c323e14bc0eca51ab7334f8da56d1e4eb010032b0f18e88800633dc2c467f449beebf0f961aa749ec29889ed28ec1013c781a2aa3f7199618860fafc94904c881f431f6ddb528c73c594297643bf02c9fa2718513427f5a2ddc01f4f2f0447ebd73290350256b9fd406082e066ece19977c9636428f34a7b625ed32f44101eaad5e260f91f2ff2673639e02466340e691bf5c2709e345c697479cccbfe52c17ce2016b4d0432cc67d7c687863977838f948d0f1d01f08af18d54b55e795643e59a427cb06665265d7f24b5fc6466424f194e5a1f2fafb81e845d0817f38371edc73fe8ee0813df9c2017a539c09d9761400f7d4f8bf142f3a0fc49012ef553474f0de14e4e1dec1c72485184a6ef1db1dace53006d500aae15b730ff9a2e24f30bf176f62e3d801eb4c30c07272d10ff159153d387ada669ba6f16272f5153dd9a58d76ad78ccc50182063748647825bf33dcaf6a20c6448f3bda82ba5eb0b89230a7495401f215aed9d66246250e353dc789ae4ec5790a042e8a515bfb54b794be98fea18a49cd4d27b1e6408805960db6809dfe27c18961082266f5e45229ba86ae6cd4a724aa0814c3099f39073471b70dfb092b5c1207a98fa945d5581b8b8be602aea3f0c39e339b23572efd639f432438ecc6f8198239edd8ac7f1255208e01385e90d5f1da58dbb3ea2741bd35e2c4283de7b1a060341a657af4106840502777a0f7fee57a3554cbda0112d23848596f087eca3049b099c3db41ef75ffce4745575c77c6cfc1d59b6a13caa63639bae71f7ac92230683a8e138e761d3d9a7d664d133e10e0e2ecd319fb2f98831c8c804f79d9ce2a2ea090a6de4f6b9372357d8c35fab9696c6b39c98a7e47d275bc036477398996ca9fceb4dfcd552d33d0f63b4d4882dc6effc820bd359327fda4c9511fe10afadfa427f5d065ab3daa67703d1779f71c72b0ff24100503c18ff61c46209062582ac7e364e2bdd54ed62256b0a6976db1a83e394d1f32549959193fd897408a845cc26bad733a27a74b2450eada60ef74a201d512ec19104dcf0f7355343076574dc89e9413f3d3022217a8ea5f4fe118aaf72d8c38287af7046efdfbb6f92b3639a73321fc0565afb570eb1f71155cf9d8315fd3f040c89c19af7637e8f6f0769b4d020c0cd0f00134165f502ac19e8ef919e2b59572c730227a1a14912bda132b174fb6b29e399d2038b74e560969067b73ad240887e6236ec2cc4e75fb32497ffad645f864b9b9be04601cd7d4cbfa5f4c31af2a4d042010b7fbda52476d2703415c39a4e395e79ebd9f68cfc4925ebfed5d4779d295f2e53d4fc90ae5e07bcf42cf850cc40b950c19055474c6caf461ec96cde389b54b044f42605d5b9e475db4dca09f2b9ee48a531039542352554cf92cad167211a307a464c7a3746a4d4a3322a37c7b7a5fe0e74c3c4cf487908573494bd51d4e0906512487e6000142f0bcc6759ccfcadfd6c15d3388633bbc733e292f7b6a833285b9d93e82cd852407dabfbb2017d301cd839e0df702f98d991b7f82fa9c153c253ed632f63e214cfea18e52b9b540966a5db039f497763d984a6d2460027c851cd75f0a09ec3a40ab87e63475a75c963ab5af3c7ce572c8eed5842bf14ba3aafa29b41011c96e243b6c1e959d7088144e08ba5b991a17728768ec96198170cd055fbf4096509aa7534297e985a29c4a497fa78f25fb25ff232def86edf9dc743f03209fa29eb9ce7f6a3253a4e4cf39eebd08e9dbb86209a04941f621e360c78c7bcb6db24b7d97e13cc0626ef9a9a1dfab73f910fa12d5279c8d1ab3e9e7a3a3d18dc7d97017aa47914deee1686d423ee795f8a0f35fbd4c7386cca0644aba71186577d5866235cb192ee5774260936c3b1b56c9e8d1c2fa9a320294b37d3cbf5103ace1e26acc82da9649d0139099e138fbd7a2149d22aa50838a0caa0bced8cf1455ace31d8e7de4626503f4fa77933267df55b51ebe6344f9a09009a30fdf2201d507419ce0649f67e347a26580bb2b1145d9135fa7ac9362c850926574409ed886221be395b96492a9bf23279eb322ede231ae7df46477da5c0dca25e17556ef33e62c1a6a957c3cf30fe22898bc4724acd4044cb743cea3db9f8d28ab2631f6be70df84da97f3b42598eab55be8b2569079bb6b4d71dca1797dc89dcf4161189de74392d88980235f336e5fc8b73744a77f46207a73451b459e3c793ae41168f277272b8fb49821903263624c37208f2eef4528b4bc1d897f957b40d21e31d4a901455de04edfd1a69995ac9699a38d195cbd9c3f41fc84faa008bdea0edfe518bbe6a15cbd6a26067c4309f2ef1a2f352244ca56e3615ea3c1a53496c6f6c467d170f0ca2edd048504f311ef1157f53b6d9c7637a337d3425145b6cf7217e9870f706e15789254aec5520c0eb14d6cb901220cee80b97f0271018c3fa560114aa6b328622dd49a6d3d82a0e5a77ec9c59759af946ece9dc3e79dc4c69b3f2dadd7877094a9b27cfbbfe64cbb7d0fcee32dd9ee34f964c25dc8ccfdbb9e3b2ddc2d60a7a287aa77f77a1e4439ed0dbd614ad59429cc66e5387b1537214041c2ed9f9f0f8caab1f8c2d41f28556b4c49ccadd2da3b5488d59d916d7fcd0326bc43d3ca5637f576550e34b9a7d9b92bc3b5cadaa599f6cd5a81d4442be01cfe8a6ec02948d2e3188a8fcc91207920b8478177082209e4bc3e07289313049b4224d58a50f6d90e53979aedb8add1cc516048c8fd17db63c1038f4bbd7ff745c9a534746512ea7f5d9a8c8a00eb7bddc2fc6fafacc262335756cb2f43ace27cf3eb5edb917c619acae0132f951d3b440956f9eabd207993963f3410d3cccace7b371b912db684e30d6f3b9234b0ece3ac49a6bc0c750c36f17a1fd850320a8817de583027436937fa1574c592d6c80fe57438c4c577df7d804ca8b88eb3f6d3404774b40627c08775faf55cb5271f1cf0752de6f76c3852b95fca0c27c30ddc3f5b01c227f33e2d344d13bd679565944d17c882e1edce8f3c1675e32ca90b108f20212b567783ee4f876078c113e3d146d90ec5c254dc070437b6c9e34e310494a0bb8a97c301794c8a14dee7fc70d515f59ae89e7b65d0cf6c860efe21db9dc96057ec46349867346e6efbbdcdf9c646a052f5f7a3e5258475a8f23f3dd4bfb43eba61a28a16170c33360f3febcfc94","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
