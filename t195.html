<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7bc23a08619e4f3a2858721df03e5db093ab500c087bcae7d17fb077446e4cee6a4a3f5e104bdb01dff565b7c16528a883475de0bce63b914b212d8dbca6f34604d4e34112921e48a80db5be636f49c61ca8deb35c2fdccf29227de5256233f5ba39259cc4596a4579bd70e6f4ff9eadd955254d7720bd24051926564ab3f8c1027f8860fedb7da8c28f2715917f733c91b3c5c344d36c1e4bc860728d7b7e055c3e3309c397eb267b109c718d911638cdbf1ce3201077331b2cb68f585372a67514135fa3e9cae0b10ba325552e73e389d0c465aabe751e028f67fe6457407b06ac96d69a056dca97da2202c0599e8e05f3fe2d4277d55087cdb9f42f104647205af114cbba44c42ffc63165fcfec137642f42866d00a68d14a9b0d74a3c34498c25f8f6bb452eb2b814bf1cbb55d75194db55007be8015cb64e3ce6c185f91964399cbcfcfab7769ec734a0618f95374a849746eb2ee230bd04c9620feb6d33fa796d0434e6d9febd90bec30ce0968f61f97b866cce7d4e6b74326386f8ad80978d7586bc7068335a5e0b974c8bd7d53d269a90719ef0826072eea315edbc9ea5b1585d9a92393292ae6e331b9aa47d3b0747f63fcb851071c3ed910f3cb19377f1aa2ba773f522c6582ca68c4b7625a962f67487b263182293a2950ac65dc6c93a26b2d3e2159f4b73c38d5caee30b3747a2615f9130e06ba0d7e257ce1da7a6a5123dd0f3411bcf3cec55390fca2a5189efdb924d111ed46799d2bdb5d2b1cc55bfa01cb1936f117e7a044f41a7ab583ba003d54716a3f27c27ef549bdbbf0076de341e3846bda1b4af5fec274205c2e0e95974277200c6cb3772601930ae0b98513cff06f28552e8cbdbd6afdb6dda707e51aa0a0af1ece1862bb0524fc71b72e88adb05908b06907e4bab1fc14ceade8b8705424423137f0dd1a8503730865bae4052ce51e6127347e190b23013d701acd94fbd636308c204ebb189888b1ea29c48c1c128f96335e35eba2069464f002df5cfdeb09e0b20452ee614c49e9f0c544ead4bc2c62f5ea2c6f6c3f9ef86ef3526858ff536c94a78e8e33754a0be536ad5feeded707b6dfe26b5ac9f0f8b036f3b225729b60472e86e4a92f99e532b79e89de92a6916d7efd348a5a238c5484645b5004ec0e3c4f9091bd3fd09f1420ef15e8c225403ac88e93606071bd2ccfe46883772f78424bb56d53e932fc1e5845c6083a383a67d0f135a5bce36fb3978a629ae8e0a2cd763e56ba4c5f0c8fb8e34b6d449c9fe1be9825a6773d3ac7d62184199ae8a8727b1a2999b43ae38f031e595d5c5e576375da54492c2d5daa3f13b3aaa1ff8be5eab42d4b8e1cb6959a61558c0d0ae66f70c7da2f1bb22a8c59a7ee7a80440f40a1fbf8fb4685d0963a0af8d2e1cbd8b5082658d0f7d7ab213c51366fd60538e9632411bd21da63e2780ffeeaacd62e3919cc88a640e6d09534e3b916b9211972adadc09841c22614eaa264a8bc4976450e53e47775353377c2d945f6ef156dbc666a293eff1e3573f69b13e242052b6bc11a76a0054972315f459485d48b2f7c30dcd7404967fb3a1c29d3ffd2c836d42d66f248a3f6d7454b0f83ee30227634af048886bf4823b9837624d52774f1869c6c782f9b4891b004ca7c81040b66d83e04e6abed8bd7b6bcb4ff46552a5835ff509d23e606d2a4a14ace7c78ae0f04fffed9347ba2837ca2ab53594930c26f8e3829df818a51b6a41652874833b0c8d6cad15a547072fa7aa0cf6bb0279f8b9428e2bf3196cfe419af38bd5c8182d2ed83760839352af0d12d3925bc25ea72daf543b0ac27b357358e2bb5789da48b84ed55596a61c6c626c7e9c7cf58b6c2c61bebed89b532dc6a7091e2fca4ba342d20aefcfeee12ab79c859d727fc182d1831c8bdb38924b6c9d4936f9fb1cb28f17cb356a859a213a58daa1ce7936f0dc9b04005d77f16accb0ae78b88f5a6e070fc794d47074e9b949103f450705ee2132394769d1a2e5189be41afaa4438307dc2ddf3e19c1cdfe0ee568f13d2e1344be106ab9af153f5967c2849a0769583627256364e7dac963c00327a542d11fd0cbb469b4cc83ab498d97fd18a9981f4dfc8f9f7acfa54be6538bff206cee8864c2ad1d9f6db0a126e6106f0515c8f64ef4ddddc4d828f736be48b19c6d2ee3a3d14eabddaa09ab309e3c3abd99f9cebe93226e173e14ff18fc6cdd1ca25948e3998fb3f38530461de8402f1fe34f29f742650e110cb4881aab33817ba117c724680d060cd6db0288f0bc40c0eb676e9d2737a43bcf02de8c41da6fc1873476f3072ef55388879acb90bde913bb4e52ed9c17769c17117bdfc7e141ddb3a3ebca660172893ec5f12d6b93a33bab055d20336f4fec5d47256116c45c850429a2b54652668f772f711b43ccf81d849063075cd43d0d15adb19b8e07c56fff119e8a999afc334f1cf4d5d9369251e6d0ad803e6f49a067659889d0e712b8f4bd42e670b11859c4d48ba70cec3c443bdc3edda8d25db38534454d9b2eb43ac1ef7ff6c693ccb42ecc4539296af21eb724f7de070d842c59560bc4d2cc9a32b33ec48b9f73ce5a8b9048f55bf751446c011167aff28645432b8cedb1e60a14814d25972ded88d1ba29dddd88b395609f537641a1049f8dbfe1a1aee9180d4f638d9a03febe7e628c381c75b2fb048789f1dd66b1a4552544d1de570bf59e373f264d11f540d62d4af755ded7a91bda7c88819b05464cd449aea562198518bf31240a13ecf7576f4f353f164ede971b7572a383b17b386856563447d3205d7da127efb0d2910c16c949a6aa7849101840bad3d8999b8f34a7488979890b851c594c3ef4e7782c4816da0d3c6f1fa9667eaf716db2e4efd4f7579bd76ad5ef46cd0772a25a0d09a084fe53132357f9bdfa92d4e7dcb6593bc73da128be5294774b00e0235382c8c59326d315bb16eb1d606ca210a9754c5deac6915b7e5e84a9de067bc2ba9fb83e5b83fa4d2d02a81d16f0a4a25455c06a32af96e36cdbd0f05241ce608a90dd115b13fa6ec8bcde7d6b9ee6f97efbc9eb98448fb40c2bc5e6e9d476006c5fa91e8c603c8fa157ef1053d10bfc7253397ecf02646171c1bf0882a639c4244f96ff0e5fc924ec908f6abd5559da8e885044ad1f4d465bfa26f562849d4d480ead3d22e31ef25a6a175e63f4aaea719adc4de3d42a3eb80aed9915b93283270ac2f9ba4ef22478ed3c6f146899ef3eca179f51473277f43a45038ac8f1742deda5f60dfba8d6625c7c8973dd981ab9ee9d21f9dd19a92359e3cd6807cfe400c8d009ef102a0548ca376c7dba095d42fb1ca6e724208a4039a3517a0de50ccfd9317c328c41835c5fc77d7f86667aafc891e2d2e9b28eb45a476015fbb04d019e961387fe72d111325eb284833e31dcf2d2d4073a0eb7d4ed4d1cb5917733070cbf9afe48dc5b522a8bd5b0bbe01386a25bc44ee4a01f99f7964b65260f7101f16b86dce35effd2c02aff4ddaa518cae67b08e1e6a04264d18893b12a50140e90d05d2a0a170883f388b4d7d99cf98be4a06d7aaec12b66eb83402bef1e0261c1b008bb19283c646827f40bf8dd354cb8def5c38488d6123c456d2588972d7f7a489fb5ef09636b427e8fd937505830083f9f6f0806a023e5343830ca4f9b5c3ebad925c1aad367c5997497eae8d417cbbb5cda8f9764a5216d77aea7ee03d25c750247875b7cd60fd4b5309a0f5e3be6768b78b9de467510e25dd3474b197879c4e3bf797157bbaedf9335c38243c7fc288eb81e901b2d57f6575a9452c84c5b6ffab2c02dd74876a34583d783eb5837e2122816c06d0fac794660eb04d0da277a30dfa8eda33c1d26aef9df51e490ca7ee78aed2972c3c9fddfded1aeac0a42d6f7cdd40bd8a83eb711da96bc0bd44ee7ff517fa3cd67cfba49bf6f4547086e5866e96c7f117372a456df4eb04c310c9915d499174cbc454a90155d21108e493a28327458c65de5974f81f9d72e2bfc9123ae84c8844d8a23da21c2e1dfa2635d599096e166ff3dcdcdbc928cfe9ed2d0c9549d5932771e6d8ce66281dc0e5c514cb46587d0416ba7bc4aa026a104b7a25b1700733cadc678d17abc687d1b5f4e9deac08d3c965a30915d55042152629cf3070e4aef5fca0e8923ee66f05aca8f37f5429c8ec90414902bbe12e2c7487b44d77fafcc8b572f310869032c9d9132dc0cc1b785d0bc831aa4d8a4d206e0457f1b86a5a036f15ef9f788e3f42527f91c0db25117f2f73b1d7acc24b2908da6692c0b43ecb79e71e03e305cbde6a34f02992ef289fceb5aeb83710442683282d5ef682f626ace6c39334ae6e228840b0db179945e099cfe81075ffc487e77b25520663627c9a0fde2e16ef41f65abbc8229c905203ae9c89394449b2732da750ed2222f2d41b9c001ae01ca89627ed724fafe078e8dea3f48b2c565237241c7733bcf502813715fef047b9b3fae1151e6e0536adeed42b0e7b53f6305d42d30b7d010d5b6ec04577436aad6afa6d4d58048bb48dd214167fc442da3e53468802d66531fa2e6475fd4cba47e39b8b67e1cb204516d8d1689e84189fa546796650549749b51a5796d7f1bdf3ec25e59f91581acb4e95102f63a32246df08ca3121410af6b14112fdc8f607a0b66566baf7ffef41b26058d51ea00a45692a655c8c1990138436cb68e049a0bcfa682158f3fda068a806c598be82071345fa54dc7e4a8d972cf1bcc29f0b91055f5816bfd493d49d5b23dd9e2c2f5f8c59b47e6866687e4a95b14bb67180e6889139a41d61b7a614b29491a0daa63adededbe5a5c4b5964d022272d08f8bed39f77a30f1952609e6f2240221e4169324f7dccc2ed45606c107410db93d1a598a1bc59fd897956f8d0913d5e35513265943d1a16af3d330a78a4f6fe6f60f53030db2ac70cbfaa2ed135f3ddd61d1c06fbaded353027e4f4cc804daac753f914de0fd11d02ad93c69698475672b026811fc7087e0afe6c5ce2e0960a28f57992db46501102fc2158107417df67e33c54c1798d5c8d0757957f5d3d4d6989ce9e9603a65c0dcfb6b82ff6286b1d0655d153088f4c4c3be18a8c8073447208e9512e2208ff300bf097eb3f6ebd69a5577db8cffee7d290d61cb02579cef20c5396b8c7acb738b2e929a561e59549af4b8acee36805b328d703f2dd40b96c72f3b0774bcfc444880330927cd7bd6e50d7311c6fe2c34e9cc3f7cbea3be5e9d14e2f8a49c2da0e5a60da68582edd867e7d6a17795eb4cd662768fad7d01ec206f5bf4422a5c8fd6e52be8fbc5c071fdf9ae38660ff4841af02765c61aa1043f6c8ab474f1d4a4509adb5be7119dd736497bdd064b7f922b06e1df535e3290f70376e89c623b392238852f7c579b7fc35ded61be2f2227626b45acffbcdd7f40b7e3800b972f98c5583ed4a8f26cca3aaa5261d89cfc57cabfb693471431d90869533154f86b37349c0afb80afb1399c661931b3d27b7624b947b3ef2cbcc3eca1e18fa4d11360502497562ee25e45ccc7066badd079453f8d6ecca37557bc6fc5b67e012d96a32a2185a5a7cee0d469fac1ef09342fe226f33bf81ed4d425f36c4700ac8d94fe11b1d8e4acfa004467d0a033213bb18d1bad23a5e0126e96d22e81cea3eeeb840e2f31530c13c3e1037402e307bc3c4a33ab3caa4554a2c3fc8a69a63ab496ab985cb96fb6d495f0fc32f9fbf80d76dbcdb952e5c1d7481670987d0dd201d43257328e4df04635f936865c1f1b1213c8ecdf35e80a23c7ae662b9f986fd9a06f96020d93e7b4fed36aa5346d17cebe021baa9b9ee69572aaebfb0a8ae5239b965aa11d49f0cd57e8728c4f5ac1b53f802ddf623dbfc1438b7f4e7373ed7b41be305786601ba1e66a3a5777ba0298693cd59496029421ee152b6b73548aeba98d1d84013024fd65167551a86f36952f0a3434b7ca8c76e8a0b2d7e689c89714457d5e0610e0086aaaa8a4057a7a0c4e379832c39f9c794ef2eea12340a9222da9bd4bc6162822eb637ae61feb709ecb6df85b2dab873ad7a131b2b68a25ec3cf1961c739f09cbf5ff5bc3b63d79c1a7d0a5bbdb0557e26ebaa6e01ac55fcd980cc1d867ab12defe4c044f57c31e2ceeccef25acbf8b5d16521ed29efb8e74ede66cbbe917501f66d52c0e745b400b6dde1736edab75762ea1494da1552353f83c7a5f39c9219d2013fac54d21debe7787541257d34dd230078a47a2eecb69267f69776a8019d08c8a83894052623e9fd5b293f778e31a0fdf216d893cc930f46810f8ea2ae52dcfb8295759ba3a38b5c13c40e5699b3b1da47743f863bce4d0f989120624bb645a37137f3633b7ea83a5184124b7900e7c299d5a035f4b7f5d70486a6ca3a9bc948dd6274839d7c3bbed98f90da537e4ae241101055199b216aa46508f45cdbd7794feec5ff51ce5d6a7038dd5673d207046a72b7ff9a7471824df86dd0dbde26c5c1b953e69a68b9a87b26189a9d1f23fc88f2bacd848a8d40d25ef3939cb5711ab9a5c8c482ca291694b66743d6d8ba958ba230fecd86ce7470566224f9299aed00e70ccaf0c2ba24801928c677bbe28a9fc9fc9dbe9cb095c7988a5b2bc7750f443b58b1109fbfedab1b46da1055afc9b30d15a8b66313b6950fc55cf59467f3bf69c793428c51cf3773c0a18a052f3b451ddd510533e5255694c206b82f774dcde64205ae21d783a21cf7e0bc78bc59a43288f9f727c6bc41f45b9a0abe9bd12854311f08fab508865db28589f1635489523ecb1bf3956357d0aa9bed6d87e8f01a7dea6a29fb64c3fa209aa0500ac102e9dd124c66b8476f42ac17df7aecae7c702cc636560446ceedb9928e94c3f79fee7dd7684e1803de839835a24642168f4858cb8b39a03dd40d7d4995a376db46a97388d174f867d16f24e872c98f7eea448182e42505b7eb843973feb43210212dd51feb81814331c65de74a5f10952d71e4682daf195a6fb81c0286f50de2b9f9d30b6ed08f5ef3e6af89c33ed017bb665f85352abc77a5e4fb3714b3b4ef6a7964445e86df9f52638c9f8fac979b025047ab944c21438cee03189197c3de41a117fd78033bee39d47c0eecec8a1fc4c00efb2620ad850851839267e7e342fb59d66392933d7a1d5d80f912cf038a53e53344327d9f7dd03b2dd7e457ded6302f7535d48c3e703d51b33e70227fce6869b7bd6197d2ef5e34119a980d09e84cc61f3be756e797d5bc9584bbe759b1609b287a730f4d8865a7d39696fa39aeb0e643640d114fac418ce9cf3fec137757e0ffec21829e460ec4bf808390ee0e29b84878ce1f6f91e102a4398259fcce33f5b5da9874870ee0c1d818ae5a355a30882cb84d26b7b984d6c6562d6c89088ddf061f0abb436569dcae0796f031db6043b9b6e7ec8336f5191f3c4d2441248d5c85ee820811aa5674d26963cecdadb502a699d1049acd20a4e6dbb1013a8eb93497819f099771d3d3ad61aa3da685829681d606967081817616a413d80bd9248265d10165eecfef5d7ab176a4d425d5309d8ac2ef8a68773607e99dff4bdc0236d7e0b4fb1e1ee4c402163f8db6623f6bf42971f722408b329644a2b904e36e1b945f33b4a7daaf2637ed8907bb5af9fa02aeb5614b9afe4cbdfa010cb8849b44451ac4a958716ff764a2d2889045f53ef416c685ba1623dafa591d8d6b348ff26f2aca8568cea34e946e3364b3464de2a5fb894b772760b6a2f6d98fd8a5ffa1697381df50eee5526220366a715e8ac53091137ad40a88f4d2197b97942f92ae0c540df207b7df2271035ffc3fd18e5af3eb0c45a491c9af975aaed23ad795a45d15b8040cbdb46ce9d23e38e82d0c4228eae9b9e541c5e2a72008c4bc5dbd09d4ec2e646287a6516d72528966125a23fc1cca7bdf54613254a5f0b0d4213a3fcb224f9cc440b72eeb3e4ae4b175dc63e723d4bb04cbe38f892dcc3218e17db2f7a8e640f08b5d5640a128fdace953e48e51ffa2f1ebb963f19db01646519c16ba5568bfa82027440d6cc6c3f875f554065e66fcfb35b2cf22e1801028a8f2643380974123b0ac181df2701d21b6336e021e256f23c186d5c57c5924779aefd49eac37775ff4f06e5d4e00a9929937f22b591bfc46d22ea74b7ee9db2682b455c2777e2d1097c071283f85c93201a8252f198fc94ecf966f2618a782124441727400310475c14b03f74b4a0a36003c787e3cf017d161da84e4bfe580f91cf2c6ca76d56051314686effeab31eebfe1b7626c1099218ea52afa2197c781d5dccadefe737f27b2c1d30d0921f7e69f0a4b236a859886763e74ffcb42f0ee1f2cbc9953d8cc293cd154de4e7cf24f39072b44ff47b6ad5292b0f99e6a68810241e724b070c458c2763f318a6f5a239a63c0adf2d284beedf6d9cdf6a06411b36e096ac3d794bdda8e2172ddfb0d805c28ebf500cd9fd135d0e59c943a92a53a6e577d632ad7e300348ea57dc32f966d19fbb81e47fd3204cf7753ff878c6787d8bf92b2c8f84d8ef4036be3ef207e4e3bbf737e15ec0e49b51bc24f5af065a8bd9530fdb057ebbf299cb40e429fb09080e2ce9db848d36f0f455653ce6a59b133a14151a0c3102495c846f4c8beb212e664ad5e627c9bb3fdff1bb1174c5352166c955c394f3a286800f5c0e36a1686828ee1eb1365a9f60022585b72ea44cfc948a9882c2bd79b94ad9533ef81c03dba723f48f0cf641aa882a0a0d6ecde9cea7990a49e61f7bfc486f68f6bc14b0f51edd30551e0bd61ecffbafdbb95417a4856e76bff07978583e627118da9e0177d98e416ecbe2b33141cfdfbcde2144f750d095b0b204595485cb07964df001bfa5b8f5b3144ad173d4ac8a9578b51d8de90b43c9a5d73148c3f3845f8451c7d4e76df632f8fcba0a44d261c339e92a4904638706226706b1f042c2d7cf9e146c891b1fe8e9ef8a1e2da2232ba23e85534b23995d9961f5ab5386c7d6a30b5604fb390691dcece629d6afc96bc332287cf7d635742883e200e121abdc8c5570cbc65cc45bcb617963a303c97fcce41d864045eef00ba43ccf7d42aee7b2455b56b4b2208381c90c711ecf1f5f092ad30bb23e2300e6a8919d2ae90f7ca7db479261b2254f3ad6f89942873b4b9c7db4e64d846d4a73dbcacc39073a1f1d5e13733bcc2b5570438e3b0617ff4189c8f9f97e7a11a6690803844cb300023708e87cb3daa683875e2e85503c0e7b9fde20cbf6bbc490b59daae870887ae4c02d6e3a186775c880d6b2325ce8186c06f23646231da5f1280c13beabf3f215ed4bce4ccfa1f117ef1e4d39c38ca4c21a42507daec7cb578304588360e872287679eb6eea5511204d32b56859eb4ec9978733c2334cef05acb81183427b35e0828b85c3a2d713b1bfe60b3d849a9839f2f0cd1952a245114d441fc35b37836dbbdcfbb30b440d07e49a4ab750cf942147812343a299da0b4170f218d4ae5108fc4111a7e4a52b78f1cae12cfbacd3760009511c352433af9915292435375343cde7670159d8a6eb4040488f8e2ab1afb8c8a7ff11575fadc061bf1ca1c93c47eb572e959b43de6ad8cb49d827c55a5f7873906694b798d161fdd30f8c4ef52f11ff80803553ae44f2ffe9ed502b4f49e5a1222087fd90a3ea03df32a48fe460584493036613b05184ae7faaf1e5f0852f842cda35123504d48055138ab5dd673561b12a016dbcec1d33a164d1a2c2bf0606ad0fbd055d3a2a9a6e384778ab980b132bee4cf61b0943e0a048ce086438453e1330afd5fe8aec81f1a5bbea32235607e4909a7a78fe16f9b5a3b366fb7efa606d4d973bff3229f66b042ee455f2c631b6d823e1d1bd6b1c998df22426a82263d818a8f960efa8d2b0c12439b66b06326a1b42ad0e090b0581ab89189059089c9142cee6a4ec8b1b766f704cb4103e37d2b8a5f3619bb1f6f7837b9055ab606a4a1344e8aab221f76ddaae765cb6599c53a95e7131b1b09f2a9dd593c8203d5ad4531b186ab63b04951aa4258e4224384d89fd176fa8ba39e36e0e5aa86ae5a25c1b7e769a64d17e2d7aae6492f2e899a451c3195fe82d9e3dd543446edf5d9e067c238aa5d2f0b62f33049356d7b341323133c5defe26aa1b537ea3dc78baf266d178b33b3ab49a4b5d03d9a31ecb180e187835749a8a485c7f6ef1dcb0aba6f2bd5ae45d5d3af507d03cf90a7187fea6030c3239b4da00befecd59509afbe6ded98c57044092110761a59e0429b8936d1d14642ed943d10ce4d08ccef681db74ab62dd67f78a914742bf14f85ce49420e66962a4d46d2a64b2134525da4bfe04e85861032b1eeae10c1325f73806d70bf84a501b08d2251df870cc55ea758ca1c743572a994aa6ed72d3ad30e57b0b99acfbfe658c808d6328e88aed879a2f70bc32b59bbe5e5efcaf6096998397c1cd1b5d9e67e7add59aaba5f73c4fa0198baec5177729fe3ddc940262b7af91bdffd793a71b45e02ff53bcf8609afdb25d8e4b6dd1e612251533a85958635caa8416201f7a04c07bff3d12b4632f4317a298ba19270f444c723413ad846cd3398112868f72ba18b62f73493a7fee9f9817ec628d7f5cdc595ee0fbba1f06900655ea713ebefff01a8a702b01965e106dd325e1f79cb1aa76c21446fdba323dc9876795addd05dd8df45fb7df129a90626fa392799675606a2ec4194d55f563a4bf374f6f4bc553dc831c410df1c1408e3b9a749484a13c99abdd337c5b267ee22c15753b3be0be3bf7a6c8f74bdf13836089c706ddf36575ba400db8a839a443f897e780d560237d49750772f66a21305c78252a1d3d06ac6509f681dea635aece0bdbea8c85dbff9ddc6c210fa3a3d44477f31c4a60247cf54092ee9bfd43394749048c82b6257ffdd00ec3801036035aa1c385d557f832006a74943869de47024bdade4f6fce9fe63a839c0cd856ee8ebdf58070f9d9cc6ac08db02fccfc40ed7d74d3e758eeb0c130b4b9f67888a4534c625c54ff4d976cbb3bcc444abf7bb914c0b691b0f568406beb7338b5a71c7bb244b1588d97fd8d71002f0ad4d85b6f72d6738a6dac60951f3c726410b781d18879270c36f025674d7f2e0292a30609df9fba64c7ffcca86711b3ab47de8478bbba07072709c6657deda5a346281afda045e49bf189611df90b599ab8ac695bfdcd0882214f7638e498ab2d0fd89444faa6fb323978c0c27637b39157c30532902d7a593d8f263588de61bdcabbdd0d1def82fe8ad1d1fc12daa4275dbfcb560aade6c517c85325ea5881c9746861e21c1618ce8887aa989060217e9cb34f810fbd5f79aafc3760c0ab36dfeefa554d40fb62195213f3585142a99564fee0e8c12491009471cdef7fec8eacba448cf7a27b34ee25c48e8fa5095cc7fce36457e793d3a9e088cac962975b18ebece5b1290ab95cc90b81a1fb35dab4da573e9073f0bab0fc6cab8d141ea252ce197c071e17fee6bbba3e708a5f3f1719fd016f9b99329971e5b702044bdc8a93f86fbbee0e7fbe078d939853fea88f2b91523707ce0bc9cb644260794fc82273372b71cd9d0a5741205a762936922ce650d1ef80c3bb3febeda2d1cc22391e1209316af5d0b3dd3316593980cf43cbd5b8063b8d4a0b48d856a629471a1a90884874218df20abab28be5ee38b86325c4ddcee9e14b04737d4b544d2685a8309b2a670b0ea5b118b1f5f8fe8d750fe7999de6084452b6a87ad634b092916c27889b722e9749f8fceb25f46a2fdc6ed4c0e5a7fd18d8344e88c37874c6da7329a4444867e42425ec890ee913d08b88fc3e6e0d206fc2d0e9ff7733e530991305321ffddfa39082445f8e6cef6d70aa8221f0a33b444b901e29e98c2584867ae8b04b0606c0cb56d50857baa7293e280c98a3c183a7a3a714275dbb7687e83d7de072314c81b50c13deb9d0a5e772720a4467e4eaf442a66a02bedd31f220817c146ac0378343f2ee37bbafe58cc5f5d3aaff8e569e7774ef348e182874c196849d2dc4cc005916fff8b9243609f0a6cccb0f3b8a87aeebff4687649442266ed007759ec022e0e1f449f0deaa3f509fa2b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
