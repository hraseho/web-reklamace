<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a6ee5887898ad5d14fb70ba4060704badc02423b70cc26047ac650216f60025c5a113b42ac2ee1fad558b3bdc7763aacb0ac73fda67db872d078607ced5429c944ea9e20668ea6368be6b881ad43eae3d44b56d2d6ceb9073cdf46f1bfd3ad5ef73fcdef5c19125efb1b6c13c3e55a5a1564d5952992646329b04cb14a459e9bad0c41675b40f82b437699cdd957e2a7c798314f36bc2e171dd4588035c680d2efb75dd1a846e814a2166e06b0d518e2127f2fc77ea5b6f261302a5a78558ac990b447373dae56812203a529e689747f0614013a707a68cb0e4d607efb3e4d06a2fd1364c0931a5ef5d1f863168c6083b3a6567d76856427a67d59de3ff513c96bc9f4a6c52c3ef67362c74ada0248a3b919c38c4ee8e9d33ab723f47b943ecbe104b2b509b7f641244b290b33ad34514973b0c666f460f23b1764a66179c093366c8b955d8a1e7a00304cc774fd9083dac9a4f62beb58079f76f61508fb0148183d69fee956e97d6a71590306bd83d5c4cf128b9cf7815253849e8fb66848778c53ffb9873707f034f6d164e16293ffefd5dc6d881ebf8aeeb84a4bf61950f46e1856b4d422d9ed83ac5801ecfcd62d0945a881ecb7eec6d2ab6a8259466f1cb3982e4f05dabef61f4ad1ef6197e1d89fa6c137f6c61f2ac3f05b9c45fe05c91a150dd6b5f8bf6cf14b7f0c7842b346ffc169e9aa5e7cfe2f35fbab259ad62813dcb99ef14e13461ef03dc7c0917818b6996618929ba7be6f6de4f2a294063b0028bf1054e96de2473c17eab9d9139d77dec646a389e304e2baf4820fda072bf5c3bcb495e5e05967fc258a5e7f03541194edda6376f41c0db0c978bb553eadaa980071557feab3ff037abf3534536c99b28d7e9208639057379f95f9473cd7668ccee7e0f61885d0312c93b35591df288b54624358fe2deec25ca3251bd64d27ec250aa09e939b1aceb93c1e484291e19c274225809bfa1b450b558954559f14c4951096914da195b453dad4ddb16f540a22432eedbc4a3a2a4939fff2f55c5e402a353c0ff0f6b297b84b4058d7517df7348e8702f6197151cda8ee1ef7ac6fdec2cd97fb658e14cbf8e8b62d0763c574ec80bf9466b7e6f08430bf7a5708b724b5916d26f98099081f3e069f43f2e62a828a1a5a12e6a05570d8f1cf4490c85d232e9f80fe903c18ddf5ba62aad7a915c796877fa410a5e8ebaa2a8647c0df486c85c5f51ae5e692f29691d460f5692b8f7fe0caef6faa05b451ab41379738ed690abb222f8c88be1409884b95221cd5bbc895cab98a4a5d05886bb3196466265a1a38c2cf9c87a2d6b24fb76f51a5e3fbcfeb82ddf16bd015eb17db38cb7195bc91b0fd3f4dc97fa4e4640c24522a4e258a24f48157cf58977e68f039d047fdc2d11eb8dcbcbb79e45be5755d4616e630c55ed3e193268d985a876c2bfff7dfa3b81a77bf338b4a1b919a73eff7de85052eb44ff058e12bd9fa61469332fb244cbdd27230d86fb76bd68de461071dbd241788242dc49df8777f8ee64e0d3be99d3fad199e70f99b9c3a10a06793f76a7f840a184ba292ecd1c626efeb89364602354e8e93f5a96d82218f4479590dabdc92ddca9e6965713619f6de92fe1bac65128635b484bbc68176fccf10d9bfab022ae378f1deaa01e88db9961d2288c995edabcba480d560a459d17df714c4b3daa098e0d9d0f9e5de98c104090064d2e0c44e261a8b3404500c79a74a40e771c58867254c5401a886100042bbf0383b029165b89dc9d6e64db9464665eb69f763d01ee703ce2531af786e7b502e2d5b8b389eb99fd84dc52d668d1089ad77bfb9bf9a65c992167e47f745c3d666b63bc14c6f01ab5d7a5b376c76688acf475acc2913b394144b93684e0a115ada70b731951d9423fbd69f15b16dec3b5b76fa2844173aabeb1eaffbcead7e1a0228365965740e5924c826c5231ab0d7c541bac6a2d42fd474ad50803e24182a7aafbe24eddd47ce23935bec1d2114e2e603bbaed68dc8d8af47c6e34b56416552db5541f56125369ec303e78db946cd57812e222c272dd141ebf32beabd0506099c635b8663ba4ced2663dcc491c58d7c6287dcf54bb5c5a3bde42dc20222ef472a911caa9301c09ea1fbe1bb2a0ae71a4efad8c73db40fc82b2bc81dd8eb33f5de5e5ab9644abe7d073df7accff367ae0afe6209e72a7ef4d9d69b80c26cfecad9382574598bc0c79b98fbe794ed0e45dd1fb3faa7573d1852b917a2f0103914f0944871de6501916fa9ded37ab20cfb652367ca5bab49a061dfc8c9a4464767062bad62ab2f5bb704131d22603390cf75708cc35caab7c674159700c4696329d0f88f7d38b4e53bec298da8a2c5daddb0c28f6f7ebc84932f3e271787f10cf3ba3347e54c10a794f4056572182c39c037e1d972c30805ed6aaec55fec9883bd15342a1fed37c2ec0833b11866b215a8060b132fa61ed6dc8f8a5187b971682aa754eb9f19ec0a693b152ea5fc4b02b0fd5782afc7d6be9668a1d4d0f07de3d7b778620e2921372d2e5017e868228d269b62b65fdef3f564bf56213ceef4c8a3a8c1a1b37e99aeb8303465e45b234a502582af2a85e456c13cb6bb9123fc2558a0f9d27628c21f944f48c5f46f4f960c5f21a8f97a433dab7e32ee355745bd28334ab9f07ccf0b550a71d9616aaa7b97135f4b696f870716b441abd7820de0589e4e8f49190b19c3ae3c00bf305999b08e879ca07582f796a515acfbc64e99437d4d3f0be54c314481eacd5f35bef2a51e616fe2e59413396d24de055246003091d8218b4716b20e93a83c47f052ff87cc285e8104c25d6718c702d2f8c2ed548502ce723026894dec8438cd9438a762c693e663f6d3fd1afb80ae536b519b835ee053c21c353b94370c562401033f7e1f2275eb0faaae80d8dcce400f81e7f06ecbde90fcba05d079d7ee584acf98d9d8826b756d09c95270efbf3f37334855405f10716f9ff0f9507ee6e4fec9c18b0b3d07683c1c8e00df5ead0719ffbf412b121535a962571e408837ce8a9f6943c8b1898a0ba401ed3b30f2f691b8bb01e9332efc4a76d5c7ba3a1694c0b422c24f4f76332e1b568a1574ebc1af1e0ae8155ecea4623852ea34f2fc40ed0fd0aacceb38a541c70a30b6714b39131425bcaa80eba1a3545a11ad183950b3b3ca514a18306b561a91d1890b81553c453ec263204f8a05948b8178c26a33fc845881455a5d0314b20e2e71dfb028cd84a5a7b7def9ba5f11a94a5d48591a70d222f994c84d7713694879e36eeb9925248df34d3c8fe27b9a1602b28a0cda0cd5c06ff8d4d899e680f5aec4ccc53ef56604b842052e5759318933ca0d5ff7420c2b083f50188136c234270eb7fc14cdc4c50229d05204a513ce9160fe23683b8bf4277bd30dca3e37162ec14f66355d3e11f128d9f907b996b4f023508340785893d01de95da598704d0307d97562dccc64ca82540b7bf25361249fd750b7ef8a215373d5d87047b957da1a654799cb6893ea257f49d5103a730fe4662eae66edeecee8f4eae03b8d9f46761502419851587ce9c9b3367d577c4c7d0ff308ea12fce3400f348f17e29d2d1b0fd0c400a5dae4009adc51e90fdcc292051e2a8e72649acd5374a07d33d00d068437c4489644b065fc0c8987534db0507296e5372294c395a285a7db9e9a455a04fcfbd3804f3915256acebffc1d934d2044e90785e584cdf666380a55f4231014c8d8f05f63f17340fa8dc6b82f0c36d8aa4028ca49f6a7a9cead9f802fa4aed5030855a396379abf7ca6d6bed68c6ef8a3c2017866678b6c6a49dfb8eaec9058f597449f8b8c425b843d41c8535e10463de3efe156458026c3f47585e7d2c0f94a5dccc10dc36797d59606c9375619378561dff0f01c4b7460353be3cb5bf2f937544d1efbae17d74e8d0d9d71832a381d33b008a6a010ee314f1847ad037d45d229ea49f2973d633cabf7eb1051bcf831b944ff1b4085d36108412eb2fe4271e7b7e34cd91ed2cd5bf1ab56e2a873d112e55fec3bdca636a0381d55182ef2a0a2c8c2a6bec690cbcaae75b6eb3a421ca3d73ad5fdd4395b76ccc8b71bdfe6fd8fe5eba378a08220c06d745a608ed5ce6f1298583e5b2b2fcefff8041f7a0b00ae6d672393ac42b70909af78e676133846dd76974fa39a1add6ab40086afed17500c9292b4bfc7f4ec10f912232fd652a2018f92a8121e09878f500a72814e90aacae9fc9353d6c7adf78f696ce128aafb82756597d8f85575286b0f30cc9184434e5905edea5eda092fcd2c95a03f4aa93b64ce1e9a7d103968d3c5ac7beda11e0585518aa5b9957c061a03deab333261d398b53dfd605fcc3a2ec1354e27471d0feff1357ce70f54e31e44819cb098f3a7d28ce0f20fd941eeee8e7083e272ca2147215e3c0a6e7b6612d70b2c33aed8d6673466d8dc1e8a2a1527a22826cbf37f98a040b5b69c93e50c8cd9c8c67a1f6c925823876d11bb390ecbf40cbacf1e7b62878c59d0454ddff96915f40e8bc3cd721066c809cff0c4f5a50a13178af060689a1933249e9cca9748718bb690bc0bafad325f9902b6812d2891401088aa08dad80e7b919e139aeb39119de237ec689b23c40c4488014b4a606e87fddbfe60239772e00b7ad6924398b19c587578707c884a84ab9179ec7dc442c5d754aab39b752012690ad55bb3dd074179fff5b15ee1e02b966ec5175fb6668f30e5efe997c7736dd9c8a2a4e184cd40a0b259c25f2359852f66662440728121acb9650e31ae4c8d7ce73976a367f462da072118775f327843051f26afa39d1cec5efb8492bc7df74292ab210a8b6cbce5d5263269103d2c2b674bfe51e5998489a587333e570ea861817c5411d1e4ebd1534b75a745211e56d6c53580919ec40576aeb33c2eeef7c3429ee701bb049d0e32e4a628cde26dfb112ea28c349f750b6bcb8bae2a0da5c6506642eaf2320948b74c0450c2e239bb05782bc1cbb7b2b9b89e8599165673d5ba58cdaf7482683d36e790e8089b663ddea3682b8d84df649fc9673fae5c4d9593253aff983e12fdf110264d2d8be106d32b7f30362b64f4d983bcfc2ed2ea138a81d1cafb98a332cde714bb55ed0787379a4bb7e5593b6eae1d01eabd4dab0d518511210543bda1fbcbbcaaaed12d78ba365d0cad49a67d8fbe00782dba14252469d540f6e28adc5134aaa98a94b494326281fc1d3b0c6b604cedac4ea4f13771f22195c27118b90b0e42e79b5b9f6cd97b40f552f91378282e4db30ffbedff37c519919c2abdc963cb145d26d329e19efe1591a8f760fde430287df71de5ddae7a4fc327bcdc4d1826691ae6178eea39edb7494a2a9c54aa873e37a00ded5ae96f781468231a5399e598f35b8ae9ce2f47ccb8b88bb044679223ca7d60e4dc607567ea849985dd809ad2bbd5dd61f53f86d8e38b3813588d48a6d4a0f2afcfbaeb29eac04cb1aabf8534d5dbd147c24f3c5c7e2b651897b3e9896415efa8d4fa094763f43e2edb0b1d292798ccaf0177cdb6e47c261854347397e65d174566a15836886e175bf3f1b2a8c1005ac2e4d1d9052723b0b68f5c4c9503dc15ed916a997dac722e63784405603fcf0eb87a6bb76e995cb9c69a3f9b60aaa9ce0b4b36bcea069ce6601495b5441ca85e6796d0950947b0d10c391fcc588bcc9996f9461c63a84076e5c42b9a3c2459058ba803c4c57a174e46873b6f86f757a7e175d08e5bc956667ed92732c891f7f57f33d21d287018e1698dbe1382e5900b98f072ba159ee15c7e3487dccab74f1af867bbeb82998e02d7731a3f46da0517a081a7f63c0ebec5490877c71252dbeb07dc655cd3d4363ae8e36fcae883201a17b9fc4ea936d2907800456477b121b038b80f179f5029f7d34952bb2ff536726c750d485e98a185da6087cb893e3e2390bca327f4da81f6751a96a433507950fe209d3914a8559e5af9f1bbe94d64c6f26561493359c7aef62846815289ac04e3f7014f59564af3f9685c465767f6fd061b09d6e2c44d31d1eb9ea5644a8a6f07bf3294bef894e437df6f3e8226308aa871c96933027a34e2b82c7731c15e64b25d14aefb0289e09eb9fde6e4ec9534887c01e493129d31f69d955ca15e032cb4f283c4d95001a779b274010e5015ce246e5ce009b240424044a2aeffa2abf9774984cd633d982ecf0341408fa369924178d1ea55a641aec98b997c511e20ce8664f3b9407573b346e3e0900a121c3ab688c769bf55f99cc5f24d877197e80349da5e614beed8ea6516f16f26b1d60cc7555af71a73593d1a6ef99016336bb7ded65a8a22c3a4ed7bf5f00cf2265018f8c382945597ce66da129e828d39d437c672c847fb1b1d654a29078b493a169ab5995cce32b1c6763c7cc9f71e88e0eeced6c21980c4facdc666c23e38f62ce4aa1066cd8f91a4f2e12b8e78aeb5652c641738671b53cf2ae8ada747ca97d19ef2758dd3f0cda0796a8b6d14d30a2c9f26ef1d7e14809a57f5b3a0c47cd9da4d947b6ec246251ec07f82dcc2113a3b083b0fe67f19b10ddcf3a8afe845a0169a4fc101a6254231546acffde28cf0a936447414e317988f0e650eba7abb3885ef100a36e360517f97fbd82b6d724141ac0e9c24f7a2df07be84a8564e56427993b5a996ab1151bc1f5a33f4d7b5cec9fef35f0ebbee48c52ff7627744e2ffa8d24d817c57510cc9a212157936552095ef6ef802a57878dac88ab2aa13a6bc5221e742aef5545e82a89d7b87204f7e586dc0b161784a4e1e2f45aea8a508f5ffc0b609cb92461cc26186460b5503f730df026b6d5f79c8febae4e01ed47da1f8d378e3e40da8e696c9dc76d289f0d6ada80b772e5380609dacee0120ca3d3f6174f06dd8638c99b7551a346cbe304eed28ad6bf74a9e86b4f04b5def1f1e1b0e9a9062423ebe5570722c436ad54de6e661da21a80c2af995ae82bd413a3f4a273160e016e370e64a73a9fe10a64e1b551032634b13f8cd66d0ba5ade9b464ca19490b778e6a58de6732be579b2f4c8dba18af063f820b782ec524b52ba3be1415b1307eb7b0fcbccbade1ba8888318a6f94f87fa2765e789a4ee16db8ff1c7094710eda61ef54097c7c6ba479811625b53a1cfd72cc2cabd4c4f4ba2101c7b9cd5883b998c0d9cc1db3fa9f33753c3ee0fd73f6cbef9ad25076391b89110497e1ff1291d7bcf8e1276df2bfd9c2c5ecf4406181de438eab1bf91d3cd605c33173cc56fc2685fe36a684f8950a03dd5e22cb17208134025ccbcce181f6f72949ec1713e5f3830cb657828c67c8ccb7427376db8ec544b6a4b8094269495a6950ac70833e82d2fd149f152eaf957a746a540c3a93f5ba692de10ba4c136e1ff844d6b7e95edfa57dfcb4f39ee0fcad2c287d2d7174855362a3d2db4a720f589d5a51cb4625ad8fc1182a2c0e081cfdab295133d4f954abb313c02ef198db4820e2d28f98a6a9a070862e76d4ae6a5238b2590ba705aef99b2dd6538bec4eca3c386405679f396099264a8286319a67af289bf586db7f2be87a0a38d45b75193a6d9b941c35269dc9e66333abb90bad15bb3c42104b5b9441e8d417cfe56ef9e72cdcafac754a6bbd9fb7a67bad819cb680e25f693fab9920850949bb975521071b99be9612508839d1d7756bd3fb208b25b1c7e9cf629483a52d50d09ab07417fe9678e8987bb82c3452ceb4ce98c7e40a3ce0de04db9adab816c036a0e409ca37419fdaa91cda7d7234a353808c50a785162abafeeffd43eed881058f068cdb613d9b532bf91096c145a1b60335ceb893234d759322273c60f50708394e7b542f0150bda4d907ec33511c81aeab129267d2ddea9da86cd48203e2034cf197f924e76a329e7ece828b9cfab04f99abff04f6952e097c6db22754d5fa2301b621e0dfb28d983ad820563ad25f7d3069cb0bc65537345891f6ae4cae715c77c43d523c3069ce99ae8079bae4d46dc1800a30bd6ed969850e24550310a76f77ea9d6a0d80eb6d8aece9bbc8693a664c85271e9468fdb523fa39561ce670539027b6cfdfb7b68f0c9ce557d291da2859722618cef2895acdceb8e5552f479fb71b43d7c6e881b283b98a03746078d3ed8851daee8da106ec260b6b3da2d3fce6bede444000f3ecef96b30e8ae9b9b34269fd6dd262b27ce59f0c55ae69aa8f167088b2e592c4fa2595ee02d7f355584000f854da47c6865643726e485e93ab0b073f79e6e7615dd9eb158d8401cd614a0cc78f7234cb732df3d4d53e6293333b4f0780dd54624e7d152edd90d38f3d0e78b31bf62b3e40d7e6775430632b537d701fad13cab03653947e5185de2ee17630959a21b6a9660bda201f6da05e226a9e8ecfdd3361bb32c3ef55aa64e5de71a77e077d6a259fb3a0948620214e8790ac7caef2531d5a08dd5a1e23360752c6158106a568ef3780aca941a34aa677d8fa487d8daf506d655e0df1df87962c1acd42989d7831ba3ea45794000daea2b4a08cc0fd5f6b1884fa178c1ace4f4e119e0fb28dba3346eb021f672f6f14f1c22ef9d435b58f0198b4f525ad9afb88715db26b21bb6ac5d4749b9295c913f413288eed6a5a5660126c413ad2b35e2e0c9ae04a8e9f483e7f6f7c0b20e27890a201d67100a28383924c374e20593e8d54b99c76afe7e814efa42552ff7b57c14c7a854293207f4c65cb1e53f9f2b95f235997e8e3f9e8555a39019d29d762f09d91f147b9caaf62da0a5a231c02accf2a40d521c9ab0e14f1ce05851931e6534b88cc8b20d89f0075f63230502f5bd03d6d8b82d516ea019507a76fdda0b7848862a7302ce2ef1229498c0a4f8a9b2cc5a56dbec1beca771419f7bddbbb5aaf69d4493b247da562c7132a8d7a39eb996c8a7b8716e554dd7c9c29cf99b4abf6bc7f54f1f4eec0149f7c6aa6852da1cc1dda64374f53f4e0dc9ec0f503534eb2e6b463ae25e83eeeef3f6adc42169f5e12ad05c97592fbe2b9e3285a3b0b58e2ce951975d9eabc762726d4ea5c4045428425798dad2a0a20bc7ea1685aa2e55d92e0f05f4dc4ae37983cc19fc3ff9f5205dcb323417bd894668b9ed24b1c56967ba5d4d6b73de9004870cc8471d2fee17a4545bc56505c360939fe153965295590569531c690db1f8f244c272148531085b14f442e15a5a628c02c5d7e0b1e017e33cbb2f25beb8f77e9f6f6608e7408ca24605265ae459d69d3b44985d944541bab47d43b8c3c7de555428d99ec7921a70a54e262b613a8eeeed813ca0e7b97a38f0ee57370c0295356f22f822137dabe92e6cabf057a20656356929e35ba716895a1d8b226c4c34fa16f8c4e1297333696ad99af9b8c816897d4a065ebade20318aa7d47690ed8d0d2ce8aebe72dec8f978e094cf12521a0e148e8cdd1267cd92712adc55db6b068059c25ab5940fb994a7f2b394a838e0963c5ca0e30e6904afb7063387ebdfedd7bc88b3e941659f1d3b6803411a2286833d405a4045569c1eb550be88c962e49df2914703d937b2b53bff1b6fe8a3a94afbeeac680460c5f8f11d363ff49b4ff170f556e0dc75bd053d21f5a6fed3ca41d8ff39f621637290fc3532fb347c20cc4ab87e6c3a9d56ecaabd5d71e057eef4deebb0c539d3c5a40addddb66276b57d29afaf5f3cc8297047ce9b3b460d1563704ee29e36ad5dbd96b9577ee86db8baa4ada828f0e514e5d8b1b16ca402dd90590b06fee7115a8a02be61fd1156989d0dfe5f2d5d04334f3af73adc2e4908b2b99094c8bcfe90dd16a3ab970993de51df354f8956b5a5fc9cd69bf4e3ea1db46f979e33555d7accaf71ebc5128e5ef23d2f1413a14f6ff9ef9a5d8b47297c54ffe09017fdc2d4a6dc61a3487b3ba6c7e8fca3c87c15563c5c799f7eac977605e7c5ca425fa2d66b926fdeaaba12e9fb19512db126fa2f0ad0c63952e72d4a54e901cb7435af417b2951288f17d8db0806d3c1725ecba2c65ca46453bc382c02904a2dd9c5954b2eb72ae42fb45c932f59b640ed89d9e372484dc85fa0d148bfe37fa8ce7027ac85c5f42380b5b724ed681558ffd6cf5e0fcc69541e5fa03bda00c7ae1104bce3a5f6c5646123247cdc48e2eafe912f36fd2e5376e355eb3c5922d15877b8df404555e2945161a7c208c6374f0667ace9a8c844ba455addf86eb746664ccb1e183cfb0f229d3dac77d428332ffb205172518afc7f6ce4cd079e66267698effc5f963ca64c1a3b72dbbf9837d86260a6f06fb229579a800cdded6c3dfe7ce6ae210c11f8bf26b56c9a4bd749760faf4255a79d2c20a695ff6d3ea8d534c60e988e7f38e5ccbf42c97601d72c01f624433e4fd5a6bb64d557344c2ca6c12de7c3b801d10656750faf48d935761068f899dad8957f03ace87d5b86429d4f40a975ac908e360465ed5e275556ca826ce40ba7a97fc00214631d21387ec30406f811fd73918d2fcdbbcf60ac69b3229177b17e2daec3663543b486a10ebac90854420d3124d9f299a9272a93e302d94c0d307849d4077b9e10fb90c8d3f4cb1fe4d925b384de130dbfc77fab1099bd7bf13a20ec2c94603a34772ecee3600bc4bf580900e9546d295356d98535b06511e81ddb28a84d7c821ebd0bd9b526d79ce258278d2c40a995cc336ebc81fc8bca975ef704afd9e4f592457083da195b190000a9d8ac0594bbe4d7f3c40ca1066f89132e384ae3e57899653f6153144be17edfd9e60ce15234ec56c2ae2821df5bad24588f16984bb7ece0c3c9f8dae4f46f34d156d1d246e1488af7f617da371cea5d0c92a262a0f0ebade7c0dbacd2c6e986c7c978774dd8f305cd5de2f85994afe3482fe05fd79a996ac5854bdc6e170ce3aa1f59ee3fcb2acf75208f854a208e4c1c7b2aed3fd0989653e56af68a4513b1fe8832a1f1db29312a88fae92ce8b1a31ff141c691ffbeb4a6b7419bd3cff29be0bbfd087a6da1ee31a3fa002710df3e1b6891d7002683eb9d77022563cd0526b77f9c1acfd9ac56e732da893acaff276f41859886cc05c6863bad7dd6eed72c31b6ba8d8cbbe8adf40bcb4cb0fe0891a2abc758da05fccfd928e6e1499fefe7b3c514fe80a7b85addddd0b91ee38f2c80b186cf1e378473ff7f4d372ba514069bd9872ef7594069c0160666291288b09f9d08e52222e3d94894191888f6807e7e181e60ce74a94d29fcd3b375933ce2c3afd9d7dc6a0c417420cc90dcb6e6e9d95fb0e6889fd01d7eaa92de392d117c7881b4079f75f54c5da06613ebaba34bddef91bc98061afd184abfcdcf623e060192d22316370b865e6f3b17440674ec453de6aa07f67c28427614b8ca571b1975195dfc466cd043872aa9e1db5ee23ac6f573bdc682bc63874d81149fb6a859812eb2c9b721be26fa0320b74e85a13f8a6ed382afcbbca7652396ac0c012393861db4b27895f76f5747895ab86b1d106f31cfbaa2246d3caf91c73cc2d25c33bbd5d935c5e7fce1b18e1a268afa0c304218e6a90bf39fbed6acee1843ceb7aa650815c7bfeaa2978548d5c1fc85c195bf231cc5c23c2f6ce589d3f2155063bac789f8456919557d99e6d0819f89220e17e13575c7e6c86791f88ede21f1c30a30aabb5ba056e08c297f081dcca7d391de8a06860057979fb3e95fbc934267d133b1a988c2dce7f282f9f858fc557b99a39aaaddb08cd5b19b1eb484c67d1a147c8f662c4dead1618ebeed969b7a73feb9833d2c38e10c5cdd995ff3ee8cdbfd87183a6f1983948ea6f940b6c0d9f305c4f008750c6885a37b3ed0b31bc6e696926727c5ae554e13c1901e16bb29c28a20954ab09f9251919c7b6e6a2ec5e2bde94a6f4edfdee6b223570882f6c3f6fc21ce9f9a4d7a2b827ec8aeefa64c060ff46b851164750858bf9cf1118e873bef1d23d9fd689710dc997a37a61d0bcef5344ae7d99555ba2beb8b32d5dfe558c1c39db320727c83fa90a85e265765486f9c1a143415db7bdc7198ce52caf920cc6fcb7abea67fe8d22b1fc9ae9577cb9f3e6e180174715e7f913294177c5dd5858f5d47fbdd6a30c1bf18a10eeac389a374d316ac569f463ed678168f69716f356bb6e81ae3033799ebc6f94ee224f5e5814e5eb06a170925f6a05fad004ef7d7687a3110bed147e49b9a2233ba39589118d4ac63342bd530bc361bb818a215e179da77794c5beb2937c66e694b833d7bc0a5903e7c5009a421289fb86078f0425c9e071089e28608738dbd566e513b131f72ae14fe39eb8120ab9509e50e2e5079aa268772a2cedd874c625dbbcd4018f8df220daf54e46a47e5d67ba97b93e416c2adad95780642bdf3b84c2b0804ac1bd1db1575a066b469c745afc54170ec252c18f602c87de22cc0c540be0c35d06c5f844e50ca99af82461946f477dc4617feac4bd2074dbb88b119244c96ad7824c2390cd3feb21ce7d6b3df348458d8c83fa8e2eb5e0ef65ee7c1f1b7275cbda1e71cfd0614c16db8bf240557b49b4c38055cb707f2026b28924011dced6b60035432d3a51a0c177fc27875416d42b97081cb72947206110503d97c4dd8c084de09aa2c253b46a302fe6a13349d4aac79438a61d295d98683535d159730a7990204dea3973e69229744dba8f2476352fa8d8cc4462d53b278677754ef0f9a4d15dd376fa41d5b1bfedc360c8fbc2cecb085b39c73665d2ed433c38a8e536ca717ff935f83b59132471a3982960425ebcdfdf550d99c8a06f6bdcd362aeda08e52d1d048d00d91c4160c4de28a087c4c408be4922fc274146d103a9686f8763a3f0ba8242a436d2c3d9fa10be30140d2bf7d69401b5d8da041152e0039d15bbfa26a868b87f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
