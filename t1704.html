<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e5fa6dbc24f29780088826d98d83c694f136447a4b170e501a59bdccd5002700168c6a95c049b80cf50bf9b46abb2776a36edc65c798e4d65d741dc951fdb1178e4437cc87632b11a1baa3ebf819f5f837ec53f44f9f5c0dfffbd550db43f89a38423eb127e5b9112db345e6803bbf8ef0ab74544309d4eb48b58cdeded9dda563791c320a9e52829ad717423757a7e2675a32fd00258f0b63e06c8bd2f082981f88a1e82054c8843fdc1e38f313a34dff33f32e97252ef1f9f46af2b2fcd3bbfa17ddbe27e75c91fbfd7165c3250f0585fe76e748f7a54573396ae5f482e8a5b79fdaba95721b1801fac0083b647e5f792fa0b2d6906dd72abc6cf5672636926c77aeb976b70359d75471be106871a8019f7dd5da4ab700d625f896cea370478b2b5018e5b69b4f8dcb826164dd44ef31f55f4b2b7c795c27f6562721687324bb30855eeab9cf54a6375371c9b7498949dda847af5cc819bf6eee603fc97499f37137d7144741cdc17935e77ff4e5710ab6d853908b1e9ca7b168994ea7580c9a09b8c00d8bae68334274ac3d87744c3a13177a14dd9039de2c4d2c22ac5603b9ce30d68b3bdc55c45554f8f0b6576b467f6a06f981ff24e5c7b0049a86054b52e74d877ea4da927d5d354fe14dfaac8479623ebf125a85a6d14ce87d034148ed5ff69d7c59f0ad78a4f4282460dce3a89bf5aa5d1a59f466d668c3f5d95615249b8b2a50ba3ab4606849fabc169dcdb525dfcf9a71216ddd051fde8e24554d31163a629515818dc924c96a369c151aedef3bf09b568722882eb0e1b56253ee574c2b556b232f8df50043ff145736f827883bb5fb80823087311d49b7f41c7c74071f01a51ebd7121b5fc42842bb04b9697e556dfa7a14a8073adb427efed43a0e1eb76b577f46aa46079355b1642cd695208d611135794d6e4cee71d036fda114a3032d03cf0cf06c08c5664641800731f0e6212adaaaa03366e1852d05108609758840e5f3e821c6d7e6fbce506ffe7d891a92cde35b45b1fcbe66c58d87899ac6870f8f6476c213b9ca41d0e013526a63a11e388863bf8ec96721329bd8ed67a4b86785da6eaaba6c1f700fc06c392f5ccc4309de9e7c7bb0925833d2c84657e7f347e83055594e25aeb7d1e52c28471687ca8e7e61a1f59692689db9d7d4449f22893b7f7eafd427e51bc634c8bcc969bf1cd1b2346b51c9323419fd441aa5b8331c7066358958c495a534307e563bea921833a1a5bddafc9d49cebebf6a248bd5189d236c550fca0370d97757dd9a07b38dda61b9bb5aed7a298064ddfda463b16c71887a17c828d695ed53348604864a31bf8146d10c4fcd2ac515e19af60f8016fa9d5f930ae4692c95b096f1e35559404b6d1a4d15eda9f29ed7e36597ae42fc6cdb45fc5e687fbacbb87a4fef31e103934c930679d3396d80b66cb92084824869c610abbad592a04cf14af3a14f9b4ac4f08cecbf433d3e6810c5f7305d611f0a4e8dce5ba68e46df687047dc4b2cd48667749068798532393f8da7273e8f255a8f31ce9319b07e5d257f18a594dc2f0ad84869dc09f446991fddac936e71e6b0da6cd819d9a9839a95f8fa64c9a2ec00c2a3b5168038c852c18828b0cc7a66915aa57b72e71f67749fc04a56fb83923c2d3d0242e9bec69bcd16e9ca956a2123b3a345f6b05faa7830e91462889b1f235e58834c6b1c91785676a1711e22794df0045fb791e9d9f6dc1677dac61ea8628357ea73e436eabb5b7384f5de318cbb9b0e0e957e7e691a2a8c9147369cfbbdeac87f723b63ea8ac773b1fce7194106e5b62ad58539a3ba6841449dabd20348476667b9ff73746244cd41b63545c762185225d566a921e270bcf1477461efc5f1074bdb0eb7bc2dabb2ed0354074ee011e712ff6948c5565c2463b9cf4a4191c8fbf6337dd40534def47f7ef40e48fe051576952059b8af94ece1bda04de86d194b36d2dc3d2dd1d182f14bfe897475bf3bd2a8e6b3fa6108d597a4ac3c3db2ae2f2c0f3b9d296f4343a088e647a1e4be776e5673423aa731f92e3e85478ec5abde8e65b6967e0b328f524295b8d88ddbf6dfbb6f988ca55086e2f47db996346ac2a7b5acd694c5e00eecba11b4eb83fb1dac26b5c3da58718ed63699eca69e03987f7a812a22c458d9c02c0ef5c22c00ac62a52260d4493379101d92f11e3aa12fa9159e218806bcf728ab9770c1da50398051390eac099b95219afdf076e0649ff0d812c415a6e0ea7949a53e25f13d35a3f68bf493fc2919bfb4702ba594fd3c4214c36bffa5c79385187d5e429af78f94e463f4540923a5800d001e4e6ec8a99fdec50250eeae317287f2a3e5b2376575d5499dbcb37c93f92890f16ef378d9cf7e339bc785c5929cfc55f75ba1db379f082bf39c5bd750722430f5ca3c3555c15c8b5836b392ea4fc2bcaf1469fb710046c6d3bc23d2a3900479a4ec3a03a5dc44446507c32fd01d33a89d719d7ed3eb8f7fb218ce76e853386a1de1777c77c3c87b891d3a41d5690b14221a10b3c15c6239fa0567e60450e0a24809b7b275fa43fa53bb7a269dd0dad1c3e5afffe84137af61420f779088396497f8d816a6a04b6b8d854ffbbd7e93921f2746997b178c5a3acc905189b6e90b33957649726f50ed31ecfb8f405f3486b50f5cf118118c9b76fcf4ddeeb646ce4681dceb5e32005757587d78c242121ba161b38024a529108a680aa35a7b15f7a58e0c46f25e0f4ec173b28445d8e2499f6fa0f584d3547bf3773686187a802b8b3c0a92502ff0dc6ffb5149e881fef3609a6175f8aaa43b7dfd316a3c47f7a9bc7767b23b81ba2d40c80030679d072a3b633b37562619d3a99bd042f7c690ce01dadddee9985806bb92cd747f4e216413894155e0e16bb6ab99c9d39537efcf2d3283a32d9dce1995aad6763452a978205246132b49d0230a52cf58c5406ae53ce40553f60a3c26ff7f36ec4e4b1b2942e79c32c4db49eaced4233b61dbcf4b9ed8646a3f43de93cded8282a0ae396d00297c707a09d4aa803239a0f8b5a561e0bcd566c4590cbea296ea3cea3b7923f54f2264c064fa64798c4447fd1287b3594938eb7c57429d67f7e1ec7e46f242ee0563f0638df519c95a0d605546fbbcab8b4c466cdcaf63c2f98147319efb3110dbe760bc1fc1bb4f1de38cdee7d58171dc622e19ce44d338d800b0ef17479a1e6deed5729453c42b1dc71cb1d17ffb1c5695ae821e092a039281879dbc9417906d775380ed5986529f6456e57700a7e2d80ea41b682d653dea5333228294758875a94512aeb848fe4557e02fe93917ba97800d8220e3c3616869f91f0a8958ac821cebcb2d13fd0ea6c19a08bd907ef0a7e0c9767c0a8c4df5efbb200005a800c207be727a95367ce5bf1aeb42e62a6114a02f6283b6b228f9d4b59216bd14a4cbd184d9a9f2054234276e3df8c66940557b00de6cd77c23dd5db81354782d570602ec528e6b3035853b9bc7bc20959a82423443239df7b64e2dd83d987292bf48fb7104efa27a6d1edfabd9b4abc4d592a022343af48143f81a895e633adfaa765f0c45fa1e32197b08a020a7dc22662a9d938657f05b83ccdb3ba9b4496dbd852977f861b2b13e83445010c98fcad4f36db8d946ed6bbdd9325564631ebccd5208665b025c63b803af86e10a24b04d8ee0088e903b13fcd06847b947fc74e01f48b3318cbc63171b493784fbe804da1f860236745a731d786a2d4ec3966fb417270c9d82b482d3489a64c229f8eda6a4e01c367ca6386c2cc9162cf6ec244652526d6aff5b30cf5272e18f68fb49aec27bdfed7a509aa3c865b526d7eaa952bd7c1fbd7e4bb1016989df48169dd6cb51774b044f3aa48a0e7ba887f2ff2df866c0f45366fe9804e1ef37bb2043546d5fd970d02e8484eab2fce73d9e6cfe87b6d5869d893a0f90fe0a262a7c979c46b3c6ebe4fb6243f023269dd46966dbc781eda5f12f260e00a60808a6abc2d35daf580860ca70e03513945159d9c4489553d29a02f8d3595127be92486701ae1faafc953e3ad9095afda1575ae9a721b3e507439144e8d69eda4fb578de2cd6b42ac7cf68f6748c1deb88bc1f997d0e4b782d4232235599170b5a42fb7661a7a518dd35c09ed503eeab3914d8da0d1f4e605aa75518c1001d19ad4431dfd6eacfb6862aef3934a3034d3a58bdabb23b696b250ac975c2fa2feea60a93f8a1588ec07ad66ebc63448ec91186279780610a33cc28c1f3d902fd16ca149236cf679163d27a65a721d8846bf3b8c13e83a25ef502af74f7a430c1381463c551c1c7b148e69b8364c67a75d23ae448966b938577f008b14ea71775de7eb5701594d68c650d3e5db805d6500a8b4d4cc712e3df5f5418db600684f0a94f6224f0885bf41be4557570d895e3f72af970a2995ff803e457461c99c85ec8d05866c2786c538166415a7791bc080a092254a668e476dbbaf1d5224b990152e63dbade00bd092c142a859287590ad3e3ee7ab81ca59bbb658a2616d4f1202e173f461ce928136689132d3e482408c155f432410bc7dc33b777726e9a9ed28db9b4bc3c9ea2f3eb842944b0b1063ad465ea27ee3238136fb9890d88776210bfa7be622e0d5d6424ae289b7024829885a252cbe0aa2ae78ddc48fa7f341ba9210759eb5b4e6ae2676cbed73a3a83751a85ffee187b92fad8c649d22b210534fe5d950d299f2976e3f059e4831f4fc8259e10f2a5757dd8107785e6adbb3073a21476fc2cc8f8e9366478a4720bf09ad947214df9b330462fc215abaae437e72a9542b3dca716ddad2fa038dc514c8a00ddac7767be2396e44424b4dc20c08a06e1940cecd0373776352df82c8a44634a0b8a74fea596c10bf646c165cace7c105b28da2a74074c75eaf0efb5ee0b9a3c97e9f4165a636a2ef2a949422752a21157bdb43d727d7bf2e231e7e5dcb39dcf63bfc020602155c99086d9de2dd58476a80efd823d3d45040a5f731bff361bb5a98d4e2f388216df33d337c0e3846623b190ae7babc058d56a802d55eb8967543ee191ca7bd88f74e58706466a1effe0f4a0a5e11d9c2557da4c9cbf520de36be8d77172aaf15766e9df96ddead93cb953403b8be71dbf7f3095a09d19c8c109021c2e11cf449eba80c394074f5e7d6cad9bb6db945e7be0b15a17d5c8fa3568c78b9bca7af332508687fcaf74bced351944a29c8c6b9f0abb32fb4ebde8dd25cb59932e2fbc158f95ab2d03f4d770d538772fbd1c61ef8c97e5ece52da1ae55408b7c198e838ddf22dc5402075bbd128de3e5af4bdb79ecfd86799958d1e06111ba2629927151228af1ed6007973fb78b2751ac039bf188dd437d9d2361173c8a7c5584b311356f47dfad65cb39e50ef3e0183fd9217195316194acdc7239e4703db0e0830ca77d8f5821be9003da0e2e260bf6ffc0541ad5de00816c2d3bc99c0725e2bee140019f1a60f1e968a270b4f4510a08944761a4a812cdf9583bf249629e3d42b630d5d932e71b92e912cc8445b603c946339d367a47aeb9e869ff62fb772df327439dd0e72e47674eb3c4a16036eded154b53bdd32b26c6cc69482e45caa3977ee39468760a8d3b7f31d37eca7a500459841b8256cd11c20a2239d844de91e4ac673316c1c732a965a87daa9cbd6852ddb5d9a6ed6bd0f235c81b5c91068d20df9c31f7cae51ccf5c79b94401022dd61090169487edf44493288beb0f36e9381d2cc0c30b0fe6a06320d6ca47f4855332588a50c9ae64ad759963324351a10318c82e0d57f53060c989f0a496c4d778509201345f5b3a3c02339b2f2d4d85a304e7b1f8d33573f1204380ef104f9502fe1f8fc74d0fe355d2fe30c73ff08a0b235f03b5b1fdbb01970f24e0a650d8e85eb6c31b67bf3291f31f50fa11859ce412426a2b137d73d6693e06d2491d000ad544a5431339d33533c25b632f913cdc5c9cd513dc54c7dbb1a0982e0d80efb28f66432b3c3021641963909ef531af7b1a269d20c5bc864adf24bc0dad22b94ec07e7d3377cdc0f65faaf1be90dcd4bb432cbb42f277c0e430b66fb14cf808e16bc292ba4ca393aa7d00a166a23318ea50711922bd20f4d94f6ec4c0675be485ff3a8890548117eb78a9636c7b3c549fbf2841de228b51455aa299e25769e194fd14ae1012e589f45129870bf1d959583d36fd4e82b5218a62bf5bbda5c19d584c7028c79a31b80741f7c0b7f1e9671fdc4bd656ff26805d155cafaf0207d9d0c4af0aa929ebd374e2dde48e41db021bfd2119df9260e6201974f0a940b54d9fe3915f2ea4fa01207c0ac4e3911e06ed939bf5cd813dc9ac8fc5e2bc29dccbefd62a640db96f4a25d97d831cf76953c67e47296cdd9653a8b322de324dadcf610f4eb1a398e07cd4c69e04007b1201561415cd556a308c322e62dcf6918c46e4d4329a5a80dd8c4f7019f503d1dd43b136928424faa7823893cc1463fdbead65f6f84bf5e8b35c2e7654b3df070aba2571c1a993fc75d2c0baed0140d32a9b96d33b78564af4d210ed131f2094fd8e62d96910039396d8b4061e99e6ccf498c57537726c4799488fef57be819ded8e3b1b87ecc69b830edd92a1535f7b8fee4074b0d48a3e92f6e4b0b5bbdc80655984d4f587032fdb77054578c0f27ed05d5ec993770432a18c6176b856197c761d7a85ee5437e0b0d1a624e8d785bd5f0ab60f07593e828104eb7bb55a05d7cc712d35ad18ffbf3d47ea587e2043e023e1fafe56edb83778b22780cf08a05f65497f709437ec02878f181d378560819d12dff7c8e73db9954f076119c8a4b42e281f2fe46b4e01e069b1c7dbb73eacaadc4b2b2f5bcc46697c2baa7f55492f454d252e820a41119d8768f9aef60c8b5a65c13dffcd361bfad03aa41cd3f2d48c9d653605fbdbb40c5aa1dae67cc140cc06956abcc5cce01ec66938b99a586e48969fe6029b8e50494c8ffc769bd2d70b7b2fee250e0d67b5d4851b9c40bae55088257d47857d87a0c094374a18037d40c69e82b3c6199c09ef574f700cf1f9f6b33b98692297436b3045e2580f4af83e25c649b810e8fce21bdb4aa5cec5db42a97a198101b7480912c7cd399a0faa7ac7fb52c8ad64d91c7e955637c83eafa804e4858411b112006eb7565f1ce922b3162e029245cb9d7abd9fe8795f738c510d50fe544b4fa01bc7e80da3f8d3765adf9d8b65cdbf1c5888ad93878dc9f85b324bf4513005b2903849a193ae3793672c1fc4ce43219a97a53b04ac40788a7d43f42c1b39109b546f1425c254154dd0b11f92774ac32859efe1dab4fcca4c29a87ef7a9541aa2ec5805eeb74181c206b0c43152f099fddef0ece6e1c8a182d835a2f04158af5b82028857e7304583555d80cf249cb8fd448a031443e423b645649ed257639d1996b35c475448cefef8073f52ff12aa0f4f6655adbff3e5557292fbe4280b55390148dc6159f6fb3fb478380497afd33301cfef8032fc572e17768612b131c7898b10adfbc97f45bf99b1671b93cfb8b4ac9de8102f4f273a28aac41fed0b5501fa360e77f1db83c2c38672e69c8f80b90433cf95bf8fc0b3839d1c7a6ce765c5d223aad95ce8299b99b186ea1f535869ebf6f9bfa662704cfbb49c5920926cdd99b30814ef211cce5553d2cafea6d147c03c8d9f2f9d93886134ccc24390d823855b9dce53417ea159946cd0d878834ab350e72b37c251e79c8ad2988b42225141164cfb225cf5aa8f4fb021a3ebf3ff12a5f511412675f96529f45285587c682aee5fb7f718ba20cd836427209291776230575df64d3baf4c371ae288517dceae98b2a621ed8e1bf303ce4631692de075756d634298833ae9034a7504e2c11a906f8cf187a8a34cc8f58222f672765dce5806156b9ac87683fb3993d7528ea5280a85ac9070d18900c13f34aa740d8bfdc4c9940ffffbc1103e0a6b25f2dfdc5a6b88f9a4ae8d9a2aedd0d92ba8a65c046681d392c33cee7df52d8c581210003e38e0061129970bc16bd450500f1a44e498fe6865c089e49d5247f7a01c69e127bb3b36a68977726e89674e33ae5f66df7ba40688f38577ab7be864e2d56b691527666fb72ace551d7b2a9b6f5bebbe4d934facfcf77edb9042393b6de3692cedeb1177a57a500b023be1e35eb1b109b59c1f39d2f6ac81c15d1c5bdf873328270a1a72ce7e9e653760bd08ef25be2b3c7db05b54e571443406993144ab816eecbf4df323ee78de79fa6abbeaabd8933c77087bb72a64c57671250e1c80de5aa7ec876ef7c306a787260bdaae8d3667d60c4532b6da63274d569f58260efb6ee6b1b06a23cb85bfcd7470d8d5d5190fe9881233bb3cca05c1142519e94c81586c5a9c82e3dd7fd266e1a29fda326c35dde78c399abecc8bd48f1e8107ddcea784a88650db92fcb1bbf8ee1f46d283e27c8755a4a83d9ee771c13617a8a4c7797f8dab4d89113c74829c32fd33c64307d2becffbe6f4cc2aebd4813305a8dda4077f136b9f6f0032c9ce4a55d3dafafa0aca91f9c2f80ce84bb5f66e2ab038bd5a2f6a57c86f1dd1abc0f5a1fd8cd0a0615160aefa8818b7d97d54752538c7bceb6f63a3cd6dc0860e2e57e8c784eaa4b3fc81ac22c1df366828937d406d783c7f2561bb05317cc0399f107e6f8b341ecca649078c8e1377fa5f282622e7c9231afeab7c221bace95c438e7d89f8470ebdb3643c2af1558b20f9bb5d49f13f99d171acee0a8743f20500406fd4837cd3782c42f4dfea262d8e90ffa37cc1839d93db53401a34f4b9990705b5218c76c076b664450672de5990c091b0d96e73191a2f772a47b1a3592a32039731616498a1e2999dfdf4d7189593f943ed8bfbc3bed9d30056a3c6f0c42971a9ff6e80e8196c6d5caee6a2e7cdc262a2adb4b9743b868d128e4a15e9e33916909a572b33e41a4f8e732f7638e2a5dcb9047c8c2aaa00db826ab4a028c3de8b4bbc44507f4e52e9d9db90b5823423847543b8265218d70373c5a8eee97527b1c36279b49e57ff894f57247f55f5c56272e3eb3ccace57702a5aef02b86e09e77843ecb6086c46fb1b40766a460d7abcf58277205a2742455b50583205c97d2f1c246282332df286219fb5b2edf2246e6ac38d614ec86a3a6b0856995fd0d8354ccec48f100e0a3dbfe73407fbe8f43c4a9222079db5e77e198fa3ceefd1dd77a0e3550d8fb9bead4ba04a96c090001b74deb63254ee20ea7e4f3027e2060d9c0760edfcd30909a633db93a909fc0266af6bf2b5e6ff413ae82a05e773e3f9419150050b83b8b79cac46bec1a51857820592cd9a68fdbaa13d5841a71b8d3ea8871308097947172f49550c21153936242cd0d6a42843ecb729a4a6b60bcb60916ad987869341b7c67dc9aeda4709ec145658c5e2f59294d368138a28d263bf689ef972747dd0d38559d9479a93f312b2c3ec075aa7f94c2f7b5b19395c4d5318eac73db5d4d32be16059a41dfb4f934c2a48eb931b30a56add0201846bc3a76e91b1f7d772191fa3b8446c78fcd07968c48c2d91bb3a94315896fa6cb3d8eb0a73c3f7b95341ec96dc59a997c53af728cd217b01bd72b89b83eed0b70db415f269771db209d75aed16bd4b8c5f53a87d1ae190382b32cfeff04953c9ea26cf4adfd78474ebb4c28bdf149d1f38ff9460c594e500ae317d66592e97271353f4b1369878f08afbaf22828c5516f28d164dc1511a632e94bd527e26b460dc61b4269b8b1b608cf871d7f50cf4497837075fc67e896b1842f289aee68f3a67f7906e11d6c3fe87a4cfd6d61220c6b87b53d7464fe5dac757848e63d8a0d7c2881fcd7efd2e4cb86f63a0ef9fc58c7394b6df64d7895ade696e7d4f1d5fe1e2de001b62d26047c95657ceef5e25213c299f57c381822027e28db6aed01c1cb02ea601331fadc8a69f33dbba597a8f5c5faef68c3b779c9c28f5ae9ffc4219b8fdad10ccf12033fc406c865fe759d4d2b0c929a345e6504488485ffe4cfdcfc5fdfc20721f9f0cd2bd4d4a52fc4e3b74925642ad36657987b8ade7c87bf468a4d92f795ba55c4202e8ebec5cccb33157ee6205c85640cbbb543a7a16500391a3a4e6b4b68e2d6c2f754591841610422dd892d6bed86a22946bd376d4e52f9c40282a4115d9acf288b9815b93bf29b53002bf7e572df3485df867fb8ad15c4c4a16e9d2dea1ce50920cbb8deee16806e947b40203f7f0d401f50eacbff7b8b3149dbe4a5b6db000920149019d9306d4cb7d6d238a134795172cc9ebf0b5a73f3e889640fa3ecf97f31d66c0569fa9ba3c83c65e568a36fa2ecbdcb1420fdc0216ed7af32c0590adea85545487f0ce9bcbd13cf3af82d6acdab81e5092f2f8c46a1a6999324124b46a3c86dd1086edae7c392cb90cc9ac5170bff4b771c26a6e160c08449b905521687473e05f5e9f73680a7fac73f427f300fd3e650e561a3b9f844d318d4ab8900f95adf9acde0ea4f9b38f6a60c0f1920fc2917c699a8d2ab0b85cd408c31ac834a2d531e78e53ddf0148001e6efde5ff7258bca68f1a2a1ee1afdacf7003641d322b3c1494eb7e5b7f75ebee72f96e8f865b6f59937cabfc38c1b378ed9d211c967438e71027eb0b8b5a36cbe85f2adb46d519e5761d02a3eff4951dcac9c420cf2ee51e040f84068ff1b6219ea100cdbbd804cbfd6cfae04a35","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
