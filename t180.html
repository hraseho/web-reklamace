<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b828ed7bb276662a0ef3696343f131d2e406948a32dbbe1a7fe847d4effc88cfcfe1a220e5e96e5879688392998f4494e42190460e28de7a6e4683fd4f9501112ad6113b8c8a09778ce034420ec133e622d880f8bc83a5722800a0e950871208d2a46bbff8e57a09f3411b6590269b837c53c8de73466577e07d55fa1afa1def918317754f3db065fb856258c554f10edb2a2cb2e34217ca26754ad4138ac6cff63c2f0789134c97de5a69799377a569b5c41fb6b77a18e483954da97e2189357b22dd6a926a97ff6435b92b5d137c150de1ad884b62d48c30d7880040fb1d6f9ad3358c530c3d63607f28c4bb9706e04b23319c50cc864a10db8e37ebfa60c8f3f0229c1c12f53793312ee5de803581aedcd9a843ce76d770b29d6d06d5fe4bc9bdaffed992bb600d0df40eeef9fc4115b222180b332435f5dba1e006d2dc395784f03dcb194240406d05f6ff83195ed2609621c22099403f103b03e6b72b7b436bb47adb66c3d129cca96b79093c23870d7b50183d35bec37a1a68585a9064b3f83e25b002823d7bc1c03873daea8c50f713a7c0c6dec7ce73325c29297513fd0b1dfbbb8ff6623e5e7a754ea43483f6e47b8620d7efc82397469547721a3f1cf56895162179605030536b0a8802a4f9d59908d8fe88c80879ce0c70cc77c6fc605ae54bd08984824afd4cbda57f9458cc916b2b7c2fb1748ab61a90ad868b2be53e57f156d8d936ebad561d98584dcf822ebe11500b9afca480e7eb44ca026d45a8e7b8b93915194fcca22791a3ac7ae0ff9f644cecae1cb53bdd3d859bcb6e894c786106f443b0429ecf33ec9f3fad228bab4baffe9118363d6ecf1d657e9e5852b496615940a3ac7af79407e309d6d35a4a6fd9d56f605d7fd57490e5076518f0c04ad6b0855f92537710e213bdeae139ae7f7ddffe00243fd5d284a1f07ea71b7a8e5f5be2c123a1bcb7cdda151461174d6a5f451224ce8c738887ce78f92bb0c150197629a26b0d89033ae6111ba83120c72f90bc421ed7be726af3363a21861c52df86dda39c9277ca9e11d9db034ec0b12468d840b537396744fdfd34448c0ea60d3300f0824959ba937376ef579c7a29eaa1d9416a693a99910bc1c13fee83d392a7547d31ec50f4ef6103f30475c8e55e14f526d9c0a72631c8253093ceab0ab5cb0cf64a7efc30dd360452c2c385e28ce45dd8885abb68c29f8eb32f43f75cea82b8804597d020b41ccb95903bd9c07802ca8a00e653ac45befba4e3dbee18a8602272475cfc36acf4eedcaf0438087a885fd2b5df399f81603896b56b751806f8f3f637672ba34d79ff0fc0c0e71e5312312226f28e96777b082991c9fd48fedd3fd412c3bd34b20084c68fe0528355b8b089651ca354e2ea6afc3a1e41fafd4776065fa9e09a34e3e2ddc52ea06f345c788d55f1de073abefc7c3bf7483f2e750af0b2e3ace47f8af27c197865d85c26593fdbe776f7ec751218769ecf6b81867ff81a3dcf5a8c37f04bdec454b7b684f5e149cd6afa0380bf7ec0058be1e36dc0fb32caa5af5b318d22f167047923478e705f95c746db814e319608a90379dd0b1e705b2ed96c8dd681e595ddd7bba5c0b709e8f5ae1715187c1e5173fc01b1f73cee4390deeb99b2cef95b43cb14716916a0a470ccf42b3963ef1d7f47d712b49a76762b3b81ecf3ae2716e1d81c587abfbbf2b9a580da252dae37e08875368e322425343ab64e64047e94d9ecbe8e5b1881f0aec1cba7c7fed65b066f2203c3323ff39407a77e172869160476f947be807163ec926389edf2a7f1cd534233ebeebca71ca8d2380debab59aff4de3349b51e838b9e19a3b5d5e00c4794b6db521d183b222a57406046589222be3bee9fe3583c9ee379368cf15f70f3280dfa617fac5b05f454af324af8745cf94b2f70a2769ecb22c5216e6a6d16d92b6f04d8bee7cf9c62ea8838127550e55b253b4cf67771d0b2824a5808be588a8efbc057dd0ec6df4221b06959476f7af03aa1d88f716a3a8c09d5cd7c8d0a978cf8ef077c560fac0197b76558263399df914844e9a14e5193b2799105e15426354bb31ea95ea1dcdb7a38409e1c09a63b6a80e6b810fd7f734ea77f479294d51dad6ae3506403600fd080aea4a12a9d4bbd230bb619e2c09ae7b8a124029ad8c2abfea7f6cbf759690e6e25ea737b77f77b932873fe851ba25f21420677854df86633c3346362c7c66212c344879e76f3815e1aeb70e27d4b1984c787d7d64993f36d7697b9d01f2fa54859b24706d5d3474ca5b27d16845eff26254c904128f8340831b0751b0c9861b477d7d389f2fde66f768ed4faf7f66bdfff5a41f71da74a8a9345b4f89e6ba27a0b62143723494456f1ac3b22bbfd7281fb0ff37c569a4d1464f614ee0bed9add37e563cbc9eba3fe947dd79cc54946f3a1970795e4871287ec6b2b8ff61e8f25eac537f3df650a0a8ed0cfa4b8a5c5ebaa98d31c3ddd1f3cd9439d27c55e871e415a8d11954115f1e73b90447cb1515ce089d62192d8c0e4c19e22d72d772c3d269e30377ce29b885f011a2d06727198669de34850a83e338442502af99b974d6d732dd019b7339122f25be0c0c9db5b8eb0b690d31276b63261b88923460dbe116ea6554f841f132d176488dcb8f8837e4c99fe6d76b7c287cb596e6293b00c04570c3f223540ef2e24712cf60bb8530b83ed89206886e098585044f15abecdd73dc2a3f837fa84bbfdcb010d18abd8f28285c279d2d07ca7c7f6d73dd7ba1f3cd59dc9e96912aa82bd605d84481290f6d182b160df3f9aadbd196570f2f3a06fe82f19309211c642e4d777727634b568fc519f51ac3aa3c7248e8b0adb9ecf99847feee2053cd1dbcc2456fb9136051b12543fcdb5536debbe57ff2f63d5fa56fa51e85f53e9455215f4a9ea70dd4d24b0a84a1b2431c2dd998e1e0aff73c81499ec9e02cb33b41344fa1709499a348765282936dd6c426f8c14f12ba6ad6d731bc93bce1c992f2c0e9ea721caaa7df6ef38706269104804595e649b18e90b96be7028571f009ea2d24bd7c77f6215fda3d6f7b35e0c7b884b7d7441c0190fc6d191e455d4b710710ae6a85320b7411f8db9dd2d9af043bd94b88837a03836e026a739c1d051fcbed1ba8b026250c6e8e19e1a82f6eef2accda3d86ad5681a35571a9cc7a8fb48a6af2ed465fd2e61fd2f4153fffb3316160e3738de1bf4904c0a0e8fe014a5a2f163bb10ddf60743bd7c5fedbd5dcb5a74a281681f48f8bea1207e0b00708a240503f4b5c3ce1421a8229b78bdab231c1219d268ee77003d5c75cb6620d3f0a43676b02c882362bfa1a69f0b76d45aad680066e337cc39540d3066e7d230e2bf044106e42b9569f094a136d4b4a4ecca6925b8e49c76c8ccb7b0acd912829955c2d2af538ec0ea0a0c42cfd054a0e6639b06e686256bd905ea1afffc7faf070ed579db9e54e1b12c7bad04ee0c98a2f1fd17c0ce651305298de0067d5c50e1e16ee2eb45de3510853bcea1aa877f40d5bffe3752731b7b712ba7a6e6d2440160b3b9a530533af55ac84233e2b251f2175105a361d67af507e0055c68fd9cc3104a6961f630063467535040e5296168a5967c258ac5fddf1146b55715e73bcd481f73d08dbfdb92df5fc8ba4c8d1b4a970eb01ec49c3f6b4ec0c25c56142e0bd5071fcc9595031fd1868d9bc69f08fc333889c770e430659afa930ac254610a7140187ecf5a302308ab7e1e7b2f542513b92f48c2736e253651bde181b1a03070d795dfcfd6d952cbeb62ef5a69090301eb39477a10cfe427b7415cb1c956b5e7586a60b754f46396fb9ca4e2aec4d98a6d2f5f91e8bc984ba9d8a5de6c4702be0ad5d14b8c9326dfbfa41e6a590140fd08a6062fad23c4910e8086ebdc237e015272808e7f1e74e593e983ef4caf095379b4c039687306ac2bc2374963d6ffc45fa7c6c359633c9af49dbcd94533608a43e534d3bb33d8e69e160bcee2e2bf39bafdccbe80c7a9a408a69ad2068a3a053f222d58935a29d85ca3a29df583b3c14712a4b943691cdcf82110d820c377ba8481f6b2d9ce8ad89035468b80f43fc0d115139b33b17bc40b20c9581ac6429e1dfefa9921afec46183576a8c142ea42efd784ca67bfa33cfc47ac292db94e720fd5776c3c215fa806a17a8b56dfe0aa133a6320bc90f0794131d171a00da7fd9c33e7c4924a325d0780aec3c29ce1db62e99e805e2c24c20b9e27356ceb3829ecb9913b2b48b7a89fd9c98d12634d62da5410c932ef26af98a29f373f88ce0f6326c63eea209ec53c6b861edf2886c1d57200fdb044a27a27701abf8b8eec88d686f3ccbd0267d53ce8070679ef4d352506d3e70e083f97a61c30499e331a856e0c39c5b7f94c4421cc75d25cfd2a44238a6a48c65d6648e5e1bf86fb2c54c9b601b483e7daa5d0566db035ecafbbf0f478138f2c7b71d96836486ee0a152e693b40115eaaff009a97ec7b9137d7ec7cd7bedc076ca40f0b469b01bff011ac0cc876ec8c359495a1f0b5e88c656508368a21db5b2c4fa504a9e7dd0be3f6ae5464fe709bfc4d85514a9303207cca354fb0ffba4d2a8ffcac8fbbc649bc02a6406282495cfb8a8d202b2652eccd126d628b799f7a0f47331b382509def78442f6f6b9562a5a45ae1fc33fb62bb723b6fd1b304b1b3f0c693640bf2747b658aa39b8c9fd12bbffc00714ebf476b8c1ee028d60641d66680e1496d14cccf7b50888ed61a22bb6a340cf91a9ebcecbf6630cdeca16cebf3c2af105b553af78754158fdd960e21437b4b6086319317432c72bc1c9994437104f8bf7d67f5ccfd0e387bcc351c7d8938a2497c68213fa03e380203acdb543eeb73d5096b0d8d97ca4bd14646f1c1cc664a5c8f7bb8a6305821847c8e23c5ccf5654529c657f806cffee580c425052fe02e1ac0a9e83f0c152a2582773ad9e490a2fec9ad9f7683ebb3bda08ccc4694f4c360c599e8fa47b8105ea4196fe8a70e716375f504933df5a2b12ba007581fe3df231a8afbf16ceb70a08f4b4ac93ee40e658bb9cde2dc8be471ed14758bb2c24f362446b73682df846d71744fa70e57d842f5e4fb76afa985fc0e7539d9064b2e3db6cdf831c4b768d70f8c4a92519c7b23f2c68f79312e4ec9a0c7e78adc61297e57f70946749ee0f66ee5287f98a39e256ae7ff44e124a8bbd1ec1943a1c02c3d47a7e6e494c5708dfd3ca363b8619bcf3bb40d8c365e87a3d01abe23f1f05a3b7c34440bb5454b04fa2da2ebec3a33de354266e4758506d5d9e0aaec23cbe4bb86270ebd456ba190fc3443271364148815654f5d7e067f00f1ea4ae23e549c4d3ea7ee0728c1cbf91932161214b493e8f2bcf51215ae814657fe0e43f210f609293d3804813c454b41ed03f585e1ccb48d4435e0600e7b16bd1be732e503bdffbad26cb5fc353ac8d173aa5981b3d6bbd8f1bddea5345f95a2fc9bb07ab9fc25c6cc9a012cc7655d771d04fe3077a74f0da6bbc92f35308c39c881184dad0f4629e5fa29787d10d63202e06babf22673477fb923736d0ec324c05945311e8aa4cc66369b0d6c97412a3dd27001670225dcdfaeda05d4243fdb18e75afd4d009ba136af68c192f1feb9cb766741afae0960e0736075d387c6caaa4f82953487f9190086543b13bb156a621d5d93a8eddccc6e140ab008b8f0990fc344baf67b539078c10b1efc40632cba655cab8343a640fcbe647236bd043a57bc8fb1321cfe49b9f613ebdcbacea3a2654cefc194eb1cb75e8c621de2755bacfcd7b550f65b3b729b8182af6c1b1f5bd10d00d78ba050b53648135e5351f3bbcf5c7974f1c19d294bd0ad8b27fe54c2ce8afe2fc9e4f39cc1e122837b495d6a6d2257e2e1088bbb9c2b3c693b44d64c5210ca8d8cd32c74c6b969db42b7c8e99e94232414ae93d20b7070220f84f796f8632b71306de1f71a3e6f46c1d6a990eedad0a330b5c0155ce6c3a0e34268e276df9b0f4eb7fd991b09db1366b8a093bf2ba2cb1bec53b463fe544c0cad0b5fec8f6a7948e3d40245bad9e0bb648c7b7627bae98dd98ed5a10cd9c188cb1587709407a82e9ec84f37ab52ed0c36023126c81dbc92daeb4e2baeef451f5e2f03a9ed3c51bf071f7b512cedaa3f7251759eeb03206f64339ef2038f8468eca2394dfe8da5566688cac6cd2b5f22c6da254342c3ea0eb809dd34be203b02a1875cee6636a1f4b4ce9b506de627ef710b0234751e56a40a58c2d11917bcacc43ae62bc83518809f4d22afcedcf27086f12d37ec039ef97f15a07a3bf9fbbdc802774ea9739f9d632ccfc749da34a41611d82dd77c34877b924a2044ff0a78e266c0529af511ea120473f0628bfdb951db9d22ceb2b8cb90943b38e401f531242e7ae691af2a02f79e7bd01a2fb5067d558f5f99cfe6c831e95fbb6d7e36917cda72e917c50a2ec13b61ed61eb44e584ec8377d9b5b367bfbe6d7c62aa7ca9738a507ca25c1fbeacc3487fde5457d0674dde9d2d994ddfc87865a04366ab3b3ef376fe883fe9e1d7aa5232ec6f2e62bf88229ce289172aa7d46b9fc0fb6c577f38ea320b75e0c1e083ca7df7530f7d77841cd8ec789097a84236692be4a2a4d46c54ae56ac2e4579f2c01b7db7dc15a53ef236a994d76b60a1a3c2d39c55c239179b472403ac75aede2a77771004d81dd72e43fc9344bdd5dc5d2716e3df864394c129398bf981c3bcc1910b43395d27ecb338ca6e3ae47dcf5eb100b0d1001ed5d1a3c7f4189ffab563b36d9ae01256a6408933e649f1f48052ddf3c72a1143660d7acffc11560a656d39587bd0aaa064a715ce7b22e19061e2eeb1f92d5d76d1dfa7a09777383db970e7052ba2fb4143611fbc18d9796b812ec76e3217a2bfaf9248110205945ed6094f39ad8c1d0eb96a61ab5174c39e8b2b731349f22d767ac7c4beb2d40a9bf339518deb780e1205dce239baea9d1067614e329534232619be44b2932fd691f833abb7c3f875b566b4607f27cf568f066c0aa0042ad927e78e7024907c7d2750e862aa72fa17e8e81b4e7f553745f17685f83e1ab799b102c6c5c1f6e28f2a749c733ac81de2f083a745a35445a08a6df917c02b6ef57ef9b543bc2b5e61429690df9de4f9240fc1d84ae86231093edb228dd88f946895029e86a181ad8ad0ef12e1b2137e025bf4bf709c3796c213152f1834b5b29ebffde237bbc12b5850bbd45c617d54c5d5a1cf899b9a09a0daf4a67c6a19415fe388dcf301f4bdd03725bf14b0f5b1ae12619c1652eab8d053f3165cb952e671a7dd8430b0b9fc6fb2548c4c87c3d8865560c083aedd3d15fa03c3f220e6a793e7f517ae550be7c6951bbc2da27a4ab5f77409cd3a01b9e2018bc901200f2583fdd7d45c38c9036eef6b50219fcf36049669ce06ba698793225fd9c78286ef453a52d38eaefc90afc07ac0e503d67d6e667a640eb2c7c146f60e0df557b7f2e8c857a5a937e1783e7b55adc39ce5578ea21930f8ad767802bd51ca67d3dbdc2958294f9a8231ea9b5ca1e2d3d3d0fef007ef9becdba518107bf5f4dee8410ae42ce85c93abbad30ad88a3e58f64d50a28a40f5bce366c22c1513a26660d281852378cb3fcb397bc624831f97428ba619b8ff30a94d0da7023caf4b89ee4dcbd3b83d46a772f0bfcf519a0e10b2de61cd7e73c801a7ca029228668723860ad7eaff59b90f03463adaf4a50e7a8b2ce5f5c4f8ee4c2121d532f7718cec7901b771ed9579f68dfc15c929e3af03ec45ead8df3b3cd4d7883dd11db47c60240c915de243ef505e0d206dbee6f0999198ebfefcd2c9ae94895de0bf3f4403edba00dd1b24a6bff654ed9f12ce1e586c541f6bceb487bfa109cba35990672fe4a30e028cd4aa9411ce19a666399af49a130dad1d52e440d3850ef1c5f67becad98a06f8ce35b8eee0c1e2bccb857df04372ceee10924a183032324fc2454b2ab9940571dff66985c7b95420a1e54a25f71399a96b5c4b0e1ab139f90a60e9b9a7486a5c902324a2b9ce15e020b10507514ef53a8ea0251e9e5bceb89598f9e4cd6a37c15274c3a05c008c70d5e992ce62ba4bcee2b63d243fffa900b187790af9b49526abad980ddb25f4d43c016ef37000cb3a1440455d080a03ed2b755fb336c3bf361d2aa0e3eac4ed17c1f71ed506ab7a9227a5c0127e61c1a1a7ce5f20ba6646af924cb9e6e3ee5a4223a554ee22d3a39c0dee947c8b230e9bee212c83d257bf1e95c62f15d2c038bd5b7b0362f24d5772df0ace011bcc6a207e768f142204986e089908fca6886bde2ec0ab094ab3f525a41c2d9fc410f68b35400003b7676f67daf0e449bfb2cf270b32fa0bf1e82a0217e40b45bd8dc891f3f4a64ffa7e09e017b1bcc2c387bc3d6dabc5b4f40da74e01354f8f5207d9520f37c7c97924a7ca30a91983a6620fc842742cb5f4c0a0f945163a0e653c78b58143a718839975747fb28fdd8247e0e0fdb85cab8f15b8d9a248a34de48413c0406ce6e6fddccbb01a1dda501517fe77d7ad7d898f3430cf43de396b853dd1fe0d1cf27013cdd083a43144fc929dfe06a26bc98c2a8fa2a3781c45cef770e5e602334a129d01fbb3022bf4e928f4e5f03d70cc6b02431887f6fb4d01b5d74503bff91b7d592ef29fa960efb918324a31355d40211b7edadbf57784e968738c87cda0df3e923dc542ceeefb3868b2fe6f1b8960d089848fa0e6dc854f03b744948ccca30d3192f1aa06716ccd74c70ff3a34ae10f14936b721594128d11739657c0bcdb08ad0dcca4a42269b4997e98cbb33ba3e0388e7b96c0f02e705cfc861a1b631d739c388ae8125658929592d053e2f99f79f0239a9f886ec96833bd0908d516876375eec55f240cb850fe044e1679595b7a89dc926b5d1d9f7c6fba1141d31a854d5c7bbb135b4e46a94df8ba0474110e9ff24a5d68aeefb934765c1718f13a518d4c909b2a86a293b2e7f0bb997b9c5803be7382006dcd3365471c71ff6bd7a380da976ad090fe29eced9080a7c94a699528c49a15f08fe5be178d28d5e68f27deaf69bf3aaa32e323c479c67630076bc08f01da7394506d66f7878f3335b6cc58d3e87406647d383a6c00d6c0729462891001a0cc34402e5dc512764b53d78fb99396e9a3b76e3ac9882f68676e23f5b66eb2a426a4985bd7e9218ccad6e43b34e2bfe51266c204c285161a38fdeaf7db08eaa5f983f5ff526f9526f2844b1190a2ac598557859e3fc6601acb87ce62574e25c9d8546cf937329b5cd51d6f61848c73d92ed4e08e6ebf15c842032c3493c5f40f192dd3fbbbd2494d63d302833d29f8a16c8a1e8c4f6233bb4c256420a40288a4fb3fdd1ff39a09a724a3bebb7a1393a3e666a5fdc8347ce98e885e30f5c23ca5f7bb10846d266cae3b6aa7b04d7c3846e270e320f689f6dfca5a5df512b777c740852490af5f59d2801bb150d80846cf614f31b8f4fae5b558b07fab1643a3a5b9f01e42ba19d65e2111f1c8c30d4ddb569715db83cf232e5cb7b588f922eeb4eff8168ed0bc9d043b3cc0084554f42732297046f5c1921234a16bc0720f4763ed394cb3ebf36773124e94f8de4071990aa50725be8802967a6724665478428c76136884adcbf4f5ad404b7998f531d44c472e732bd1ffa89c422e3077390fe7ce7be34b482aba1eb54a2aecc9198c7f71fb3cf07dc8a7e62990e152f36e7c79ee6d02a0daa272c96fe183316dbecb9a955af4ec181343ca07894d7912ab7b63ea542a74e182926521f2be4876bb087017eb9043d438c7add99d1beeb139f7240089df2e03359422a091fadcd464ff5975b974e36eeccac485695f5fd9087e0c0e6df3e00299061744bd4bb179fd648e2b4c82588413b2337f52c16436c7805aab7d65a9df09d2da812c2a0a62cf9d768942fca2bb017adcfcfbe192994c360459e0a42ebb1e3f7434a275d2eb1fa277104382ee999fcf5cd0886c78c7abaca39f936aad7780e1b8b5f76aeaef0f9ca3f3d3c56e871d658438f32f34a94b7941f394cad929c530540efa9ec7923a821cd72c06e9fa1a8cf9b2dd6bf42a8f2587e77d36a9374cc8417c6ebead9f972f1e728196a323138c76b2b9c9db8f654746a511ef579a04f34c25b631a8c3419f1f07609f8f0f724bb6c0d12ff9e8a9ae1b5f657576d809895f61264be2517d4cbb53fc1d901e527d864c6bababdca5751087a1f46d47f7716e22d7dbf27cc65d03fd066ff80f6ca52f6dc51df119b6129d04ce14d8861c6411bb99ad93d467899addd5b8cf83b7e997f4edd47294a8d8d34d6d1ca16996cedd0bd868bd33f03608e75fa82c3d04f981fdb8c518c9a1b5bf7a962df866457fa06434740d24163cb71e9ca4f655d420684f3c1411a28d9cf4da615fe1e1b4ba6ca560740dab8755206a0ab7e34e59ba4c4f6cb2bfc0359b0fdf147733d95f6ea681c4cdce934854e13fa728f5f79d04f03dfe015a6e9b003010b19b1eb5317c84e09ffef9787bc6081ebf49e901a2211e49e44e8232f2970e6d572c81d4a5bee54d928b4e3cb39b2359ec8ff09815dd6171a4896f88a0d73b6d1219b99ee13692d312ca6ca145ff325a7cf07810f58866841e115a1c4070c6c13b7ef3ee18f5ff07c87884f68cb76c47dabc65b939b69363a1954b4d3832c9fe5182f881cf63e2dbb700b7caa46a23c78476ddbf69f120d0f9c202aa49014827d285b1ceabfd9a11a4ee8cd108e41741f4a7a0541458d367bdd2574687ddd8ccab8992fa34edb47688e6733311e9114d41f4790145ee1684626b1ea1fe848145f7682afa9f1081d0addbcbb95b26c9b33782d9ca0f96e7af44b389d563726c669b95a7599bbc65382fcb83795107a05c9a930b0668214d3ab627f04d7aa7f9e100d2b0d2b1f9d82634b88f2aaea65667f5e38a89c508720f161364bee3e6e092c4e620c120bbbfbd7dbf5b0a49a150269836fca54058667e924e8b633d8565af72286da39490c4a0673eef99fd83587ad963495d1114b8349b663a74035529300f7ca33b2302e2f9968a39d6c4e776d5d6ea6094cd86c321bd62dcd4e54680828b4b0a47f1980ee9c76dd8fbc5f931a54fe64bb156f37af06c5b180594918a66fef73852d197b2964f37a79968f9dad656895500263f719a202b280292bcdc87d099968370e10b3015adc79501b888090c615be9cda38e184b0650f9e01712886042641db3b7c229c3501ccb9a46ec48ec8aa4d143127c3bf4b78e7f7d2d944a89f4d6f56851c2b54a0929cabbc1a02ff26a69ef0e5b16373a69daacc0bb5651ffd9e2a97cdf0a6bf80f55a8d27d1f9be71a1cec33375c28f09dfeabf0d5f8ceab069df0e83a96a6994f8070203caad4953620dcbe712665098433c775f5d72cfb474f9c675c6557a4d2e5678124e633447dad26bd5576a2621369fa80f634a7214527556dbb69fdc77edaafa24dd3c94c87cd4453af6a6a8955d64e8ad4ebb18115fab4fc74607f56378e30f7c7ed6d528c7ff44af9f0422088bc05ab241b241c112d89defe80c7e6d2fce3c7bd4ffe8d0b4f60b63ee5bf47400ae5077683293580ca60b0f54b5abca1b7d83b53d700085b708088db2973081f8947a28d1d927982ac2585d610d07250b6a67da9659045e627f3d37a2a82404baceb49fde7cca19ae0398aa3558137b35448c22ea55de27b4f9ee4b2775398cf916f27618b5c60d988506d7982d4922c27593a66e013152eb3ce8b72b28a50e47581dfc71ff61c5b20dc257a9e072e18b30ea88217af0b1ad1101c3cf946d7ff57fb77afebc55b12a09013418bca9f029e7b6d4767e0b697cc3a321b19ed88b33c3cb5ff10d9874c9f885151af7a79d78d10edc78b7ae4c020ace4d508d53b1d19c5b5edc28d524d5f41ed6de091f2693fa62961a1090c8e0c85927ed9b881c814e6957f33cb75f40a9bd8f6183d776adc7ac5b93e3f82a3e4cd44fe0b1fbf74d66011df660363e26242bd277bc6fb2c62625e40883cc080809245cb06353f701ba6bf91f3993054c9f623d124f763fdbfd747c43a56ccd97d039dcabe1f5f9a30baaf040278b0be994ed09eca73954ad389ed9bd8b589334d3ff37b6cfbd9569fe2a35ce6e9af9400018965f20279b1b028bc3aa5cbce97cbd3c88f35405c72bdff02ac520b3f283c167e3dfcc02ef5d2d620171027949d45c159cc7690263344e8649c5848d257a497b65ab42ef2ce67e4b476429c692d563aa44ef4ed2a2a0926206f9763e95f65e92d859d3ba757ff63fff28a2dfc0555ad6dda58d34c684dcd580894bb9de9f53f9ba1c96364a660c27d7dba1a8ac394a7bc80caf6dfb75fdb26e7e7e0722747f4816e6c49abe8207d88c192e9c43f1a2d14fda0ce54cc5cf84f28198aa13b03b5d98c824305d1addda164f64fe13405643fe348f8d095b0bfbed625d9106fd51101f81a90996a53103842e47845da554d64b28429aede7a19edbc5057e1d834185272fa066817d7dad6d3345eea9b1d7334290bc821697b256bd2c2b1d9e3d82418110844e4fed14e84fd18b233d41cc41926e5215f3d2b64f935e8022ebb77411326a029cda86325d9ce19e19e12908f295a5851ebf47d552600e27fbb6319bfef3826824c603223e05412398d727251b9fd372af3eda58d6dff2f059b754a426ca9ba6a05c5ef826f73698ff0164b21ba3685d1bb2c96c705dc33428bf7f07faecf663ab29ea494b814b8687087661780e7175cfc757cdd910d0317730f62b5d1e0dd9353b2ed69afc9f4ab5ddd49c3553f12313082cf4023b7ba08d27a69fe91ce065aedebd4dc65d51369f4e689cc5c133ea55e5b13401bbf39ee9cda2439c703142eee85f9e95a4c75091f0f0fa84fc5cf6417ec147bc779f61befdf1f9ea63c982e39eb68d727a737eadeebe20146e18939c5ea248a946a1b02435f4eae91b64d75d554a718b93f81d883928ab1a9cceb2c4383993cec739c4af2268ef7e82acaf0b2275e67aeb19a7e86da96058cd39822379b6b10b59cf5b7f96add343dc647ce22488d482342aa261331be7044646f031889c4b0184456ddcec38049ac75d0ea3de42332d486cf09e216bec465bd1498a329224dac49eaa79f73b3e6c154c9d1c4ff1a39450c9eb11cc8956a35eda4d57ca7f4d6cc787f4e89154d51db2a499a15ba1727f87bd9e832ac160a5fd7f7de1b2400b99aae98ea66f5c3d3dfe11e2cf154ae2d995aaa24edb8c48dc8a3470bd4006f48ee2e05ee7317070f25bd85fc353a62c2d41b321ca1bd259a561d2313cd4dae33d4944a547534d636b9f2399cb9c5a47bb175bebfd573fa34ce7cc4a0f3ac4a8b8c442bec8edfc189bb37355877c9d6b4686dd75699f8e14c7b230c73933e94f8ff1b4b0f9c0f80eba5803358de4e5cce4cbdd3b5f025493a78779cc723d7d5202add2935deedbfccee03e974f88586bd82cc859d34838559506021cfa869e9ccb9a8673d3f715b9832ba4c9a68e5358676178b08fc2e7da9e6ea017c55d90e9d786c316c3fe61c2434f67da6854ac4095384e5b9fc0b30ccba61c68e9dc6e0fae5fe72b5537150a918ea0f6e1044dc515e0161bd9f8355439d62b90a2c7b8bd4b80534c74720a1c36b07c9987c986fc29f20edd15d10258bf31b91c0aba21a2a251447af30bbd79d16e5880bde12f65267b4bca420bda707c943ab052888699a6f18cc6183c55e59449d62b4b46356e962349dd35c3321d88827cedf70a53cd01a19fbbcaefbed93295c74db5a00d89265daea4c58eacac29dbae2f355d47b84c2e6d92748aebcd88bd3adf62307f08500d54d775ed4f9c779c556648","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
