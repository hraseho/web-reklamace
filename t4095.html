<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6da9000f808addb0db87d743371d62cd853664f2f010815abbbfbb1947e66f96475b381e48b48bba11c39d81b0ae5b28ed747f767c8e12ca392c85cae997995024fe778753dbf800b37a23b3bbc4dbbf92be98c5cad44ee0116beed3f950eeca3b59389c004d146439e4db3d5188dbd58595ca97b8abe8214bb3a7f5f251cf8aa885f421d6e3727140636e460944ba32cd64f384a9f6d8ae28e54aeb71a39eac2aa356c5f9a979d868ca4e983ac8bd0c6216c075e0951978469d910c575c7121d842f83e2830471212830e275b4753c9a115150055d0d2efcda5853dea2f59824a6b1528a493f6b6256a31ae5a8f3e89519e9168f4511c377f700ff7b9220706a0684ef055fafbd71d6045c00011df5b8ad6f088e3d1b66f003b993b6014ac3e9585d9a7e51d96d89cb82897bf629a22184d6df03e6bf6fd96ade1fbc4f8163fc5717e1c226af617754efe0594a7114cfeffe27f233850ac9dcf8910c5e0734985f09dd7eedfeb638636974fd54cadfe9562b42c2e8d15504c584902d85ac78af8b0f941098c25bfd355b07ee523386eb252c55d691c65eb5aedd61a3d5bd6f2986010e0c1af0e250e2339202e557290986fdbce4938f24183fc6d567998761d1d63623ef008bce4d2a90de872ce13a8380a4510a45a648146796b402aedcd357aa3af0fe610b801098e93e18f6410d8e09dffa4688cc12b4a58d4793c9cd39235464ff3c9df29ed698f5055148bf7c1112f16152360aa07c11631d79275310153f53b12c053c33d3f3060fad1c1625933fe23d40a352b73fb5a7cae5d3a5b0f04ad7a6dc9db8971e6989efde5bbf662632d50955885cc45e6169cba5d858cfd68af22468852b242ab1265376a4ceb431dd14bec99cd48c03bfbdfbf775f66d25be8f4234e7bb884cc56e274a62cfff9fda0be9e92353e2ab3feca788e98adc1b911eabe5c5834204b5940dda7f398496d343d0c13cfc88d687df695012c1fa033ef004bc7b47feecf139400813ccd6b1f66338da3fc05338dab63c6bb61d8b0701f959db7cfffb12d3c683a57b4848b9d9b709fe17a7ba17c84a4d806e33f89a1db2dc484f718502be58b6e721cb26f01c57b7423113cb97a59e8f869e4ff2ee2dc4db1a6b47653060fdcdbfc2ae8a7bc1afd23bdd017f0744e75261eb4d47b100ff21bca8fb1b42dbd28e1a6e5f05312e4266039d9242f614b163d92498f981571faaee1dcdaa9b6c76de5a37fd2e5235ccdf24ed1e823269061dd34deca10c512a99e04fe1637d1c2e5715e4097df532e553f75f9e86b5c4c72c269a94271f426a74d95d9599315b652f619b0f40723771679f4b90f217a5213a70c2ab6fb45c134d943366e7dc80e2116c264d5a3a481e6041d42a32a97b758996965de9aff581283591386b4a5d34600342c32382040ab19cfb7bea6ae527cb52c1e9f3a8c752d8a11ff597dcf5c0a73f9b8c398fe62fbe03728149c0d84a2f6847e69f30bb4e20d1bbfe9c62fc7bb69801fc0cab697c92d45bda5e84cac6deb5f8c06c2f1b02077bb4e1ef5ccd73fb35ef0ca9321bcdcdabe46bbf8519e6c6bbad47b49950aae7b984e0e639a23da2a08e36d4b2e32c5a486cd37f04acfea28a678bed03371bab6594284aa89c475dce030a002a143a2b788e57ab417b6106bb70c96ac6ca2a5754cd847119e94eaaa45f365122bfe62a9352cc57d19413f0d616801f11d4345248295501099d02f131852e143411db3b6f5cb462091658e24bea94d730fba38823b650a0c79ccdfc3402fa1d801ffdfbc051d2e979819af01c17284518419a276821f14dbf01cc75b765c6c2ea55da26aeaed0dad16c2db8b7d67084a5cce090ba85dce45c106b2de6925b9a7e90ea1b178b9664dad22a96d37ec400129ba8054727489f1395bf07b670dc9262129da367ae55f8a4f99b5381855397085d193ab7d83d87ac92089c54e89528cba934d92936b1a280b4b4acf2150af564ccbabec042c3bf2dda664e77a46515995510e444c184d078b111862ab5db5a16e4af80cb9ebc5e97a8f2a132c4503ebf573bbb5de76e9a868b315a0db412f977a056af093687bc8631f6c890b656a015b3aa796d631d0a216cf0f4a3546ee120efd38be0431af8c722393dea1ed7221e5295e57ae0e9aeb998f6bab5c516b71b84892e3297bfb270abd0f01f67c37cfcdc1d5db3698b5506dc80cea36c150afe228ccf302afd2eac5329d95425ac6f83292f6ae712ef47abd44a88481b8add6d3027866a493b86a0803466d7d29d3522b6aab52596eb505f54e086b4547854206ac97d0c39570d0984fe80d54e2f4603f3ebab4860e754c3aefe8041e6eb61ab27c5aa37a9b830ed1932e9b442f7a3c39f53f71eb8576c5cbd336e5888933d98b82f534f8cd9910141c1ab4b2576887b218b0644859db0f471f80527163285bebda1014939564422313515075eba2ced1184d9cdcf45ebb392d9360c6c4d3aa2a3d89620529c6403d9230dce9c9a57db280a43f6f8e212e40c9a55011af49b334e94b32e924ccec5a2f99ffa519d49bfb7bfd44e4c3648d194ad6828fe338c6e8f7d7baf52e4e9f1f8727d52fefff2f11f26441572cef77be90f3aa8829c54ac867ea982a2593b334c87dc658ba04e5c61f6ddb8c1822fbf245d44b113731262c55c4c5c30103f3e0f591f15225dfd294a53abc02de000bcef804462c3e882aa5aff625d0e60d9956ef1b1cf164034ffe0ba8e017c95644ffa28ed3db0415c7e515284cc058eacbd11e6036aca0e778e5a3eeeaa0be7d0dac67078bcbb7d8f9947859e1ddf1ccfc56e77e9d5bc6fbec24db45f2ecef7865eca9024951209f6314b82d63596e672a86d19b8a76370f4cf13d0bb19ae0c8bfc68810ab4b0609ddb73f1392ed554d17c96009715269988e481fe47d2f97d7a5a89ad8835b07f6493d1ad31c071e31a5347e0ca33fa3b2ce2e1f75f8cb9ef7b91a681adfcf99ff9ae1f411255eb03c61250da6965e43f8c52a16163da0187fc13db5fe8c4605ea7228b8d2f61c77070369b4db4bd5e2c24bdac497828b544d654f2f73327e268ca9606665be49eba54b17e79c6ece2342f30fc25ea9ea6ca74704b01e8f0828587422898225eb325f71be8593dd2097889c112fc3e98b9ca85560cd7f9415b3b0f7e668486cd45051e7ad738a2127333a8d5ef4088eb444e61f9aa55e95638fa36363087e4c897822a3af572f863c0500637c8bf05136e0fd3ba2bcfa765ccd16cdce00f32090b18697cf1645bc873f9228141c04659a0ad699fc2df6c3349ce905dd734795603b970b9bd62716c408c79f0be2f683971810287d64bb8f0e8e27b086398b0a5d45d54b2a9eecb7be672dd0bff134a423f2283a21e9c24324207d625a97d0220a782f2dea46361b3bbe0bc1ff1bba2a250b94500d973c9c8fc4c10a3e0e0c00b3ab6f6f4d4f05cf5ea9016ae2919dee40dd7511f8140a5dbb198c9a9c8bd7b1c4b6dc94137c11416c1227c8e917b3c0e5e0d61612009a8d0e1649fe2ca96dd64abf57dd37b0361427fcf1bcc30173e5aced21c866fd41cf4ee6e975330ae2af2934e8164ffc6814b422991d4b2e37fce6fc91596c6f1175a1a47e5187d22fabbe25a6fe650879b5dece5a5879ce3c30d8cb291d909a9c6ba337f0a7c0cac8bc967992a9987cee2c71541e3e74dc055f1237e174ab4d70974dad93fa865d2d7fbc2279c89b2c1470ec676d95c52ea57c2c0cae56cbf49b5ef62111f97e8f53037a93bbc791a21f1a4417180afe177744d90c30239d56858e99c48b4b62cb045cce0b2fc18cac93f4fcef201924dd86b8911591a249724d3d579fd240caef3d43ae1c9d21dcd96a42d035dea5c1efab469675b83a2a3969b980e227aeeffd37ac353c4131058ef6d067bdb0a668a0ebf477dc9a2ccec2309672739d1ef234753d45c2ddce22b18ff1f1b0a26a79db49131750b0fcd7f309f86161296c10ce52560605618a1086e70ec48000b4b1b6da0524c5ae5d795d2ae525b0045bcb36247f7a36ffcfff2c32963fa0e70180a8d969f9103b548aaf13fe53b857bb36ebdaf7999cf8ec6fd2a61d9e1b8d37674ef2af8c917d3ae3010af051da80cfa523889ce4920d6cf7d21dcad85a3440a511fb171876cd7590f0f263585c2955a36dc8888e9d959a2676bab03dcb65c9a5f33301b40453f991f5238094d486cf410b0a7d6de7d813d99faf2b92bcc6d3fe86790ba7c1b599ca076b1689cc1229411efd2d7d8383f6b8a1cb281e711e8407fffa0840ae6bbefb67ade5bd2c0ee6f1da65c5078e86d9c244c375961e975f1c6be138fff56b1f236bbae3a1f1ddaebf72894c1adc8166b5cd3d2c921d22d57eddf652c6298110cd5144f9f998d6e0bc51f01d0ba01a3d2d923353b11202f8ae15db263bafad6cec77bff35dae90114190791480f0d187687f3dd65fe3281f0db7ddd486ee978f34f32a4355cdaea993b85c0dbb6de465341b7ac1b8258a1ba068727d5339389cd11e0565e4b397555ab0867963198a9bec2643ea2a842e6601941b94af012ec8110609812836f2987225348f6f23fca5958defc935ec115d074babf5b39f5007265b6a409d6b9e8ae9823351c50bb575112682087e167e711a70e95fd822619ffc229d0b6b303deec01d68e7af9b752f8cb04b852f072e70eab69fb480a3fc55340721186501a6d0416880968bfd8d4fce856023bd8a45028da5749ed8ab2d2a9714b3ebf963e2a0ac7365d744a4c28c71a4a4b5ceae9d72baa24e7fd149be08d8bc7637e62187faa4fa305f5902e50596ff2f65c622beb0ceb412185b5767c01477fbb0e7202d6c6ba53d56c34dc33dfffe28e545e7f72a3a47f6a8a2efc7c265e9f2354dfec2ec2fa8adf74e70eb6ca6bd171224b946e57ef4c4f017fb4a4fb25d5aeb722c1f636956317d746c2c8a1fb063b7456d8d4149195039800df54e85cd4c6bdd41b425b911e9215f79a66fc1ef5b41593e48c999e41ce46d1c1ba029a1d4bee478c365cae49a9b3e1e5f901ea7401cf726a6d9dacd04ff14633200ff817c20dbadc296d609614977d636cd6eb61367bca62ccbb8da8e4213a1cc239c258c69554fa1e911c3dd6933fd277d856e2b05f64af4b6dc769373bdfe1642f70659f4a2dafd91a465188b180f5c9a1c14e52258780d3de6354f0f03ede90bd7ceabb526b8bd857bbb65517fe6b9425733a381b5162e081d7e2051373b1741277c364ccceacc0bcbc5b23ee1a75d92c201fbbbd7ae861169aeba35ac1654e7e331dcd3b462e08d0130373b177e24bf29d78d88cb4fe74c01db6cbc6822ea1cbd181042bd3afa65629e9765c0367bc2f7d34d7060b49dc257034b6e73b20b9ff614d44dfd5d132a69ddae272fa45aa49c9300b3e5d47be8af41e73a0cc0b113ad77837a7735a7779c8d03d3fcee29d867986acfc75148922c6afb8950afe227b6fb6fd0420266a03bfcec1fb24e982352a86e0a2825fe6b12937da5423e3092e156ffde064b92592567a67201cf7048ab8502350bea6cc77f0f639e3b72927c2d5b8bf3a68312e432e622092256e0ee46059a8061f5ff49f2423fcf85fde592ee5d4b4edbeabcee8a7f1bd33fce9cc3f0d0dbd278933f566fb5f2e128cecc769f5e53d4e2460127508d1bb23b3b04207858c80099c8380846a86aaa1d9e7371f692d5f087798af5baa65bbf49ced58bcb518342817d17266c12b0dcd15bfc09786b0171485a675a28c0c74960bb6dbe68c806fca8dbe702e30db49680f26724c8e2e4dc2fdcc1fc8dbf6ea9482be45064b849267450c29306be3f1a7083a11e6682ea8ce16ba204dc6fbbdce7ad534dc982819bd693d36d6fc08e911fbae83744ed8d7a1491c0bf868e5726dd13177755eb06390e1c2de8f8f7bb3450b9ca18287bef7ecef24a527ced6719e2410ef3e5486efd356e488d9898fb2051eed1a8ea30505eb989bfe7e3978e1bb26c67ae13312c740e3bded4a64e542a458f5eb56d323aeb3d6e266554d1b9f3f4806abab7716ff7e87f567528b9f197c2bd3bb783b5ad2d01584de44fcf873160b696d1ccf58e64ac05a084d2740adbe4e53e73edba315c2cefff34855d34a81c70d30c599094f870a63ea104f0bcd27e4473eb5161c2b308c4bdfc9452096fb57975e9c0e7f50bc3731493322e692f3943f9854a2fbe5507d8cec10bdcd1fe3bb75147c961f7484b9ec072fb347b98df3ecbde00e54dd381e4f581b8f46501053cc8809f71b467f9bba98090ca2d0da9282195e9d498e5100909e51c084848d32934a02b0503241056dfb534d1989e389cfb9b32b1ddd2171fca2b4ec106be84665327d0d4b1e8ab1949b5fe7529be056177b812db75bc9323243d6d3f92f97e7a7246877506668cbab4f4547095be0f0ed26730ba874345661da3cfc83f35a1b1978d66216b5ddb191d854b88a6ac35a1bd50b7e135f5ecfda20158c28511c7b253a0f5b74fa55a8a4aa3adde65b2837ec77ceb07c72d80838eff9a109b4f13ccad354cd530c2fe4af23b58d03c38b3f72678f8b30993259bf65bf81e7b502f942792aac759f34d7d6f59e874fdf4953f808e8281cd8605083d54571a690caf0424fa94828b7de181eec6c1ec3c05ad96118e84e67dc87a0b87c5f3fa00a38fb6d1ab8b96b585c08b5e2b40bbfb1db7a3411389ff0d6444a90377b833babcfdd54520fa4b4e8c4605ca317f483144baa24cc4b4ecb13da0d7e0672cc52965de09ff17698668b32da1aaf92c20d6f114bc1d21ff61b7872948ffb10e51d943e334801979279dd388fd87ac8885fed537f3ff4b4c4ba9c6fb07ed0d16a9c5e5f2b9838ee5c30b8ada5fbb4f28947f9207ec723572ca108d1559afc8e0891d2bc704c770f95202f0afbf585b5bf9c14a429cba2151201ae137134e9c5ac338a18a809f34a42cd48308042e68cfee0e5b3ec9bf64c4e4fd14da94531edadd40d0f6464ddda956c0a84b12f84673aade5d224fa2e479550b26a6d3a2669dc1250bf2e4d3eb2cebae87230003e3700215769f4eae11461af0f23bca5a74dd0537bf480fc809bc14c24264262afce3bfd9847cde34af5ddc95e4e665a115c7fa245090bb4759e28d99a0179e65a562266f1698ce91774716a9ee144ecc2aed2368d91e64a81faa97d0579eb376582612546adf90380988945d5ee5d00b701986ad3715f5d0025f901c40933cff2dab3a35457e39e25d16422ae8de43f0975d9dac854d354ebf18de857f90f47e8afc37fec1fd068daf27754610393543ad2c27b30cda6b972c4433af163ccdb29fb25cee3c11e84ba987ebf196120d8e9e47de551fe19315bf4bd46bf327f24ccad5e279d47a0b61db8dfe03e7a3843a9b3b5e2a3b8539a5d0f004b2c843a6c3ac816aa2e2667b95c757f9455fe90fc7a55058e67f1d8695034a567b948209672e71d9199f4bc81184b69a7ce3315f14ed3f4610593ab87fa06cb90f98de2e549dd654f1fbde3bc73cbb6eae3121b3bf743a409acbd9928aafbca919b7e0cd3f096194f130c47b0f5105bc8f8385d020303e4a919b8d14653f8b91a8dbbbb3fc36dd87e104874ac56d335c4d184b4257b095c854f87e92c869ffb81893bc1facf094c63f429c1ce850b94d5b73856a9b0e5f9c84ea711fe49941081c53b6b6098c3d27ea3edd4477c4869350e3969939c51b9bdf31742ba2cba1fe0abe46826e70214aad2412fbf3e909d396b1c35de99c4c2b1f637b6cf40a49ca7a15556c52db1f24e8e16fb1b554d75f2866ab5078628297f3707975a203019b66e805d0664c38bc6d90a1e8058c5d231514a5af971663838812371925e56c328dcd82ecd1fb6966aaa2bdf3bc98bdf515f068a7118bc5672d95e0fc5bd2860624e98aa01790d6171381e91e15763e7b9ca5303f4e3a0ba69e693bf9ef3dd2428621b30a62d6e480fb3081c9bfd19ce7e0c3d4f9af9ee1baf1049e794836b61101542523dbf2cfbeca90771fa1ac3960be8985a1f126046987d38d216b76bc522feb9a3d3e2281e8c197b69a2e117e5b0da850e01533a8dd34d556e3d93aabc83fb3d3e82ef52d0fdd98573f187ae0730a0e2aee8aa1dfe43367878812c456c5634fd0966efe9d1412cdf9bf168a00b76bd2d14864d91c562f647b4d5304a4ed5a942fe150a58dda8aeb07a95824c1759febfc444579d1eb43119c94e2a3fe06cb0e519f6fd1bddbbe663c09bd81ec69113588540cc54f271081bf9f04c009d48c8f8e54521043b857a6d350f89c4f1a01fcb75f63f01e58322de0a2cc69c6a47e2a7ab0f03e8289e654b8f187b3a54d1ab107449d4f3d3f3920d96a54625abe510e4cbd4030d90d54951ca87bbf05d6f386dba516fe284521242f4f2167f946f9b2259e45f986ec3938da586ed9623d7d72c8df108beba17d7a581c4dece9ac83c846bae19aa19c4c8753b00f431873bddf9e19ec20845fbe38646a9b62b60ab405fadd315d52bd57012ab14baa42c3fb63011fa4a9ca3a95edfa6e19e21ea1907e8fafc033530209dc8812a109175f0dcf9ef1fb6095f3d0fcdd0e60e945eafcc2a5f121e2a63734d27242cfb97ebddb122ad88abeeff38f66a33198608ec56648051d6fe444dcfe0c6784defa6ed5492f308614e3d2faba38fba008b359e24e5425109101c68bbe7206bacc333166b280685957d9d72060f870f6e687c6961d88a4e4cc032dbfe06fd4d42c2cb9fc89f934c028c9b68e0cf2dc93bf0f07acf44e5b56398fb33945320bc9f63789116d693d335f0da18d52d9f64e78fb98149f2ee2cda0515a51d1c3730746bcc7a8225187d5db4c0642cda33a6aa89ae798a8b42a1121fa13308690ede55dd3546e42aa62a7d5cf08a5de5f8355043a2ccdc332b889ea45cccac41916e9e1d58dfe5a4c3ef61a8f0117c9599093fbf118876c1e39280f1c9314abbd750defe7c99a6668efe252b33d9ee1e67565a02e783b872daacf2ad8a1179535d0a6f4fcd020b2882345674ab34a490455c70903c2d1880ecfbd0e3c973cf994e405f14536b2fffae49a123877ddd238d3cf225f63e7fd754c31fcf8c0e36b3ffce5849387dec6eb384053c6cb7f1b7003063709f68297347f454f20eb66b5e3ec8a3ab3046afc842b4ef65bb3e8bd06ed2cf334746fabb81e12f22fe83188907214439286cca50e58e198b2cb6a518b779d3b3ddc6795b53fe744e25923b99b2e5c6e74466a47bffcf23694cb15cd5ad3c7055c2c30d2522aaef208e15a79c8a55f0790348c43a76c5b2e466e62806ab86de422c6916f633967f1fed677bdf07791a00ac053c48ac69f43de0b0e87ead9b84cab040774d3e28c8c276d86042303b925aaf0756a458eaa6e3f1ed27b729c477f9a5fd8b60bb100b132efb8aa4d11c6a1281e1466e8ff7fa39cc2aab744d8cc5fa849ccf6f543cdc4e46f971a6148d441cabb8e8272e2c84f893eeef0f9eea0ccb9ab299e4952b1755ed10462a27e1157f8a1204f27cf4431109b0e9f9190a3e8c601d86097810dd81d3cf5fac840abe0c4a19c3694bebea61540da931539c682063cd989a91e26c9c7dda3fdbab3df46a0209e81ee1cf48c460092c3ffc77fce0811c550af6a41c1283aa4c79e238c5596b89c2b1337849d008be17d0ec7bf650870fecf58dbe481b4347c4b3b14a9585df22b52fa583d894422da25550847b7dcd65e00526f9be2dad718069e65e588acf3c953da18ec06cae7ef02ad29a623c0be0d1f0378f251b03f0e765ec9861e542b0b7a01dcb18d9a577f85e0d5e0cdfbed93548093b36ff9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
