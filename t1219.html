<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5bb2a7c848b83c62bcaa50ba97a2bece45f659d7718b2a306d089ec56acc47fae26f9d173ff644f925c47dcfecb6a508c591674b25daf58b21e624822ebebde333df5ba89bf30c7b520880cb0ddde3a2f52dd6ae6bd31fdb9fd786426f995e46f7daf119fc613432b8971bcbe42384e07d2907f9b47fcd83bf229e12182bea9610ce1da71c0156083c1edc58466ab4bfd2a691b7504b542ed79bf1fa68d67df3b9b8a7dc3715fde8b4f5e0a7f64297fea55451d3d60544371083e0abe60bfd1ad74941487096341bd1705e89c714e5f84c57582b65865dbff28db355cb1d7bd78067effc0225a0c3e4561b86f889f08d50a37c22a42bef16ef59362fbbe3dd87750b36d224ee63750e261f3dae24746e2b4ec2e476001c297a882dccb2cf502c54cbbfbdff58a92136da8402353d8f1523491c0e17fcdee48a9849fb03ee78873f763ccb69022f3056ce7d29bc44e5d71c2550d583e3d3a7c24aa92cdad1204756a5a70b851cabc7c932190a897b23cfa8ae25ae649d7802f6143ec4d7eea48ea79b80c1299aa384ec043e9f1084ec845aeab84c8192ea8d32450b236c959b11c46805bce93e1e6b2b5121d3aa42f05c4cdd39010745b95848e7688b37f33b34972e8b5b1614db952f1c4feccfb202200b44299115aaf0f703c46560d238a3da5b9a090a2e59c53fb76e8c3b17ed6b37a2ac9a2c40f3e7e6387c7a25e66383058916c6c9ef804da259e768a9124c6a4c92d22798d9aa9b4bea0415fead78ab5cf930f01ecd99f957850b9500aa51111f91caa5151f38d4f50cc6ae122a6644fd096047f9192a9c910c79ff3ec3ed202e12e7f973a89ee8cb927093589239ff6f307a1f7894d0aa2d412289d8c0eb153987f2f60762fde0d77e981fed202f1ee41fc5b3062e80d92af9f68dc7f9fab12224db9dc3a85086978d5fa7f961a8ab9d1ec11ef342e902c21b10aed93d61ddbcc63c3d50fce7d4faecc56846cbf2ce07aea66a725e41b7de5e9635d4c168ec25805cfbd0c70e3106961f36118cb5320a12708b10dd3f9ab13558211fab1435120cdbf4dabe05ad9ae7a80b89885bd679a62695a04d7b0d73fd8802a9f85e5daf74b03161a5928886616317970be0f0f10ceb3d3c4ffa8fa44be436d348043e4c02479884987f6e9aff15d40bc2f03bc83d05831331c6b9a51b145f2c59b247586a123573ce45cf2d87104fd27292f2becfb66581203c1c32f4ee89c9f93eed59274841f595d061a872c96ead99ff4e1e019fda5a7b821e5d94af92a8d5454c934725cd9f995a59ebb6f1e0bb46c9ec98c1518b2b5490762c4aaf9946a67446b936bcbee4c5201c6589483e0177c590b03bc14ceced0c7cc0d88458867ae54cb013c083b142c0b1b199c8d60bffb90858f525db09fb4bb38ddc01e6088b668985f26083bfba2c90d36762c7b6d3cb9b232f8558514d9436e83e4a8420e0849600f9a85e81363f1aa907e34a2d3dff4c03c2a8a0062a97f9dc7ffc99daae45db4b632c31554d8b1da8afe05158aaa6106fecc107830db8c8f9da5e4055a570730e1f8ca030fbd85056440ee1d3b12b57ce91f0fc274aff3b40acbfe18778ce15eccd617076e6115c683169bcfd2ee784968d8b5aec4256b0b2a723ab10996cdfd311cac39cd58f6f988db9d60aab272c25e19b1513e99f1202674d16c114dc147654287ca8668b20e92051ff7efba2558bf65d4fd0f2c9f9ba8c75565d09201eaee21051f84d3256a6c8ae470ddac330ffc4241e7943805175c1b46055736b63a4abcaee304976260bdf99106220640d0cc04578340eba0a13d173b82df54bc98256effc639910b6c8c0e6b84fce365e97be9f01afa29b8cbce63a303e4171c6e14d3e17bb32830ff00fc5a98e657a7f11a40b329765782bfe2a00903d0323baa08d5e7d5a1e7de514223234eda1c4d12fa67853c3a9c3a6a3df2cb2831fb24fe03bbdb08a1059f6d2afca026e1f925737be4c1523d834d65b63c314addd0f29a894ee3004cd9f52b5a80f03fd56d09ab311a4883bbbe3df9fa714156158dff9fe31e1f097606c57bc6a82b47cc6ddb5524ee4e9d7c87c8dd23e91ff7a6c658aa1be3e6a17acb203a89188f46c0d266a06da6b64c73dd04c54c866988121307faf0417f8e730b059a336a8ea5f8d711a3718796c5b8cb1e67d43e419192cd737eb457e890cd50291511931174274defa4ebb8f2628f3e2039174f8a6b86217996d1c7149a4f0e2b2597daeabebd525dcd1eb43c0ae8bbddcd59fb5110d5c1afcc72d1cd75fb739f9f547889c935e64a0050d4950d6c0f0a81a16be063416c514e797b2e525dae31ef653c74bffe750cb3869bde1827e2c216472075f0a5eb00227adc1b9a439c464fc90e4a88d2b526d1d3fc77c3053a8efbe7acd5e4305d2184a888646d075dd483a53352500f2c86e5388534f8a207c51e139685305a463f8b9cac0f4cab66abfc8cd767d7de6fc32038d509aa102f051415d59cc5571c2b8dcedfbdad721d36efbed8f75f740a592c76aa999d9ee1d77ee26d76b6395c95c0d25b73d491bb9b8d5130f89d5272e607903f444e8a549a9da1103e1f3def7e20ca36a45200fa5673daf4323c618c40ce09b53a65445f728a52a258ae277db857c21147dfe550fe72ca5bc678b23069b0747455d000246817d85527baf91f51579624b2e9aaa126181c8fe20e2b10941b01b5fdffa9af7126735d6d928aad9065bfe6debc4fc8836e73e9bd0bff6a32040d91d8853ddf6620fc56779d655cbc4cea61b06507a8ecfd54470cb92a0d15788adc932218c59c5842326412f112294ce3dc6b5ca56230bd0b59d378f189854e16cf182fce2f0a2b25ac54ff9d09eab002223dc521f15c65ca501a4b7e58dab9318a778d76dadc694ac0dca107131320f0ee438faf43a060b2cf34df231beb6c9519101799764edb9961238bf2657fd6642d5f348bcf17a8f505fa3762a8bc497e99984f4b1222c58cc4edc9af78d7d992cc1680f3fa4f8148548bd38e6eb62ff7857f729de2b135a0d3fc088fb87e91be34efc1b67fd168b8ac227ac724004e8cdcf6d6d8eea33d1df9d7d4c4ba383dc410796bdab2fcaf1de696c7652f0a55234da25bd096f3423fd17b37a8265b296743076658c69943bdc141cca0c78d3e44bfa02f17ee1cc1c35e9152b29adabe11bdb7fcc07ed12fd0ed621dadb6c7d038da073d2e00c4a81025023c599e40c215bebb6607b39f230ad696f289575f327742185d0b01b17e331360bda35660df4844bec4cc7c86b1ab42098ed0ea3ddd37b467aa535ea7b13a72af672a6c8f5e8d94b2b50a565389dfc20ce7afa98ec39862bb933cdaf181fe4d9262102562c35c072555d68be705dd91dfaced333f27c66c0310edd2141b13c65042a9a0984822cabffa6002c28b12cbfe5fbf035aa6020b20ab52ff1f3d0721bff86d12a2bb0aec4b755f04ef7fd59f0cbf3ccca1e7f6e674389404f8f5a771505d6bf247d308d2236f1d2673bb2fe6677327eed54ddfff276b96d28144f266aa35458cbab9937a959433842c955435677d4623603f4fa2a56b892a3dcdeddf2dcfeb949dd104a3f8f98102d16a781773d38b864c96d3529e3ed0d8068d92096d491243e099dd20d7fa60e7b787f762eab3d2b7884a54bbceee595f04746ea96051ac0ce38313f3e8765cab9607af18001aab48836bcfca90d46652b934182020d90ec14cc1047725450fd4af0fc25b2289004fda55c1a8f996700b305255f4cb7d0ebda7dd1e67af52ee372a79785b7390c165dc1742f8410568e2f500c6bd1652150fc9d1517641f8b5c76541167eb068eb78015bf99171b6908f934a9aad593c85e566ce6ab1344dc02f59f5a60da07023f9eb3046a658d677fe5ceb2cb25f9ad7c579f1b436918ea9968fbe8ec386e2f8227989e02a8a631c4377c5da848d01845d3b17d62427d8eae55b566ea3ebcfab2f7119dadd011127ed871eb7a592ed001be5212b8cc49171f74675d2ada63d28d3a61bcfd3757f7e0d42ab8d55921ba3c78e74cdc78b7b7dba472c6e50e6b64c1cc2b5d26d33e0fd4cc6d08c7561f45e3a7577b4c7a4c9e17bb85b08b9868af9a54881a58764a0fb6508cb1b7e9f79fd071fa09ce14decdccd5cac826221b790f74c2833c6eb49367c32f6b03d723700e92a85ea567a4d4838029858a02d3d85d3fefb1af60315c5c06df028e6881c56d1dd34952439c739953cf48addf81a1b38d9cb3d44a1aa7b5f93070b4813543e85af288a2c703c3c0521ee12ad79e1657aa711b878d46a5c4f857300008169611edd301b6158792234afe8660404519d4c5260543599ef2e0d2408b84d76e68d23961ddf632e7f86170632183eed7d909b144a1acc834d6d451b7aed85540431096e425b385474060a148a13e38064b7fbd52e0a7660fd43cf41f064a46ec2740fc19d4e13d21ee728f166c20416138f7fd8adbd27f4e55111d8a9484cfb94c649ae0e738ea40374128016ed9efbfae4869383e820732af516cffa0559dd130d70840ba188e7bac619eff98cfcc9596a378ab3845ce0bd0ef8b0be2baa8e60fb41d76b733d650cb0e13442cafe8cf9918dd99f256e2886f8e2c58a8b62b38826942819b39278343edb4281fae24281cea02280e2759521778ec6edd4c1a871d59e6d308b229ce380e3a035c2c2714e0472a71ffbcba207bf173a5519e1e1a220a4dd0c26127d019a4988eab92dde6aa1b1c2bd32f485b09487472d5fdcf6e08634955d69e0d05b5f137f05a417a044ba37e04301c550ad99b69bfaefe6dfd2bd4f558dae4e4e59bfc81c58e93b694a4e117a44e85e4ca9a1c419cfa6991ca17d83f5da53145006f5e0dd5a62a388db870a462473eaa70204a38d6b668ffe2e04312fcd45f280f2dbb1d7bda334fc034ca0e3a60a2ab802c92da9cbeea2070c012b89656b4cff129a9033a3d408e42c2a4a434bf35c7c5f5ac7c1381b1aa3f37550fa8a4001379dc0af08eb6965903160bdab4dd8bb4dda1afdb79749495abe2eb49c8223b54a0c765c55c7cd95ab319a2cf249b541d4c6fe5686062074e1380c6f65dc4c977ec90b105be39857eb6ec6e20cced4c0bc03c7f0d5ca9e9190aedd1ab378aaa35d01f14a76f535819bd65e9b800a8a0ef1f6f4f494ac78256a07d721f51c9ae64f722cbd6f7891b412efd019eae462066205cd2c712cacabb4bb819fb8dbbeaba8ea8b1c25c3b26ce737871de670bd3de489560e3f4708f2d9080b67c857a707838c989e0230227ddabedb6f32cdc798540e6a7de699df58fecb5868de5b2da53cd24057fad4a248db415f1b1b3b93df3a0e99dd75738b6c0a94a45e92f89e89119330e7a1e3e20c4f28d29f11b978b9c1f1631d012f448b8515a9a9e35303625c064a40a4d1b20cfbb71b20917367e7c36740369300536d1b0772e88fce323892ae3f4a0e75829d8c40b6453038083c745edd3149d9b406a71d18ea0d1b29e641695d90934c62c06d5d9861947eb25f451384d69a602df8b1737250882635a560d4737bc51e2e0bac1a6abf758a4b44fa57ebce19865d299d02aedb3f348f483cdf44dd369192749695f3ae982a960e73cd605083f52d8555b0879ce78d2abf8edd645a996443c650cad085528138b40ff3ddd44fdcd018f90ffd8b677e37b3af418b1ba4cd83190e63d313bfaa26e1ada619e57d8361580ad39acd92439289b9d40155661fe267f13cf64e28add4ca9fb49ac14b7c244cc7a6c06a8a57eae8cc002b1207da6b0b3b0514381ecf414efcd629c0958eccbf5d578f8e3328b13a40f44848a23cbede4098ce8113c53d268a6c7bf4b18ccbf529fe25defdb0943dc5ce08ea554c8b73337562cb9cceceebce6a57e997d40f0cddab3ad6252cd9e5c850383276f456fd8fdccfc8708afe4d11a23a604cdec2b1dd4078a88ce6741c2edeb2012d28fdfd751cf48dc3aac307498d4b30dfe903ea99fde98398be0143fc798505e9e762113909836c6fb22338a79d8777b6a9f85369935f19f0bc8e5a2c189494e970d9055205e36d43f7a540f04b632f93a4a35af27c7581a20f9809da611116904fac449e627a35856a1b122674e2cd938180688854edbfcb832f2a9d1c848ef3a869df5c9a04576eaa26eebc86feb05332c00472afb58a96f2c3c501bff41b4e381e9257bdf8d34b24c1867f01eada4b49f9ff854690c387d0f79237c681f54fc70a0e4f408b8a22af473e29022a0997dbfb00c3aefcca55139c01628c16a05ded5e1269702f47e3a9622472496498f576a8fb2b039a5d8fdcdb478c8171dd0c7bc56f4a1272c429ef1f54be7c47bc5fe69c5d5e19205b0adc05d4362ea3e243c98ddeb29104dd0369d85956fad78c425857417f9e081c589c552068ce8856a6bb4f4415d49b7727849fa37b36e04020a3d348938c4d56bc0096233a9a5bee8826931e8eea416633f0550e17eed317066a41cdfcdba5b1320a74b543f915fc6d67d9423a3395883d58515257b08697c61d5010f866cd757357f44cbb4aa669425cd7e335c416b38d94af1134d9db7f9642e71c6f96af55cc38851a4c99accd382cd142e68040cfd528025eb08958d1dba764069b7f112101f775324653d563e5f9f48a5cda84639036e673bb3cf886600ae9b208158ebb7a5f73b6a92bb5b1d3a16aecf641844bc0eeec79ced6a919e0a84daffafb1f684af059a4ccb2c798825a8e6355754a2752aa0dd37e5b6896240e90a695dbd8007ac4d8f5aa8b4c88ab2dd57bb015b98b6aac54377486470f29d83ef6454f5dcb165634cdf0fdd3ebcd1a5637239f910584f01e782edb371a5ec74e267da483963fa43cc1a59274972ef09d29c578fd2952a08b2853c095e62244b3cd56eea6f89f53fa6ed2c809815457ba296b8bf19488d0d9775b46d0ff7bb6c8d7c55dd62487f86d445c2bf21ebc4561c10267e1e5b513119c952bfb5d3feda569958771f043df8cfa560018c88ea22797b13f9accf250880bf533b5ee9955b08ded9c9853761b54ad95e786118f914d9c752530df41266f2e326f471f2908f6babb67de68e51624a49ad59770e31ab9e2b1e301ef312d15db773fff75f65dd6f55b8aa7b1c5363a67dd3c40d3c242d2662fd00a442d8301b4a0c43fb22afc3e2695703453ae7105fb2852b78ff5f324bc71a7fcc40eb36355d80da9160c45940906d520a382f84ff6b4bba4aebe06141bea4b3c7e095432b8a0a4ddf20e82ca0f264710e78cf5dda43a87109587edf70d24aa58c6acf63364421b47edbbeec940300e4c1495d1e9a2fc5e11a97605e4a6b9fc227b7f342b6d7e363e86056f3f8c297a61eb6464382434148f39356403fa209b53c761322af910259e5fc7678c8e02d608747d0c7ae89382c2b4e2a77c86c774ee3c58c60db6b6e8e2429ceb830723a55fb91e2cac2f0fd87e75c59661f5bb2feedc4cc0754051c30872efdd67295766eb63beaebde6dd540bc5022eb6e1ba0da0bd4bbad5e52dd7d8a6187abbb17436e9a05355e2003bd8e81b8b35f5188fca322a52920b0f778aef0d78ed7cbd5ef87b3978c8e00e01be2ba8856b9c101256bc20b7e5d35ae0d92da13db1ddad33a677e47f19e619b7a77e5f28309d5f757b201e64e394e92c05e8f1af341a54ec642e91b1e567bca9e3b40ec01d1188857eee0c1c30382fbe2eb35b048b4a7d473a91479fbd0724dd48a8366cd4a9d4ae4413ec0c96bfb145380c1091fdee90300b02220029ffde03a388fadfd02ba23471054707890c9e4fd37573935c74330cb7ef80d6f1cf41ef0752e604ace7b073cd03eccf4f88d8b31bbc4fb62a5d213574d869ad3174a7c34db8355826f56b3d3c0917bbd5883ad4d0a91ad65c4457ce9fc4dbade820ca3523f9310120450ea3d4ed720b461beaadc6006795aad05160214fa5baef0a39afa7392909eb9cb69a8294648220caa4a169de75ee24872bb36d1d16571b7b7a1c978a3bd78db386b79cb9754f96bc51ad6de8bb0a0978bce31e5a83d2db8e63757ea95f30475e0e0f4b800677de3b6ba1388e6d839ae0fe084aedebe24533f9e9a71b3308d46150377bef9a23b36236d651429ac1cd12fcfea2bf6472de0c77c62a504fd6beeca5220b5927c99d6aeaa53755a33ee32c1084635aeaa29df44db142df2445cdccbd79f8d6b62f97ca63268f6d510c6f28bbac2865f17eb883f3f3a216e4c7e3486daed3a8c0414f5d782e6a98c30c9890c2dd2e94c992e297b7957e1619fa77304fa7c2aab3138f3d52390f64060485aad6a949b01f4a68997d54efd2a33808e94c464302916c9ef4eeb5fae48ab2eec2ef61f0ce8b0a4e87b37ecd622728d8d2a16fc07a59e535b783ab851bfeefc5a8c4fd04729df966d102350728c4413761f6ee8f1472f8b1073e68b5e0d02f6e32f45330429ffad3b5fafdbbca5129eb9a96366ec208f3d9b8e0bc0e8d216bb9aa032261eef7af0ebda8ac72eb19e72555243a954f701c9c7c8d14f228bdf2a185abfe3f88a49840492b57d4c031d7e65693b07feb8f99c6cd4fda20bce71a346dc3953f6e7489e09e3b629a4def9a012a58000211533b09467b90c5b5ea43f5a35ea72169ca432a7ac43bf52d8d056d93466ae4f4d4a32dbf478ed8aeb3043b726073f561cf29aeb5c85142434ad8c2e6d8bae6efaa0acf4d0ecc50c235569284d869ae671666f1d70eab04115202cbe2446701cc45369ef660fc0af35c21c4581a6f9d2669705a5c2e0a7edeaa04260b837ce627a61b715491c0858218ccbc0db6a5e267e16ec19acd803fc5f576517350ffcae954e500271b25669b0632aa8bf24a20cf5cfd5102001d70b7c091b3fcc29318d612638405fd2c21a7bcd549e82f9b641342f3dc404aacb103bd7305e0d8f6ea263c25b01f78f9e47532f39e4058da73d2c7d0151ae1d113aa79bb6cb62d57f4962d682e6d476d4c32937bda309cb9938601baf80aab056761340a7dc3fb6a2fd9d3cb780539d6481d15a9349310b7a648fc54b0633cd5576dee1bf05d4543baee16a8964206d973576422922da0f01b6672b0c37ae764093f3f6326338736738255858e8ad1733cd0ba6e51f8a5443145069e90a804379287f43f50ef106f009f8dfd97c613e7fa1b44d3dc69edda0de3fcd8291889807b8ff6a6bc398f7d448f80412c7281efd569fba24a2dfb5833052e10e000e72ca0aae17e7fa40bb5de3184268045ad36717230d08ade29fbd17dff77b8846ad88047240eac7a92951ece1a2175f190ef72e1c42627362ff6174fc97aceb5a92efaa39bc5c165f204f8b011590ecff5974eec62c017b5f1446fc39601ff2b4da0ec4c4b0ae2e9f8cf38789aebcbdedf63f9242d56af1c10d89dcfa7cdb7044ee560272ab0db30beb5d731dbd1bc939c119e4f63d0514613ac7093991540895d075a44ce92e790ac8ac919fa03174e59e40dc272bdb0100fd4325df8acef031f01996ee5220db514d0d7d5f77a8abd0c7db0f82018063e3f669a93f01a3dcfc2d3f8f10a48f1096d8de5bf428bdb24b2687070492502361620b0245ecacc763363789e6d8b62d691a1bd3357f7f007e02ee797b18e8bee0a137f7ea40669bc90ee278d7b6c3364af2c223a2aed0bcbabd120c7d1c7feb22e7b81c7b1a8a7bd77acd570581cfd6970568b90e5853aa0018b34270da067f5da913f26059c740871e503f4a8ddf4ec878f6eedca78b89ff542dac3c5cfdc95a9e9d711424b04b05c7c5d52da4b298fcb56db841b4b49e0c3840c6fd35217cca580088f800e30da34a300fbc35fef28bd8b25880ae054ff928b4cd9b78e720172ec8dbf0760518e705ac2804b901d15804afb4a79feed9b197264bd8961b5f35857245f00737061cc7b456e0447b402b016da8785cd9f99a23c18db9efd0a26e6d24c028d1e4b1d4e794a5d022b4740700c1a1305e8a0935d5278bcf71044be27dec7e4448e6443c34a4c202bb49847fb72b506e8e04c66b0bb4e55dfda267901c720a483c0325562f8695deac5361550613c5c6fb6b21bbf7d2782f9ccf8d5a1c4286695aa007ad3daf2412c5176a7167345b77dff335204dde69e10f7fc3a809b0ab0b95abc2ee25a39b9c82f5fdfa0a25b71ab1f6b0c9278352b86dbbdf319d42e2b3e1bf396a1b1b937eec58da9efbc90de42db1af90fe69e955eafd220a179a2f6055581371113345206f1cf18b1895d1ae7731d6bc0a149a07295222531669f8af38bd339e7aaac2e4aa3c4626ab0a1669fcd64b2dd6e4b58d448dfb0734f449514259b1b8e9b6bd82285bdbdd8fdd228d9c7e71488000b98497f4aefb01003e16b481975748ce9f33013a9a654924a5e08ef5be4beaf12786d17444242bd542f5362c8121fa9d930a99d642a8ca18c74d931fd112d4fc7ed20d9879e6a9a4f210cd12b7339a179d835197368a8528fcae486fc4286a0181ad6a100caffb4844e4f44532ccabc29760ff938cbc8fd047e847bc0f171a93efcc6bcad521b23f32c57eb6ea1564edf58ecefe0881d3e37cca1341011bffc14fcd8185d09af6864843974c3d14fe957bbd522380e5423f61349ab729d68659bbee96bb9b38c538446d710eeab34fdc3a41d3c9c41b5cb2ac5b050b8609f7016fc17143380d1d701418c9b6fae47c55db7094b1809a7eba2c09eb947324e0699fcba0a3e88d4ef10bd82ac8a19e60dc81001e85703486c5c540f5b9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
