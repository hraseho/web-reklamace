<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9595fd46366309565f4b926d7522b680e01f19bf5f84896f7a393fa0609b809f6dde8661c1721dea00467bd4c21ffd6ae2ea3fc94e2e377d333bb4f92c74fd2690f360b52e3d53aaee38547f41944d9c51e19ad1d27e979017830656065839a78e58de0a8edd42e589907b9352d150588a3f7ebb950b0890d3795daa0e821445d1e21430b9a5a55eb28ed95cbbc5d22a19ff8540819352a6db3ab0c236d81928f5f9b635efc7e7f2398c3a80eaba1ea49246800674e3a9fccb2fa3571eff1a0592a0345eec70e1e79ed3fb366d41623303bf0626d2c1117eff71e9e2e38d79e3a9afd6e28cdc9c3382f06edf3ebc22b098cfd326229a5fe42f53d6dbbf365f865525cc82bb1eef0a6eea7ef2ac71d1d464488c605c5072d692f03a6b7b7bee8f92926b92169951c6d9b80d9094c920894303bdf026c7c85586d879f1f676192b052b30b9a7ab4bc68f5298af679876562eb3cff1e42bedf1ff65c3a30fe8de528290f0aa6e2f598383eaee63b27c4b504dbebd9da3f4a484bd8b8f3e8f7ea55c07a0b62859927054818223eb85f7d3b79f6423dbe8c01c1ca52675965caf5a012ca9b674b2d7862b17929b48f226ee47bd60bffa60d80ddb28e99d976ca6addb0bf58ec4c8d477dd671ceb57700ba1469ad85bd36a004d8f2b994ba7b30ee8a5ae15df23d4577e7dec2890cf5390f50053b4d606fa30a2e1cf2ea37487869c0aee43c16a2a257bb2c09a0a3e7cb526e66eda4ec0689e1768a9898c89bc7d852ce263c7f0e8f3c71210d07ff1a2c262884a1b04fe2f033c7c288940d773754cb110652e2ba3ed2d4babbf69e681b2df455ad5d2a255329f2c74797efbd31393fcd8e98d2cad82f14da8db963a7101088796b5c0878bda5e73662a852dee8b0eaa79b7feac0f05dfa45d30846b282b0177e595efc07cc90ef5f5c8a0c0b417112fedf3ac70413ec8b2c2dc5e9ee914fa245d86a25dac3bfac08580f382205d0ff5fb8c27bba58221d6609ef4eec3427ec64c1f74f86f4aff517556bd455ab3859403eabffb5e9c7cfc487031bd945a5fa570677e19fb827b6ad9c53cce0214671ed1ccdc3c2fd2dfd300c039cdb2cd36bb28e3100401929e14d775b94f1793043ceecdc93ccf2fb38ef7ed2c4903ad1ea4ba6c35d616780e46d38a6997254f6507c209eac9c79ac1c0c2a296efe7af08d10e9ecefd175d193a03b0c2ce7779e8563b5e60c02088dacb4f3e905bb898ff22082aeebc1b88924c5ffb7cfdc3968364e4daec100a04b171bd6a984bd65e3c4fe57027c068e1d5a54da312e0e13d50972e4be06a76948601eadd95ade963f7e5870a8ea3b7f3df4af198bad5661affe7d4d5573c37f2e1cb7020623cc4719de2a7ef02c2f6331380a05c4b1abdc223d13458b23fc59e4a7545669509f89b14d88793fc86eb86b1f038e9a3863da0e4e0d99dcf0386a836bfc411387293cb725898fe992e44e4c57ab2421b26fc5f9f328c2e10c3c65c631b95fa1d789a0aea32764260f104dc9cbb02c1210ecd44fbd4a3f41d446bc8cf1ce37d29a85df15441237599803eab9530879dbf784fc8ecc651378b60f326b70ce5ef68e7dd882d4238c8449bae12cb0aefec653190be17461d8729e7372c68d53d58a176d8b02b9eb8ce1e9cfe4ecd8a904c994678c64f53f064052a69ba369660b824388d19ecde20a5a26d61d4bc86d62e984cb95850aaa9d2edd8984659b3a51487d8c9c11011c8824a711c11492f80c66018c1f51f6c55357e35e50250a9986154fd074e2249441aedf9b15a899a1d00d61c87a41dd0f4003ecc1cdf53aecaf032d0b15b7f5674f3fdcbeb3e7c1ce740ac7b69aa0a6bf0e105a8eb9cc8046653740744acc4f2b745a52eae10dd3902f518e30bf1933c0a1ce93ac687c576b167cea48b9f157128c738df3b0f7bbcf4f2b51b48a2d64855f217d0c9395ad8b6565faa20f3f972ca3603e38f44659e9019074bc51638f65d1434a10e96e74a665f483a6e08470fe0a9b255c7f5c2d70ced04d085de9f73e6a7e450539592dae3e484dfafcbbd9dc9994afe5150ee6a247432ac1673f80dcd21f1414b4649027ab565aa5a8f2192b7e6ba6fbe7ebc36dd59efd739fa1a598db715be3c5ae6208d318a512e40a1d18c3eeebd180d645eb5ceb23e1dc43a94cf6ea2a2be77de80117a91fe4985ef86fbeb0114668629e45774d6df74812de5cb1eb2e8dd557680ee4cefc694d8b7b772ac18906ce808a8778a1feacf1d2e630abf411ac7817937c0addbe49cc249c0e08e84a0903d0f48df6d9dc011eba0781c08971b5643ce2ca735e6af1e4bbf2e869d13437e64ba125e2ec8ce4114f85fd85e206b0b3d2b96b9b3e683d8b5fdfcb1e4d9c44d1e4fbe2c71c11dbf4bbc5227c888cf5c04628814294c176850e380c8cfe64c52c48170158045c045d707af00da734c587526da75db2108a5cdd5680461985f1391511111854059cf85d74cb30e0d01cc8146e0e6c94b3601454ee0f6c174c850ae3188e262286564a66d82b5a11937c9ace9c3ee9e07d6eadd570328e64715882ba661f25bc0cf2fe4fc2cf3d6804cf373ba3bd5b1dc3ba6e3311a814c2d5c6fab4423bddbe3f9134c8cb9e71e2a2564c9249e8395334931e56f80072102d52567066fe4f99419f550d18c5ddb5ddc43049a37b77b4387f523db9b162b53f4c7c9de12ebd0843c1be0eff54018f671c0ea20d8f6868c3dcf27fadf5884f05ca296035a6d9ca0f7347a4e8dfd0f33e841452956f2793356e264fa6dfe6f6df6b41f8ef2bc61f7bc2bd165657ddb1eff0348a917cedce8e21a3b457c9536e66a016f6bc60cae5bf59fdc26f1055ae9b6891c5d5da9c1baad53bb8b75c74e5d24404b958c1885c3cdde8073b09245022041f5d07e8cd118fcbf0cb34ff48f0325f4f341fad4962ed0b254e064e4f048ce3695afe22c1a3b8def2eab7497f9a0d1733cd88aa154c4e1eabc1a171ecec980475d944cb4dd990036ba79c4d1afd82c5978efdd85675b6e28ce7d5e057c81a528c8c1c2105029eb130a0a301dce55ccd6aee469875614d76029bc86d3d1b24d4314335cbc265e96787439812caac29a60b85b0c2953a14db7a1e17d477c1d9658095e520454f03eb7d1ac4f1bec63a17804d5491124ce371c4803743a60cfb7a8bcfabf16a4a0d36bf5cf6816b52e59e13f29ff14a2087c1fcf9c750bbe0a244c5c7aa28b2e502f43320816eb3f7ea89454110a2dc23038b2e05cc31c92c14f54cd7e980194f54003dc994929c3f3077bab588941fe6d9f4056f5e352bb9f13570a716711554af6dc85a94f07ceca9f697f06d0a8ed4790a369e5eb777eccb4129c92479a47b4afc0ffff6ef4c9dde106c7418fb47d091c573b95a39eac6622fdb2b2fe6433a23d3954b708238df46b3b4ba75accb19487e38efdc664e209133d5647207767eade3fd049c244565cba38ccc30a9550f48b06ad5f773e6c2c1ff999c5a37db203fb054c02eafb8dafc3ce1962c73c4567ed184d471d6c64d1c2cda9e93bb158fc3f1af2a04c2178c7abb639e4954997368b783274378c74619ee96afef54fab23d26c915458e791b88b30c62b37c9bbaf0b2d88c27e0071ba169bc9dccc5980b6e2013a73082ac7c791712adae5c3904da63799660e107b61855e8554d3d030a689dae4a72c4f1ded83c142d32678433a9b194469f2bfcdbb784495df33bd393d7579474f13dd92cbb142cbf5f4cfabab7b749f923610146c04b36beedd6ab0fedb2a7a28b0b4ff94e008f1bc8b22286024bf76940a5da5bc13c4e0b0b1ec1ab32b347caf776b5fdd9643322afa249aad270010b3767d1e605d24703949caee02a853ef0bc2c1268a83126f9f22396b280c99ccfc48f03cf1ae95073a8483de15bf144ae7a6f9898e94d385d83b75b8daab93b825b6f56489b5789fcfa93903de96a17b624ef1b4f73f1e7bb139465cab9a0f5d0189110958dd5231bed3798fc466e52fa595399b407bebe4449e7d57e135ee21af2de18e309ffb0a368d9d4e384d110de9115876c60e64e62be4cc1b54b109f2b68cb09b168830d83ba80b3f21775ab1b800a56934acecdf792f5901e0a17e22a8c0309a63dc7e35f89f355c71267a39246385e4ad3a3c8a1916520fa14c603584281ff413986cb3b1054cfc6a4f2350500ca649a97aaaf701363cca7d129a6b2bdc85ea4e92742e6ce4f542d188fe2bfa0a7ef9eeeec60e5e7647e645f0987af0e8cf1ecf04402402c4f9f62b6d4488face944b8b72accfd706bfed2e5b3e69ba919a50cdfb7bf9f7ac7253caef140db42aba341ff9796945b5ddbe218c8e8fe90d45177f9f3b1ed87feb33275bdc708fb41729b1020d739877629fa9dd09a17a4d090f16db9cf54bddaf58a790bee10d6898b6edc4c80a1f1a8f5511306d7de82a7b7decad2b40c5de9509501cf16f73f2a45a287cc5f9f22a4a15294c8a5570aeef411b4dff7ae3f323183c88ee600ebde06570217078f9fe080d0279ab99d4fa78b33f426ebed36f987a6319a42aea27d7f759486a0a66ae3203ca2a4d420c8a519621ee882d00d4356f349752245b2083b9038392e78d77a4759f0bb9743b7c1b489d2144beb08f171fe69757c9c4be6b126e425833146673057b1104c357d2844afbf0fb62dceae8c9bb5a2212539f88916d60f57e924400f0032b11a4739ea33880632d7a892518e22cfab92ac7eff5735afb983bd1ed3fe6587525eb76bc0c2b7dc8b90f939a0215952415aaa1f1ecf8f247a2dbd9d4923de8e504a46cd02e20f64222016cc95b5f21a980f10d52e869fc0f58a077fb2b0ce14c1e7ad5aea614ca79304b6ef46a8b3f0b63eaa80c3b9b33728517f9b88ca618e03ba7aa435697e10818d49fb6f3d0e8ce8d7510b2f6e6e112b8cfb151f9f512ed23708ad5980d1a971a55eb2bab5f155b5e066f3588256f12ba80bf655bdf3fcfd01f0268ed83dc6a743f4cdf14063c6398c51db8d7fbeab01a480a8a0c845e0283e80c1999069c6643f8b71d003e50065aa809b750e9276519ef071305bedb4507a2fc1979e20656abdafbcea47e47efa86125b3a6cad38ac14fe400999d0e4cb35e4ee6a1fdcf4e6ec03278592ed5f0a214967d759ddbb0805e579e6d71699a34f23b50ea30bb8dfc82815563433f27d9cc1b7ce28c8c5ec737bd166f48bb9ecc2e27607403ea00e6609aa7a694ab8fc79e19af1259d25143c2485c793ad4dc75e9c9597ff06d9e79e6ea7ffb12d0b18d28c44dea83fd128917d5bbece3ac9e8a3aace845c41e426f3ded989a73db94de3a35eb9299b305d94c9acac34d5888d4da441df55c819fa5adc31f1b9f7ebae664b1c4f0ebc634e5ff8a778283b9a7604ddd92c2f90f11c89e08e8786371e91dfc0e57914807a431c0df9407ebc0629912522cf96f789c70db7757ffd3784e00f420d996ac52e0776f72f014dbe934761649dff15ca3647275226ea8c752d30dd41c277e49e58d3cc3ef8583c36195659c8971c44c174c6b617fe0e2f37b0302363eb8e0dba5ede6d682896eaca32e4cc2df6736a58f3d91b0a31d63defeea5702c653d1385e73c9ac82ee2c4c2352ba65b8a581dc3bb08e09469e641e833f103778b955b8324b9e09f10ae060182dc6ca0837c0466ec086ed64945890344389f9a8cf4166bc0233d87ee2ee3eccc689d4bd6eab5b8862d67bbaaebeeaf9f6db1e007a7bb714d5c35b70f5a793cfc7aa3b071db07572955bf6e6a9b282c4796e74cc758d9bf11116f10f6a04bca92c80e8a58dcd74db1975a65a0a5d0661fb71dbe2ae07dc0f84eb452d7083d8fea517ef99faea0039a6f959de783bef159ce3001c16bcd5f778ab0e41c17364b8eef482e6f6486c45b77ef42566ada3fbfd11dec4b942ddcbc32a0d89189c207547b6a1434bdc2b971aa995f4c2665bb0d81d25ec6250da84b9e7c415c4b15bf2e6a819e89d068cac318eff25cbd97d0ed1b852c3f3e5e696c270ffb325ad263397fce66883d260390224965d2f8eeef74f820aa6284c5eb0bae699df7db6a66c30d7bd83e70b6b83debe561374c3f2e307164dde734107be51f537966d47dbf93b7069f719b89ee36d9d56bd66d772d93664dbbec1bfb7f134b7b7378b7bfebfdd0f68877b2ba40c1a25deca3fcea2fedfec41ff71acc7195936b0ae6b11f5d3bb88b363da1ea8c4082705723412460f6160d7e617f615e4263fbdce96d39634b13d338969e8b52441ec370166412b82a2ec068a212b08667a319e6f36d6260922b2406cb290cea0334bbdd1a882d317db368bcbcc4ee498d3911eb1348f3fb2ecb120a9a5c9f69305cc80d4bb1db176a69bc5fad812a96488aff08895b2e121570d36df0201102ecc252cb1c208d7a0cf518f543eecf1bf622761a7222d4f105fd6881b1a4f06564207e3fb6970ea6a656a89992e9263bebd321165e4a7ca6c5c0cc18a456a137a549b6e76e836003130fba81a8d2de6570d4772ae1d341b6dcb9ab6130ea654071f797073aab3d89ff8b97dbb8b2b6b0c5029a75d9e571c97f2abc8373adf62fa7238302567abbb107c0891c2414801466611eb11b442cad7e8c706044231620bf5a45707ee6e3d7bd65701dd641246e55848e5ddf50accad8e58642f9b861da557bfd1a6449ec05ea13112ba4a6bda646541f0938e106d1b134c2e77e8ca0ce79674fc074f50b9de32a945e39d786adc95f20952168ff125343c61a0f22851a705eb19ef6b80208be4e652f310e012721c6086bff46a5d02e6c96fa9133928f340b6ab75a548dbeab7627a8f872caa0a6c553e09a1d9da0ea7ad541099ccb880d5fb8898a446ac441f54f0e0a8672977b6719e6a5c04fe82de576feab0150b28db54ee62c739f1a5f745c58cab5a8a9cda284ab8fa1ce7fe989356b9353d7e0fd7b5dd573741ae4cebe7437cb8ccabf4a8314c05dd701b031d5d20262519c10aca4e4f27203edb53d4ad7d6c014d3d9bd3fad4e743a34dd310fca44d4d9e4b54b094c044107d11c8b5c593662be02f333508e2f6e1c61c701ed99a4819d94e8dcf053197afe6e53fdddb84d699c730d4654475079d44e087321667dfb37cd0656813cce8226bdc6ccc6fe74a4df5e705b34faf39f607ddddd21af0e41b2dfa8e460f2c109fbbae8ff7b349dac2b1afcf2fef1d58b9724e57af60c3bab93345d1c6609c90474c3da2b8632552ad40ee870b08bc4c8f974a861b2d14b4722c3eac5380bbcd46ee8c21293d816d53e42deaa32488331891f38ca27da62cbdca04b68cc334a9d829ce8f9125f76008f268613999fff45825c65df700048f59444a5a2cc0a773e5b26fdcb8a696a076d577f82e0b65273e77611a5154cddf8293bd8c3e0b971fe5012ad5b060f27d0013ffff420cba4e3f549bcea9ec02d98dc2fc241e466421618ce20bb61f53e77010241b37827b5970b0d60fc6dbb86c95aa7ab9efcd784783f2f2ba88921570005445d18bbe7fe9ac8cedf5304f02f67c284a976d0bb1f867290beb51efeace494059b878f1f508572e8d3d27b107c91c40a7b8691b0435ca503abb2ab518c7cc8f356bfd0c713ee5aaecf681d4f65137e8a774c18303a180c9cd05f862a9973b8598b8ccb8c13b3497f8bad58694540fd377dde168ff55400718c5e006b765abea7b03ae0922e56ff85061e25227f7a0dfca3d3bc107ee9e1f92fa3389c106d27542366b01c79c02fcf0bf6ad86b8a4c2470277baaf0f6cd6748359e2a0c44e72da3569fc3ae4572ffda2b5a4b986fa9a8ec9762e5709b26153496109dd6760984095ca4ac32f4f163be39a680e8acc1fd4b23f2813d098689e90c2f0baf3d8bf4efeaa2dc006f413669c79db37f0b1bb49b889631919c472ac8f5fef4b08d046b38be907e3215dcc4caa9ec302f66142c016464f8196be2925d5596e061fa8783ec510ec9b93b28689c9290193e2fbea4e8ecd90133ba77ac9cba8e2e9702416146e9d1017a15d77df43c83bf6f36007270dd311db1b6d17aac9fa4be36d78f488d5b37c6d655abc2577382f5c2ee7f97a93389c045100c8c2d041080de3eb21d0eb889530c707e86f636402c97be854782b5fa69f916db2a20112d7ee26efc6029985a02661ce7dd6d0684487a3313e9241d5cc2ba376e186b93bb72eee6fecd0192a8ea0d86b905d62dab1ca5f43b0097d978fd0d006ba12c18d9135af63575b8f6f4592f2efa64bf5eac31af37281806f4b72316d21f7a7fffcba721117b3abdc102a16198b4cb9c096798e9d9962a715c2b5f63b3b7981a5af00569930f1bca1a5aa2c765d17f19519d07d3b20ece960b27bc3988613c5aaf39a083db4325341cc95f2d8c3fd28f49bd2f07c4d024bba97fa7f09a3bf5fa37fa6b252d0287166d1fa40a3f94a5a8b51bf1c710ae8a3f6d340a92ecf543fba882c2253680e2c219026aefa1e56009a7bd319db5c4720a792aeca7ce7817db5dce6415cd58f5acdf5785a7fea99b1107f73eca01eb72390f06321bc2464e82c856a2fe160febfdcfa889bb55d1b604911b3500b3c2bc650457ed514ecf2e1f7167faff33a3398599b3025ec7d162068804c017976b5b8f9410ede863c28ef5f322556e5b332e8907859653a874004c7c00a89fa2546234bd1ebe249c93b4cdd1e8701fd88441b0cd3da2924b86456f1bec0a75e6ee4bd80fb8850516b846017a5d30251e788360036c0064d622b92f8f66144ab31807ade6da3e9fc56acf186b86fea0fbd73e7eb549e52d7a535c82c4ad87cf17506de0f126f1cd2d6639e45054bfc2acc37ce6f06e1ff0ea4cb2241d43fc8df8faf52c40134de47277bf0d546ed19737e46bdc3c481e446237dd0dd64d0c5a97f416a7745276c1ddef22eaf94ca78084df1a05369f4826bc0f7a32eea6a3d4c68b8156fbdbf49823e6056736539218f4588bdbb595b03e7417408c6521bfcba639a162479cd6941aeed4b005d1afcdb008911b5eb1b9eee575753201f4e06bfbda48e7464c8f621ec4fe7fb830ab62c7be921a771a3d980c7535e93416eb1b4cfaa1a2814d0925e76d32f1fe5d2c52fe87eff4e002b3edb51afa3624be95fbfe2b676e57c9d85e1190d0f91576d541e4a3a052f85dc4de7be064e71e4f0e917ce34edb027a825ec0b816c7d0fcc6863e04330c889f00630ae7bd0ec8a91f567cc2f681cf91a9aafe6366ca09a383f073a13c922f2cb2a6e85f67b31c9b9960401c27d2bc1ebde94e074728bc1c9bf0ec4a48738578178177b8d3226b11f6a3a5208ccad563faf31a9b0a5066bb8abd413ee85da81d0913679aeffa91305b1355fb8fdd5070c9a38e2808769d7bc5d834bdb23fd9ffa0853cc3a84282e97f2bffe058669ed61312a617367bf822f29f0d0cca0a79b4e39896365d32fafcdf08238d441624207fc7d6d34c159f936ffc4bf71e461bf0096a1c0bab358d3a5c5ae791e7d486c0398bc926ad28cbd306b08b684ff4e32251c3ba5a60f155d432c7015b71ab3955322dee0140778b5f0c2c25179c34cbcc4345908b28f2c74be2ce9f25af41bff6b1f5c67891a54ba68821c97ced96031f2e1a2e06a17eb1ba6aa4abfefb3d76e9f248af06422747396126b2e53cc7121fd7b369f5856a52077f18dfa1aa33c3cfcc2f652f234522ecd9d1e193a5e9c2afcbf40673de431c685d7979e29d3a2d48625ec090a4eb34070586d6a4354c1ee2d90f5ee949fcecf562ccb9146c2a78746283cdfffbe1df7e4f0e671c66342272ec4cb477c81766546ee7804226a03b4927c4516d6cfff075c63b6d9f41974bb836b54d862abc46d99c763986a45e1fb56a53f9a5634dd0aaf8a4d3f3739761bc0d48d8395a937812ab21cdfca52b62c0e2a5d340112baaaa12bfc3965a22c1dcca160646c76edef2d3a2e190fe8d3bb6acb1fc19f95dbdf7d6f265fe0355a04c45e6c3f288e5654c21ff2eaff019f59708ed6c510944c1e81500fba67d9b10b83c41833740cec2361629c1a76316267d2f497cd8996c25b50695ffdcf1c2051a1119bcd881521d4a4b77a31b7f3f699fb2ab28528abdf874b27558ffc64e2e1ee4b5d9559cd661cbb5ff9b645ddc0e52af3e0281e9e0346225ba201475f369e4035de1c147068c478b6813a1ed99685bf96ea05b0c16189d1505c3cbd0dd83f852d504e4479aeac6ec2f71ad1b712bc19cd2369cb865a50f61bf37e2de2b8ce0a94ca0e73d91617d0728084a303be56baefd4c27b9cecce55fb764c9b827f4d5d2038cc622117bc4f906ff9f0d1a5b790052cffac0a13e0d6aa5e04158432b2502b47364e0e47972960345e895b46f34ab282975912bdb6295b5cca41da76ef99f7251c53a416707bba7955288e352700d6d5a096a90ea673061833e9425136d51b89373592b78cac58f05a4c018a9bab0805f746798f933bea7bb2fa77a488357a2091da2897147aea071cc241460a2df3d4cb07c93ca93700575aa498ea2c5641b1bcb749f8dfd4c40faa0667f2209da0ba4fd2b33552826f5f91cc865cff6fdb28e10a5b7b146ab0219bb880e276ad5d17c2d1fe98b6ff82fd7aa9a819154337e92d97ec4bb0b8277a0622ced60e558063f2d6c379076e114510449997481fc0d638954a324b67b5079c31065c13917f6ba0bf1cdc6b4ac74d343859fa09f227cb3177e6acd3c77a4cea04b19465863294fb8a5000ab16f5ef0fcda1ece2563899f606071a663c0a8592853bc9b18c59cc0a06c3b7ed06912ca5baf5dda1275dc75283f8a0615decef70cc481f3ef89c1007746b00c4ec296dd74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
