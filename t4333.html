<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab3f4e3c3490c89ada6b0010146302f6ca94a7cb929c6bd381a58005a3b72f05b2bf64f1c166345031eda526b20dbd81510c8c7ffb3862ad7fdec1ae72952e1c51bbc40556f317573816ed8ca03b9dcf2d661ff287e7c4c250b62de5bc3e8ddecb214623bb2a7a8c3aeb3b4f08b26a0c00006d498e30fcf046895fd9ba68fc374de4962ea604f1f8fb04507d17db3730497b32c1a24cd1d45f49237f9135ac42efc39386206a1d7a11ab5ccb026b12294151bfb7b1cdf312effe43617937bea5f323e6f7729080460a030c5790c250c21dfaf1baadebad26566e0e95ce20af973840d235627274223cf0292071eeb0af7c23b0e4a8e129f4f2b48b7277464eb6a29b42ecac0bcf6ace3b916b77395045ed3384a9f692b821f4ca5cb5196fd6b0c271b093156902389ae1ca9cb0fc91abb441c6c4a75b70c25b36892b73ad46baa29d9a2548303c61b57dec29bfa527afe11e4d20a622ccc800e84061d8670aefe40d1d29435dc21f09aa8871bc8ec1605c0b4113cb808f7e8bc1b228c39f6d78eb4d2d78f0396a8a9e4ed47360375d57dddbe4dbee2902838add0f918a1d52492424cfac219a6b7ca6c8ce5ceb0b61205d9d9b4d530f93b37e2869110f84eed3ab143a69aec21a3907a8a1144fa572e627c14bad71f1132d9abd3c8230dc91cce4fbd81b649db205eab255511847ced2ac173805cf4106de33495628ce198d6fe4233e2fd232d09105ff44d4f5e75f1140bb6920361c5627e97b16bdf1a8e5eb47ba2011a3775ea547eb9fce3d37dfa4cb708d4cb4727d34d1fe4a7375c20cf1d42f2b11bc2b00d79bde7ac4a8d5c122f939a9a3755a5506391e375cbc06c085f209c369d8ae3585496a3e7d1e052d9906db4590d1b58c3cc4b1a0304c51b9a52424778e2a80de366dbc3862e9285219444c57b9021300758a3960189eca26ae986e8300ea512103cedfd66e74a66655af34677f6c236eff1cc90fd7aefc1117aebb805817ce61d21b1e4212047b86ddf0d8a6079fdb9363d0b25ff7ed194e9f8022927760a8cdf62ffc90f2a335bed1fca1ad96c2cd9a4e1595e859fc3e9286f26c81d0a002d96e917cba6d3fbf503e712e30e6fee4d8d1dee6d638b3138f52107c8475ce77add119bef278dcc2a525564651055116c4e5aca620fc6beda61a1558308cc73a92c653d50708c0e873a1f0b97370a99731ba4ab6ee44be923f54fa1cebee92e1a1097e528c6704d8814dc932d44fe3fd1d70aca38dfcc535740297dc9512e5bf2fae28bd70fb739c63734d78c9f70201e1cd8d9793d41a940bf0ec8a66c0811857cbde0a7964fa2c01dd7507af9da72e52333b7373e92fc56f72f755aa24d970830755b10cb3b2b2430e88ff051f1ff79a276f92bc73b11d1ec18dd553b6386951cb147afb890381304bc6fd4315620a96727ccd933bc65cd6dc77ee05e7521769a389a8cff674a4689c0c779d97f8f62b03e72fba4d88a0d0081bee71aed4dba53451474a867376091c8f28aab8fe7a8ea6e99d9a560f5502bda0223bebdd680bf0c350e5004a3d68a3d6ac41dc0fac5b9517b6bb7a2bdd9b4e89a6246f3f7a5ca076b26d6c3762bb779f0b340c9d6b0e839250bfdcf2d9ad149f1a11b498a71949e30cef681758fbdcaa2b819be5b2483f630e2b0603f7e645e9962acdc7cf4126c54e9df152c4a2b64dfec5dba0c9a786ea090ff82c404629a00630c6775d2e62baf99ceda568895cf7b993a58467c99afea03745bf7ad1c90a975557bd22353079ba6908388ed55308b45ad285177dab78fc04864c44fb04370a7e1dd194322d0fc16fa58bf93e8b58db701d30000eeaf0af659fe1bbba682c5fc20b65b151a1e395c2823ba5be61bd79d766de021ffb8d6bb9b1475ceddddee70c26e632513416093a07d2f54bd4808121b8eb4dbb1d615fde018c618b46771fdcaf1aa61e644b9778a56bce3259a097b6a38c0f4c8ba99eb7920688f8d02977eae3a61e4796e9ea640094dfa0086280c55f4e2a054b6288f7f55924dba5350c1f22ab9cb17fedf1c4d6499bfbae90cb8a69f28c01fe2b9bd0bbad978b093d6242f95c6dcb8b59f4b3890f08c8f2b77552ac4096245e995cf79a9cb7d74ca02cc0006e683506efe94c91638daf91f6c605b3e41afbb4bf998167e90aee562b4afaad60216915255d230615b0ff903a7d832d2d4727d77d9df6212d7c22d0c41a651476e652a4187252d8df98df59ae321da9c7dd0f206ed7e6c19f5719f5dc57ff767993d4cef10285cb2b5539d465d01e4f333baf6715738a8760d0c1a40ca786b47520b0c8b628996f533f12f02a57cd3a567af51512d52d75d34b9944bdb3febf8d02208582bfda20c0dbeabdc3cb781a3b11e645b6dcf31fcc0edd2b11aee84baa1e1dd0c51054968203030468abcfb635505d7cac42462caad7d55de11cd2ffc7cdfa7a4ea4ceb6d2ec9a937b23317d4bbfb5b260a48aeca8a2d2a655ca4b8b40948f42ae484b09257697560244561e1befe07199f47096738a43a82bcd89065bdeb2c6bd828ddaca60c22f76115160f492277381f8c3895f4a24bd9d9998ddb9cec9a8ebc7d7672365b688d59453d564320c58b46b366c1ff4e17d61c4d86d9387ffe24bc62b9d169899bd41f73f24d47f9931babb220363d838626e876b65134b41b748b3349ab97fefa9b2075f6f3551a32d464fd8bd5a391d3151c4712b2661b922efe16bd1a2e78c6d8431b93811bb815cfddf0ecf52db9c23545e0ddb82a99a747480dc63ea9c5822d8b99303b868599b7162f3080b2188ed4804d48f1a6dc2ed0381f08dee2b7e9431c9c00fab5dc89c72c2c0621ee2cbbf52e20f6b64f11b10283f0ecd0384c78f47e7e1319c3b2d38a72e7edf5207d2d3566f6d7953bd2d3f6a8707d56c3aade047689bb6b27a4c86e0fe1f56889463570e958e95e1dc71b46179906141c41789944f4046c4ae7ac52746d1fef9db36cee61fe6e4e9b603952b88be4e760e67e654150b02fbce0c8a439bed7bb78b7d3484b1224aacd48a7d93c83a4a337878e90712f80d63371ba6d4eb6e47fc36c4212fae10af07b4b1cd55111bc8de05bcd6d2d5e0a570bb6dd49fee1e6eff200c2f16a3289788caa2bc485a4978e132e554d956999260af014fcd496aa01eb59e6801f14a10969281e5ce7a9096060b1127e763ba3694f137261fff5e2c82aa4f3a658d339eb08383f180ac0db541932580ab6e5d0720315c3350838c3ac7222f6b408c20e23207ac97d32dc891a80e124a7c18bc072f495802fe09ff39eac0e280d5de7e81ed7edb6458ee7bf7af4fb4f3c3424587aec92faf5885a6cf7c636503bc8cf50f80c7f618383d55dd8ec21e3d59617b30178d28533a987695c05ada83c6167d9791c03bbc8fb9eb4fbdf762d0eb03eac9acb5aa3acb7ed1fe11dbc934d59e1e75199daa98e082578655603a28f31a8f81df76f5b240d9f7c0bcf77dc0711a57617aa23c2960c397888cee398616ac67cc1f3166ed18f37327dfada48a64fdb3663150b6acf27a962bf4d5e09207db82afc07cbe1e00bdccb968a96d7c819d7a44c2cace71c99a7af4611d512747e47ec2298819bcf4f9010e4b593f9b7d06a523271e707d095e4a0812ddaee8e6d6ea3f387d9fe53dc4c386fcf3dceb0322666e140b5136e74b9f3b0760fa811463cbb43bddb95d8c86409dfc381b45e1d4ab13d3f687306a7a4b2ba90916e921d69236fdf66c332df50ce5ca08852f5d90f149dd26085c0b3e3ff16bb4b65397550d6b4a374474475bf05c4f849cff2f5617e4989bf48dc48954549b2bfa594e4ebb4be4c2473881bc2df880937dba5f99aa835e2b2a1c8b357d0eed9da8c301dd61d78e7fb6419a6c20ded8478db224ee14b0ff13f84efbe8756259d2592e04493c378c0563f9e9e577a7eb85ba1835892117a81f6647b23e782fd96a23e20dce5405868f0b7b5be48428073321fc2390981bf2e3a1ff2041630a1052ee554fd58de6eacac7d3bfb84a30c70183ace163f6f37559451b11da9f242a276f093b7e187d448f64fba0bb29a8633860c31c472d9a8119b8e427cb82e87b70c3f8b333e200166b8f1b5d41f9117304abee66b2a69a7a89e414726eb0cb277cd17bc06776ae14bcad90c9f7f7d4d844ec2c9421aca6d0ccad56fc72268ed5e46246a0a9bc9865d724020412d3d68c786fca89631f5fa86a9f71ce8c8ab6a88041481cabacb7dcfeba4f73db08cdb33c8297e48af052724998a501a35c4db0baf75548ecbbb52185c907d70fdab88562993b34af583c85b97c0b7158a69861edc40bd9dd9bda31d5c83466474be45eacf1bb06a62a1e4d4de65fa1b3f0fd2d6704f48106f5467f7368f59ff5518ec5903862f43b8d60252b6450326a351158433147cd2b8ee38bf008d68c58f4e52bb3b0099b23c6da6db4cf76870ff04a640b105e14e8ff650b5a0ebe66629894c55063282a5dc430f4b2fcd27216f8e0a09186b5243f6bdbc4b3df4f57989e5fd1774264284990af50a24aa3a52e9ac2636b535bf7cf382dcb764e5c490db5aa00459630faf2350b515c036a5fe13f06923feb3a0f1b4984ddadb24c9f29fdc792561d315b0e4cc8308251543dfa4b8384653915b23092103943a9a6f6289ee1db2aa99d45d8242b0ca26db95799a2d83d23ac802dc5aa9ab438785570bb8b59e747a80e3950e70caaffddb774fdda85e91977b608b86fcc8ba33aad33d3a172ac2734880de1d63d96a426e5652d20c6265e7b57129d19958ae7059de07b807e51738920e5cc99d36250082c898d7129ae3bc034d2266ad78dba9775c09da99403fc9fdeb25cad6f6977a9a283e539b3c70ad8da545ba96985b04e4e32a43ff143a1b58fcb738f214fcff646403153e9ae98abf6dae9215308e1bf775ff143871a0ed29d802ccb67d0c79cd143b9ab0682684f28b65f276d381881ef1dc7bb2003d7a8bf1ef4983117c9828f63ac188b8178421041c3cb7b499ce39089e831e2f0102629c45573a8039c295b66246d4a357563084fa10b050ded1793e992e5ea5442d20794807c0f85069dfb5a503fef959a75001384d88148316639c1f401dea3c429ffd2f031549fbbb84c5d26272281c9adc00e8df84299661bfef2c85fe83c412ebfa4651c352efe748892baafcbaa47a10dc0403c71e342f81490f3e27f7f6d762da1056fb6a83b9bdf259b3745df82d3c5fd6f7d8c9ae1bf0753bfb0c46ec3e5c11713afb37e25f51a50435b32246db61fafe710ee48ee9c559afe88678e2689b4c9f55a8be010beff38c91d89e60d2c975171e7336f58a4061be200dd991eb4185e1191e449dee3a73c1f6b98c78dc5ffc3e342abae50d3a28b9b1e95d2ac6cf2cc57e17f974d4bb7c9fc734d000b4141a5d5bf505a8441c998d2147f9ee257fc29a3baad78d5941a3fd7eaf54f90ee81192d28c9e2b02a8d8f212e1567297d6c2755c936db04920e09e8cae2f74cee1e2a9a5f386e8968cd5a5c369abfc94e1d0c115545321dc61a9712f32c67af06ef47b9d49f8ce5a2c398a47e83839611f3f0f0810d159946c379114474b34c09483c04814b24dacfc411f325c51308c0c22879e71eb7edfb5db30094567d7c76ff6480ed0d56a1c1f113f91ad1f7d22f8621c689ac59d4b0896724bea7e75f5fd61cefd6236bb5aa82fc7213d5af11e2a12d013967ec40bbb99ae73180879d3ab0ec943f00e40089791d26f45e4696cf115609bd463b1c76fe566d02c9dcb369f1aafd8c2fc91a38e6c4f361e78ba9747e4972ccf6520611a5fa46d55ace938af7204fc96932270756ed767b5a9668396020f70802f8923cc6f9e5a4b6462b60128649c848bce398d9909c372c703989ff9bacc1fd49abc6c21cda346254b9d170f771c147ba53c95000e42edc78314c7410239f58d7751bc43f1cf096447dec5e73e49a241489c1ee00417c60e3c3c7578b07c1d22949bbd983797c47a6cc15be380300f616fcae77dc5d9cf186f2275251eacab44592fbe5b00c6c4fc4da6ea72c61c51a6702080c5ca79760c167dcce703e9a652a0b9b73b54cf4c9e426e45398f7c54e8278ccef67a6d52442650c41cec5fcf89048a536799d19063ae78ac456aed9a8ad9ac0c0377d00a6894a8d66dd13aaad65d78ff14b44de70c269de077a9ea3236bb13ff9200a2e46c223bcac599fa3b520dfb2ce7d181103675f6a7d50a1234a615e57b24f04a0b9f865ec46d8331d2a7035c5f727d472099be266ba7e53c8972c127d87adde4d53954b2113f2932b673f9fe8b33e78471e7a949c427a6d4e8709fc52febdc8d332d65c53e1c5bd634c44ef0a7b8168c184df888c75ad8dc39778da33fbff3b716ad41264eba49fcf4f10b072f34df3c5e69fd0c0041aa22c3d722f97c16d69fee3ef8dbd75bd54474f6d92dc4f28fb80512e4b85e4361bfa12187e2f3abad4bde0136321cfe2dde8eaffcdbfa2ed1a769b87ac0b2ae029a80c7e0fb0a17ec7e4ce351ec40d684f38935f9e2501dc4efe60b0a65a459ac97ba9ab701d1869054f52cb57b073bbbf673bc32a4f184729043a50e52a3a4a84b0dfe92d38fb759fff1988158ec24b7ae7abdac2e621dd5f19bf4cd1afbf752108ab3f0ccf99b7e9d9b0b599c4223e913d5f09987ba44969c9d34220c2b0720f0a60e6c42538ff5004220e1111683df6f484cc0be33f93df9ff3ca3c91083dd737820df1daba9ef6d2960f304959d810cc71118f5a046f81908ac57180601429221effc37bd4a11c94e86544cb7f89af30181f11a254dc54d80038e17ceff0083cbc020886f3b4341ae1328af0fb31766feac8a959b4b3e9d4acd377f798e9ac447253a20ba484afb0024f7dece01b1801b036cf52c875d19c51109dc9eb3ddecd2f4bcdfdbb0c209f4daa05c38f18b1b62f40bf50833d045293a63496a7bbbe1327f2e1a3a362dac7174706a995bf04e971451325ed759ef640dec8004af29d5fdcba5721a9bc0e5b203694f699bd17688831ab50edb36df49f5edd4057c1214d59022ecd8f1dd6667de7c666553480dd8dca05074b0f2f2c7d7fa60d45c834d8eafab7817870b67d1ae741bca1c0681224a8c0f16f45cd8d2cb2e10acba4ed9f01ac8392cf679485359aef058783132e923044d712aae8e19429d283336ab0c1fc80d43163bd9b01e56be6ad0573ca14a2f7fe9c6b431d3300e3375f3aba30b1dc2cbb67b535dde1b18359f4ae423cceafef1c1851a07c00f697bd6cbb7999d93ef7cfcf15710b4d4c860a31603a2fc64a19bd5a301706b80eb2e76f7443ae40a9e4e9d12cca830402d3dff3201042042a2990dfb2f83f83b126013c0d333cc16d494fbe7e6fe31dc4fe17e26d5881824c505f5556e7927f0e7d2c523265e30152d2d983758cd0d7f0eacf35f88a83be7feacbcbc028a13c78033877e637815f432c57225c65e2a79c25c0c9f775fa4509c2f602c94224c028f3fb9341fbb9abf1ee2ab080889b86380b7d03ab7634089f296eb4aa39893398fef3ac8136cd3ed92bd6ffbb9816984a44f7b4ff3798bfd9984874f4c9ab3de80dc5b8daddf6582d4bec5c1de181675afbc4601c12154bd2f0266dee6ebdb169c66cf6c4757b151cc894e74f08b2746a866912b63360bc1df0db06c2edf77d6f1b22c660a26e82e5738de022b5bbe26b4b70e03f524cb3e1e0dac69b685b95eef6c29ef9ec6239b0085b19fc3a298b7f4a3e608887a468bb1a3a47495b4b9860a283e1de15c6de552b5b481d6a25990293186b3a7057406ec6d95f53e3771a847f6b982ec9f8b6fdcd22868fb8dd32e2d40e8650ff55f6063c1cb2133124728e4f47481f12f3c7107c03d31e793a708d199f515368a6672b8bd2d8a7027db7e76e54c431eb7089f3c24a0fbe3c0167f20adf1fcbf604a02194f12e6bad958aa8749216b806f3e801b1c01157be493ca23809e3c4c56fe84f0d6e9706e9dde8b09579ade23f79b899831e2c49baac1f19c80c58628f6bd97aa286a0e44733ff18b6e47b6f52e2f5384cb47737b10c11bd338d6bbbddc8154ecaeb01a95a3bfd7f1285263b926f3589071de5236c7ad1e36061c38aa5df2aaea59d3d3a72040c1e9f8d6a08efee34f7d8c7be1b83758086ea1f79f5fda1d54905acd5106e666045258dffd3502dd5fb5d63d9e9e90f221486d82e1989641a04719899287c502d37665dc3afe5bf62cf5ea3acfc4cddc9502e8e7351ac38000a970fb0b87f64f3fcbbc43ddb19222f099dd21a34ca71f04a46e5fa16846818f80ca1f35c161673e093add5c643c0f8020a36f3bf60f62d3d5ea33c1f9dfeaaaa6d20304c3fafdcbff2b9656acdbaaa19661095f1def6904ce2a670a3fd0d7af2e27cd6800f77d786d158c41d98c27db34a8a018592a2002c624919948052d150e305d185523600a66b28a3cfb3dd57e124bb21c39c83b575b82116219a583ad10a08d71f41c061bfddc44d066c5965b0bcea068872dd7fa360dbe61aee07a40dad5b5899d86315c45b3ae8eff57d116f0a7cccaf3c15fc3ead1118fb16afcac0fd65f38b8d5de7159ad2ee9f024013b91119d47882f233078e74665e3cb04e33721d714c88bd869099626a9370b672a9fdbae0f8f68d5539097e66888167866ef3fe1d66ff9bc38e50c344009f331b012b1e4f9e16e2f66a0940bd72060252099b9312f5f2e521afa8164abc023aee35e2c529a3e7c157382fe53d0789710a7f9779a3c5a6476f0e3b21fc8b9e841bec8906e420b0d6d5e683a3e70d2a3c6a5604d9e40298c1b47aa5e8159bb220482c864523c649c1670a964d779ec20589b813488eb9b7b36f028d624e63ed8f7779f679e01582425a9ef2b7ea6c9fe547523aa077ba6112bf45048672fb4e8d123e4bc6e886f9ccb870eb8d20471703e20d90088c22df9c0782aba4216df05f14fd6921bbab1999cd58c82c498dc016abc93451246a57a9e2eed5b6033f2c74c0affffb9b59ce66e85c15b778f56f4ce2646cadc4f598d1a3a020345066f857c445fed72b762e40fc023d0c3113686f45138eb42f29173ff05a95bf246f272910f2c8f9b2ab5fcd0ef0fbe14bf7696d3bb71e436a4d519d25a57b891d7ba9ec59e868e6c8d977d30a8ec900e65c8a0cf0547748bbc80219110c1eaf2ae2e40099ede304d8c7e9aee19794c6274b46cc551deb08d846370fdb1b92477bb0e0cfd7ae586c3a473874007bb5188435e704944dac38b7988086b40f3842fd9e81421093ca3d12c882c5c06b349daac8812a86d20cdc62bcfe3a9b2a0b860aae8e5b17f3a2c6b13513b072e22b44383add9ceac866ffa15ff0d456a43a4deb7f65296be22abf68bb3e1ce7b75603fca7d48374ba44e523a7f21e1b11871e58bb7d046dabbf39caeaf93bcac80b60b8d7c8afd683c010f0a7100f952944042cc9ea08ef14a82018768df2f11576d4517c36beb8dbbdf9ef0e7988fbd1e5b9ebe1d9776b04324e327ed469b94817ef75e83f25109db190e9ae8dcada859474f61ace47ad2f56da36f5b2f177e829959e4d0a827c42b756e2dd2f35d4063981456469584c22d7f5d2ec7d401e9c1ce60cb1555984b60dc0c2c1590094bdd4543d64c566216fd6d1fc9b218e05c650ca860f7ade104eef981cc92190ac06f47b064352649f22b864602e1e7670e1b35716a7ca1f1a7dc578193096ebdb23e5bc56f4a192dc070d089c1f85bd73245d75bc693e543ef7ca57433114e0e0c21fae18d064f77a59b9a5905ff2397659c214672bf43290a076a2cd0e01bd9282c784c29f2f0edd5e9c58277c01c2a564c8c95d1393035d4aac6000ec973e085c5044bc0ac5cddb8b1c0ceb56c6a53dd9ac3d178dd4203828a45059acdc44e4a957d050efe3ff20c06c45decad099b19b1d7b39145c9dc0619d476e66ff9e4fd733e9ee46f93b8d6a9f6bf7cada2b7c13348be131b205f2e49a03d412bb70d095bdcdbb453e78780208738566e6d246a50ac2d0d42c4467d6648341fe65653975948081eda34e5976aad6cf07180fe1a4f5f7154c95922650bc1683fc787cb9aadec39585ce57184e02d0ddabdc114c393bc1f1cc92ef276f2cdc22d97465fc026e693514","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
