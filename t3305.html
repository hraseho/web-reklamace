<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c77c011c7254ebe3ba71fe2865129d4e9a59fcc9db56af49ff1405cbf25bf901b6f7dfa165befe7d768fe5563fffe5bbbf29e7127142f157142da9a7a781ca1fd33d3a9e9f5003a5b6f3431abb9ee3e4d7cefcd334b772e7655a5f953cfd6786edde999390910abcca81a39c1480488e67727c1d07a984e825f2f9b87033fbc5ceec246fa4ef53cb5089bed5cb835e75533eec045e3b9373448061f37098ea37dcbd9a5fd3a07912cdee653769cb82f3b0a353ab6bff5593dc66635dc19127d75f8c92cbbb955fee7a7cb995fe728178b8712f4b9a3a09a25d01909b5cf2074d3bb5e8e390b4c246057a200bd12056f40eb46c60117a3dafe8501884453cca74922aa8b5aef8c2fdf38402e897d92de53a04f46a256806e0b88c8d88c1987b2ce4459d3e7dd44a48f5d3403c3c6300339ee6b671e711f8aec4c5c90efb958f12588da9e3b2d511c51e19de31aa4eede4b6fa5374a0f0bebd9a2884f61783454d5dbc10ed6ccee841f85bf687ab0c8768bf1c17c8697fc1555651282447d86cbb8e6daebf78e32d859feb985437422d7c14e980c5cf24097e52980346da82cfcc1ff7865cf3b4e2179e758b8561189bfb101c5ab525ce0c000a8542ba22938cc7faaae87108440c246bcab271168b54b1f0d5a4557622ba33571026957e29c8fac2fedcb4218aaab6635f91cd032b5ce3697c67a7019bbdd98d5b33e5b0b11eee63471cb0d57189c73f83871cd44b6c958b0050ae44f53ba3575e07d75f3eb31c26bd36510b8b7cf37e12ceb7907e92cacf492c0f2c0a2dbbbfeff6a4cec02753c9702f61b6467d46b7c204c4fb8dedd30f2bf56ac288a429e3b491addd847496186603e86ea275cad12626a9ed917bf08fe7c9fb64695b3b9da530e8d747bb3771427d6e6f25f814a7bbb14a577611b03b520886458a77df5d9353e85ecad1e58d2b75c142f2b6904760e820b543c3bd59d8af1bc78bb79ca8aa591b87be41f9906c452299638fe365ccb299f26ad9b0e2a0a4bbe98a6050b2536594234b9752be96d0a16e961bc0eb216c40ee11cc5c2a9c5585dbc9dc6fad5af0e0090a25cd0e8c37387e7441127b4350b35c9dd9c19280821029e9e980f67428a8b50586b485eda080532bee6900f4d527b0c927391f7eacd854d8f3f0678053491c59aa606e52deae9eac4f67b4c972970d2d1704bc5f800e39add87dd8e06706a4b8d13c877f208028dfb9cd875c7c710bfa471b2188b184603d8014502ac207d242e1e80a72b3497fbd12bdd3309a09e969e445fec3fd99024095ddcc207082a94b10832dffc5af63bd73a21bac014550ae62ada24a0a14e46768b661e7523d86c4b1a90d10f910d594df073237355807652fbe457d7fa0ff08b0f18c2c4fe15d4ef583740a5e0fab71b2739b3b619d186c0c597d1ae3dd03a24c6680c5068da0562e233185cbaf4e368fd36f8c6b2f6e86a4d6bf1c5de179a78f31cb88ca23dab979a00652dbe83da286454f7fde5842aac98661dbc5424546ec930297ec504311e9ad150cb9ddcaf305afb3b77ee6991b57063f60a9d1ab873d46f17760243c607ba31963a1d066eae7b397d1c8c6b9a7bed163443cd65bb89af4ce332ebc9367136807ac037520bc920bcb0e78813710a4f889e1a2cf75d58ad40a4cb2c3890c453f06cb10f867e579a017a60fc34b2db6465b90ed93deb919467d302afbebab9ef0f04141118bf36cbcf61a0c432602744bdeeaacdb8904ecfb6e2ac8990d1bbd6a861de55371dff0f87baab4c1a06d1ec624d0254e560d370cb23af8418f8e9d7e33bbcd9dc25e43b8ae8147c05cde32d7c5aca4c854977cfda68104b4c5bdf1c1898101c3fd898b6fe8031cfd9902794bd4dcb27a528d7003ec22ca36954a1d7078ccdf744b499f2e2047f690d9a1e54f07873e2a04d7259603fdda97fc59dcb9dead87911ba6d74dce9eb71016fe8bd5eee984b7f83b9fa745d60ca6db8a59e7d3681603cf75bc23b469351458aa0d1cf6fd4886fc84ceb3c8d08ad2dba4e2fcfa74731a68f1ddf2d54cb953b6b9b6f8b9208838b8b499a9ea2731b1303fe099a6f7ca9e7cced466d7a2b1e43ceda0bf247cc369ba3100eef99148210f78046107057f77944aa88fc8597f151f2833504eb87c936401f067275df039e64c854aa6b365e42eb2420f05e61e9e63772cdb8d9d857de07af0a4fc23f80c62f3c84e23d9f126a1670d809a3f8d926194b63f802b56da6bc48caaa99fc6b0ac9a85d6562092e57a38c322d7b6f45d4f2de4543c0d63eca55b7174d22e5c89b0033edadd3f31a5f5d7f13f1502601fe22924254ea38f98c2fa213529114e227348cacf66b30705e37eb1c396846db60215e7eb1acefe819e4157b3d819fd29cf5829c7c96bf6b89b85c8d3711159ea39927685b3f3bc459bba83c19d90a2eca1d7464af18f8f80681a83dbbdc46c4e825d421ae8d03f1bb297a8ea4d24d6fa8025d0661272e217e46dd13f57ec347f5018cac8ae4e6fc82dd71b3695c8c19ce6dfe76d2361bb3649d9be6538fb29bab0daeab78ee649ca5ba185facd18a20b353c5d60d0e158de5fde7c7fc0ef9d8853d27583910b079e0d5c9b0a1b9014941da24b9770a3316c0a644759af61fde749d2340ea64e79452224e3e949cfd601c92f2d7caa903c3297e1786601a90b8640330d64fd4e70a72c2a255f4c711827a4326def326396289a6c1fb7454b62f2cf106aa31ddae821d552b1bc745f8189db82148d0396323b8d41c7fb5b1644ed3fc0c78c0d4cabdabb4caa485aac58841139a206e6b8363ab68e21595245e2dae44947ae2019f5a7eeeefa10fc4700fee4f57bc19c1c636fc183eb282ca5419f720d044b4dcfa6ad4d133149ab2f68c0d53bc33741816ed9a4218ace75c289dc968eb8049dce7540b04356285c49d30cd5e953a0419e4b2d2d1bca0738a4fc065c0dc8bc49e4b9dd9f36e6f8ef18c256eec17889524579b2ec1cc0d7a03ce8391fa78054fc4490f9ef8431419a8955f3a0cc32fed38b0f24e606dfd83f7674b80a5e8b1795ae5371e6061c7938e226a895c38ab3a3c131c9aa2b5f23ffd63e5291237761a262676bcb3b7eeaba4c5c82f8ec59afead8c234c5126fece3b7b0022a6384bc4ee0e06118d17b864dc50e80cdac5dc8a757033a6637d9b0b28954d677341cfd37755f64794283a33ae0c1913929a88e33ff9d50c8d473d9e6cd2fb80119c53f32aee96b43b1e7879e389bbcdf4273862a33e296830ce4811525d83fd17772a9667f427a40a431859566ffa45d10081309cc216c3971d360a67c96cdb40ecd063fd87c1f0884a92a28f16dc63cdd2b289973adbdfaf1fe452fab9ccee05652379d1ca18212c98b2bd4ab70e18120c39e5889c1b0b9604423bdd1b0ddb0525d2d11aa5755ad8c153121e3221973df4f783dd7931b5e610ee1c5845a36d3eab7db5e58faf3e41306446c5af9f05730e12ede9626c4476ababa5fd09cbbbd9c7f926948235ede153ad396e57676fce99ff39c4417e102e54354639e6f82ebdb0950a3f95b3097d9fb203051947085aab08d935097d33d8146fee8642d97e052ba464b7d2ae5be3a4a0cc3674e3c1537b47208c25fb4760195b6cf25c25dd6777beadd058a2f4432486948261b0757895da09ac0983b8d3b730f64f9bfee49da429840228d37a63d25acf8ea8d58cc119645485682f458820dfaa21323bf62311c482a7c1d2f65d841d916e98e8c60ef573e11329287be55ed5f11f1bf56e57449ddc440ead77f1a4bd056ae855ae090cd4d7369f35aaeb30e1b80d5231451c6d8a95db11e782abe46c890c4e339337a59c4086f0cd92f49446c5511a41284c78d3a1d933aba80bfdce57d288d61eb60e605f5ac894ebc53085daf957e390068011eeb4921dc148b3874ac2ae7a26bb34829f219f4b0c695434a68e12b2fffa32a3a53ee1fc2927c2a40c445920671aeec8c946e827f5bd37fbcd847a774738a22725043a55b4a370443491f550385f5d26c389bcd6a84bcb6f529c39f2fe946c4a6bac1df3af4fc88e1f21bc0b9313686f553a2f0a9e76ed7a0aeb820a58b6055f2165f764dfa3d954e993c2dbdeedbe2c2d972826f7ec8a69f22ba851f98eedb26de69d6190ae82f911594242cae8915413b72a150ae33a3a4bd5e835b5959be81aee667750422cf54cd71f1001b7541eead3138204eff1f6e293802d2e4fc5d75bbb69c976286775023d568e4e43f120c9d9bb6ca9ea5529e5fc589b2581dffc92bda887e298c92832221d3c1ccfd6b1719acf51ecf1bd1a2c18fcae2bec036bddb3f17be71209c31726a7059936d0d68998d7fba50259c84a495c9c25662caa5c6cdb988b363724f75ffb7777260f348fba189244a8d748a8a1737c3b0a990d647446680fdb416d9d7fedf19206c63b6f5f72c3c78cdfd1f5548c661deb5cd4779f9f91d66b1b93d8de2b591d1a61b4a937e0a5b07e8da6abe20a6fc5e38c5c022446e8d27628b6f36f47e510be67611d24c7290d71b80560d05d341052ba76e549ffea8ea4a6c86b284ea3378ab8c95d836547301b8885a4e37935f57e16c506b54880801e8ffe07abdcc40a859ec831983d6f68d09a7912b274559a0f6d740b5ced8fa2635de1d8bb6da7bd2e46f32bd9d4820022108618b2516f78a9f4fde2cd14ed7d0ade4b84836294efa079217f8be25b9de86d68117af67eaf921d1fae3bc543548b145db7f7b7fb8a70fece9fdee9ffbbfde717bfb41f4fac011538bba7c059b9d468bf8921e5ea9c04b856f6d2ebbbe0ce492ee2b87a589d5faecb65a1691b7c4723ee5e34ebd7fcee17c0bdf4969a88a19af5a154f5ca4866a418b323f9b20fac616141bd172faa65fc8d801d4d18bb3fc15040542a3dc3c44f74d5d96b6bd890d862bb21c4f95140cb00165486319b047b6a11fbf2219311acd68dc735f72b8711cbe4d7bc35d77853548d8e7344773a1c77a7965c0ac044bcc7d2c2291a46fa574961089b71b9875d7ac1933049b233a984f7f24fb929f654dd709ad246441ec71c02d2f9691e3bd1dc3a6cb3d053b1feb6a4ee7f094451468fc8a34e272ae06c8c3f940571433d55eb572aadebbb84a0d3ee4534fd3bf5cff192d5f385fad85858eeb8c881bf5a5b487d582bcabf2eb5b97e2ce2816b77ed7724a8ed893eb21fd44a7e7ed7d6194eca07690c0fd84fc9fb881e71665f0a82afa029539d94db7ac91a18984ef0a27da2b552345f19da1f4d87447a78562b7a4a04a5cb95ffd4c5971276e86abfa98067d657b802b837578813d7e6f7003c602fdd4d2e04e278d7eaec96098bad2f0a65d0f7aac5e8a813795586a0da00a087f61e5bf389aab939e7641f6793e3caffc7953a49e56cc26711192609a7f04ded3cd172e86a80692ff72ec17823ba85a6ff3873302b909048bfd4ff045ebc4ffeda2340d5c2a7163ad79b9414936485d48f2bb68875ce6737c23e8309aee417597f99a22cb0de8ffd143293aa188df8a75b1456252cd1b163eafb96f5a04863946730170a0f50c3578dc6e48c5ae56d83c81f3cfb6f153f3a578310cb6d482730b10f6d3b9f70b64e5ac5d0f260dd54cdca4c6631e6e9dec541aaef019c76c7e8a68f66ca9a2e64b234f042e50e388ceba67ea560be01f9aaf70552c2b769023ee82178764de481ccb6018f719b8895c71cbc8b208bf072d7f75d1285a3d7b855c17d2e97d23bc670f7bf2600f2b2c1b8b3198ccbc4cf589bfcc0149227eac1489642d9f14316d53ec02998b61a88c25c6ab1ec90802a86ad5061cac277bbe308197cafaf572a6bce990dd62c5baddbc71fc3af06bf2c17a60a6cb50f1fc070dd27e708707fab726a9b933f307090e1a2e2fe92ae41d57bc9bcf2616bff2dc4d0dd8a996b4572e9921608f6da3a0ccfd11e28e7d2cd91b181d28597709bb0b3fb7abbba23f52624e47f0df658c0a1eb31a610ea5f76ad365ff8bb4197ce56a4613cc817dc0d50c48dbe534805c2d77ff6981e5ddda6036b061ca6068aefcd9e5b94c1cfb447aee95977dced6cc27089c9767558bf85af20ab2d1554af4385f77dafa514b4b5193dbc3546b4627accda409ef4f59e8183988c7b6549a207def03aa0512b2b40959c3a6dd898d9ce86fb69ef286f8e15ef1d1c1a9d55fdae94da07d7eea589d13e2523b15c48460252295f4d3067dd3db349ecb48dd33e794982c8ba9a1f38e27aa9b955e5fbd39fd24f15cb29ba9a8c0cd12850bf153b1312b673b7aeeb2b51547d130b9affd021d9ba2c731b62019830744e7470367a5bcea873ac7666c2781d6ae3ac0d444c0c9571fdf12ca8c9177a040c482358f6795a7323f602ba5cfd57431f2b53e64ecda62cae23247a364203f4e1989ae4ef5dd28225f3c0a21fb4effdbf83fe3b219ff4153019701c398b0ccb7a6bdf360c7653d9c6261d63cd00b1c565319bb4d338593237f08456849a633a16f536be85b3d699565f14eade18443d662820166b99aa84b3df90417982032e5e40e151d4455f42d4fabc8e4f88ddc2af7e8db088eb94633819fa528ee455d8b40f3beb2f82ceef514b48b090fec39157472587ed310a3e70d13b20bf3d5238d59f4a83309a2f62905839ba4157a83f0da936255279f34ef2bba40d3cebd456a4096c1ac0de0e5c300494fd0140b12fcac8d351b30697cd5de9fa69bdb047b356f1d99d2b75d49dbb369b02d2bd23a3df1cad069d62628158b7ef52b5463c98586def38d74beead60aca4d7e64c2d8c9cf13061c7a5ff3f1cf046671156aa8153333ca4d49efaaf01c68a786a724328a2b333fd14b2f00b06a762d2255077850d57cf7194807b613627777dd9dbde2d91faced6e9d347d5f4db7e2c9091961b1e7ca66933b18817841af914ff1ab11153499b2b27fcbec7ce8458718ca81121dbcb2e1711e99a4c31cd7fc363eab25233e2158328853be8dab083eca0a7c015200fb7f416fbcb59f1774a38d6e65b2d8a9df7e60d2cb93c344272226c8187757812574cc8ed14790a357639bdc5cfbb1e62b2e8b6472e9061617055e6c6c46b62e78876680146c2578ab4ecb88164e32057752052f92fe3493556ce516391849c4d2d29c0f3eba0a977921421ead513d341af6c274aa5ede0b87321b9dd06db895f33996d6e812c17e03a2289cd6f95836c38feadba0fa8602e1a50e6cb1f7f141be1c12826e5b9e2c7e1fc4df7136f562ce6701829292d5c0617ac08910d5f612bbedd05a218ffa89958911553ddffe3320c6e5caae3143ae8d03761ef66d3da2e3ad3450b849072a438e0f4fb1d72c639fb293c4241d96736d11a8f8ed2c618ad10c8f6ec3d4df768a259508cd29c37e5ef412589fd5c8ba5175f49c596e016e238e7b61b7a4b11f347eef45be2547fee0fa4041922d150a66069934f9bb26cfca10334590e1b56d822dde6574284807c1cb708e08af8a0202c81c537d2a2fc506e5efcc43c4d12bd0c3edab0759afa4fab7ae706b0074f014a213f6acb5f05b0e315c81d919a084046a6c6d69068dc8c7568fdaaeed6f204f926ae762827a3edda5f50d41998283bc87ef62a373133cc03d04ab58fff22ff5a9b3d54c9c931816634243d8cac35eadee6281c847fd6efc4e6487e67f4674bc2e5170487fa83e690723ce66aa6c0776e413a6646e0ae307db3657357ca4d62c6e40a35ad7578b09639cf16d1d6566f322f03c86d24ecc921e876e7ecf97e0906462649f6ff645fc8ddfd0a72db6e17a0781cbfe075326da056f419d37c321fbecf0dcb4c7490671fe4e78c8aac51921a99dffd96c08146d8a54ea5d5c8bf4a582861a0dcc06c3f35f0d5db0eb61fb085688a5bae36ce8d410ff12ffe7c5e2eb04810ea19bd91a0be1360f0b86ab93c6f6edf480be812c103b7638aa4fa30599fae4eb7f2cc4df754b58e7dfb851b3fb776b57a8763d04005f80c5b18617eb0c2f3aae1562799321dc2a6bfc7cc31818a2ed6174513e129f94d080595691b86e40d87bd2dbdefa6a3acf9f74b6a3f7e1c784254c57c8382e8d59b509132e484da134a731e04839f090262f32f56ebc876d1d6c82595d79eefba72d80bb978a78c513974de3f12e7bf41b171de38d46be825ff405d9587e1612814a38b08b361298e4a53865adfe5b5b55cde367fe81017aace686f5bafb0daa64324607ef5ae9b684eb7d540ddf9b26812deb368434077ee66cb8c36311af2c3fc742132b2b6a7e14f0b415da857cc54c027a78c7c9c1723708bd5116d5ea9d3c6d75b16b44fdc5291aa134e7edcc1552a4a86df995d7c3040d8e37178992f23f36979591814c33de7bbc54e552c17da9c55ab45251dbaed5a8bafc0123fdab529fb6df070c9de2d219465f12f3b941e9aaf0fd52e3d9d3a57a74dc81b146af92907f5fb9f98e8192f7f312f5480d1833e080dc632c47461297484d4cf5836b2e67c365bc35d46f91fee644e84cb1b8490eee0fddcb7edd199b9adf7efb4c594c1fc7acb157ea8842ba09b1dfb90737a5429325213a730966ed8adcf28532d580de91e96010a588820d70bb3855b5ed9acd89acacedb8653af4ce42359e1325dfed3fc8fb5c2f7500787f7946ee137350213b6e4c7980263a39848023d53f01d7097303b1ae2208d630ebe014b75023de4ce3ed0ea2c5c4b930b3a4d941187f7d2500e981de19674dc015eba43b7aae6733558d65dec7f08ec1676617ee3186da8144546818212da5b7b7d7db08ccb9b7f4eef7c696b3446677cd8f8c107c93d850cc21732391fd06407e4f56ac7c46f9d91d1c11910188a0fcc84c9840118aef9b18ea103ca2f35431edcb3b4838a52a94bde9dbbf3e9e866b78e1c74a814eee418c3fba28a255f2a4557711f4a795e6165f81f75666be71b7ccc5943c4c14454c71b651e1ac3cdae69952a4ee4bc1cb7f1014ffcf6782e2e8b82bf2672be644dc617a598595f02864789d46292c2e74feb8bf24dadb2e54a028a5906df20f83d3761b3b8b166ab3fe71b07d634d56be70f0995f1fa09c906a2023e8ab4309cd567558d1a6a646c9332af2ac1c7d2866ada449042e85920a55c1107f601953cc1af5db5c8af4607b6853d2d1b4fcb0c8b3cbe91acdd7472ce27e4a5f68a25c374171de043441646549d1a8482ceea63bfea71ececf8823d58ca42c827ba5e79ab9ffc4a75e45b89c32b752702ffa6dd37123357938d247a8f452f7ea2827928c749d527af30d515e9092e0313bcf3c770038c97048a1b7f14e3de11c8fb529f8c2c63ef09d6f30047d481fedf37e48979ebccaa9e5ebe8089908a0b4460b108f9ebeefe2b5ec73410597bcf148de3f3b1476eff2e1303b7024faa77276acf83f77215f9c2cd33cf4a5808c7a94f3c4b8186ff9d3ad97da55f2cdfdbe49697f8a043f74da1ff11209ccbdc5c850954a4201e47424a46baa7b59bcce30a96f8ed8d4045cc5d25c60d0d79cc7be9f5fbddc254847231a581a10b72932fcba5e4aae1a8cc95b0b40a9e7a37af3b4d03a99a9720d50781a51eb22e63a6531537a01808b3af44c0fe0febcd6e5c020851c50f22a8a7fbf2bb7c9249349ea18aed6ca3a431f509d49bdf1b8376249c043d0c6a3f22dff108eb334bad12e74e0a07c8266c20d9fefd1b0536f9ccc49001ef0105dbea009900f4b7552b081289ab685cacb44247866aedc4d6846360362b0681d132e7f4ee5e0e3060afb01209ee0e621c00ac4091622de99b1e8c3ccb4550d83e17e0d8da2d570e0f98f1722a28ce5d8f2f6b5d640812c5982ada9df5515035be844c6360f96443249889abd8c76ca74d686eacddc567dac8797e6ea5a4d77d708587e1e20ffaef0e6316d8b602c4d0fa649d755671fd9109c700912411c6c59d6d99bf4dd50456f904b29082da543e3651d57798f7c1e16023dcab138b8351a3eae8a6afcefb1e358673aca4b316826fb520fcd975d753860e86255577b63123bb9097044c072492c67d81518bfdc2e487c81541cca6b8e7ed6f737b54746c797cadd7d9e62f5efa697f213620a81c3f83db67aebc4c852736efa9344e43efbdaf5291cd2e2cc882e202318d7120c2747e3013dd3903450112431256a28448c9512a91fac031271753c4e70d6c7d176184a8ba0aa951ee323d6f3c85b53fed6b99fed7b113e8335687ead7d4b28f54549966ace4d2f37d95069f27dc9ad1d6e73348628df25fee83141f8125a9ef56a1df2ce251ccd77206a338f388b487ae89d8de5548bb6c78c4882b32b590b9546da87d0b171cfd021174ff90b8e8ddc2aa00704fac980286f7143bcf60dcbcadf01b1889ded7b1dbf7018838e7a8e741784bae3bbb59e03b33604c6b321ed2793442aacc3c963c20ea7fcbac68d91f902adaecbb03a4aa4a5ca80b7a3414e18e35882567abdd770c660b86bcbc06782c03e2b0becbe2bbe87a16b925cb6621954ac81609e1d5cb6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
