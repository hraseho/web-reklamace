<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"121f4c0ab47e7aaf210ff2e08e8725210fbcabf735aa9db634f6d6b3230ee74f9e0a614e2fb39796a288cb5e96c059c6eaae962596430e86cc99880909e804f22f682a847b14dd254aaf57761c47bb969e87a4018e3998dd03cfef2235ca7539f7cd79b2ba6d61433f92578b8c10dcb5ff1d14a71225378915fc19469deb7f245acbdcbb05aeb0d93754a134ccd4be4e32a5850470ec3bcee91a7bf85f575e09e792bd5a8144de6f762f8300e1f3961b1cada6392beba9b235e31b61763d1fe5c96741056926996c7887b2c22c818dae7cac9d565aadeb9de698d511279688dd355412a98de1e60e83c75965b3afb1466255e1e91200d082e6cea72390adfb5da55d6c43b9a3163bee30ba68a05169e8f2c27a4ed7b46ae9c0d00da59b816319a1a26edc04c1a642dc51e7681039cc1dd16e795802c1b56943911299de3efa103d7d2cd3533ad9a8a0e736937f6ea017fc4687a34591b59b5e7ffafdf099372ef8ca8149897ce6141680de1417d81f9d50dc7a42024cef1db2cb8a93292583f439b94e568894cefc786ebfe965ce87c2285b9b912fb819661339ee77f34d35601d37bf0dfc2a12aed791955395f66d2a64869343528ee9843f1dd4b09c97d9784c46e3d2e902cdb28bde582ad05589e13afafb45c14a3e69f08e05275b23832a0e503f5654db30ccb80dd4ee6636e4267666d594e8c14f47d1e7c2e753fba789b6f8316e5610a4d5c4b3c4fe2a29d9c53821668eb9d80ced704af6adc7ccb6b377072659396279db770a16d46d870e7bbf27a4243f0eab47a371d2eab03cc8980bc5e143255706bde781a839de0720a2a81811783256fc2dd4df530c2c60e9695bf58cbdeab9ccd128ed3ece95b09e8b6bf4867e656218c9f8fff77ad2afab5739ca76b6bd2ebff35b528196509e6336ad281587e121e7d872d891b90d6b20eb163d688e66a4387734228a302060e52338a158ea465fe4159c4d1c98c8d78e14df698eea6c91a6de9b279ed59afa1761fd21e50b55d939da7684e431847e720f3f3e01073b76c2105ab5729f410a8d745d0bf6689df32558d4253bb37ded35c99a22925dedb6b395bb9b5c8d1f842e7819157d110f079b265580705127babb5157fa18ed627dbc270008e116abac78417cb62a3630ca38748b2e01403dbfa5bf3b89b4ecfa3fc7d3bf5facb077a04eab5d87b24ed0227077ffeae98015772fbb76a0653aea16bf2a34d3434dd5da349dc6298051e1905dd3ed633e28f0d018a9a7b6255cdf44af47e5d8172c59b7275bd135812f3df6ea72331f47a2b08eecfc3da85c516507420b18cadbd4ff8cbd933d22aeb2e5221d318d58119328208aa0bd80b452cf1212bbe68b8b00bcfcd1f75c997fe876fc72b89c9f5a9366042a3e47bc55502c5372489cf26745ee7ccbf61bb78923d4c88b6ea6b5f1104bd1cd151dda27c0cfe1f9c63552453aa3e98b178f1aa9ba4612b961c910a8a8d9c28c606ac004897347e567da28b64ea240726f95a2bb346a6837c12daea7dfc4c48ef794a366c28767b4b15e5b185d5c1ee0e0d8476c6e410f8a5808319d7bebef34cd10ac9954eedc2fd516d066dd168c41eec3ba67980cd6d24fdf68fa30eb7c2ad777455febf9376be451c3558f330119428436941abd43b8b1f1461ebe3748748d2368f60fc8c4c9533dafea909b8ef43e33286212796ae1d61e0de14c10457583887a146648571128335298394120d93c3ac96f011e565d9a55647437ea068a9fb34e733985fd59b0a58496ebbcb016e23b898e51d76cd0060bc24f173b3fa29682730d3c98d5d817493b9783910c1306285a0a3d0b383d8bda5f81258a6e57492524f310d7158e919bd9300b90620f22a94fe80aa56a98f9c1c1e136593d7b5d99b79fe14c640b2cea9b505a649f6f5424bbe51905c000dc81f2727e19038ad3598d6a8e272ed58a6a04f7cdccaed86eb3f40940b285dca9f99c7f5a02fd68da6ac2a784fb05f8e6a7764d89db3ba62ccc3e57bc6bd858e505868766e70a7a4a3dc378aab8e8d73ef81465af08df383a82b206a7bf071f965d58ae84c84811cae37a4539660f3bb2668d7649b26cd3a8c9862aed4ea2d7b72d4223d688c5cac38348cb5835c80bc379ce8e1b5a9d39a4fca2110e089a7519650129ca4cce443245defe352d3d33b0f15ae29a29a40af551ef8cc06108dd0d0ae2bc61869d8c2f730ee1e4360a2c7c737f2fd45721bb35809806e2e70f13cf75c626d700a734a484ef6caee8f1c3760504b67dc29c3afcb61f5fd1061ab4b5315ae080b99f5ff873477d29c2fd2e1fc14266713c2c808d7db50a41c4151e8c168441df096960444307028e413de7f0d163914e33cdad060b75cd3daf9da44b3c6aa71f06fd092befab9000c7614957798568298bc9ce2ca72e9cfe01e606969dc76abea087e097a26e8e22d0296a5da4fcc0d7763e5f6e150bfe05e7158061520d3bd09dd0d8298bd8dfcb2dc7ac2ce934d70d4076a1b0834c8dff2bfac71045fd1155cd2e53ca11c239b2b3b5081889dc445703b51d8c69eab9f29c93e8eb50abec7f18d88738738d33aba5c507dc2fe042aa8fb3ec40c323ca7a25bca746144ea3db5873ecd630a744d5497c1d97e092748e4fdef4741ebef20de20a2b74c54f931aa590fbe15dd84a18bc85c535af781163526e8b4d024c3a793738075285fcc3c5e13da38a109e197fb8968778dfaae48afc8b0acde7d83062fe17fb4e13f4005e887abd0fb05769245acd116bad882d15d7c3e3f208d213d2f5e2c0cec546085fcc4c630b1d1bb314c3a959770abbae3b6f22c13b4a16259334b1389f95c5204359cc6193f4d2ccde727b141ec13a5db9732133154f94a124c98b64ea3b40f1e841b1a2d33de2f6c982ac2e67c57b1cea546e31c372e8656ded9ff3762996afe655654fcc1ad68ff26b4b00ee1ffa5dff8b74c835ec42dc177378bf869676ee7a3eea0ec3890b8bed91ec362e0daa7f022c99d0e91576145e3ff2f29cf152e01a6a9563effe3e5325e61e4c4b7fb0719d0c898917d0e98753e573125a5c40327020d319a936883d862737e9c7cbfc04607c7feb925219d76ff87f790696a0d50788d95fd3e8722d7253447588813c9e881e25010a7821c362fdd8750e363f75b2757b92caeaf88efaa1cccedc0bf66ea7b9fdc2175eea5f4484d921d28a10f39bf4d664024d19f00cca46df7cffd34cfc5917f3c456e8ecb619fa332fd05e9ef401b22a1969958b466e5442dbb39eb4382809b100dc8c1cbecee58c627548b88616c8322e0152dd9363e3d2c7e1a438cdc4c8d4b7f0848e87e72a7ba1224b64c5dc8dfa2030b645296dd2d96f1b641346c41c6ff730b34b6d8bc459e185a9b56ebf1867e2e9ef74a82f6b54956598f06054ec5ef0dd8069665fba4b3ed64a207350c0c620a49cb4c6ddc917b859e03b79a881a4bd957ad4cd5cc49336facf48100eb78ff6bb527e8fdea4ba94ce63845d06736bcf249221fab07517903bbb5cf9ade5b57624ed33b1e9ab595033605080576e37bdd3439704c5aea8fc88df517d1acc6096d241aac419c057fb705b0d0c1dd9c16f8a0613e6f71ebb0949a7e75acfc3f9065e2b282b1e3d6da64c726e527d2a6efe7ca356ee99d6c25bf33974a7898a8b7a4be930186b9a90344c504e1fcf7b3c91db7d18c067e35fb1746d83666f7ca3c62e5c6dd8bd09a354f326ad1a38ab4bb608be5aed76e541607e83918607b3b80a357d83c31e3853405355520ccbadc7c632f3e285d6a3fbf75fdc8e873ad71968779649d66a0b5ee2240f935bfd48ce73bc16d77d9f522d7a8922aec44af4c1699cc0819eb24c7b1fa2d34db0146869cfbfbccf9a2021bc2c65b322a4095f989551d5d9da34058bc8aeb7f07c5e84cb5238b754d46c1640616a5dc263f132681e0538f4150944b8ef16f6241db1cbcdbd1e0437cd514019c86ef89a1964bb6890e3225fec53cffb8cb7dd8cf003edfea58717e38c830f40102ba75a10fb910b623b540faa615171cabbbc64a013a929d2a334c181eb0ccf31ded3734a5f4dc38e513e85e2d6173041dab889deeb22cfdc52374ddffc7e5a7af985b38b0159651db7f79d272e34b591a72bb22f5fa449d9652963d6fe4af5d8ad5afea6df8389d6b5e4b8713d1d7bb3835ee4b6e65290e19170354abb2d0af233369b5df045a509061dee7913b0973fca424a141a655e321ed0e7de5891b2c97eb2447e71f879f5cf58972164d53e31fed0c083bae4e15b17d0139fc3f1821766be49b60b31f439ae558f26628049d02f44572ba39624b0e533bdffd9c4a818f31369090aacb9b798ebbe8859d087535037ac124b87c6d7867c6add3de40ea9fcbc46df0b99c7aaa61c268f3ecda628f05d621935cc55cd8987a4ec55fc6cec86015b3afc2de78a342965b8f8e7565cac3bd15a4beb8c37ee2b6f36d9358814fb1cbfa423bfdf077ea809a40396c3cf27158b6d542b00e27bbfd61f52469d2f6d15a7017e1647614a3f00ec2872b11d550b1adabe31e7944881b520aad0b75974f781cff44e093be8d9aa03da95341d8364b791072814480a910a569a1f07bf7062d1080bbd97dd2e60a6303184fd316826e749eb271b6a5216a1b10486a2916b048267ff7d2346ad47abc68d55af87fbe4c37d108a0592aab20f0248a4e0fc13b7eaeaea304ff5d65b29e46c1545b3f8186c377da1df8e88f2105890293f122967391a9c7aea857a096ea9646beaa849d4f68ae6100e528686826fb7cb4ef5d4d4b1b52e2bfb68bc25343211f61b93e3a01721fb78bf421e61d0c92c56b477710b351dee838d1224d4e4f49002a9a6005749888740635ffc1824a03fbaa3732e931840b541fa1d4d7919ee02f3b99dab028d6497f4d04d98067f340f1d0432d1826df682c82d0470758c4206c3c4c871c3585e665f299461a8cac421c8b303d41b17b4c337c8aeaf24eb652b1599e299b3bf277db5ee2f7bf7f49c71860b295a10173aa997de2c988e1e8ec18941fc0e6fa2e717d280f8194e55de8c04704f18f3d6e25e193f972ef2fee5cb3a3caa73c0f7a971b80b999eef92106efeffae4566d04e86ece50e264bbf0836c0653dd59c2b629d4b357fd96f9bf7dbece7eff87a52730113ca02fe848a9a92b8361602b1cbd4c93bb2f35f73a85eb8cda246562dbb708cf59ca53643111980754139e2789fca42ee686dbc0879579b61fd5961fdee4db03f9417d20254d52966ca67a234560a85d6d648cc5be9f159fdb024211bf66459fd1135505a3de9577582a4c405cb6ce2acba10f7948f657418e50dfeb71afb5ef07bffc18fd423c537481086157285c627535e3bb7eb206f688d400a9202eed4b46b9910c1530910196eb9cf1d14f3d25777a439c899555f3cabaf628b3247740804ef67031ca5f4f467db2ed79ca1ea6f1697f8c624be6b390532cdeb19ce996d96391465be0c3aa78ba85a8f14c3f05e0872dccefdf959a2a68411bed6584744f25750e284d9573ab8e99386a0b9d5dd278fa5a0b80a8d822f34bb8aa804e547c66b5eec6f66cb607352c7e0cc551464825f5062d8a0beb01d306f7a87c6b6f3b52cb3d7f955efa437679215ef65fbad427d092d38b1279fba5956a5b49ddc407750f8e8d4666ca3163f1817955233abf29a077b6bcd64f2e969e884c7bc0f3d3f80394118fc28adcd3b08578afe50925768fc3ee8889047fde5a75875870f4872360d4ff4671ba1d956af7cd5d56308297fb5201c28ff0ac24a2a0c952d70251a32650dc42fdb90f3a61b3c2c746eb789b13b08d96f52dd2deb96440bcc9d71f72fd92655c6d4287e00620394c0304a6a4b52e66420878ad3213083c5eed2b375651efe94d8e6b463b596090e59d9be087cabef8d33e5bec90fcc5e35246bcdd11a108a7375daa4e9e813caeae178e691ea6dee0ceee71ae517954b17cb26f48af48cc48beffccd05cb8704c89ff8018491378ef437aace55b75b2485f2f3b0cdc2c5009efe9e131dc9f61456461e0b2e6bef0eac967a3fb1022b9842eb0f5eac82c4b212896c600d0000423c55d86d29fec0c3621cd6d751f3f20e9692393b0102dd07dd2572d5d88fa279a4dfc8b65f1c87a451b15b40dd8d9e66ada7b30b7f62da645c3c1bbc38db7d0af363bf3258d73c0b18f8185d24cb5639813ab5042038ff4557161fa663cd8c878f4b55602289beb4386ac549565e2536faee577293bb5e89704d4ce5a94f25df17e580c6db535bb60ffd3b84289e3420240d2f1b5ce108b9e6c1e8869c30b28d323a03238ac2afebfbe3af97b42ee57e6681aaf324433fcf20272b3d5db74abb8f05ab4d07ac87cc610a3936b37af1cb8bc152c276c5a60203b1d75c22447e265371c53c4063840d840a14a9a168300dc4256ed2275598a6955e2527408b76e5be06efa5f5f84695c873ea99bf0444e4c89feef2dcca58871463c541ac3b95b4e1100480cd3ede23ba4244955edcdf19af52ad65eda82da79bea15f3272740cad730d9ef52857a42d752d78ed210676a8241b10ee82f6a66780f3a45b6925f84e3244098caf3d9c7222047dd7d59626cf3fdfc32b8047bee267d64f239329684bf432cfc7135ddbd04a99b92727299fd446ce396df0d9bcbef8bc9d7011fae349ba85d1678362e7b3f5f0d1fb8efdb415824a9488f6c46db615cfef50802cdc8b7795cbaca90fceefe732563525a62ecbce028838afd0fdb8c55bf815c7d930b47ca2e823cef5bfa6fcb2142ac2a4f129e4c20099bfcd22ebd66b6901a725fb6e0bd40fd66c0f8b1505be5c00db3b4d38ee89d9e6856c2e4e0771272090725dd1ef83a244442b58ddd729735e020d650b2b4dccca3ed3064a54185cef07f2a9bb89f7e6349e06de91a52db0ac5b90a0ae8fab0182a65c8cd0bb6a93041b15be50e27b796edc81532fc0495164dbccd326485a55fc431bd21cef574f351d39a18ab6968f6a60c97492f04adb3a0fe5984f62b2072ee469759ce6ec06defd82c1aaaa96d23293344ca0048f7bfcd91e51f069b077f685b00459f51d4c6353f37e7825c748de09c630989f4cd9734444927b89ee1e4a57b8b214df011e0a71a2df3e1718d2d413ab7c0a83e23f40306c383091f064d2a7919c8296d64f63c256bff93d235f0723d38db7e920fb548604d9692248c58bf0fa0ca613e073a44809f193d4d4a153b8f142155a971677c17fb45b12a2ee9f94551b53943704696150920d3bed4983abb5c094726801c776f6b4bee69450a5e69f0c742c9a6ffc4f96e3e3eb2f665d25d6590a49b3a1fe3692c513c2d58ed52fdb112044d1244e34cab265c76a48caae92c42ed15d76878fb0e03b925341db36eb800439b116844e05130d99b1d5eb1866920d14ce031be13470dc99c7c782b170555ab64ee5c6fcb35cae762dddbac3996160e5ff119c111b1f1b30f7d30b76b350058842e1ad94cc1740ae64df67908c8a615593f32bc706b3a49726c620ef643968b749b87a5358ed70dfc22c548d58284fcf20de00ca735031beb293fec9e135d6a606d9121ff497938aab9bea0f56615c5f6ae45bfb4343a1554c126f1ba1ccc4c5e4f78eeafb93d10ca7bf2e4ce55766b751929b141741bd2fa2afc133a70153c006ab21b2554fcf7a8b5ed50dc76432aaf3a664c99d490f7f901ae99d912caacfa7795e90fb696c9d9418592c60e7417e4e8bbc9e43b0aff1a1324bde0fdd87d9425dc44f21a5127a63a880e801c136b96e8e28c724ab08047a6f58890178665f9ee5bc1f8aff2e5faffb856727da470bfd8a15fc0cc776c25595d9d4ade4b709e3902158d63f825131f74fa14336e44609780d7faecfb54391d841516712dc0879c654e88af8211cb9019e393700776f3e9da69c927fa0c28f5dadfca2138105daa6d3c915840c0d0278281fba3e3d53afc74ea4643916a0f92fdf7d06ecf83c7046bad0f93b6ea6b8fee2175ae0432092ca7ef752b263ed23d1c04686272919df46b3abb53926af9874bf4f803a593046df527a828b8b2508ff01d412fb3fe13df72ffad238539c007b0cfb708f43da9c99654b2a107e41d6494944cd025deb696cba682f20a63ba4fa8e402709a93de066ea114dd0f0e1cd7878dbd7cc2826fc39fe0b07389399d3817d6940ff9aefa86a14d6a175ffe949eb51d147aaf4c8b169bda5581a6fa94129f0595072c3b99bad3b5173e4687f5843fd63eb073671b7e6d613b530a3e08372b5a43dade069cdd21ebbc57663cdaeebba42c1d5c1c679d6c0ccbd2a878b7ae3e18265eb3a7c1ea065927603f63eb942f1e72195327cb185dcfb44be8458cbae844b4ac3ae3d17f58ee7e74679c990af426ee8dc08a81077291e932d9563583287c07e2c3965e03fadd7838564b0d9e4f9a9008be1c4514db1dfea6fb3d50a83d61bcd590d206602ba214a2da2e80ba57ca32a50622f237de7723b76914dc53c4483a0fd3a0d1de603b0602c5b042040f9e98e22e45f00e082c681a5e4e908dfa46b8aa5eb7e6645b459e23aaa9d06c5d96d7aa5af47af0990e452a5b20e1b95ed0d59bccaf59cfef53331398b97991e7c96d387e16fe77341a0f3f3a6e9dd84983713cce25adb9401cf7304b9934d9e48a4e9f11c4219ca7e97c5f18c476320828e778ec5006c13144e0e8cbd2711cdb4e8fa571de9d946ca3230fbd6dd1d6da465679a97de4404330c815baf5fcfb751f38d3f21fc30c5328fc3dc62d285fd08caa548cd200b5321e07f5a79dafedf9893b7108f4dcf756828e4c6613b09d9bfc423f78437c478058044d14fbfc7701826b81f6d9376ab1349e06ed4696d6c7d5b237910987a46fcca21fe30fd0b5ab2fcf6a4e0e09beb05c7d457309d341ea6df41151dcfcd3c7db45ded220c799dc545b5304a34edaab7f5fcecaf0433d1af3acf9dd23014956a7c0f239f0300639fbb514ccc265c8867297439b5d1440570720e23d44e296630c234ead202983faee1287e8194111444093c58d36934440b661f3f9547f68c3fe64b4dea5b57b23035b2aa86a508d10da82ab8f363be3d5d948a3ef7ab8a1e05101f0dcacdc0b8d9329a9c2bc95abc6e45950aa0cceaadf62c0ab10ae8c219acb198f5c57d2a09fec25f5808f7e2c5bf0c1f564df2f8dbe66b6165ec1130b60490c071bed679fbfe981e85e3fa6e75be88d5519c2520e4f8341977d7fb2dde3d0ae577c55465523bfa3cab78c0182d90b31f3ddf726bb7cf7930bbedc9cfd746eb8d60496f9cd0bdf1f05446e4b57be591d52573addef6f8e7e4f8a07bab8696e7f9d3e47a3493a15e1298587fa075396242affaf81eba374145e1fd1d7bb3f60c1245da0a8706befc4c443ae936909dda57fc68512e41def5c91d0e3e7ffefa6d6dfb8df1ffeead701dbcd931916b9c9c47739775f5c8c0eb4d04175d36709ecd613d798140612f2a7f71abb1621ace124fafc907d017fe71bf7020364cc3530050f0434055f40945f8b8c23acd043918642b26bac7332a51f8cd0d815897b63b1cfe14afc05478b328bf37594e93bc6ec8b7b0186ca8bdb38393e9768fc78eae2e10bffe86a019352762faac9b68fa00df38e7fda724cb3d7fd205d502bebc4d12f3b11c5f5607d18787eea74d197149ce43c966c015d167f69545feef2a814be1b36ecdba19a0029b36ba3bbc5424280370becd298c3a832bedfb37ae667d3721bd6d56718361d8293e8f685297029eaea6487172ac33e505ef0d8db335efa86bee6eec3bcfa435798f68f58dc30d06d96a58cee0ff2c323e7cf62e73274a6171afdd2d94b44e9e16e932de4471248a8004c42d59ef8945d1c01930612a008b8fc28c3cc1cf9923978d8a641d9297bdfb5065df6f582807a1826143c940e8aaff4e8298d8e946eecae7975e8db758a1c394b2100688d1a3f8ed052fb309367230494adf1e97375c2000fce91efd588fb7b6e841558a34e349bce040f1657b3c7dc7eaade460a9653317034d2998836c75fb7b73d0dcd9d84eed87a4ce81d59a8fe3aa346fe94fa2843651cbae38b833eedcdbf15c907a13b9756d2079d8a1f6d42cf5be29837bdf1cbb64d7351695b5475efcaed4320aeee08ca8777ca400ff4618c1b7436ff812f6c43f713c058a8419cb17159cc63a39b4d747303a8396d9852001c10b794832963d8ad4d3f205bfd80bc2808ce5be17b511e5c68894f55b968e05c33776425103d701f1e86350b996aded149ee806129094eab2787a4e5632438dc468c614f65589d48a5e75c0e545f70c9ac863616a8fe110c63d615579ab5493042284b73fcc28bcd54ecbcc48055ee118a8915ca8bbb511bd9c978610b5effe2be06b5365a4a762efbafea0d352b19aed2e2dcb22d3f6814ba13c262e125714d35bba264346662718176bdd64f09615f087bf80fdfca070bfd9ea0a81871f90acd94cd818ca5a9ba7803c8838ac8547bfcf5563554444f2ebade965aa9b606a4c2ff54fdbabdeae7d14b8b30368ff1ed41e4d1d5b091114f3b8836202b6c81d5b65649bbc50de00415c539aad814a821a59d5247f505bbd3df1ed0f87f9151e31789b2f7a5ab61e7d15e8397553837b7395c55842fbff98dcc886eac0d51104f173f380f6573e9b974be783c5ead9510be865721e2630c80181c945265ad189df44277a27d1f81e19b01aa60a6797b3ad5eafcd195192e325fbc28806bb5ca086c7968dc900efbcf209b705e6e0b587d9b98e4e761245c1279a9bd93ad20147093741bf20a04d31ee5b9a0fdfa03c973c8ab265b713fd94df3d12ed960d8d026ca088889eb391d23db1c6306727ec1d972225925dc354f6011991abe74a626b5cac825f1ecf55fdb9f9cb532bc8d50834a5dd7864c1a0a827ad5a053485b769faadb482d79bf16eacb213f9ee0d8014bd08beccfac98235403c719c528fe49802713fb4fe44c5fd11e6b62f4524dd4cdf100211bbc2aed549f1b601f72021b5357fe77487322695ea36eaf6ef9944fb1d04e8757ad1e320296db246ee48e4251a8e6a142b3c2f5fcc994303a78d2678f6aa5fa785edc226b533f2d1ebcc739df63918c0925968f64257e2f6d86a1db9dddf3a07bf627c329b7c5bf4c0ab0078b2529ebbd896fb184c777fedb369d97499845f9b14be5afe13c015211886bfdafd573891cf14e583fea8a4993182f770d36ffb23efb552d17cabeffee210b1759a5393a3aa14123fa84d1c64afd9f1557febdc4bb70795b1266b35cd0869ab4a94c598b9f5e37dc64efbc9b782536ae3f507e955643bac5eb70b057107f113f532d7e8689bc1652ab9db5380609c475f3bd709502151a2af12e5fbc160710d1e1f9d9cfdf9d416ceb788bb96c26ba4c0e96839a056a06402bb978e78342cd334cc427df1b207f5de88ce6d8041de32bc9f33a21eb601f0fa87eb00b2aa0f22d7d23d32ed68e82d6de470b702a2048eb2818e7ed1639d935f3b1a63a9e52867b1063c896657a466d2c56136b6a6a4b45b374f993a8812042acbc930cf3de96612fc46cb48159338b6af029dcce3c85c1873ba109002e7ad9bea3d5aa5f7a8b1ad4bb00e0e005270aab23ccd69df2996d6f06cfdc1a17628c0476b3eb707cc681a9c9362e5ce0a714d057983f7dd86fa8462a23beaf696ad2f288c0e94a16d31c5d8252fe7e1aaedfcf1186c5e53149a8334d28aca0780f5f691b2d7bf37b6b3a743fd256e16782cf3a6b5d264447223f68a1c0b206620e44c50ed0d491c7a8432d16bb5b9a673684f2e476806008656fa57a49a43a6c571214e557b0e9f5825dbac43655bc76881effaca616a06a7379fe5f8f4245a2ca27e0f4ba7a29269222e7463d94ea79a14b14b7288132b0649db4a25c72d012f80a1932a6f75a0a3f2809eebfb2f75c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"f2148d09b9a0814ad8138dda9fab1e5d"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
